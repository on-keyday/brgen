/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./out/lib/src2json.js":
/*!*****************************!*\
  !*** ./out/lib/src2json.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar Module = (() => {\n    var _scriptDir = \"file:///C:/workspace/shbrgen/brgen/web/dev/out/lib/src2json.js\";\n    return (async function (moduleArg = {}) {\n        // include: shell.js\n        // The Module object: Our interface to the outside world. We import\n        // and export values on it. There are various ways Module can be used:\n        // 1. Not defined. We create it here\n        // 2. A function parameter, function(Module) { ..generated code.. }\n        // 3. pre-run appended it, var Module = {}; ..generated code..\n        // 4. External script tag defines var Module.\n        // We need to check if Module already exists (e.g. case 3 above).\n        // Substitution will be replaced with actual code on later stage of the build,\n        // this way Closure Compiler will not mangle it (e.g. case 4. above).\n        // Note that if you want to run closure, and also to use Module\n        // after the generated code, you will need to define   var Module = {};\n        // before the code. Then that object will be used in the code, and you\n        // can continue to use Module afterwards as well.\n        var Module = moduleArg;\n        // Set up the promise that indicates the Module is initialized\n        var readyPromiseResolve, readyPromiseReject;\n        Module['ready'] = new Promise((resolve, reject) => {\n            readyPromiseResolve = resolve;\n            readyPromiseReject = reject;\n        });\n        [\"_main\", \"getExceptionMessage\", \"___get_exception_message\", \"_free\", \"_memory\", \"___indirect_function_table\", \"_emscripten_main\", \"_fflush\", \"onRuntimeInitialized\"].forEach((prop) => {\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], prop)) {\n                Object.defineProperty(Module['ready'], prop, {\n                    get: () => abort('You are getting ' + prop + ' on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js'),\n                    set: () => abort('You are setting ' + prop + ' on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js'),\n                });\n            }\n        });\n        // --pre-jses are emitted after the Module integration code, so that they can\n        // refer to Module (if they choose; they can also define Module)\n        // Sometimes an existing Module object exists with properties\n        // meant to overwrite the default module functionality. Here\n        // we collect those properties and reapply _after_ we configure\n        // the current environment's defaults to avoid having to be so\n        // defensive during initialization.\n        var moduleOverrides = Object.assign({}, Module);\n        var arguments_ = [];\n        var thisProgram = './this.program';\n        var quit_ = (status, toThrow) => {\n            throw toThrow;\n        };\n        // Determine the runtime environment we are in. You can customize this by\n        // setting the ENVIRONMENT setting at compile time (see settings.js).\n        // Attempt to auto-detect the environment\n        var ENVIRONMENT_IS_WEB = typeof window == 'object';\n        var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';\n        // N.b. Electron.js environment is simultaneously a NODE-environment, but\n        // also a web environment.\n        var ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';\n        var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n        if (Module['ENVIRONMENT']) {\n            throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');\n        }\n        // `/` should be present at the end if `scriptDirectory` is not empty\n        var scriptDirectory = '';\n        function locateFile(path) {\n            if (Module['locateFile']) {\n                return Module['locateFile'](path, scriptDirectory);\n            }\n            return scriptDirectory + path;\n        }\n        // Hooks that are implemented differently in different runtime environments.\n        var read_, readAsync, readBinary, setWindowTitle;\n        if (ENVIRONMENT_IS_NODE) {\n            if (typeof process == 'undefined' || !process.release || process.release.name !== 'node')\n                throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n            var nodeVersion = process.versions.node;\n            var numericVersion = nodeVersion.split('.').slice(0, 3);\n            numericVersion = (numericVersion[0] * 10000) + (numericVersion[1] * 100) + (numericVersion[2].split('-')[0] * 1);\n            var minVersion = 160000;\n            if (numericVersion < 160000) {\n                throw new Error('This emscripten-generated code requires node v16.0.0 (detected v' + nodeVersion + ')');\n            }\n            // `require()` is no-op in an ESM module, use `createRequire()` to construct\n            // the require()` function.  This is only necessary for multi-environment\n            // builds, `-sENVIRONMENT=node` emits a static import declaration instead.\n            // TODO: Swap all `require()`'s with `import()`'s?\n            const { createRequire } = await Promise.resolve().then(function webpackMissingModule() { var e = new Error(\"Cannot find module 'module'\"); e.code = 'MODULE_NOT_FOUND'; throw e; });\n            /** @suppress{duplicate} */\n            var require = createRequire(\"file:///C:/workspace/shbrgen/brgen/web/dev/out/lib/src2json.js\");\n            // These modules will usually be used on Node.js. Load them eagerly to avoid\n            // the complexity of lazy-loading.\n            var fs = require('fs');\n            var nodePath = require('path');\n            if (ENVIRONMENT_IS_WORKER) {\n                scriptDirectory = nodePath.dirname(scriptDirectory) + '/';\n            }\n            else {\n                // EXPORT_ES6 + ENVIRONMENT_IS_NODE always requires use of import.meta.url,\n                // since there's no way getting the current absolute path of the module when\n                // support for that is not available.\n                scriptDirectory = require('url').fileURLToPath(new URL(/* asset import */ Object(function webpackMissingModule() { var e = new Error(\"Cannot find module './'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()), __webpack_require__.b)); // includes trailing slash\n            }\n            // include: node_shell_read.js\n            read_ = (filename, binary) => {\n                // We need to re-wrap `file://` strings to URLs. Normalizing isn't\n                // necessary in that case, the path should already be absolute.\n                filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);\n                return fs.readFileSync(filename, binary ? undefined : 'utf8');\n            };\n            readBinary = (filename) => {\n                var ret = read_(filename, true);\n                if (!ret.buffer) {\n                    ret = new Uint8Array(ret);\n                }\n                assert(ret.buffer);\n                return ret;\n            };\n            readAsync = (filename, onload, onerror, binary = true) => {\n                // See the comment in the `read_` function.\n                filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);\n                fs.readFile(filename, binary ? undefined : 'utf8', (err, data) => {\n                    if (err)\n                        onerror(err);\n                    else\n                        onload(binary ? data.buffer : data);\n                });\n            };\n            // end include: node_shell_read.js\n            if (!Module['thisProgram'] && process.argv.length > 1) {\n                thisProgram = process.argv[1].replace(/\\\\/g, '/');\n            }\n            arguments_ = process.argv.slice(2);\n            // MODULARIZE will export the module in the proper place outside, we don't need to export here\n            quit_ = (status, toThrow) => {\n                process.exitCode = status;\n                throw toThrow;\n            };\n            Module['inspect'] = () => '[Emscripten Module object]';\n        }\n        else if (ENVIRONMENT_IS_SHELL) {\n            if ((typeof process == 'object' && typeof require === 'function') || typeof window == 'object' || typeof importScripts == 'function')\n                throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n            if (typeof read != 'undefined') {\n                read_ = read;\n            }\n            readBinary = (f) => {\n                if (typeof readbuffer == 'function') {\n                    return new Uint8Array(readbuffer(f));\n                }\n                let data = read(f, 'binary');\n                assert(typeof data == 'object');\n                return data;\n            };\n            readAsync = (f, onload, onerror) => {\n                setTimeout(() => onload(readBinary(f)));\n            };\n            if (typeof clearTimeout == 'undefined') {\n                globalThis.clearTimeout = (id) => { };\n            }\n            if (typeof setTimeout == 'undefined') {\n                // spidermonkey lacks setTimeout but we use it above in readAsync.\n                globalThis.setTimeout = (f) => (typeof f == 'function') ? f() : abort();\n            }\n            if (typeof scriptArgs != 'undefined') {\n                arguments_ = scriptArgs;\n            }\n            else if (typeof arguments != 'undefined') {\n                arguments_ = arguments;\n            }\n            if (typeof quit == 'function') {\n                quit_ = (status, toThrow) => {\n                    // Unlike node which has process.exitCode, d8 has no such mechanism. So we\n                    // have no way to set the exit code and then let the program exit with\n                    // that code when it naturally stops running (say, when all setTimeouts\n                    // have completed). For that reason, we must call `quit` - the only way to\n                    // set the exit code - but quit also halts immediately.  To increase\n                    // consistency with node (and the web) we schedule the actual quit call\n                    // using a setTimeout to give the current stack and any exception handlers\n                    // a chance to run.  This enables features such as addOnPostRun (which\n                    // expected to be able to run code after main returns).\n                    setTimeout(() => {\n                        if (!(toThrow instanceof ExitStatus)) {\n                            let toLog = toThrow;\n                            if (toThrow && typeof toThrow == 'object' && toThrow.stack) {\n                                toLog = [toThrow, toThrow.stack];\n                            }\n                            err(`exiting due to exception: ${toLog}`);\n                        }\n                        quit(status);\n                    });\n                    throw toThrow;\n                };\n            }\n            if (typeof print != 'undefined') {\n                // Prefer to use print/printErr where they exist, as they usually work better.\n                if (typeof console == 'undefined')\n                    console = /** @type{!Console} */ ({});\n                console.log = /** @type{!function(this:Console, ...*): undefined} */ (print);\n                console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */ (typeof printErr != 'undefined' ? printErr : print);\n            }\n        }\n        else \n        // Note that this includes Node.js workers when relevant (pthreads is enabled).\n        // Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n        // ENVIRONMENT_IS_NODE.\n        if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n            if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled\n                scriptDirectory = self.location.href;\n            }\n            else if (typeof document != 'undefined' && document.currentScript) { // web\n                scriptDirectory = document.currentScript.src;\n            }\n            // When MODULARIZE, this JS may be executed later, after document.currentScript\n            // is gone, so we saved it, and we use it here instead of any other info.\n            if (_scriptDir) {\n                scriptDirectory = _scriptDir;\n            }\n            // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n            // otherwise, slice off the final part of the url to find the script directory.\n            // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n            // and scriptDirectory will correctly be replaced with an empty string.\n            // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),\n            // they are removed because they could contain a slash.\n            if (scriptDirectory.indexOf('blob:') !== 0) {\n                scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf('/') + 1);\n            }\n            else {\n                scriptDirectory = '';\n            }\n            if (!(typeof window == 'object' || typeof importScripts == 'function'))\n                throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n            // Differentiate the Web Worker from the Node Worker case, as reading must\n            // be done differently.\n            {\n                // include: web_or_worker_shell_read.js\n                read_ = (url) => {\n                    var xhr = new XMLHttpRequest();\n                    xhr.open('GET', url, false);\n                    xhr.send(null);\n                    return xhr.responseText;\n                };\n                if (ENVIRONMENT_IS_WORKER) {\n                    readBinary = (url) => {\n                        var xhr = new XMLHttpRequest();\n                        xhr.open('GET', url, false);\n                        xhr.responseType = 'arraybuffer';\n                        xhr.send(null);\n                        return new Uint8Array(/** @type{!ArrayBuffer} */ (xhr.response));\n                    };\n                }\n                readAsync = (url, onload, onerror) => {\n                    var xhr = new XMLHttpRequest();\n                    xhr.open('GET', url, true);\n                    xhr.responseType = 'arraybuffer';\n                    xhr.onload = () => {\n                        if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\n                            onload(xhr.response);\n                            return;\n                        }\n                        onerror();\n                    };\n                    xhr.onerror = onerror;\n                    xhr.send(null);\n                };\n                // end include: web_or_worker_shell_read.js\n            }\n            setWindowTitle = (title) => document.title = title;\n        }\n        else {\n            throw new Error('environment detection error');\n        }\n        var out = Module['print'] || console.log.bind(console);\n        var err = Module['printErr'] || console.error.bind(console);\n        // Merge back in the overrides\n        Object.assign(Module, moduleOverrides);\n        // Free the object hierarchy contained in the overrides, this lets the GC\n        // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\n        moduleOverrides = null;\n        checkIncomingModuleAPI();\n        // Emit code to handle expected values on the Module object. This applies Module.x\n        // to the proper local x. This has two benefits: first, we only emit it if it is\n        // expected to arrive, and second, by using a local everywhere else that can be\n        // minified.\n        if (Module['arguments'])\n            arguments_ = Module['arguments'];\n        legacyModuleProp('arguments', 'arguments_');\n        if (Module['thisProgram'])\n            thisProgram = Module['thisProgram'];\n        legacyModuleProp('thisProgram', 'thisProgram');\n        if (Module['quit'])\n            quit_ = Module['quit'];\n        legacyModuleProp('quit', 'quit_');\n        // perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n        // Assertions on removed incoming Module JS APIs.\n        assert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\n        assert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\n        assert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\n        assert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');\n        assert(typeof Module['read'] == 'undefined', 'Module.read option was removed (modify read_ in JS)');\n        assert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');\n        assert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');\n        assert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');\n        assert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');\n        legacyModuleProp('asm', 'wasmExports');\n        legacyModuleProp('read', 'read_');\n        legacyModuleProp('readAsync', 'readAsync');\n        legacyModuleProp('readBinary', 'readBinary');\n        legacyModuleProp('setWindowTitle', 'setWindowTitle');\n        var IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';\n        var PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';\n        var WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';\n        var FETCHFS = 'FETCHFS is no longer included by default; build with -lfetchfs.js';\n        var ICASEFS = 'ICASEFS is no longer included by default; build with -licasefs.js';\n        var JSFILEFS = 'JSFILEFS is no longer included by default; build with -ljsfilefs.js';\n        var OPFS = 'OPFS is no longer included by default; build with -lopfs.js';\n        var NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';\n        assert(!ENVIRONMENT_IS_SHELL, \"shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.\");\n        // end include: shell.js\n        // include: preamble.js\n        // === Preamble library stuff ===\n        // Documentation for the public APIs defined in this file must be updated in:\n        //    site/source/docs/api_reference/preamble.js.rst\n        // A prebuilt local version of the documentation is available at:\n        //    site/build/text/docs/api_reference/preamble.js.txt\n        // You can also build docs locally as HTML or other formats in site/\n        // An online HTML version (which may be of a different version of Emscripten)\n        //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n        var wasmBinary;\n        if (Module['wasmBinary'])\n            wasmBinary = Module['wasmBinary'];\n        legacyModuleProp('wasmBinary', 'wasmBinary');\n        var noExitRuntime = Module['noExitRuntime'] || true;\n        legacyModuleProp('noExitRuntime', 'noExitRuntime');\n        if (typeof WebAssembly != 'object') {\n            abort('no native wasm support detected');\n        }\n        // Wasm globals\n        var wasmMemory;\n        //========================================\n        // Runtime essentials\n        //========================================\n        // whether we are quitting the application. no code should run after this.\n        // set in exit() and abort()\n        var ABORT = false;\n        // set by exit() and abort().  Passed to 'onExit' handler.\n        // NOTE: This is also used as the process return code code in shell environments\n        // but only when noExitRuntime is false.\n        var EXITSTATUS;\n        /** @type {function(*, string=)} */\n        function assert(condition, text) {\n            if (!condition) {\n                abort('Assertion failed' + (text ? ': ' + text : ''));\n            }\n        }\n        // We used to include malloc/free by default in the past. Show a helpful error in\n        // builds with assertions.\n        function _malloc() {\n            abort(\"malloc() called but not included in the build - add '_malloc' to EXPORTED_FUNCTIONS\");\n        }\n        // Memory management\n        var HEAP, \n        /** @type {!Int8Array} */\n        HEAP8, \n        /** @type {!Uint8Array} */\n        HEAPU8, \n        /** @type {!Int16Array} */\n        HEAP16, \n        /** @type {!Uint16Array} */\n        HEAPU16, \n        /** @type {!Int32Array} */\n        HEAP32, \n        /** @type {!Uint32Array} */\n        HEAPU32, \n        /** @type {!Float32Array} */\n        HEAPF32, \n        /** @type {!Float64Array} */\n        HEAPF64;\n        function updateMemoryViews() {\n            var b = wasmMemory.buffer;\n            Module['HEAP8'] = HEAP8 = new Int8Array(b);\n            Module['HEAP16'] = HEAP16 = new Int16Array(b);\n            Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);\n            Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);\n            Module['HEAP32'] = HEAP32 = new Int32Array(b);\n            Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);\n            Module['HEAPF32'] = HEAPF32 = new Float32Array(b);\n            Module['HEAPF64'] = HEAPF64 = new Float64Array(b);\n        }\n        assert(!Module['STACK_SIZE'], 'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time');\n        assert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined, 'JS engine does not provide full typed array support');\n        // If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY\n        assert(!Module['wasmMemory'], 'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally');\n        assert(!Module['INITIAL_MEMORY'], 'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically');\n        // include: runtime_init_table.js\n        // In regular non-RELOCATABLE mode the table is exported\n        // from the wasm module and this will be assigned once\n        // the exports are available.\n        var wasmTable;\n        // end include: runtime_init_table.js\n        // include: runtime_stack_check.js\n        // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\n        function writeStackCookie() {\n            var max = _emscripten_stack_get_end();\n            assert((max & 3) == 0);\n            // If the stack ends at address zero we write our cookies 4 bytes into the\n            // stack.  This prevents interference with SAFE_HEAP and ASAN which also\n            // monitor writes to address zero.\n            if (max == 0) {\n                max += 4;\n            }\n            // The stack grow downwards towards _emscripten_stack_get_end.\n            // We write cookies to the final two words in the stack and detect if they are\n            // ever overwritten.\n            HEAPU32[((max) >> 2)] = 0x02135467;\n            HEAPU32[(((max) + (4)) >> 2)] = 0x89BACDFE;\n            // Also test the global address 0 for integrity.\n            HEAPU32[((0) >> 2)] = 1668509029;\n        }\n        function checkStackCookie() {\n            if (ABORT)\n                return;\n            var max = _emscripten_stack_get_end();\n            // See writeStackCookie().\n            if (max == 0) {\n                max += 4;\n            }\n            var cookie1 = HEAPU32[((max) >> 2)];\n            var cookie2 = HEAPU32[(((max) + (4)) >> 2)];\n            if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {\n                abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);\n            }\n            // Also test the global address 0 for integrity.\n            if (HEAPU32[((0) >> 2)] != 0x63736d65 /* 'emsc' */) {\n                abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\n            }\n        }\n        // end include: runtime_stack_check.js\n        // include: runtime_assertions.js\n        // Endianness check\n        (function () {\n            var h16 = new Int16Array(1);\n            var h8 = new Int8Array(h16.buffer);\n            h16[0] = 0x6373;\n            if (h8[0] !== 0x73 || h8[1] !== 0x63)\n                throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';\n        })();\n        // end include: runtime_assertions.js\n        var __ATPRERUN__ = []; // functions called before the runtime is initialized\n        var __ATINIT__ = []; // functions called during startup\n        var __ATEXIT__ = []; // functions called during shutdown\n        var __ATPOSTRUN__ = []; // functions called after the main() is called\n        var runtimeInitialized = false;\n        var runtimeKeepaliveCounter = 0;\n        function keepRuntimeAlive() {\n            return noExitRuntime || runtimeKeepaliveCounter > 0;\n        }\n        function preRun() {\n            if (Module['preRun']) {\n                if (typeof Module['preRun'] == 'function')\n                    Module['preRun'] = [Module['preRun']];\n                while (Module['preRun'].length) {\n                    addOnPreRun(Module['preRun'].shift());\n                }\n            }\n            callRuntimeCallbacks(__ATPRERUN__);\n        }\n        function initRuntime() {\n            assert(!runtimeInitialized);\n            runtimeInitialized = true;\n            checkStackCookie();\n            if (!Module[\"noFSInit\"] && !FS.init.initialized)\n                FS.init();\n            FS.ignorePermissions = false;\n            TTY.init();\n            callRuntimeCallbacks(__ATINIT__);\n        }\n        function postRun() {\n            checkStackCookie();\n            if (Module['postRun']) {\n                if (typeof Module['postRun'] == 'function')\n                    Module['postRun'] = [Module['postRun']];\n                while (Module['postRun'].length) {\n                    addOnPostRun(Module['postRun'].shift());\n                }\n            }\n            callRuntimeCallbacks(__ATPOSTRUN__);\n        }\n        function addOnPreRun(cb) {\n            __ATPRERUN__.unshift(cb);\n        }\n        function addOnInit(cb) {\n            __ATINIT__.unshift(cb);\n        }\n        function addOnExit(cb) {\n        }\n        function addOnPostRun(cb) {\n            __ATPOSTRUN__.unshift(cb);\n        }\n        // include: runtime_math.js\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\n        assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n        assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n        assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n        assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n        // end include: runtime_math.js\n        // A counter of dependencies for calling run(). If we need to\n        // do asynchronous work before running, increment this and\n        // decrement it. Incrementing must happen in a place like\n        // Module.preRun (used by emcc to add file preloading).\n        // Note that you can add dependencies in preRun, even though\n        // it happens right before run - run will be postponed until\n        // the dependencies are met.\n        var runDependencies = 0;\n        var runDependencyWatcher = null;\n        var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n        var runDependencyTracking = {};\n        function getUniqueRunDependency(id) {\n            var orig = id;\n            while (1) {\n                if (!runDependencyTracking[id])\n                    return id;\n                id = orig + Math.random();\n            }\n        }\n        function addRunDependency(id) {\n            runDependencies++;\n            if (Module['monitorRunDependencies']) {\n                Module['monitorRunDependencies'](runDependencies);\n            }\n            if (id) {\n                assert(!runDependencyTracking[id]);\n                runDependencyTracking[id] = 1;\n                if (runDependencyWatcher === null && typeof setInterval != 'undefined') {\n                    // Check for missing dependencies every few seconds\n                    runDependencyWatcher = setInterval(() => {\n                        if (ABORT) {\n                            clearInterval(runDependencyWatcher);\n                            runDependencyWatcher = null;\n                            return;\n                        }\n                        var shown = false;\n                        for (var dep in runDependencyTracking) {\n                            if (!shown) {\n                                shown = true;\n                                err('still waiting on run dependencies:');\n                            }\n                            err(`dependency: ${dep}`);\n                        }\n                        if (shown) {\n                            err('(end of list)');\n                        }\n                    }, 10000);\n                }\n            }\n            else {\n                err('warning: run dependency added without ID');\n            }\n        }\n        function removeRunDependency(id) {\n            runDependencies--;\n            if (Module['monitorRunDependencies']) {\n                Module['monitorRunDependencies'](runDependencies);\n            }\n            if (id) {\n                assert(runDependencyTracking[id]);\n                delete runDependencyTracking[id];\n            }\n            else {\n                err('warning: run dependency removed without ID');\n            }\n            if (runDependencies == 0) {\n                if (runDependencyWatcher !== null) {\n                    clearInterval(runDependencyWatcher);\n                    runDependencyWatcher = null;\n                }\n                if (dependenciesFulfilled) {\n                    var callback = dependenciesFulfilled;\n                    dependenciesFulfilled = null;\n                    callback(); // can add another dependenciesFulfilled\n                }\n            }\n        }\n        /** @param {string|number=} what */\n        function abort(what) {\n            if (Module['onAbort']) {\n                Module['onAbort'](what);\n            }\n            what = 'Aborted(' + what + ')';\n            // TODO(sbc): Should we remove printing and leave it up to whoever\n            // catches the exception?\n            err(what);\n            ABORT = true;\n            EXITSTATUS = 1;\n            // Use a wasm runtime error, because a JS error might be seen as a foreign\n            // exception, which means we'd run destructors on it. We need the error to\n            // simply make the program stop.\n            // FIXME This approach does not work in Wasm EH because it currently does not assume\n            // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\n            // a trap or not based on a hidden field within the object. So at the moment\n            // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\n            // allows this in the wasm spec.\n            // Suppress closure compiler warning here. Closure compiler's builtin extern\n            // defintion for WebAssembly.RuntimeError claims it takes no arguments even\n            // though it can.\n            // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\n            /** @suppress {checkTypes} */\n            var e = new WebAssembly.RuntimeError(what);\n            readyPromiseReject(e);\n            // Throw the error whether or not MODULARIZE is set because abort is used\n            // in code paths apart from instantiation where an exception is expected\n            // to be thrown when abort is called.\n            throw e;\n        }\n        // include: memoryprofiler.js\n        // end include: memoryprofiler.js\n        // include: URIUtils.js\n        // Prefix of data URIs emitted by SINGLE_FILE and related options.\n        var dataURIPrefix = 'data:application/octet-stream;base64,';\n        // Indicates whether filename is a base64 data URI.\n        function isDataURI(filename) {\n            // Prefix of data URIs emitted by SINGLE_FILE and related options.\n            return filename.startsWith(dataURIPrefix);\n        }\n        // Indicates whether filename is delivered via file protocol (as opposed to http/https)\n        function isFileURI(filename) {\n            return filename.startsWith('file://');\n        }\n        // end include: URIUtils.js\n        function createExportWrapper(name) {\n            return function () {\n                assert(runtimeInitialized, `native function \\`${name}\\` called before runtime initialization`);\n                var f = wasmExports[name];\n                assert(f, `exported native function \\`${name}\\` not found`);\n                return f.apply(null, arguments);\n            };\n        }\n        // include: runtime_exceptions.js\n        // Base Emscripten EH error class\n        class EmscriptenEH extends Error {\n        }\n        class EmscriptenSjLj extends EmscriptenEH {\n        }\n        class CppException extends EmscriptenEH {\n            constructor(excPtr) {\n                super(excPtr);\n                this.excPtr = excPtr;\n                const excInfo = getExceptionMessage(excPtr);\n                this.name = excInfo[0];\n                this.message = excInfo[1];\n            }\n        }\n        // end include: runtime_exceptions.js\n        var wasmBinaryFile;\n        if (Module['locateFile']) {\n            wasmBinaryFile = 'src2json.wasm';\n            if (!isDataURI(wasmBinaryFile)) {\n                wasmBinaryFile = locateFile(wasmBinaryFile);\n            }\n        }\n        else {\n            // Use bundler-friendly `new URL(..., import.meta.url)` pattern; works in browsers too.\n            wasmBinaryFile = new URL(/* asset import */ __webpack_require__(/*! src2json.wasm */ \"./out/lib/src2json.wasm\"), __webpack_require__.b).href;\n        }\n        function getBinarySync(file) {\n            if (file == wasmBinaryFile && wasmBinary) {\n                return new Uint8Array(wasmBinary);\n            }\n            if (readBinary) {\n                return readBinary(file);\n            }\n            throw \"both async and sync fetching of the wasm failed\";\n        }\n        function getBinaryPromise(binaryFile) {\n            // If we don't have the binary yet, try to load it asynchronously.\n            // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.\n            // See https://github.com/github/fetch/pull/92#issuecomment-140665932\n            // Cordova or Electron apps are typically loaded from a file:// url.\n            // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.\n            if (!wasmBinary\n                && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n                if (typeof fetch == 'function'\n                    && !isFileURI(binaryFile)) {\n                    return fetch(binaryFile, { credentials: 'same-origin' }).then((response) => {\n                        if (!response['ok']) {\n                            throw \"failed to load wasm binary file at '\" + binaryFile + \"'\";\n                        }\n                        return response['arrayBuffer']();\n                    }).catch(() => getBinarySync(binaryFile));\n                }\n                else if (readAsync) {\n                    // fetch is not available or url is file => try XHR (readAsync uses XHR internally)\n                    return new Promise((resolve, reject) => {\n                        readAsync(binaryFile, (response) => resolve(new Uint8Array(/** @type{!ArrayBuffer} */ (response))), reject);\n                    });\n                }\n            }\n            // Otherwise, getBinarySync should be able to get it synchronously\n            return Promise.resolve().then(() => getBinarySync(binaryFile));\n        }\n        function instantiateArrayBuffer(binaryFile, imports, receiver) {\n            return getBinaryPromise(binaryFile).then((binary) => {\n                return WebAssembly.instantiate(binary, imports);\n            }).then((instance) => {\n                return instance;\n            }).then(receiver, (reason) => {\n                err(`failed to asynchronously prepare wasm: ${reason}`);\n                // Warn on some common problems.\n                if (isFileURI(wasmBinaryFile)) {\n                    err(`warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`);\n                }\n                abort(reason);\n            });\n        }\n        function instantiateAsync(binary, binaryFile, imports, callback) {\n            if (!binary &&\n                typeof WebAssembly.instantiateStreaming == 'function' &&\n                !isDataURI(binaryFile) &&\n                // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.\n                !isFileURI(binaryFile) &&\n                // Avoid instantiateStreaming() on Node.js environment for now, as while\n                // Node.js v18.1.0 implements it, it does not have a full fetch()\n                // implementation yet.\n                //\n                // Reference:\n                //   https://github.com/emscripten-core/emscripten/pull/16917\n                !ENVIRONMENT_IS_NODE &&\n                typeof fetch == 'function') {\n                return fetch(binaryFile, { credentials: 'same-origin' }).then((response) => {\n                    // Suppress closure warning here since the upstream definition for\n                    // instantiateStreaming only allows Promise<Repsponse> rather than\n                    // an actual Response.\n                    // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.\n                    /** @suppress {checkTypes} */\n                    var result = WebAssembly.instantiateStreaming(response, imports);\n                    return result.then(callback, function (reason) {\n                        // We expect the most common failure cause to be a bad MIME type for the binary,\n                        // in which case falling back to ArrayBuffer instantiation should work.\n                        err(`wasm streaming compile failed: ${reason}`);\n                        err('falling back to ArrayBuffer instantiation');\n                        return instantiateArrayBuffer(binaryFile, imports, callback);\n                    });\n                });\n            }\n            return instantiateArrayBuffer(binaryFile, imports, callback);\n        }\n        // Create the wasm instance.\n        // Receives the wasm imports, returns the exports.\n        function createWasm() {\n            // prepare imports\n            var info = {\n                'env': wasmImports,\n                'wasi_snapshot_preview1': wasmImports,\n            };\n            // Load the wasm module and create an instance of using native support in the JS engine.\n            // handle a generated wasm instance, receiving its exports and\n            // performing other necessary setup\n            /** @param {WebAssembly.Module=} module*/\n            function receiveInstance(instance, module) {\n                var exports = instance.exports;\n                wasmExports = exports;\n                wasmMemory = wasmExports['memory'];\n                assert(wasmMemory, \"memory not found in wasm exports\");\n                // This assertion doesn't hold when emscripten is run in --post-link\n                // mode.\n                // TODO(sbc): Read INITIAL_MEMORY out of the wasm file in post-link mode.\n                //assert(wasmMemory.buffer.byteLength === 16777216);\n                updateMemoryViews();\n                wasmTable = wasmExports['__indirect_function_table'];\n                assert(wasmTable, \"table not found in wasm exports\");\n                addOnInit(wasmExports['__wasm_call_ctors']);\n                removeRunDependency('wasm-instantiate');\n                return exports;\n            }\n            // wait for the pthread pool (if any)\n            addRunDependency('wasm-instantiate');\n            // Prefer streaming instantiation if available.\n            // Async compilation can be confusing when an error on the page overwrites Module\n            // (for example, if the order of elements is wrong, and the one defining Module is\n            // later), so we save Module and check it later.\n            var trueModule = Module;\n            function receiveInstantiationResult(result) {\n                // 'result' is a ResultObject object which has both the module and instance.\n                // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n                assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n                trueModule = null;\n                // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n                // When the regression is fixed, can restore the above PTHREADS-enabled path.\n                receiveInstance(result['instance']);\n            }\n            // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n            // to manually instantiate the Wasm module themselves. This allows pages to\n            // run the instantiation parallel to any other async startup actions they are\n            // performing.\n            // Also pthreads and wasm workers initialize the wasm instance through this\n            // path.\n            if (Module['instantiateWasm']) {\n                try {\n                    return Module['instantiateWasm'](info, receiveInstance);\n                }\n                catch (e) {\n                    err(`Module.instantiateWasm callback failed with error: ${e}`);\n                    // If instantiation fails, reject the module ready promise.\n                    readyPromiseReject(e);\n                }\n            }\n            // If instantiation fails, reject the module ready promise.\n            instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);\n            return {}; // no exports yet; we'll fill them in later\n        }\n        // Globals used by JS i64 conversions (see makeSetValue)\n        var tempDouble;\n        var tempI64;\n        // include: runtime_debug.js\n        function legacyModuleProp(prop, newName, incomming = true) {\n            if (!Object.getOwnPropertyDescriptor(Module, prop)) {\n                Object.defineProperty(Module, prop, {\n                    configurable: true,\n                    get() {\n                        let extra = incomming ? ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)' : '';\n                        abort(`\\`Module.${prop}\\` has been replaced by \\`${newName}\\`` + extra);\n                    }\n                });\n            }\n        }\n        function ignoredModuleProp(prop) {\n            if (Object.getOwnPropertyDescriptor(Module, prop)) {\n                abort(`\\`Module.${prop}\\` was supplied but \\`${prop}\\` not included in INCOMING_MODULE_JS_API`);\n            }\n        }\n        // forcing the filesystem exports a few things by default\n        function isExportedByForceFilesystem(name) {\n            return name === 'FS_createPath' ||\n                name === 'FS_createDataFile' ||\n                name === 'FS_createPreloadedFile' ||\n                name === 'FS_unlink' ||\n                name === 'addRunDependency' ||\n                // The old FS has some functionality that WasmFS lacks.\n                name === 'FS_createLazyFile' ||\n                name === 'FS_createDevice' ||\n                name === 'removeRunDependency';\n        }\n        function missingGlobal(sym, msg) {\n            if (typeof globalThis !== 'undefined') {\n                Object.defineProperty(globalThis, sym, {\n                    configurable: true,\n                    get() {\n                        warnOnce('`' + sym + '` is not longer defined by emscripten. ' + msg);\n                        return undefined;\n                    }\n                });\n            }\n        }\n        missingGlobal('buffer', 'Please use HEAP8.buffer or wasmMemory.buffer');\n        missingGlobal('asm', 'Please use wasmExports instead');\n        function missingLibrarySymbol(sym) {\n            if (typeof globalThis !== 'undefined' && !Object.getOwnPropertyDescriptor(globalThis, sym)) {\n                Object.defineProperty(globalThis, sym, {\n                    configurable: true,\n                    get() {\n                        // Can't `abort()` here because it would break code that does runtime\n                        // checks.  e.g. `if (typeof SDL === 'undefined')`.\n                        var msg = '`' + sym + '` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line';\n                        // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in\n                        // library.js, which means $name for a JS name with no prefix, or name\n                        // for a JS name like _name.\n                        var librarySymbol = sym;\n                        if (!librarySymbol.startsWith('_')) {\n                            librarySymbol = '$' + sym;\n                        }\n                        msg += \" (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='\" + librarySymbol + \"')\";\n                        if (isExportedByForceFilesystem(sym)) {\n                            msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\n                        }\n                        warnOnce(msg);\n                        return undefined;\n                    }\n                });\n            }\n            // Any symbol that is not included from the JS libary is also (by definition)\n            // not exported on the Module object.\n            unexportedRuntimeSymbol(sym);\n        }\n        function unexportedRuntimeSymbol(sym) {\n            if (!Object.getOwnPropertyDescriptor(Module, sym)) {\n                Object.defineProperty(Module, sym, {\n                    configurable: true,\n                    get() {\n                        var msg = \"'\" + sym + \"' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)\";\n                        if (isExportedByForceFilesystem(sym)) {\n                            msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\n                        }\n                        abort(msg);\n                    }\n                });\n            }\n        }\n        // Used by XXXXX_DEBUG settings to output debug messages.\n        function dbg(text) {\n            // TODO(sbc): Make this configurable somehow.  Its not always convenient for\n            // logging to show up as warnings.\n            console.warn.apply(console, arguments);\n        }\n        // end include: runtime_debug.js\n        // === Body ===\n        // end include: preamble.js\n        /** @constructor */\n        function ExitStatus(status) {\n            this.name = 'ExitStatus';\n            this.message = `Program terminated with exit(${status})`;\n            this.status = status;\n        }\n        var callRuntimeCallbacks = (callbacks) => {\n            while (callbacks.length > 0) {\n                // Pass the module as the first argument.\n                callbacks.shift()(Module);\n            }\n        };\n        var decrementExceptionRefcount = (ptr) => ___cxa_decrement_exception_refcount(ptr);\n        var withStackSave = (f) => {\n            var stack = stackSave();\n            var ret = f();\n            stackRestore(stack);\n            return ret;\n        };\n        var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;\n        /**\n         * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\n         * array that contains uint8 values, returns a copy of that string as a\n         * Javascript String object.\n         * heapOrArray is either a regular array, or a JavaScript typed array view.\n         * @param {number} idx\n         * @param {number=} maxBytesToRead\n         * @return {string}\n         */\n        var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {\n            var endIdx = idx + maxBytesToRead;\n            var endPtr = idx;\n            // TextDecoder needs to know the byte length in advance, it doesn't stop on\n            // null terminator by itself.  Also, use the length info to avoid running tiny\n            // strings through TextDecoder, since .subarray() allocates garbage.\n            // (As a tiny code save trick, compare endPtr against endIdx using a negation,\n            // so that undefined means Infinity)\n            while (heapOrArray[endPtr] && !(endPtr >= endIdx))\n                ++endPtr;\n            if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n                return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n            }\n            var str = '';\n            // If building with TextDecoder, we have already computed the string length\n            // above, so test loop end condition against that\n            while (idx < endPtr) {\n                // For UTF8 byte structure, see:\n                // http://en.wikipedia.org/wiki/UTF-8#Description\n                // https://www.ietf.org/rfc/rfc2279.txt\n                // https://tools.ietf.org/html/rfc3629\n                var u0 = heapOrArray[idx++];\n                if (!(u0 & 0x80)) {\n                    str += String.fromCharCode(u0);\n                    continue;\n                }\n                var u1 = heapOrArray[idx++] & 63;\n                if ((u0 & 0xE0) == 0xC0) {\n                    str += String.fromCharCode(((u0 & 31) << 6) | u1);\n                    continue;\n                }\n                var u2 = heapOrArray[idx++] & 63;\n                if ((u0 & 0xF0) == 0xE0) {\n                    u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n                }\n                else {\n                    if ((u0 & 0xF8) != 0xF0)\n                        warnOnce('Invalid UTF-8 leading byte ' + ptrToString(u0) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');\n                    u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\n                }\n                if (u0 < 0x10000) {\n                    str += String.fromCharCode(u0);\n                }\n                else {\n                    var ch = u0 - 0x10000;\n                    str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n                }\n            }\n            return str;\n        };\n        /**\n         * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\n         * emscripten HEAP, returns a copy of that string as a Javascript String object.\n         *\n         * @param {number} ptr\n         * @param {number=} maxBytesToRead - An optional length that specifies the\n         *   maximum number of bytes to read. You can omit this parameter to scan the\n         *   string until the first 0 byte. If maxBytesToRead is passed, and the string\n         *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\n         *   string will cut short at that byte index (i.e. maxBytesToRead will not\n         *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing\n         *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw\n         *   JS JIT optimizations off, so it is worth to consider consistently using one\n         * @return {string}\n         */\n        var UTF8ToString = (ptr, maxBytesToRead) => {\n            assert(typeof ptr == 'number');\n            return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n        };\n        var getExceptionMessageCommon = (ptr) => withStackSave(() => {\n            var type_addr_addr = stackAlloc(4);\n            var message_addr_addr = stackAlloc(4);\n            ___get_exception_message(ptr, type_addr_addr, message_addr_addr);\n            var type_addr = HEAPU32[((type_addr_addr) >> 2)];\n            var message_addr = HEAPU32[((message_addr_addr) >> 2)];\n            var type = UTF8ToString(type_addr);\n            _free(type_addr);\n            var message;\n            if (message_addr) {\n                message = UTF8ToString(message_addr);\n                _free(message_addr);\n            }\n            return [type, message];\n        });\n        var getExceptionMessage = (ptr) => getExceptionMessageCommon(ptr);\n        Module['getExceptionMessage'] = getExceptionMessage;\n        /**\n         * @param {number} ptr\n         * @param {string} type\n         */\n        function getValue(ptr, type = 'i8') {\n            if (type.endsWith('*'))\n                type = '*';\n            switch (type) {\n                case 'i1': return HEAP8[((ptr) >> 0)];\n                case 'i8': return HEAP8[((ptr) >> 0)];\n                case 'i16': return HEAP16[((ptr) >> 1)];\n                case 'i32': return HEAP32[((ptr) >> 2)];\n                case 'i64': abort('to do getValue(i64) use WASM_BIGINT');\n                case 'float': return HEAPF32[((ptr) >> 2)];\n                case 'double': return HEAPF64[((ptr) >> 3)];\n                case '*': return HEAPU32[((ptr) >> 2)];\n                default: abort(`invalid type for getValue: ${type}`);\n            }\n        }\n        var incrementExceptionRefcount = (ptr) => ___cxa_increment_exception_refcount(ptr);\n        var ptrToString = (ptr) => {\n            assert(typeof ptr === 'number');\n            // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n            ptr >>>= 0;\n            return '0x' + ptr.toString(16).padStart(8, '0');\n        };\n        /**\n         * @param {number} ptr\n         * @param {number} value\n         * @param {string} type\n         */\n        function setValue(ptr, value, type = 'i8') {\n            if (type.endsWith('*'))\n                type = '*';\n            switch (type) {\n                case 'i1':\n                    HEAP8[((ptr) >> 0)] = value;\n                    break;\n                case 'i8':\n                    HEAP8[((ptr) >> 0)] = value;\n                    break;\n                case 'i16':\n                    HEAP16[((ptr) >> 1)] = value;\n                    break;\n                case 'i32':\n                    HEAP32[((ptr) >> 2)] = value;\n                    break;\n                case 'i64': abort('to do setValue(i64) use WASM_BIGINT');\n                case 'float':\n                    HEAPF32[((ptr) >> 2)] = value;\n                    break;\n                case 'double':\n                    HEAPF64[((ptr) >> 3)] = value;\n                    break;\n                case '*':\n                    HEAPU32[((ptr) >> 2)] = value;\n                    break;\n                default: abort(`invalid type for setValue: ${type}`);\n            }\n        }\n        var warnOnce = (text) => {\n            if (!warnOnce.shown)\n                warnOnce.shown = {};\n            if (!warnOnce.shown[text]) {\n                warnOnce.shown[text] = 1;\n                if (ENVIRONMENT_IS_NODE)\n                    text = 'warning: ' + text;\n                err(text);\n            }\n        };\n        var ___assert_fail = (condition, filename, line, func) => {\n            abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);\n        };\n        var exceptionCaught = [];\n        var uncaughtExceptionCount = 0;\n        var ___cxa_begin_catch = (ptr) => {\n            var info = new ExceptionInfo(ptr);\n            if (!info.get_caught()) {\n                info.set_caught(true);\n                uncaughtExceptionCount--;\n            }\n            info.set_rethrown(false);\n            exceptionCaught.push(info);\n            ___cxa_increment_exception_refcount(info.excPtr);\n            return info.get_exception_ptr();\n        };\n        var exceptionLast = 0;\n        var ___cxa_end_catch = () => {\n            // Clear state flag.\n            _setThrew(0, 0);\n            assert(exceptionCaught.length > 0);\n            // Call destructor if one is registered then clear it.\n            var info = exceptionCaught.pop();\n            ___cxa_decrement_exception_refcount(info.excPtr);\n            exceptionLast = 0; // XXX in decRef?\n        };\n        /** @constructor */\n        function ExceptionInfo(excPtr) {\n            this.excPtr = excPtr;\n            this.ptr = excPtr - 24;\n            this.set_type = function (type) {\n                HEAPU32[(((this.ptr) + (4)) >> 2)] = type;\n            };\n            this.get_type = function () {\n                return HEAPU32[(((this.ptr) + (4)) >> 2)];\n            };\n            this.set_destructor = function (destructor) {\n                HEAPU32[(((this.ptr) + (8)) >> 2)] = destructor;\n            };\n            this.get_destructor = function () {\n                return HEAPU32[(((this.ptr) + (8)) >> 2)];\n            };\n            this.set_caught = function (caught) {\n                caught = caught ? 1 : 0;\n                HEAP8[(((this.ptr) + (12)) >> 0)] = caught;\n            };\n            this.get_caught = function () {\n                return HEAP8[(((this.ptr) + (12)) >> 0)] != 0;\n            };\n            this.set_rethrown = function (rethrown) {\n                rethrown = rethrown ? 1 : 0;\n                HEAP8[(((this.ptr) + (13)) >> 0)] = rethrown;\n            };\n            this.get_rethrown = function () {\n                return HEAP8[(((this.ptr) + (13)) >> 0)] != 0;\n            };\n            // Initialize native structure fields. Should be called once after allocated.\n            this.init = function (type, destructor) {\n                this.set_adjusted_ptr(0);\n                this.set_type(type);\n                this.set_destructor(destructor);\n            };\n            this.set_adjusted_ptr = function (adjustedPtr) {\n                HEAPU32[(((this.ptr) + (16)) >> 2)] = adjustedPtr;\n            };\n            this.get_adjusted_ptr = function () {\n                return HEAPU32[(((this.ptr) + (16)) >> 2)];\n            };\n            // Get pointer which is expected to be received by catch clause in C++ code. It may be adjusted\n            // when the pointer is casted to some of the exception object base classes (e.g. when virtual\n            // inheritance is used). When a pointer is thrown this method should return the thrown pointer\n            // itself.\n            this.get_exception_ptr = function () {\n                // Work around a fastcomp bug, this code is still included for some reason in a build without\n                // exceptions support.\n                var isPointer = ___cxa_is_pointer_type(this.get_type());\n                if (isPointer) {\n                    return HEAPU32[((this.excPtr) >> 2)];\n                }\n                var adjusted = this.get_adjusted_ptr();\n                if (adjusted !== 0)\n                    return adjusted;\n                return this.excPtr;\n            };\n        }\n        var ___resumeException = (ptr) => {\n            if (!exceptionLast) {\n                exceptionLast = new CppException(ptr);\n            }\n            throw exceptionLast;\n        };\n        var findMatchingCatch = (args) => {\n            var thrown = exceptionLast && exceptionLast.excPtr;\n            if (!thrown) {\n                // just pass through the null ptr\n                setTempRet0(0);\n                return 0;\n            }\n            var info = new ExceptionInfo(thrown);\n            info.set_adjusted_ptr(thrown);\n            var thrownType = info.get_type();\n            if (!thrownType) {\n                // just pass through the thrown ptr\n                setTempRet0(0);\n                return thrown;\n            }\n            // can_catch receives a **, add indirection\n            // The different catch blocks are denoted by different types.\n            // Due to inheritance, those types may not precisely match the\n            // type of the thrown object. Find one which matches, and\n            // return the type of the catch block which should be called.\n            for (var arg in args) {\n                var caughtType = args[arg];\n                if (caughtType === 0 || caughtType === thrownType) {\n                    // Catch all clause matched or exactly the same type is caught\n                    break;\n                }\n                var adjusted_ptr_addr = info.ptr + 16;\n                if (___cxa_can_catch(caughtType, thrownType, adjusted_ptr_addr)) {\n                    setTempRet0(caughtType);\n                    return thrown;\n                }\n            }\n            setTempRet0(thrownType);\n            return thrown;\n        };\n        var ___cxa_find_matching_catch_2 = () => findMatchingCatch([]);\n        var ___cxa_find_matching_catch_3 = (arg0) => findMatchingCatch([arg0]);\n        var ___cxa_rethrow = () => {\n            var info = exceptionCaught.pop();\n            if (!info) {\n                abort('no exception to throw');\n            }\n            var ptr = info.excPtr;\n            if (!info.get_rethrown()) {\n                // Only pop if the corresponding push was through rethrow_primary_exception\n                exceptionCaught.push(info);\n                info.set_rethrown(true);\n                info.set_caught(false);\n                uncaughtExceptionCount++;\n            }\n            exceptionLast = new CppException(ptr);\n            throw exceptionLast;\n        };\n        var ___cxa_throw = (ptr, type, destructor) => {\n            var info = new ExceptionInfo(ptr);\n            // Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.\n            info.init(type, destructor);\n            exceptionLast = new CppException(ptr);\n            uncaughtExceptionCount++;\n            throw exceptionLast;\n        };\n        var ___cxa_uncaught_exceptions = () => uncaughtExceptionCount;\n        var setErrNo = (value) => {\n            HEAP32[((___errno_location()) >> 2)] = value;\n            return value;\n        };\n        var PATH = {\n            isAbs: (path) => path.charAt(0) === '/',\n            splitPath: (filename) => {\n                var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n                return splitPathRe.exec(filename).slice(1);\n            },\n            normalizeArray: (parts, allowAboveRoot) => {\n                // if the path tries to go above the root, `up` ends up > 0\n                var up = 0;\n                for (var i = parts.length - 1; i >= 0; i--) {\n                    var last = parts[i];\n                    if (last === '.') {\n                        parts.splice(i, 1);\n                    }\n                    else if (last === '..') {\n                        parts.splice(i, 1);\n                        up++;\n                    }\n                    else if (up) {\n                        parts.splice(i, 1);\n                        up--;\n                    }\n                }\n                // if the path is allowed to go above the root, restore leading ..s\n                if (allowAboveRoot) {\n                    for (; up; up--) {\n                        parts.unshift('..');\n                    }\n                }\n                return parts;\n            },\n            normalize: (path) => {\n                var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === '/';\n                // Normalize the path\n                path = PATH.normalizeArray(path.split('/').filter((p) => !!p), !isAbsolute).join('/');\n                if (!path && !isAbsolute) {\n                    path = '.';\n                }\n                if (path && trailingSlash) {\n                    path += '/';\n                }\n                return (isAbsolute ? '/' : '') + path;\n            },\n            dirname: (path) => {\n                var result = PATH.splitPath(path), root = result[0], dir = result[1];\n                if (!root && !dir) {\n                    // No dirname whatsoever\n                    return '.';\n                }\n                if (dir) {\n                    // It has a dirname, strip trailing slash\n                    dir = dir.substr(0, dir.length - 1);\n                }\n                return root + dir;\n            },\n            basename: (path) => {\n                // EMSCRIPTEN return '/'' for '/', not an empty string\n                if (path === '/')\n                    return '/';\n                path = PATH.normalize(path);\n                path = path.replace(/\\/$/, \"\");\n                var lastSlash = path.lastIndexOf('/');\n                if (lastSlash === -1)\n                    return path;\n                return path.substr(lastSlash + 1);\n            },\n            join: function () {\n                var paths = Array.prototype.slice.call(arguments);\n                return PATH.normalize(paths.join('/'));\n            },\n            join2: (l, r) => {\n                return PATH.normalize(l + '/' + r);\n            },\n        };\n        var initRandomFill = () => {\n            if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {\n                // for modern web browsers\n                return (view) => crypto.getRandomValues(view);\n            }\n            else if (ENVIRONMENT_IS_NODE) {\n                // for nodejs with or without crypto support included\n                try {\n                    var crypto_module = require('crypto');\n                    var randomFillSync = crypto_module['randomFillSync'];\n                    if (randomFillSync) {\n                        // nodejs with LTS crypto support\n                        return (view) => crypto_module['randomFillSync'](view);\n                    }\n                    // very old nodejs with the original crypto API\n                    var randomBytes = crypto_module['randomBytes'];\n                    return (view) => (view.set(randomBytes(view.byteLength)),\n                        // Return the original view to match modern native implementations.\n                        view);\n                }\n                catch (e) {\n                    // nodejs doesn't have crypto support\n                }\n            }\n            // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096\n            abort(\"no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: (array) => { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };\");\n        };\n        var randomFill = (view) => {\n            // Lazily init on the first invocation.\n            return (randomFill = initRandomFill())(view);\n        };\n        var PATH_FS = {\n            resolve: function () {\n                var resolvedPath = '', resolvedAbsolute = false;\n                for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n                    var path = (i >= 0) ? arguments[i] : FS.cwd();\n                    // Skip empty and invalid entries\n                    if (typeof path != 'string') {\n                        throw new TypeError('Arguments to path.resolve must be strings');\n                    }\n                    else if (!path) {\n                        return ''; // an invalid portion invalidates the whole thing\n                    }\n                    resolvedPath = path + '/' + resolvedPath;\n                    resolvedAbsolute = PATH.isAbs(path);\n                }\n                // At this point the path should be resolved to a full absolute path, but\n                // handle relative paths to be safe (might happen when process.cwd() fails)\n                resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter((p) => !!p), !resolvedAbsolute).join('/');\n                return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n            },\n            relative: (from, to) => {\n                from = PATH_FS.resolve(from).substr(1);\n                to = PATH_FS.resolve(to).substr(1);\n                function trim(arr) {\n                    var start = 0;\n                    for (; start < arr.length; start++) {\n                        if (arr[start] !== '')\n                            break;\n                    }\n                    var end = arr.length - 1;\n                    for (; end >= 0; end--) {\n                        if (arr[end] !== '')\n                            break;\n                    }\n                    if (start > end)\n                        return [];\n                    return arr.slice(start, end - start + 1);\n                }\n                var fromParts = trim(from.split('/'));\n                var toParts = trim(to.split('/'));\n                var length = Math.min(fromParts.length, toParts.length);\n                var samePartsLength = length;\n                for (var i = 0; i < length; i++) {\n                    if (fromParts[i] !== toParts[i]) {\n                        samePartsLength = i;\n                        break;\n                    }\n                }\n                var outputParts = [];\n                for (var i = samePartsLength; i < fromParts.length; i++) {\n                    outputParts.push('..');\n                }\n                outputParts = outputParts.concat(toParts.slice(samePartsLength));\n                return outputParts.join('/');\n            },\n        };\n        var FS_stdin_getChar_buffer = [];\n        var lengthBytesUTF8 = (str) => {\n            var len = 0;\n            for (var i = 0; i < str.length; ++i) {\n                // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n                // unit, not a Unicode code point of the character! So decode\n                // UTF16->UTF32->UTF8.\n                // See http://unicode.org/faq/utf_bom.html#utf16-3\n                var c = str.charCodeAt(i); // possibly a lead surrogate\n                if (c <= 0x7F) {\n                    len++;\n                }\n                else if (c <= 0x7FF) {\n                    len += 2;\n                }\n                else if (c >= 0xD800 && c <= 0xDFFF) {\n                    len += 4;\n                    ++i;\n                }\n                else {\n                    len += 3;\n                }\n            }\n            return len;\n        };\n        var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n            assert(typeof str === 'string');\n            // Parameter maxBytesToWrite is not optional. Negative values, 0, null,\n            // undefined and false each don't write out any bytes.\n            if (!(maxBytesToWrite > 0))\n                return 0;\n            var startIdx = outIdx;\n            var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n            for (var i = 0; i < str.length; ++i) {\n                // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n                // unit, not a Unicode code point of the character! So decode\n                // UTF16->UTF32->UTF8.\n                // See http://unicode.org/faq/utf_bom.html#utf16-3\n                // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description\n                // and https://www.ietf.org/rfc/rfc2279.txt\n                // and https://tools.ietf.org/html/rfc3629\n                var u = str.charCodeAt(i); // possibly a lead surrogate\n                if (u >= 0xD800 && u <= 0xDFFF) {\n                    var u1 = str.charCodeAt(++i);\n                    u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);\n                }\n                if (u <= 0x7F) {\n                    if (outIdx >= endIdx)\n                        break;\n                    heap[outIdx++] = u;\n                }\n                else if (u <= 0x7FF) {\n                    if (outIdx + 1 >= endIdx)\n                        break;\n                    heap[outIdx++] = 0xC0 | (u >> 6);\n                    heap[outIdx++] = 0x80 | (u & 63);\n                }\n                else if (u <= 0xFFFF) {\n                    if (outIdx + 2 >= endIdx)\n                        break;\n                    heap[outIdx++] = 0xE0 | (u >> 12);\n                    heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n                    heap[outIdx++] = 0x80 | (u & 63);\n                }\n                else {\n                    if (outIdx + 3 >= endIdx)\n                        break;\n                    if (u > 0x10FFFF)\n                        warnOnce('Invalid Unicode code point ' + ptrToString(u) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');\n                    heap[outIdx++] = 0xF0 | (u >> 18);\n                    heap[outIdx++] = 0x80 | ((u >> 12) & 63);\n                    heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n                    heap[outIdx++] = 0x80 | (u & 63);\n                }\n            }\n            // Null-terminate the pointer to the buffer.\n            heap[outIdx] = 0;\n            return outIdx - startIdx;\n        };\n        /** @type {function(string, boolean=, number=)} */\n        function intArrayFromString(stringy, dontAddNull, length) {\n            var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n            var u8array = new Array(len);\n            var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n            if (dontAddNull)\n                u8array.length = numBytesWritten;\n            return u8array;\n        }\n        var FS_stdin_getChar = () => {\n            if (!FS_stdin_getChar_buffer.length) {\n                var result = null;\n                if (ENVIRONMENT_IS_NODE) {\n                    // we will read data by chunks of BUFSIZE\n                    var BUFSIZE = 256;\n                    var buf = Buffer.alloc(BUFSIZE);\n                    var bytesRead = 0;\n                    // For some reason we must suppress a closure warning here, even though\n                    // fd definitely exists on process.stdin, and is even the proper way to\n                    // get the fd of stdin,\n                    // https://github.com/nodejs/help/issues/2136#issuecomment-523649904\n                    // This started to happen after moving this logic out of library_tty.js,\n                    // so it is related to the surrounding code in some unclear manner.\n                    /** @suppress {missingProperties} */\n                    var fd = process.stdin.fd;\n                    try {\n                        bytesRead = fs.readSync(fd, buf);\n                    }\n                    catch (e) {\n                        // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,\n                        // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.\n                        if (e.toString().includes('EOF'))\n                            bytesRead = 0;\n                        else\n                            throw e;\n                    }\n                    if (bytesRead > 0) {\n                        result = buf.slice(0, bytesRead).toString('utf-8');\n                    }\n                    else {\n                        result = null;\n                    }\n                }\n                else if (typeof window != 'undefined' &&\n                    typeof window.prompt == 'function') {\n                    // Browser.\n                    result = window.prompt('Input: '); // returns null on cancel\n                    if (result !== null) {\n                        result += '\\n';\n                    }\n                }\n                else if (typeof readline == 'function') {\n                    // Command line.\n                    result = readline();\n                    if (result !== null) {\n                        result += '\\n';\n                    }\n                }\n                if (!result) {\n                    return null;\n                }\n                FS_stdin_getChar_buffer = intArrayFromString(result, true);\n            }\n            return FS_stdin_getChar_buffer.shift();\n        };\n        var TTY = {\n            ttys: [],\n            init() {\n                // https://github.com/emscripten-core/emscripten/pull/1555\n                // if (ENVIRONMENT_IS_NODE) {\n                //   // currently, FS.init does not distinguish if process.stdin is a file or TTY\n                //   // device, it always assumes it's a TTY device. because of this, we're forcing\n                //   // process.stdin to UTF8 encoding to at least make stdin reading compatible\n                //   // with text files until FS.init can be refactored.\n                //   process.stdin.setEncoding('utf8');\n                // }\n            },\n            shutdown() {\n                // https://github.com/emscripten-core/emscripten/pull/1555\n                // if (ENVIRONMENT_IS_NODE) {\n                //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?\n                //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation\n                //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?\n                //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle\n                //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call\n                //   process.stdin.pause();\n                // }\n            },\n            register(dev, ops) {\n                TTY.ttys[dev] = { input: [], output: [], ops: ops };\n                FS.registerDevice(dev, TTY.stream_ops);\n            },\n            stream_ops: {\n                open(stream) {\n                    var tty = TTY.ttys[stream.node.rdev];\n                    if (!tty) {\n                        throw new FS.ErrnoError(43);\n                    }\n                    stream.tty = tty;\n                    stream.seekable = false;\n                },\n                close(stream) {\n                    // flush any pending line data\n                    stream.tty.ops.fsync(stream.tty);\n                },\n                fsync(stream) {\n                    stream.tty.ops.fsync(stream.tty);\n                },\n                read(stream, buffer, offset, length, pos /* ignored */) {\n                    if (!stream.tty || !stream.tty.ops.get_char) {\n                        throw new FS.ErrnoError(60);\n                    }\n                    var bytesRead = 0;\n                    for (var i = 0; i < length; i++) {\n                        var result;\n                        try {\n                            result = stream.tty.ops.get_char(stream.tty);\n                        }\n                        catch (e) {\n                            throw new FS.ErrnoError(29);\n                        }\n                        if (result === undefined && bytesRead === 0) {\n                            throw new FS.ErrnoError(6);\n                        }\n                        if (result === null || result === undefined)\n                            break;\n                        bytesRead++;\n                        buffer[offset + i] = result;\n                    }\n                    if (bytesRead) {\n                        stream.node.timestamp = Date.now();\n                    }\n                    return bytesRead;\n                },\n                write(stream, buffer, offset, length, pos) {\n                    if (!stream.tty || !stream.tty.ops.put_char) {\n                        throw new FS.ErrnoError(60);\n                    }\n                    try {\n                        for (var i = 0; i < length; i++) {\n                            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n                        }\n                    }\n                    catch (e) {\n                        throw new FS.ErrnoError(29);\n                    }\n                    if (length) {\n                        stream.node.timestamp = Date.now();\n                    }\n                    return i;\n                },\n            },\n            default_tty_ops: {\n                get_char(tty) {\n                    return FS_stdin_getChar();\n                },\n                put_char(tty, val) {\n                    if (val === null || val === 10) {\n                        out(UTF8ArrayToString(tty.output, 0));\n                        tty.output = [];\n                    }\n                    else {\n                        if (val != 0)\n                            tty.output.push(val); // val == 0 would cut text output off in the middle.\n                    }\n                },\n                fsync(tty) {\n                    if (tty.output && tty.output.length > 0) {\n                        out(UTF8ArrayToString(tty.output, 0));\n                        tty.output = [];\n                    }\n                },\n                ioctl_tcgets(tty) {\n                    // typical setting\n                    return {\n                        c_iflag: 25856,\n                        c_oflag: 5,\n                        c_cflag: 191,\n                        c_lflag: 35387,\n                        c_cc: [\n                            0x03, 0x1c, 0x7f, 0x15, 0x04, 0x00, 0x01, 0x00, 0x11, 0x13, 0x1a, 0x00,\n                            0x12, 0x0f, 0x17, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                        ]\n                    };\n                },\n                ioctl_tcsets(tty, optional_actions, data) {\n                    // currently just ignore\n                    return 0;\n                },\n                ioctl_tiocgwinsz(tty) {\n                    return [24, 80];\n                },\n            },\n            default_tty1_ops: {\n                put_char(tty, val) {\n                    if (val === null || val === 10) {\n                        err(UTF8ArrayToString(tty.output, 0));\n                        tty.output = [];\n                    }\n                    else {\n                        if (val != 0)\n                            tty.output.push(val);\n                    }\n                },\n                fsync(tty) {\n                    if (tty.output && tty.output.length > 0) {\n                        err(UTF8ArrayToString(tty.output, 0));\n                        tty.output = [];\n                    }\n                },\n            },\n        };\n        var zeroMemory = (address, size) => {\n            HEAPU8.fill(0, address, address + size);\n            return address;\n        };\n        var alignMemory = (size, alignment) => {\n            assert(alignment, \"alignment argument is required\");\n            return Math.ceil(size / alignment) * alignment;\n        };\n        var mmapAlloc = (size) => {\n            size = alignMemory(size, 65536);\n            var ptr = _emscripten_builtin_memalign(65536, size);\n            if (!ptr)\n                return 0;\n            return zeroMemory(ptr, size);\n        };\n        var MEMFS = {\n            ops_table: null,\n            mount(mount) {\n                return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);\n            },\n            createNode(parent, name, mode, dev) {\n                if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n                    // no supported\n                    throw new FS.ErrnoError(63);\n                }\n                if (!MEMFS.ops_table) {\n                    MEMFS.ops_table = {\n                        dir: {\n                            node: {\n                                getattr: MEMFS.node_ops.getattr,\n                                setattr: MEMFS.node_ops.setattr,\n                                lookup: MEMFS.node_ops.lookup,\n                                mknod: MEMFS.node_ops.mknod,\n                                rename: MEMFS.node_ops.rename,\n                                unlink: MEMFS.node_ops.unlink,\n                                rmdir: MEMFS.node_ops.rmdir,\n                                readdir: MEMFS.node_ops.readdir,\n                                symlink: MEMFS.node_ops.symlink\n                            },\n                            stream: {\n                                llseek: MEMFS.stream_ops.llseek\n                            }\n                        },\n                        file: {\n                            node: {\n                                getattr: MEMFS.node_ops.getattr,\n                                setattr: MEMFS.node_ops.setattr\n                            },\n                            stream: {\n                                llseek: MEMFS.stream_ops.llseek,\n                                read: MEMFS.stream_ops.read,\n                                write: MEMFS.stream_ops.write,\n                                allocate: MEMFS.stream_ops.allocate,\n                                mmap: MEMFS.stream_ops.mmap,\n                                msync: MEMFS.stream_ops.msync\n                            }\n                        },\n                        link: {\n                            node: {\n                                getattr: MEMFS.node_ops.getattr,\n                                setattr: MEMFS.node_ops.setattr,\n                                readlink: MEMFS.node_ops.readlink\n                            },\n                            stream: {}\n                        },\n                        chrdev: {\n                            node: {\n                                getattr: MEMFS.node_ops.getattr,\n                                setattr: MEMFS.node_ops.setattr\n                            },\n                            stream: FS.chrdev_stream_ops\n                        }\n                    };\n                }\n                var node = FS.createNode(parent, name, mode, dev);\n                if (FS.isDir(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.dir.node;\n                    node.stream_ops = MEMFS.ops_table.dir.stream;\n                    node.contents = {};\n                }\n                else if (FS.isFile(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.file.node;\n                    node.stream_ops = MEMFS.ops_table.file.stream;\n                    node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.\n                    // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred\n                    // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size\n                    // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.\n                    node.contents = null;\n                }\n                else if (FS.isLink(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.link.node;\n                    node.stream_ops = MEMFS.ops_table.link.stream;\n                }\n                else if (FS.isChrdev(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.chrdev.node;\n                    node.stream_ops = MEMFS.ops_table.chrdev.stream;\n                }\n                node.timestamp = Date.now();\n                // add the new node to the parent\n                if (parent) {\n                    parent.contents[name] = node;\n                    parent.timestamp = node.timestamp;\n                }\n                return node;\n            },\n            getFileDataAsTypedArray(node) {\n                if (!node.contents)\n                    return new Uint8Array(0);\n                if (node.contents.subarray)\n                    return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.\n                return new Uint8Array(node.contents);\n            },\n            expandFileStorage(node, newCapacity) {\n                var prevCapacity = node.contents ? node.contents.length : 0;\n                if (prevCapacity >= newCapacity)\n                    return; // No need to expand, the storage was already large enough.\n                // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.\n                // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to\n                // avoid overshooting the allocation cap by a very large margin.\n                var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n                newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);\n                if (prevCapacity != 0)\n                    newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.\n                var oldContents = node.contents;\n                node.contents = new Uint8Array(newCapacity); // Allocate new storage.\n                if (node.usedBytes > 0)\n                    node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.\n            },\n            resizeFileStorage(node, newSize) {\n                if (node.usedBytes == newSize)\n                    return;\n                if (newSize == 0) {\n                    node.contents = null; // Fully decommit when requesting a resize to zero.\n                    node.usedBytes = 0;\n                }\n                else {\n                    var oldContents = node.contents;\n                    node.contents = new Uint8Array(newSize); // Allocate new storage.\n                    if (oldContents) {\n                        node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.\n                    }\n                    node.usedBytes = newSize;\n                }\n            },\n            node_ops: {\n                getattr(node) {\n                    var attr = {};\n                    // device numbers reuse inode numbers.\n                    attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n                    attr.ino = node.id;\n                    attr.mode = node.mode;\n                    attr.nlink = 1;\n                    attr.uid = 0;\n                    attr.gid = 0;\n                    attr.rdev = node.rdev;\n                    if (FS.isDir(node.mode)) {\n                        attr.size = 4096;\n                    }\n                    else if (FS.isFile(node.mode)) {\n                        attr.size = node.usedBytes;\n                    }\n                    else if (FS.isLink(node.mode)) {\n                        attr.size = node.link.length;\n                    }\n                    else {\n                        attr.size = 0;\n                    }\n                    attr.atime = new Date(node.timestamp);\n                    attr.mtime = new Date(node.timestamp);\n                    attr.ctime = new Date(node.timestamp);\n                    // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),\n                    //       but this is not required by the standard.\n                    attr.blksize = 4096;\n                    attr.blocks = Math.ceil(attr.size / attr.blksize);\n                    return attr;\n                },\n                setattr(node, attr) {\n                    if (attr.mode !== undefined) {\n                        node.mode = attr.mode;\n                    }\n                    if (attr.timestamp !== undefined) {\n                        node.timestamp = attr.timestamp;\n                    }\n                    if (attr.size !== undefined) {\n                        MEMFS.resizeFileStorage(node, attr.size);\n                    }\n                },\n                lookup(parent, name) {\n                    throw FS.genericErrors[44];\n                },\n                mknod(parent, name, mode, dev) {\n                    return MEMFS.createNode(parent, name, mode, dev);\n                },\n                rename(old_node, new_dir, new_name) {\n                    // if we're overwriting a directory at new_name, make sure it's empty.\n                    if (FS.isDir(old_node.mode)) {\n                        var new_node;\n                        try {\n                            new_node = FS.lookupNode(new_dir, new_name);\n                        }\n                        catch (e) {\n                        }\n                        if (new_node) {\n                            for (var i in new_node.contents) {\n                                throw new FS.ErrnoError(55);\n                            }\n                        }\n                    }\n                    // do the internal rewiring\n                    delete old_node.parent.contents[old_node.name];\n                    old_node.parent.timestamp = Date.now();\n                    old_node.name = new_name;\n                    new_dir.contents[new_name] = old_node;\n                    new_dir.timestamp = old_node.parent.timestamp;\n                    old_node.parent = new_dir;\n                },\n                unlink(parent, name) {\n                    delete parent.contents[name];\n                    parent.timestamp = Date.now();\n                },\n                rmdir(parent, name) {\n                    var node = FS.lookupNode(parent, name);\n                    for (var i in node.contents) {\n                        throw new FS.ErrnoError(55);\n                    }\n                    delete parent.contents[name];\n                    parent.timestamp = Date.now();\n                },\n                readdir(node) {\n                    var entries = ['.', '..'];\n                    for (var key in node.contents) {\n                        if (!node.contents.hasOwnProperty(key)) {\n                            continue;\n                        }\n                        entries.push(key);\n                    }\n                    return entries;\n                },\n                symlink(parent, newname, oldpath) {\n                    var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);\n                    node.link = oldpath;\n                    return node;\n                },\n                readlink(node) {\n                    if (!FS.isLink(node.mode)) {\n                        throw new FS.ErrnoError(28);\n                    }\n                    return node.link;\n                },\n            },\n            stream_ops: {\n                read(stream, buffer, offset, length, position) {\n                    var contents = stream.node.contents;\n                    if (position >= stream.node.usedBytes)\n                        return 0;\n                    var size = Math.min(stream.node.usedBytes - position, length);\n                    assert(size >= 0);\n                    if (size > 8 && contents.subarray) { // non-trivial, and typed array\n                        buffer.set(contents.subarray(position, position + size), offset);\n                    }\n                    else {\n                        for (var i = 0; i < size; i++)\n                            buffer[offset + i] = contents[position + i];\n                    }\n                    return size;\n                },\n                write(stream, buffer, offset, length, position, canOwn) {\n                    // The data buffer should be a typed array view\n                    assert(!(buffer instanceof ArrayBuffer));\n                    if (!length)\n                        return 0;\n                    var node = stream.node;\n                    node.timestamp = Date.now();\n                    if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?\n                        if (canOwn) {\n                            assert(position === 0, 'canOwn must imply no weird position inside the file');\n                            node.contents = buffer.subarray(offset, offset + length);\n                            node.usedBytes = length;\n                            return length;\n                        }\n                        else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.\n                            node.contents = buffer.slice(offset, offset + length);\n                            node.usedBytes = length;\n                            return length;\n                        }\n                        else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?\n                            node.contents.set(buffer.subarray(offset, offset + length), position);\n                            return length;\n                        }\n                    }\n                    // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.\n                    MEMFS.expandFileStorage(node, position + length);\n                    if (node.contents.subarray && buffer.subarray) {\n                        // Use typed array write which is available.\n                        node.contents.set(buffer.subarray(offset, offset + length), position);\n                    }\n                    else {\n                        for (var i = 0; i < length; i++) {\n                            node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.\n                        }\n                    }\n                    node.usedBytes = Math.max(node.usedBytes, position + length);\n                    return length;\n                },\n                llseek(stream, offset, whence) {\n                    var position = offset;\n                    if (whence === 1) {\n                        position += stream.position;\n                    }\n                    else if (whence === 2) {\n                        if (FS.isFile(stream.node.mode)) {\n                            position += stream.node.usedBytes;\n                        }\n                    }\n                    if (position < 0) {\n                        throw new FS.ErrnoError(28);\n                    }\n                    return position;\n                },\n                allocate(stream, offset, length) {\n                    MEMFS.expandFileStorage(stream.node, offset + length);\n                    stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n                },\n                mmap(stream, length, position, prot, flags) {\n                    if (!FS.isFile(stream.node.mode)) {\n                        throw new FS.ErrnoError(43);\n                    }\n                    var ptr;\n                    var allocated;\n                    var contents = stream.node.contents;\n                    // Only make a new copy when MAP_PRIVATE is specified.\n                    if (!(flags & 2) && contents.buffer === HEAP8.buffer) {\n                        // We can't emulate MAP_SHARED when the file is not backed by the\n                        // buffer we're mapping to (e.g. the HEAP buffer).\n                        allocated = false;\n                        ptr = contents.byteOffset;\n                    }\n                    else {\n                        // Try to avoid unnecessary slices.\n                        if (position > 0 || position + length < contents.length) {\n                            if (contents.subarray) {\n                                contents = contents.subarray(position, position + length);\n                            }\n                            else {\n                                contents = Array.prototype.slice.call(contents, position, position + length);\n                            }\n                        }\n                        allocated = true;\n                        ptr = mmapAlloc(length);\n                        if (!ptr) {\n                            throw new FS.ErrnoError(48);\n                        }\n                        HEAP8.set(contents, ptr);\n                    }\n                    return { ptr, allocated };\n                },\n                msync(stream, buffer, offset, length, mmapFlags) {\n                    MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n                    // should we check if bytesWritten and length are the same?\n                    return 0;\n                },\n            },\n        };\n        /** @param {boolean=} noRunDep */\n        var asyncLoad = (url, onload, onerror, noRunDep) => {\n            var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : '';\n            readAsync(url, (arrayBuffer) => {\n                assert(arrayBuffer, `Loading data file \"${url}\" failed (no arrayBuffer).`);\n                onload(new Uint8Array(arrayBuffer));\n                if (dep)\n                    removeRunDependency(dep);\n            }, (event) => {\n                if (onerror) {\n                    onerror();\n                }\n                else {\n                    throw `Loading data file \"${url}\" failed.`;\n                }\n            });\n            if (dep)\n                addRunDependency(dep);\n        };\n        var preloadPlugins = Module['preloadPlugins'] || [];\n        var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {\n            // Ensure plugins are ready.\n            if (typeof Browser != 'undefined')\n                Browser.init();\n            var handled = false;\n            preloadPlugins.forEach((plugin) => {\n                if (handled)\n                    return;\n                if (plugin['canHandle'](fullname)) {\n                    plugin['handle'](byteArray, fullname, finish, onerror);\n                    handled = true;\n                }\n            });\n            return handled;\n        };\n        var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {\n            // TODO we should allow people to just pass in a complete filename instead\n            // of parent and name being that we just join them anyways\n            var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n            var dep = getUniqueRunDependency(`cp ${fullname}`); // might have several active requests for the same fullname\n            function processData(byteArray) {\n                function finish(byteArray) {\n                    if (preFinish)\n                        preFinish();\n                    if (!dontCreateFile) {\n                        FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n                    }\n                    if (onload)\n                        onload();\n                    removeRunDependency(dep);\n                }\n                if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {\n                    if (onerror)\n                        onerror();\n                    removeRunDependency(dep);\n                })) {\n                    return;\n                }\n                finish(byteArray);\n            }\n            addRunDependency(dep);\n            if (typeof url == 'string') {\n                asyncLoad(url, (byteArray) => processData(byteArray), onerror);\n            }\n            else {\n                processData(url);\n            }\n        };\n        var FS_modeStringToFlags = (str) => {\n            var flagModes = {\n                'r': 0,\n                'r+': 2,\n                'w': 512 | 64 | 1,\n                'w+': 512 | 64 | 2,\n                'a': 1024 | 64 | 1,\n                'a+': 1024 | 64 | 2,\n            };\n            var flags = flagModes[str];\n            if (typeof flags == 'undefined') {\n                throw new Error(`Unknown file open mode: ${str}`);\n            }\n            return flags;\n        };\n        var FS_getMode = (canRead, canWrite) => {\n            var mode = 0;\n            if (canRead)\n                mode |= 292 | 73;\n            if (canWrite)\n                mode |= 146;\n            return mode;\n        };\n        var ERRNO_MESSAGES = {\n            0: \"Success\",\n            1: \"Arg list too long\",\n            2: \"Permission denied\",\n            3: \"Address already in use\",\n            4: \"Address not available\",\n            5: \"Address family not supported by protocol family\",\n            6: \"No more processes\",\n            7: \"Socket already connected\",\n            8: \"Bad file number\",\n            9: \"Trying to read unreadable message\",\n            10: \"Mount device busy\",\n            11: \"Operation canceled\",\n            12: \"No children\",\n            13: \"Connection aborted\",\n            14: \"Connection refused\",\n            15: \"Connection reset by peer\",\n            16: \"File locking deadlock error\",\n            17: \"Destination address required\",\n            18: \"Math arg out of domain of func\",\n            19: \"Quota exceeded\",\n            20: \"File exists\",\n            21: \"Bad address\",\n            22: \"File too large\",\n            23: \"Host is unreachable\",\n            24: \"Identifier removed\",\n            25: \"Illegal byte sequence\",\n            26: \"Connection already in progress\",\n            27: \"Interrupted system call\",\n            28: \"Invalid argument\",\n            29: \"I/O error\",\n            30: \"Socket is already connected\",\n            31: \"Is a directory\",\n            32: \"Too many symbolic links\",\n            33: \"Too many open files\",\n            34: \"Too many links\",\n            35: \"Message too long\",\n            36: \"Multihop attempted\",\n            37: \"File or path name too long\",\n            38: \"Network interface is not configured\",\n            39: \"Connection reset by network\",\n            40: \"Network is unreachable\",\n            41: \"Too many open files in system\",\n            42: \"No buffer space available\",\n            43: \"No such device\",\n            44: \"No such file or directory\",\n            45: \"Exec format error\",\n            46: \"No record locks available\",\n            47: \"The link has been severed\",\n            48: \"Not enough core\",\n            49: \"No message of desired type\",\n            50: \"Protocol not available\",\n            51: \"No space left on device\",\n            52: \"Function not implemented\",\n            53: \"Socket is not connected\",\n            54: \"Not a directory\",\n            55: \"Directory not empty\",\n            56: \"State not recoverable\",\n            57: \"Socket operation on non-socket\",\n            59: \"Not a typewriter\",\n            60: \"No such device or address\",\n            61: \"Value too large for defined data type\",\n            62: \"Previous owner died\",\n            63: \"Not super-user\",\n            64: \"Broken pipe\",\n            65: \"Protocol error\",\n            66: \"Unknown protocol\",\n            67: \"Protocol wrong type for socket\",\n            68: \"Math result not representable\",\n            69: \"Read only file system\",\n            70: \"Illegal seek\",\n            71: \"No such process\",\n            72: \"Stale file handle\",\n            73: \"Connection timed out\",\n            74: \"Text file busy\",\n            75: \"Cross-device link\",\n            100: \"Device not a stream\",\n            101: \"Bad font file fmt\",\n            102: \"Invalid slot\",\n            103: \"Invalid request code\",\n            104: \"No anode\",\n            105: \"Block device required\",\n            106: \"Channel number out of range\",\n            107: \"Level 3 halted\",\n            108: \"Level 3 reset\",\n            109: \"Link number out of range\",\n            110: \"Protocol driver not attached\",\n            111: \"No CSI structure available\",\n            112: \"Level 2 halted\",\n            113: \"Invalid exchange\",\n            114: \"Invalid request descriptor\",\n            115: \"Exchange full\",\n            116: \"No data (for no delay io)\",\n            117: \"Timer expired\",\n            118: \"Out of streams resources\",\n            119: \"Machine is not on the network\",\n            120: \"Package not installed\",\n            121: \"The object is remote\",\n            122: \"Advertise error\",\n            123: \"Srmount error\",\n            124: \"Communication error on send\",\n            125: \"Cross mount point (not really error)\",\n            126: \"Given log. name not unique\",\n            127: \"f.d. invalid for this operation\",\n            128: \"Remote address changed\",\n            129: \"Can   access a needed shared lib\",\n            130: \"Accessing a corrupted shared lib\",\n            131: \".lib section in a.out corrupted\",\n            132: \"Attempting to link in too many libs\",\n            133: \"Attempting to exec a shared library\",\n            135: \"Streams pipe error\",\n            136: \"Too many users\",\n            137: \"Socket type not supported\",\n            138: \"Not supported\",\n            139: \"Protocol family not supported\",\n            140: \"Can't send after socket shutdown\",\n            141: \"Too many references\",\n            142: \"Host is down\",\n            148: \"No medium (in tape drive)\",\n            156: \"Level 2 not synchronized\",\n        };\n        var ERRNO_CODES = {};\n        var demangle = (func) => {\n            warnOnce('warning: build with -sDEMANGLE_SUPPORT to link in libcxxabi demangling');\n            return func;\n        };\n        var demangleAll = (text) => {\n            var regex = /\\b_Z[\\w\\d_]+/g;\n            return text.replace(regex, function (x) {\n                var y = demangle(x);\n                return x === y ? x : (y + ' [' + x + ']');\n            });\n        };\n        var FS = {\n            root: null,\n            mounts: [],\n            devices: {},\n            streams: [],\n            nextInode: 1,\n            nameTable: null,\n            currentPath: \"/\",\n            initialized: false,\n            ignorePermissions: true,\n            ErrnoError: null,\n            genericErrors: {},\n            filesystems: null,\n            syncFSRequests: 0,\n            lookupPath(path, opts = {}) {\n                path = PATH_FS.resolve(path);\n                if (!path)\n                    return { path: '', node: null };\n                var defaults = {\n                    follow_mount: true,\n                    recurse_count: 0\n                };\n                opts = Object.assign(defaults, opts);\n                if (opts.recurse_count > 8) { // max recursive lookup of 8\n                    throw new FS.ErrnoError(32);\n                }\n                // split the absolute path\n                var parts = path.split('/').filter((p) => !!p);\n                // start at the root\n                var current = FS.root;\n                var current_path = '/';\n                for (var i = 0; i < parts.length; i++) {\n                    var islast = (i === parts.length - 1);\n                    if (islast && opts.parent) {\n                        // stop resolving\n                        break;\n                    }\n                    current = FS.lookupNode(current, parts[i]);\n                    current_path = PATH.join2(current_path, parts[i]);\n                    // jump to the mount's root node if this is a mountpoint\n                    if (FS.isMountpoint(current)) {\n                        if (!islast || (islast && opts.follow_mount)) {\n                            current = current.mounted.root;\n                        }\n                    }\n                    // by default, lookupPath will not follow a symlink if it is the final path component.\n                    // setting opts.follow = true will override this behavior.\n                    if (!islast || opts.follow) {\n                        var count = 0;\n                        while (FS.isLink(current.mode)) {\n                            var link = FS.readlink(current_path);\n                            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n                            var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });\n                            current = lookup.node;\n                            if (count++ > 40) { // limit max consecutive symlinks to 40 (SYMLOOP_MAX).\n                                throw new FS.ErrnoError(32);\n                            }\n                        }\n                    }\n                }\n                return { path: current_path, node: current };\n            },\n            getPath(node) {\n                var path;\n                while (true) {\n                    if (FS.isRoot(node)) {\n                        var mount = node.mount.mountpoint;\n                        if (!path)\n                            return mount;\n                        return mount[mount.length - 1] !== '/' ? `${mount}/${path}` : mount + path;\n                    }\n                    path = path ? `${node.name}/${path}` : node.name;\n                    node = node.parent;\n                }\n            },\n            hashName(parentid, name) {\n                var hash = 0;\n                for (var i = 0; i < name.length; i++) {\n                    hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;\n                }\n                return ((parentid + hash) >>> 0) % FS.nameTable.length;\n            },\n            hashAddNode(node) {\n                var hash = FS.hashName(node.parent.id, node.name);\n                node.name_next = FS.nameTable[hash];\n                FS.nameTable[hash] = node;\n            },\n            hashRemoveNode(node) {\n                var hash = FS.hashName(node.parent.id, node.name);\n                if (FS.nameTable[hash] === node) {\n                    FS.nameTable[hash] = node.name_next;\n                }\n                else {\n                    var current = FS.nameTable[hash];\n                    while (current) {\n                        if (current.name_next === node) {\n                            current.name_next = node.name_next;\n                            break;\n                        }\n                        current = current.name_next;\n                    }\n                }\n            },\n            lookupNode(parent, name) {\n                var errCode = FS.mayLookup(parent);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode, parent);\n                }\n                var hash = FS.hashName(parent.id, name);\n                for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n                    var nodeName = node.name;\n                    if (node.parent.id === parent.id && nodeName === name) {\n                        return node;\n                    }\n                }\n                // if we failed to find it in the cache, call into the VFS\n                return FS.lookup(parent, name);\n            },\n            createNode(parent, name, mode, rdev) {\n                assert(typeof parent == 'object');\n                var node = new FS.FSNode(parent, name, mode, rdev);\n                FS.hashAddNode(node);\n                return node;\n            },\n            destroyNode(node) {\n                FS.hashRemoveNode(node);\n            },\n            isRoot(node) {\n                return node === node.parent;\n            },\n            isMountpoint(node) {\n                return !!node.mounted;\n            },\n            isFile(mode) {\n                return (mode & 61440) === 32768;\n            },\n            isDir(mode) {\n                return (mode & 61440) === 16384;\n            },\n            isLink(mode) {\n                return (mode & 61440) === 40960;\n            },\n            isChrdev(mode) {\n                return (mode & 61440) === 8192;\n            },\n            isBlkdev(mode) {\n                return (mode & 61440) === 24576;\n            },\n            isFIFO(mode) {\n                return (mode & 61440) === 4096;\n            },\n            isSocket(mode) {\n                return (mode & 49152) === 49152;\n            },\n            flagsToPermissionString(flag) {\n                var perms = ['r', 'w', 'rw'][flag & 3];\n                if ((flag & 512)) {\n                    perms += 'w';\n                }\n                return perms;\n            },\n            nodePermissions(node, perms) {\n                if (FS.ignorePermissions) {\n                    return 0;\n                }\n                // return 0 if any user, group or owner bits are set.\n                if (perms.includes('r') && !(node.mode & 292)) {\n                    return 2;\n                }\n                else if (perms.includes('w') && !(node.mode & 146)) {\n                    return 2;\n                }\n                else if (perms.includes('x') && !(node.mode & 73)) {\n                    return 2;\n                }\n                return 0;\n            },\n            mayLookup(dir) {\n                var errCode = FS.nodePermissions(dir, 'x');\n                if (errCode)\n                    return errCode;\n                if (!dir.node_ops.lookup)\n                    return 2;\n                return 0;\n            },\n            mayCreate(dir, name) {\n                try {\n                    var node = FS.lookupNode(dir, name);\n                    return 20;\n                }\n                catch (e) {\n                }\n                return FS.nodePermissions(dir, 'wx');\n            },\n            mayDelete(dir, name, isdir) {\n                var node;\n                try {\n                    node = FS.lookupNode(dir, name);\n                }\n                catch (e) {\n                    return e.errno;\n                }\n                var errCode = FS.nodePermissions(dir, 'wx');\n                if (errCode) {\n                    return errCode;\n                }\n                if (isdir) {\n                    if (!FS.isDir(node.mode)) {\n                        return 54;\n                    }\n                    if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n                        return 10;\n                    }\n                }\n                else {\n                    if (FS.isDir(node.mode)) {\n                        return 31;\n                    }\n                }\n                return 0;\n            },\n            mayOpen(node, flags) {\n                if (!node) {\n                    return 44;\n                }\n                if (FS.isLink(node.mode)) {\n                    return 32;\n                }\n                else if (FS.isDir(node.mode)) {\n                    if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write\n                        (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)\n                        return 31;\n                    }\n                }\n                return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n            },\n            MAX_OPEN_FDS: 4096,\n            nextfd() {\n                for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {\n                    if (!FS.streams[fd]) {\n                        return fd;\n                    }\n                }\n                throw new FS.ErrnoError(33);\n            },\n            getStreamChecked(fd) {\n                var stream = FS.getStream(fd);\n                if (!stream) {\n                    throw new FS.ErrnoError(8);\n                }\n                return stream;\n            },\n            getStream: (fd) => FS.streams[fd],\n            createStream(stream, fd = -1) {\n                if (!FS.FSStream) {\n                    FS.FSStream = /** @constructor */ function () {\n                        this.shared = {};\n                    };\n                    FS.FSStream.prototype = {};\n                    Object.defineProperties(FS.FSStream.prototype, {\n                        object: {\n                            /** @this {FS.FSStream} */\n                            get() { return this.node; },\n                            /** @this {FS.FSStream} */\n                            set(val) { this.node = val; }\n                        },\n                        isRead: {\n                            /** @this {FS.FSStream} */\n                            get() { return (this.flags & 2097155) !== 1; }\n                        },\n                        isWrite: {\n                            /** @this {FS.FSStream} */\n                            get() { return (this.flags & 2097155) !== 0; }\n                        },\n                        isAppend: {\n                            /** @this {FS.FSStream} */\n                            get() { return (this.flags & 1024); }\n                        },\n                        flags: {\n                            /** @this {FS.FSStream} */\n                            get() { return this.shared.flags; },\n                            /** @this {FS.FSStream} */\n                            set(val) { this.shared.flags = val; },\n                        },\n                        position: {\n                            /** @this {FS.FSStream} */\n                            get() { return this.shared.position; },\n                            /** @this {FS.FSStream} */\n                            set(val) { this.shared.position = val; },\n                        },\n                    });\n                }\n                // clone it, so we can return an instance of FSStream\n                stream = Object.assign(new FS.FSStream(), stream);\n                if (fd == -1) {\n                    fd = FS.nextfd();\n                }\n                stream.fd = fd;\n                FS.streams[fd] = stream;\n                return stream;\n            },\n            closeStream(fd) {\n                FS.streams[fd] = null;\n            },\n            chrdev_stream_ops: {\n                open(stream) {\n                    var device = FS.getDevice(stream.node.rdev);\n                    // override node's stream ops with the device's\n                    stream.stream_ops = device.stream_ops;\n                    // forward the open call\n                    if (stream.stream_ops.open) {\n                        stream.stream_ops.open(stream);\n                    }\n                },\n                llseek() {\n                    throw new FS.ErrnoError(70);\n                },\n            },\n            major: (dev) => ((dev) >> 8),\n            minor: (dev) => ((dev) & 0xff),\n            makedev: (ma, mi) => ((ma) << 8 | (mi)),\n            registerDevice(dev, ops) {\n                FS.devices[dev] = { stream_ops: ops };\n            },\n            getDevice: (dev) => FS.devices[dev],\n            getMounts(mount) {\n                var mounts = [];\n                var check = [mount];\n                while (check.length) {\n                    var m = check.pop();\n                    mounts.push(m);\n                    check.push.apply(check, m.mounts);\n                }\n                return mounts;\n            },\n            syncfs(populate, callback) {\n                if (typeof populate == 'function') {\n                    callback = populate;\n                    populate = false;\n                }\n                FS.syncFSRequests++;\n                if (FS.syncFSRequests > 1) {\n                    err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);\n                }\n                var mounts = FS.getMounts(FS.root.mount);\n                var completed = 0;\n                function doCallback(errCode) {\n                    assert(FS.syncFSRequests > 0);\n                    FS.syncFSRequests--;\n                    return callback(errCode);\n                }\n                function done(errCode) {\n                    if (errCode) {\n                        if (!done.errored) {\n                            done.errored = true;\n                            return doCallback(errCode);\n                        }\n                        return;\n                    }\n                    if (++completed >= mounts.length) {\n                        doCallback(null);\n                    }\n                }\n                ;\n                // sync all mounts\n                mounts.forEach((mount) => {\n                    if (!mount.type.syncfs) {\n                        return done(null);\n                    }\n                    mount.type.syncfs(mount, populate, done);\n                });\n            },\n            mount(type, opts, mountpoint) {\n                if (typeof type == 'string') {\n                    // The filesystem was not included, and instead we have an error\n                    // message stored in the variable.\n                    throw type;\n                }\n                var root = mountpoint === '/';\n                var pseudo = !mountpoint;\n                var node;\n                if (root && FS.root) {\n                    throw new FS.ErrnoError(10);\n                }\n                else if (!root && !pseudo) {\n                    var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n                    mountpoint = lookup.path; // use the absolute path\n                    node = lookup.node;\n                    if (FS.isMountpoint(node)) {\n                        throw new FS.ErrnoError(10);\n                    }\n                    if (!FS.isDir(node.mode)) {\n                        throw new FS.ErrnoError(54);\n                    }\n                }\n                var mount = {\n                    type,\n                    opts,\n                    mountpoint,\n                    mounts: []\n                };\n                // create a root node for the fs\n                var mountRoot = type.mount(mount);\n                mountRoot.mount = mount;\n                mount.root = mountRoot;\n                if (root) {\n                    FS.root = mountRoot;\n                }\n                else if (node) {\n                    // set as a mountpoint\n                    node.mounted = mount;\n                    // add the new mount to the current mount's children\n                    if (node.mount) {\n                        node.mount.mounts.push(mount);\n                    }\n                }\n                return mountRoot;\n            },\n            unmount(mountpoint) {\n                var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n                if (!FS.isMountpoint(lookup.node)) {\n                    throw new FS.ErrnoError(28);\n                }\n                // destroy the nodes for this mount, and all its child mounts\n                var node = lookup.node;\n                var mount = node.mounted;\n                var mounts = FS.getMounts(mount);\n                Object.keys(FS.nameTable).forEach((hash) => {\n                    var current = FS.nameTable[hash];\n                    while (current) {\n                        var next = current.name_next;\n                        if (mounts.includes(current.mount)) {\n                            FS.destroyNode(current);\n                        }\n                        current = next;\n                    }\n                });\n                // no longer a mountpoint\n                node.mounted = null;\n                // remove this mount from the child mounts\n                var idx = node.mount.mounts.indexOf(mount);\n                assert(idx !== -1);\n                node.mount.mounts.splice(idx, 1);\n            },\n            lookup(parent, name) {\n                return parent.node_ops.lookup(parent, name);\n            },\n            mknod(path, mode, dev) {\n                var lookup = FS.lookupPath(path, { parent: true });\n                var parent = lookup.node;\n                var name = PATH.basename(path);\n                if (!name || name === '.' || name === '..') {\n                    throw new FS.ErrnoError(28);\n                }\n                var errCode = FS.mayCreate(parent, name);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                if (!parent.node_ops.mknod) {\n                    throw new FS.ErrnoError(63);\n                }\n                return parent.node_ops.mknod(parent, name, mode, dev);\n            },\n            create(path, mode) {\n                mode = mode !== undefined ? mode : 438 /* 0666 */;\n                mode &= 4095;\n                mode |= 32768;\n                return FS.mknod(path, mode, 0);\n            },\n            mkdir(path, mode) {\n                mode = mode !== undefined ? mode : 511 /* 0777 */;\n                mode &= 511 | 512;\n                mode |= 16384;\n                return FS.mknod(path, mode, 0);\n            },\n            mkdirTree(path, mode) {\n                var dirs = path.split('/');\n                var d = '';\n                for (var i = 0; i < dirs.length; ++i) {\n                    if (!dirs[i])\n                        continue;\n                    d += '/' + dirs[i];\n                    try {\n                        FS.mkdir(d, mode);\n                    }\n                    catch (e) {\n                        if (e.errno != 20)\n                            throw e;\n                    }\n                }\n            },\n            mkdev(path, mode, dev) {\n                if (typeof dev == 'undefined') {\n                    dev = mode;\n                    mode = 438 /* 0666 */;\n                }\n                mode |= 8192;\n                return FS.mknod(path, mode, dev);\n            },\n            symlink(oldpath, newpath) {\n                if (!PATH_FS.resolve(oldpath)) {\n                    throw new FS.ErrnoError(44);\n                }\n                var lookup = FS.lookupPath(newpath, { parent: true });\n                var parent = lookup.node;\n                if (!parent) {\n                    throw new FS.ErrnoError(44);\n                }\n                var newname = PATH.basename(newpath);\n                var errCode = FS.mayCreate(parent, newname);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                if (!parent.node_ops.symlink) {\n                    throw new FS.ErrnoError(63);\n                }\n                return parent.node_ops.symlink(parent, newname, oldpath);\n            },\n            rename(old_path, new_path) {\n                var old_dirname = PATH.dirname(old_path);\n                var new_dirname = PATH.dirname(new_path);\n                var old_name = PATH.basename(old_path);\n                var new_name = PATH.basename(new_path);\n                // parents must exist\n                var lookup, old_dir, new_dir;\n                // let the errors from non existant directories percolate up\n                lookup = FS.lookupPath(old_path, { parent: true });\n                old_dir = lookup.node;\n                lookup = FS.lookupPath(new_path, { parent: true });\n                new_dir = lookup.node;\n                if (!old_dir || !new_dir)\n                    throw new FS.ErrnoError(44);\n                // need to be part of the same mount\n                if (old_dir.mount !== new_dir.mount) {\n                    throw new FS.ErrnoError(75);\n                }\n                // source must exist\n                var old_node = FS.lookupNode(old_dir, old_name);\n                // old path should not be an ancestor of the new path\n                var relative = PATH_FS.relative(old_path, new_dirname);\n                if (relative.charAt(0) !== '.') {\n                    throw new FS.ErrnoError(28);\n                }\n                // new path should not be an ancestor of the old path\n                relative = PATH_FS.relative(new_path, old_dirname);\n                if (relative.charAt(0) !== '.') {\n                    throw new FS.ErrnoError(55);\n                }\n                // see if the new path already exists\n                var new_node;\n                try {\n                    new_node = FS.lookupNode(new_dir, new_name);\n                }\n                catch (e) {\n                    // not fatal\n                }\n                // early out if nothing needs to change\n                if (old_node === new_node) {\n                    return;\n                }\n                // we'll need to delete the old entry\n                var isdir = FS.isDir(old_node.mode);\n                var errCode = FS.mayDelete(old_dir, old_name, isdir);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                // need delete permissions if we'll be overwriting.\n                // need create permissions if new doesn't already exist.\n                errCode = new_node ?\n                    FS.mayDelete(new_dir, new_name, isdir) :\n                    FS.mayCreate(new_dir, new_name);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                if (!old_dir.node_ops.rename) {\n                    throw new FS.ErrnoError(63);\n                }\n                if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {\n                    throw new FS.ErrnoError(10);\n                }\n                // if we are going to change the parent, check write permissions\n                if (new_dir !== old_dir) {\n                    errCode = FS.nodePermissions(old_dir, 'w');\n                    if (errCode) {\n                        throw new FS.ErrnoError(errCode);\n                    }\n                }\n                // remove the node from the lookup hash\n                FS.hashRemoveNode(old_node);\n                // do the underlying fs rename\n                try {\n                    old_dir.node_ops.rename(old_node, new_dir, new_name);\n                }\n                catch (e) {\n                    throw e;\n                }\n                finally {\n                    // add the node back to the hash (in case node_ops.rename\n                    // changed its name)\n                    FS.hashAddNode(old_node);\n                }\n            },\n            rmdir(path) {\n                var lookup = FS.lookupPath(path, { parent: true });\n                var parent = lookup.node;\n                var name = PATH.basename(path);\n                var node = FS.lookupNode(parent, name);\n                var errCode = FS.mayDelete(parent, name, true);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                if (!parent.node_ops.rmdir) {\n                    throw new FS.ErrnoError(63);\n                }\n                if (FS.isMountpoint(node)) {\n                    throw new FS.ErrnoError(10);\n                }\n                parent.node_ops.rmdir(parent, name);\n                FS.destroyNode(node);\n            },\n            readdir(path) {\n                var lookup = FS.lookupPath(path, { follow: true });\n                var node = lookup.node;\n                if (!node.node_ops.readdir) {\n                    throw new FS.ErrnoError(54);\n                }\n                return node.node_ops.readdir(node);\n            },\n            unlink(path) {\n                var lookup = FS.lookupPath(path, { parent: true });\n                var parent = lookup.node;\n                if (!parent) {\n                    throw new FS.ErrnoError(44);\n                }\n                var name = PATH.basename(path);\n                var node = FS.lookupNode(parent, name);\n                var errCode = FS.mayDelete(parent, name, false);\n                if (errCode) {\n                    // According to POSIX, we should map EISDIR to EPERM, but\n                    // we instead do what Linux does (and we must, as we use\n                    // the musl linux libc).\n                    throw new FS.ErrnoError(errCode);\n                }\n                if (!parent.node_ops.unlink) {\n                    throw new FS.ErrnoError(63);\n                }\n                if (FS.isMountpoint(node)) {\n                    throw new FS.ErrnoError(10);\n                }\n                parent.node_ops.unlink(parent, name);\n                FS.destroyNode(node);\n            },\n            readlink(path) {\n                var lookup = FS.lookupPath(path);\n                var link = lookup.node;\n                if (!link) {\n                    throw new FS.ErrnoError(44);\n                }\n                if (!link.node_ops.readlink) {\n                    throw new FS.ErrnoError(28);\n                }\n                return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n            },\n            stat(path, dontFollow) {\n                var lookup = FS.lookupPath(path, { follow: !dontFollow });\n                var node = lookup.node;\n                if (!node) {\n                    throw new FS.ErrnoError(44);\n                }\n                if (!node.node_ops.getattr) {\n                    throw new FS.ErrnoError(63);\n                }\n                return node.node_ops.getattr(node);\n            },\n            lstat(path) {\n                return FS.stat(path, true);\n            },\n            chmod(path, mode, dontFollow) {\n                var node;\n                if (typeof path == 'string') {\n                    var lookup = FS.lookupPath(path, { follow: !dontFollow });\n                    node = lookup.node;\n                }\n                else {\n                    node = path;\n                }\n                if (!node.node_ops.setattr) {\n                    throw new FS.ErrnoError(63);\n                }\n                node.node_ops.setattr(node, {\n                    mode: (mode & 4095) | (node.mode & ~4095),\n                    timestamp: Date.now()\n                });\n            },\n            lchmod(path, mode) {\n                FS.chmod(path, mode, true);\n            },\n            fchmod(fd, mode) {\n                var stream = FS.getStreamChecked(fd);\n                FS.chmod(stream.node, mode);\n            },\n            chown(path, uid, gid, dontFollow) {\n                var node;\n                if (typeof path == 'string') {\n                    var lookup = FS.lookupPath(path, { follow: !dontFollow });\n                    node = lookup.node;\n                }\n                else {\n                    node = path;\n                }\n                if (!node.node_ops.setattr) {\n                    throw new FS.ErrnoError(63);\n                }\n                node.node_ops.setattr(node, {\n                    timestamp: Date.now()\n                    // we ignore the uid / gid for now\n                });\n            },\n            lchown(path, uid, gid) {\n                FS.chown(path, uid, gid, true);\n            },\n            fchown(fd, uid, gid) {\n                var stream = FS.getStreamChecked(fd);\n                FS.chown(stream.node, uid, gid);\n            },\n            truncate(path, len) {\n                if (len < 0) {\n                    throw new FS.ErrnoError(28);\n                }\n                var node;\n                if (typeof path == 'string') {\n                    var lookup = FS.lookupPath(path, { follow: true });\n                    node = lookup.node;\n                }\n                else {\n                    node = path;\n                }\n                if (!node.node_ops.setattr) {\n                    throw new FS.ErrnoError(63);\n                }\n                if (FS.isDir(node.mode)) {\n                    throw new FS.ErrnoError(31);\n                }\n                if (!FS.isFile(node.mode)) {\n                    throw new FS.ErrnoError(28);\n                }\n                var errCode = FS.nodePermissions(node, 'w');\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                node.node_ops.setattr(node, {\n                    size: len,\n                    timestamp: Date.now()\n                });\n            },\n            ftruncate(fd, len) {\n                var stream = FS.getStreamChecked(fd);\n                if ((stream.flags & 2097155) === 0) {\n                    throw new FS.ErrnoError(28);\n                }\n                FS.truncate(stream.node, len);\n            },\n            utime(path, atime, mtime) {\n                var lookup = FS.lookupPath(path, { follow: true });\n                var node = lookup.node;\n                node.node_ops.setattr(node, {\n                    timestamp: Math.max(atime, mtime)\n                });\n            },\n            open(path, flags, mode) {\n                if (path === \"\") {\n                    throw new FS.ErrnoError(44);\n                }\n                flags = typeof flags == 'string' ? FS_modeStringToFlags(flags) : flags;\n                mode = typeof mode == 'undefined' ? 438 /* 0666 */ : mode;\n                if ((flags & 64)) {\n                    mode = (mode & 4095) | 32768;\n                }\n                else {\n                    mode = 0;\n                }\n                var node;\n                if (typeof path == 'object') {\n                    node = path;\n                }\n                else {\n                    path = PATH.normalize(path);\n                    try {\n                        var lookup = FS.lookupPath(path, {\n                            follow: !(flags & 131072)\n                        });\n                        node = lookup.node;\n                    }\n                    catch (e) {\n                        // ignore\n                    }\n                }\n                // perhaps we need to create the node\n                var created = false;\n                if ((flags & 64)) {\n                    if (node) {\n                        // if O_CREAT and O_EXCL are set, error out if the node already exists\n                        if ((flags & 128)) {\n                            throw new FS.ErrnoError(20);\n                        }\n                    }\n                    else {\n                        // node doesn't exist, try to create it\n                        node = FS.mknod(path, mode, 0);\n                        created = true;\n                    }\n                }\n                if (!node) {\n                    throw new FS.ErrnoError(44);\n                }\n                // can't truncate a device\n                if (FS.isChrdev(node.mode)) {\n                    flags &= ~512;\n                }\n                // if asked only for a directory, then this must be one\n                if ((flags & 65536) && !FS.isDir(node.mode)) {\n                    throw new FS.ErrnoError(54);\n                }\n                // check permissions, if this is not a file we just created now (it is ok to\n                // create and write to a file with read-only permissions; it is read-only\n                // for later use)\n                if (!created) {\n                    var errCode = FS.mayOpen(node, flags);\n                    if (errCode) {\n                        throw new FS.ErrnoError(errCode);\n                    }\n                }\n                // do truncation if necessary\n                if ((flags & 512) && !created) {\n                    FS.truncate(node, 0);\n                }\n                // we've already handled these, don't pass down to the underlying vfs\n                flags &= ~(128 | 512 | 131072);\n                // register the stream with the filesystem\n                var stream = FS.createStream({\n                    node,\n                    path: FS.getPath(node),\n                    flags,\n                    seekable: true,\n                    position: 0,\n                    stream_ops: node.stream_ops,\n                    // used by the file family libc calls (fopen, fwrite, ferror, etc.)\n                    ungotten: [],\n                    error: false\n                });\n                // call the new stream's open function\n                if (stream.stream_ops.open) {\n                    stream.stream_ops.open(stream);\n                }\n                if (Module['logReadFiles'] && !(flags & 1)) {\n                    if (!FS.readFiles)\n                        FS.readFiles = {};\n                    if (!(path in FS.readFiles)) {\n                        FS.readFiles[path] = 1;\n                    }\n                }\n                return stream;\n            },\n            close(stream) {\n                if (FS.isClosed(stream)) {\n                    throw new FS.ErrnoError(8);\n                }\n                if (stream.getdents)\n                    stream.getdents = null; // free readdir state\n                try {\n                    if (stream.stream_ops.close) {\n                        stream.stream_ops.close(stream);\n                    }\n                }\n                catch (e) {\n                    throw e;\n                }\n                finally {\n                    FS.closeStream(stream.fd);\n                }\n                stream.fd = null;\n            },\n            isClosed(stream) {\n                return stream.fd === null;\n            },\n            llseek(stream, offset, whence) {\n                if (FS.isClosed(stream)) {\n                    throw new FS.ErrnoError(8);\n                }\n                if (!stream.seekable || !stream.stream_ops.llseek) {\n                    throw new FS.ErrnoError(70);\n                }\n                if (whence != 0 && whence != 1 && whence != 2) {\n                    throw new FS.ErrnoError(28);\n                }\n                stream.position = stream.stream_ops.llseek(stream, offset, whence);\n                stream.ungotten = [];\n                return stream.position;\n            },\n            read(stream, buffer, offset, length, position) {\n                assert(offset >= 0);\n                if (length < 0 || position < 0) {\n                    throw new FS.ErrnoError(28);\n                }\n                if (FS.isClosed(stream)) {\n                    throw new FS.ErrnoError(8);\n                }\n                if ((stream.flags & 2097155) === 1) {\n                    throw new FS.ErrnoError(8);\n                }\n                if (FS.isDir(stream.node.mode)) {\n                    throw new FS.ErrnoError(31);\n                }\n                if (!stream.stream_ops.read) {\n                    throw new FS.ErrnoError(28);\n                }\n                var seeking = typeof position != 'undefined';\n                if (!seeking) {\n                    position = stream.position;\n                }\n                else if (!stream.seekable) {\n                    throw new FS.ErrnoError(70);\n                }\n                var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n                if (!seeking)\n                    stream.position += bytesRead;\n                return bytesRead;\n            },\n            write(stream, buffer, offset, length, position, canOwn) {\n                assert(offset >= 0);\n                if (length < 0 || position < 0) {\n                    throw new FS.ErrnoError(28);\n                }\n                if (FS.isClosed(stream)) {\n                    throw new FS.ErrnoError(8);\n                }\n                if ((stream.flags & 2097155) === 0) {\n                    throw new FS.ErrnoError(8);\n                }\n                if (FS.isDir(stream.node.mode)) {\n                    throw new FS.ErrnoError(31);\n                }\n                if (!stream.stream_ops.write) {\n                    throw new FS.ErrnoError(28);\n                }\n                if (stream.seekable && stream.flags & 1024) {\n                    // seek to the end before writing in append mode\n                    FS.llseek(stream, 0, 2);\n                }\n                var seeking = typeof position != 'undefined';\n                if (!seeking) {\n                    position = stream.position;\n                }\n                else if (!stream.seekable) {\n                    throw new FS.ErrnoError(70);\n                }\n                var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n                if (!seeking)\n                    stream.position += bytesWritten;\n                return bytesWritten;\n            },\n            allocate(stream, offset, length) {\n                if (FS.isClosed(stream)) {\n                    throw new FS.ErrnoError(8);\n                }\n                if (offset < 0 || length <= 0) {\n                    throw new FS.ErrnoError(28);\n                }\n                if ((stream.flags & 2097155) === 0) {\n                    throw new FS.ErrnoError(8);\n                }\n                if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n                    throw new FS.ErrnoError(43);\n                }\n                if (!stream.stream_ops.allocate) {\n                    throw new FS.ErrnoError(138);\n                }\n                stream.stream_ops.allocate(stream, offset, length);\n            },\n            mmap(stream, length, position, prot, flags) {\n                // User requests writing to file (prot & PROT_WRITE != 0).\n                // Checking if we have permissions to write to the file unless\n                // MAP_PRIVATE flag is set. According to POSIX spec it is possible\n                // to write to file opened in read-only mode with MAP_PRIVATE flag,\n                // as all modifications will be visible only in the memory of\n                // the current process.\n                if ((prot & 2) !== 0\n                    && (flags & 2) === 0\n                    && (stream.flags & 2097155) !== 2) {\n                    throw new FS.ErrnoError(2);\n                }\n                if ((stream.flags & 2097155) === 1) {\n                    throw new FS.ErrnoError(2);\n                }\n                if (!stream.stream_ops.mmap) {\n                    throw new FS.ErrnoError(43);\n                }\n                return stream.stream_ops.mmap(stream, length, position, prot, flags);\n            },\n            msync(stream, buffer, offset, length, mmapFlags) {\n                assert(offset >= 0);\n                if (!stream.stream_ops.msync) {\n                    return 0;\n                }\n                return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n            },\n            munmap: (stream) => 0,\n            ioctl(stream, cmd, arg) {\n                if (!stream.stream_ops.ioctl) {\n                    throw new FS.ErrnoError(59);\n                }\n                return stream.stream_ops.ioctl(stream, cmd, arg);\n            },\n            readFile(path, opts = {}) {\n                opts.flags = opts.flags || 0;\n                opts.encoding = opts.encoding || 'binary';\n                if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {\n                    throw new Error(`Invalid encoding type \"${opts.encoding}\"`);\n                }\n                var ret;\n                var stream = FS.open(path, opts.flags);\n                var stat = FS.stat(path);\n                var length = stat.size;\n                var buf = new Uint8Array(length);\n                FS.read(stream, buf, 0, length, 0);\n                if (opts.encoding === 'utf8') {\n                    ret = UTF8ArrayToString(buf, 0);\n                }\n                else if (opts.encoding === 'binary') {\n                    ret = buf;\n                }\n                FS.close(stream);\n                return ret;\n            },\n            writeFile(path, data, opts = {}) {\n                opts.flags = opts.flags || 577;\n                var stream = FS.open(path, opts.flags, opts.mode);\n                if (typeof data == 'string') {\n                    var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n                    var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n                    FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n                }\n                else if (ArrayBuffer.isView(data)) {\n                    FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n                }\n                else {\n                    throw new Error('Unsupported data type');\n                }\n                FS.close(stream);\n            },\n            cwd: () => FS.currentPath,\n            chdir(path) {\n                var lookup = FS.lookupPath(path, { follow: true });\n                if (lookup.node === null) {\n                    throw new FS.ErrnoError(44);\n                }\n                if (!FS.isDir(lookup.node.mode)) {\n                    throw new FS.ErrnoError(54);\n                }\n                var errCode = FS.nodePermissions(lookup.node, 'x');\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                FS.currentPath = lookup.path;\n            },\n            createDefaultDirectories() {\n                FS.mkdir('/tmp');\n                FS.mkdir('/home');\n                FS.mkdir('/home/web_user');\n            },\n            createDefaultDevices() {\n                // create /dev\n                FS.mkdir('/dev');\n                // setup /dev/null\n                FS.registerDevice(FS.makedev(1, 3), {\n                    read: () => 0,\n                    write: (stream, buffer, offset, length, pos) => length,\n                });\n                FS.mkdev('/dev/null', FS.makedev(1, 3));\n                // setup /dev/tty and /dev/tty1\n                // stderr needs to print output using err() rather than out()\n                // so we register a second tty just for it.\n                TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n                TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n                FS.mkdev('/dev/tty', FS.makedev(5, 0));\n                FS.mkdev('/dev/tty1', FS.makedev(6, 0));\n                // setup /dev/[u]random\n                // use a buffer to avoid overhead of individual crypto calls per byte\n                var randomBuffer = new Uint8Array(1024), randomLeft = 0;\n                var randomByte = () => {\n                    if (randomLeft === 0) {\n                        randomLeft = randomFill(randomBuffer).byteLength;\n                    }\n                    return randomBuffer[--randomLeft];\n                };\n                FS.createDevice('/dev', 'random', randomByte);\n                FS.createDevice('/dev', 'urandom', randomByte);\n                // we're not going to emulate the actual shm device,\n                // just create the tmp dirs that reside in it commonly\n                FS.mkdir('/dev/shm');\n                FS.mkdir('/dev/shm/tmp');\n            },\n            createSpecialDirectories() {\n                // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the\n                // name of the stream for fd 6 (see test_unistd_ttyname)\n                FS.mkdir('/proc');\n                var proc_self = FS.mkdir('/proc/self');\n                FS.mkdir('/proc/self/fd');\n                FS.mount({\n                    mount() {\n                        var node = FS.createNode(proc_self, 'fd', 16384 | 511 /* 0777 */, 73);\n                        node.node_ops = {\n                            lookup(parent, name) {\n                                var fd = +name;\n                                var stream = FS.getStreamChecked(fd);\n                                var ret = {\n                                    parent: null,\n                                    mount: { mountpoint: 'fake' },\n                                    node_ops: { readlink: () => stream.path },\n                                };\n                                ret.parent = ret; // make it look like a simple root node\n                                return ret;\n                            }\n                        };\n                        return node;\n                    }\n                }, {}, '/proc/self/fd');\n            },\n            createStandardStreams() {\n                // TODO deprecate the old functionality of a single\n                // input / output callback and that utilizes FS.createDevice\n                // and instead require a unique set of stream ops\n                // by default, we symlink the standard streams to the\n                // default tty devices. however, if the standard streams\n                // have been overwritten we create a unique device for\n                // them instead.\n                if (Module['stdin']) {\n                    FS.createDevice('/dev', 'stdin', Module['stdin']);\n                }\n                else {\n                    FS.symlink('/dev/tty', '/dev/stdin');\n                }\n                if (Module['stdout']) {\n                    FS.createDevice('/dev', 'stdout', null, Module['stdout']);\n                }\n                else {\n                    FS.symlink('/dev/tty', '/dev/stdout');\n                }\n                if (Module['stderr']) {\n                    FS.createDevice('/dev', 'stderr', null, Module['stderr']);\n                }\n                else {\n                    FS.symlink('/dev/tty1', '/dev/stderr');\n                }\n                // open default streams for the stdin, stdout and stderr devices\n                var stdin = FS.open('/dev/stdin', 0);\n                var stdout = FS.open('/dev/stdout', 1);\n                var stderr = FS.open('/dev/stderr', 1);\n                assert(stdin.fd === 0, `invalid handle for stdin (${stdin.fd})`);\n                assert(stdout.fd === 1, `invalid handle for stdout (${stdout.fd})`);\n                assert(stderr.fd === 2, `invalid handle for stderr (${stderr.fd})`);\n            },\n            ensureErrnoError() {\n                if (FS.ErrnoError)\n                    return;\n                FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {\n                    // We set the `name` property to be able to identify `FS.ErrnoError`\n                    // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.\n                    // - when using PROXYFS, an error can come from an underlying FS\n                    // as different FS objects have their own FS.ErrnoError each,\n                    // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.\n                    // we'll use the reliable test `err.name == \"ErrnoError\"` instead\n                    this.name = 'ErrnoError';\n                    this.node = node;\n                    this.setErrno = /** @this{Object} */ function (errno) {\n                        this.errno = errno;\n                        for (var key in ERRNO_CODES) {\n                            if (ERRNO_CODES[key] === errno) {\n                                this.code = key;\n                                break;\n                            }\n                        }\n                    };\n                    this.setErrno(errno);\n                    this.message = ERRNO_MESSAGES[errno];\n                    // Try to get a maximally helpful stack trace. On Node.js, getting Error.stack\n                    // now ensures it shows what we want.\n                    if (this.stack) {\n                        // Define the stack property for Node.js 4, which otherwise errors on the next line.\n                        Object.defineProperty(this, \"stack\", { value: (new Error).stack, writable: true });\n                        this.stack = demangleAll(this.stack);\n                    }\n                };\n                FS.ErrnoError.prototype = new Error();\n                FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n                // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)\n                [44].forEach((code) => {\n                    FS.genericErrors[code] = new FS.ErrnoError(code);\n                    FS.genericErrors[code].stack = '<generic error, no stack>';\n                });\n            },\n            staticInit() {\n                FS.ensureErrnoError();\n                FS.nameTable = new Array(4096);\n                FS.mount(MEMFS, {}, '/');\n                FS.createDefaultDirectories();\n                FS.createDefaultDevices();\n                FS.createSpecialDirectories();\n                FS.filesystems = {\n                    'MEMFS': MEMFS,\n                };\n            },\n            init(input, output, error) {\n                assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');\n                FS.init.initialized = true;\n                FS.ensureErrnoError();\n                // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here\n                Module['stdin'] = input || Module['stdin'];\n                Module['stdout'] = output || Module['stdout'];\n                Module['stderr'] = error || Module['stderr'];\n                FS.createStandardStreams();\n            },\n            quit() {\n                FS.init.initialized = false;\n                // force-flush all streams, so we get musl std streams printed out\n                _fflush(0);\n                // close all of our streams\n                for (var i = 0; i < FS.streams.length; i++) {\n                    var stream = FS.streams[i];\n                    if (!stream) {\n                        continue;\n                    }\n                    FS.close(stream);\n                }\n            },\n            findObject(path, dontResolveLastLink) {\n                var ret = FS.analyzePath(path, dontResolveLastLink);\n                if (!ret.exists) {\n                    return null;\n                }\n                return ret.object;\n            },\n            analyzePath(path, dontResolveLastLink) {\n                // operate from within the context of the symlink's target\n                try {\n                    var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n                    path = lookup.path;\n                }\n                catch (e) {\n                }\n                var ret = {\n                    isRoot: false, exists: false, error: 0, name: null, path: null, object: null,\n                    parentExists: false, parentPath: null, parentObject: null\n                };\n                try {\n                    var lookup = FS.lookupPath(path, { parent: true });\n                    ret.parentExists = true;\n                    ret.parentPath = lookup.path;\n                    ret.parentObject = lookup.node;\n                    ret.name = PATH.basename(path);\n                    lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n                    ret.exists = true;\n                    ret.path = lookup.path;\n                    ret.object = lookup.node;\n                    ret.name = lookup.node.name;\n                    ret.isRoot = lookup.path === '/';\n                }\n                catch (e) {\n                    ret.error = e.errno;\n                }\n                ;\n                return ret;\n            },\n            createPath(parent, path, canRead, canWrite) {\n                parent = typeof parent == 'string' ? parent : FS.getPath(parent);\n                var parts = path.split('/').reverse();\n                while (parts.length) {\n                    var part = parts.pop();\n                    if (!part)\n                        continue;\n                    var current = PATH.join2(parent, part);\n                    try {\n                        FS.mkdir(current);\n                    }\n                    catch (e) {\n                        // ignore EEXIST\n                    }\n                    parent = current;\n                }\n                return current;\n            },\n            createFile(parent, name, properties, canRead, canWrite) {\n                var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\n                var mode = FS_getMode(canRead, canWrite);\n                return FS.create(path, mode);\n            },\n            createDataFile(parent, name, data, canRead, canWrite, canOwn) {\n                var path = name;\n                if (parent) {\n                    parent = typeof parent == 'string' ? parent : FS.getPath(parent);\n                    path = name ? PATH.join2(parent, name) : parent;\n                }\n                var mode = FS_getMode(canRead, canWrite);\n                var node = FS.create(path, mode);\n                if (data) {\n                    if (typeof data == 'string') {\n                        var arr = new Array(data.length);\n                        for (var i = 0, len = data.length; i < len; ++i)\n                            arr[i] = data.charCodeAt(i);\n                        data = arr;\n                    }\n                    // make sure we can write to the file\n                    FS.chmod(node, mode | 146);\n                    var stream = FS.open(node, 577);\n                    FS.write(stream, data, 0, data.length, 0, canOwn);\n                    FS.close(stream);\n                    FS.chmod(node, mode);\n                }\n                return node;\n            },\n            createDevice(parent, name, input, output) {\n                var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\n                var mode = FS_getMode(!!input, !!output);\n                if (!FS.createDevice.major)\n                    FS.createDevice.major = 64;\n                var dev = FS.makedev(FS.createDevice.major++, 0);\n                // Create a fake device that a set of stream ops to emulate\n                // the old behavior.\n                FS.registerDevice(dev, {\n                    open(stream) {\n                        stream.seekable = false;\n                    },\n                    close(stream) {\n                        // flush any pending line data\n                        if (output && output.buffer && output.buffer.length) {\n                            output(10);\n                        }\n                    },\n                    read(stream, buffer, offset, length, pos /* ignored */) {\n                        var bytesRead = 0;\n                        for (var i = 0; i < length; i++) {\n                            var result;\n                            try {\n                                result = input();\n                            }\n                            catch (e) {\n                                throw new FS.ErrnoError(29);\n                            }\n                            if (result === undefined && bytesRead === 0) {\n                                throw new FS.ErrnoError(6);\n                            }\n                            if (result === null || result === undefined)\n                                break;\n                            bytesRead++;\n                            buffer[offset + i] = result;\n                        }\n                        if (bytesRead) {\n                            stream.node.timestamp = Date.now();\n                        }\n                        return bytesRead;\n                    },\n                    write(stream, buffer, offset, length, pos) {\n                        for (var i = 0; i < length; i++) {\n                            try {\n                                output(buffer[offset + i]);\n                            }\n                            catch (e) {\n                                throw new FS.ErrnoError(29);\n                            }\n                        }\n                        if (length) {\n                            stream.node.timestamp = Date.now();\n                        }\n                        return i;\n                    }\n                });\n                return FS.mkdev(path, mode, dev);\n            },\n            forceLoadFile(obj) {\n                if (obj.isDevice || obj.isFolder || obj.link || obj.contents)\n                    return true;\n                if (typeof XMLHttpRequest != 'undefined') {\n                    throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n                }\n                else if (read_) {\n                    // Command-line.\n                    try {\n                        // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as\n                        //          read() will try to parse UTF8.\n                        obj.contents = intArrayFromString(read_(obj.url), true);\n                        obj.usedBytes = obj.contents.length;\n                    }\n                    catch (e) {\n                        throw new FS.ErrnoError(29);\n                    }\n                }\n                else {\n                    throw new Error('Cannot load without read() or XMLHttpRequest.');\n                }\n            },\n            createLazyFile(parent, name, url, canRead, canWrite) {\n                // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.\n                /** @constructor */\n                function LazyUint8Array() {\n                    this.lengthKnown = false;\n                    this.chunks = []; // Loaded chunks. Index is the chunk number\n                }\n                LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {\n                    if (idx > this.length - 1 || idx < 0) {\n                        return undefined;\n                    }\n                    var chunkOffset = idx % this.chunkSize;\n                    var chunkNum = (idx / this.chunkSize) | 0;\n                    return this.getter(chunkNum)[chunkOffset];\n                };\n                LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n                    this.getter = getter;\n                };\n                LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n                    // Find length\n                    var xhr = new XMLHttpRequest();\n                    xhr.open('HEAD', url, false);\n                    xhr.send(null);\n                    if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))\n                        throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n                    var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n                    var header;\n                    var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n                    var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n                    var chunkSize = 1024 * 1024; // Chunk size in bytes\n                    if (!hasByteServing)\n                        chunkSize = datalength;\n                    // Function to get a range from the remote URL.\n                    var doXHR = (from, to) => {\n                        if (from > to)\n                            throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n                        if (to > datalength - 1)\n                            throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n                        // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.\n                        var xhr = new XMLHttpRequest();\n                        xhr.open('GET', url, false);\n                        if (datalength !== chunkSize)\n                            xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n                        // Some hints to the browser that we want binary data.\n                        xhr.responseType = 'arraybuffer';\n                        if (xhr.overrideMimeType) {\n                            xhr.overrideMimeType('text/plain; charset=x-user-defined');\n                        }\n                        xhr.send(null);\n                        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))\n                            throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n                        if (xhr.response !== undefined) {\n                            return new Uint8Array(/** @type{Array<number>} */ (xhr.response || []));\n                        }\n                        return intArrayFromString(xhr.responseText || '', true);\n                    };\n                    var lazyArray = this;\n                    lazyArray.setDataGetter((chunkNum) => {\n                        var start = chunkNum * chunkSize;\n                        var end = (chunkNum + 1) * chunkSize - 1; // including this byte\n                        end = Math.min(end, datalength - 1); // if datalength-1 is selected, this is the last block\n                        if (typeof lazyArray.chunks[chunkNum] == 'undefined') {\n                            lazyArray.chunks[chunkNum] = doXHR(start, end);\n                        }\n                        if (typeof lazyArray.chunks[chunkNum] == 'undefined')\n                            throw new Error('doXHR failed!');\n                        return lazyArray.chunks[chunkNum];\n                    });\n                    if (usesGzip || !datalength) {\n                        // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length\n                        chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file\n                        datalength = this.getter(0).length;\n                        chunkSize = datalength;\n                        out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n                    }\n                    this._length = datalength;\n                    this._chunkSize = chunkSize;\n                    this.lengthKnown = true;\n                };\n                if (typeof XMLHttpRequest != 'undefined') {\n                    if (!ENVIRONMENT_IS_WORKER)\n                        throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';\n                    var lazyArray = new LazyUint8Array();\n                    Object.defineProperties(lazyArray, {\n                        length: {\n                            get: /** @this{Object} */ function () {\n                                if (!this.lengthKnown) {\n                                    this.cacheLength();\n                                }\n                                return this._length;\n                            }\n                        },\n                        chunkSize: {\n                            get: /** @this{Object} */ function () {\n                                if (!this.lengthKnown) {\n                                    this.cacheLength();\n                                }\n                                return this._chunkSize;\n                            }\n                        }\n                    });\n                    var properties = { isDevice: false, contents: lazyArray };\n                }\n                else {\n                    var properties = { isDevice: false, url: url };\n                }\n                var node = FS.createFile(parent, name, properties, canRead, canWrite);\n                // This is a total hack, but I want to get this lazy file code out of the\n                // core of MEMFS. If we want to keep this lazy file concept I feel it should\n                // be its own thin LAZYFS proxying calls to MEMFS.\n                if (properties.contents) {\n                    node.contents = properties.contents;\n                }\n                else if (properties.url) {\n                    node.contents = null;\n                    node.url = properties.url;\n                }\n                // Add a function that defers querying the file size until it is asked the first time.\n                Object.defineProperties(node, {\n                    usedBytes: {\n                        get: /** @this {FSNode} */ function () { return this.contents.length; }\n                    }\n                });\n                // override each stream op with one that tries to force load the lazy file first\n                var stream_ops = {};\n                var keys = Object.keys(node.stream_ops);\n                keys.forEach((key) => {\n                    var fn = node.stream_ops[key];\n                    stream_ops[key] = function forceLoadLazyFile() {\n                        FS.forceLoadFile(node);\n                        return fn.apply(null, arguments);\n                    };\n                });\n                function writeChunks(stream, buffer, offset, length, position) {\n                    var contents = stream.node.contents;\n                    if (position >= contents.length)\n                        return 0;\n                    var size = Math.min(contents.length - position, length);\n                    assert(size >= 0);\n                    if (contents.slice) { // normal array\n                        for (var i = 0; i < size; i++) {\n                            buffer[offset + i] = contents[position + i];\n                        }\n                    }\n                    else {\n                        for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR\n                            buffer[offset + i] = contents.get(position + i);\n                        }\n                    }\n                    return size;\n                }\n                // use a custom read function\n                stream_ops.read = (stream, buffer, offset, length, position) => {\n                    FS.forceLoadFile(node);\n                    return writeChunks(stream, buffer, offset, length, position);\n                };\n                // use a custom mmap function\n                stream_ops.mmap = (stream, length, position, prot, flags) => {\n                    FS.forceLoadFile(node);\n                    var ptr = mmapAlloc(length);\n                    if (!ptr) {\n                        throw new FS.ErrnoError(48);\n                    }\n                    writeChunks(stream, HEAP8, ptr, length, position);\n                    return { ptr, allocated: true };\n                };\n                node.stream_ops = stream_ops;\n                return node;\n            },\n            absolutePath() {\n                abort('FS.absolutePath has been removed; use PATH_FS.resolve instead');\n            },\n            createFolder() {\n                abort('FS.createFolder has been removed; use FS.mkdir instead');\n            },\n            createLink() {\n                abort('FS.createLink has been removed; use FS.symlink instead');\n            },\n            joinPath() {\n                abort('FS.joinPath has been removed; use PATH.join instead');\n            },\n            mmapAlloc() {\n                abort('FS.mmapAlloc has been replaced by the top level function mmapAlloc');\n            },\n            standardizePath() {\n                abort('FS.standardizePath has been removed; use PATH.normalize instead');\n            },\n        };\n        var SYSCALLS = {\n            DEFAULT_POLLMASK: 5,\n            calculateAt(dirfd, path, allowEmpty) {\n                if (PATH.isAbs(path)) {\n                    return path;\n                }\n                // relative path\n                var dir;\n                if (dirfd === -100) {\n                    dir = FS.cwd();\n                }\n                else {\n                    var dirstream = SYSCALLS.getStreamFromFD(dirfd);\n                    dir = dirstream.path;\n                }\n                if (path.length == 0) {\n                    if (!allowEmpty) {\n                        throw new FS.ErrnoError(44);\n                        ;\n                    }\n                    return dir;\n                }\n                return PATH.join2(dir, path);\n            },\n            doStat(func, path, buf) {\n                try {\n                    var stat = func(path);\n                }\n                catch (e) {\n                    if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n                        // an error occurred while trying to look up the path; we should just report ENOTDIR\n                        return -54;\n                    }\n                    throw e;\n                }\n                HEAP32[((buf) >> 2)] = stat.dev;\n                HEAP32[(((buf) + (4)) >> 2)] = stat.mode;\n                HEAPU32[(((buf) + (8)) >> 2)] = stat.nlink;\n                HEAP32[(((buf) + (12)) >> 2)] = stat.uid;\n                HEAP32[(((buf) + (16)) >> 2)] = stat.gid;\n                HEAP32[(((buf) + (20)) >> 2)] = stat.rdev;\n                (tempI64 = [stat.size >>> 0, (tempDouble = stat.size, (+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble) / 4294967296.0))) >>> 0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296.0))))) >>> 0) : 0)], HEAP32[(((buf) + (24)) >> 2)] = tempI64[0], HEAP32[(((buf) + (28)) >> 2)] = tempI64[1]);\n                HEAP32[(((buf) + (32)) >> 2)] = 4096;\n                HEAP32[(((buf) + (36)) >> 2)] = stat.blocks;\n                var atime = stat.atime.getTime();\n                var mtime = stat.mtime.getTime();\n                var ctime = stat.ctime.getTime();\n                (tempI64 = [Math.floor(atime / 1000) >>> 0, (tempDouble = Math.floor(atime / 1000), (+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble) / 4294967296.0))) >>> 0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296.0))))) >>> 0) : 0)], HEAP32[(((buf) + (40)) >> 2)] = tempI64[0], HEAP32[(((buf) + (44)) >> 2)] = tempI64[1]);\n                HEAPU32[(((buf) + (48)) >> 2)] = (atime % 1000) * 1000;\n                (tempI64 = [Math.floor(mtime / 1000) >>> 0, (tempDouble = Math.floor(mtime / 1000), (+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble) / 4294967296.0))) >>> 0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296.0))))) >>> 0) : 0)], HEAP32[(((buf) + (56)) >> 2)] = tempI64[0], HEAP32[(((buf) + (60)) >> 2)] = tempI64[1]);\n                HEAPU32[(((buf) + (64)) >> 2)] = (mtime % 1000) * 1000;\n                (tempI64 = [Math.floor(ctime / 1000) >>> 0, (tempDouble = Math.floor(ctime / 1000), (+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble) / 4294967296.0))) >>> 0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296.0))))) >>> 0) : 0)], HEAP32[(((buf) + (72)) >> 2)] = tempI64[0], HEAP32[(((buf) + (76)) >> 2)] = tempI64[1]);\n                HEAPU32[(((buf) + (80)) >> 2)] = (ctime % 1000) * 1000;\n                (tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, (+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble) / 4294967296.0))) >>> 0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296.0))))) >>> 0) : 0)], HEAP32[(((buf) + (88)) >> 2)] = tempI64[0], HEAP32[(((buf) + (92)) >> 2)] = tempI64[1]);\n                return 0;\n            },\n            doMsync(addr, stream, len, flags, offset) {\n                if (!FS.isFile(stream.node.mode)) {\n                    throw new FS.ErrnoError(43);\n                }\n                if (flags & 2) {\n                    // MAP_PRIVATE calls need not to be synced back to underlying fs\n                    return 0;\n                }\n                var buffer = HEAPU8.slice(addr, addr + len);\n                FS.msync(stream, buffer, offset, len, flags);\n            },\n            varargs: undefined,\n            get() {\n                assert(SYSCALLS.varargs != undefined);\n                var ret = HEAP32[((SYSCALLS.varargs) >> 2)];\n                SYSCALLS.varargs += 4;\n                return ret;\n            },\n            getp() { return SYSCALLS.get(); },\n            getStr(ptr) {\n                var ret = UTF8ToString(ptr);\n                return ret;\n            },\n            getStreamFromFD(fd) {\n                var stream = FS.getStreamChecked(fd);\n                return stream;\n            },\n        };\n        function ___syscall_fcntl64(fd, cmd, varargs) {\n            SYSCALLS.varargs = varargs;\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                switch (cmd) {\n                    case 0: {\n                        var arg = SYSCALLS.get();\n                        if (arg < 0) {\n                            return -28;\n                        }\n                        while (FS.streams[arg]) {\n                            arg++;\n                        }\n                        var newStream;\n                        newStream = FS.createStream(stream, arg);\n                        return newStream.fd;\n                    }\n                    case 1:\n                    case 2:\n                        return 0; // FD_CLOEXEC makes no sense for a single process.\n                    case 3:\n                        return stream.flags;\n                    case 4: {\n                        var arg = SYSCALLS.get();\n                        stream.flags |= arg;\n                        return 0;\n                    }\n                    case 5: {\n                        var arg = SYSCALLS.getp();\n                        var offset = 0;\n                        // We're always unlocked.\n                        HEAP16[(((arg) + (offset)) >> 1)] = 2;\n                        return 0;\n                    }\n                    case 6:\n                    case 7:\n                        return 0; // Pretend that the locking is successful.\n                    case 16:\n                    case 8:\n                        return -28; // These are for sockets. We don't have them fully implemented yet.\n                    case 9:\n                        // musl trusts getown return values, due to a bug where they must be, as they overlap with errors. just return -1 here, so fcntl() returns that, and we set errno ourselves.\n                        setErrNo(28);\n                        return -1;\n                    default: {\n                        return -28;\n                    }\n                }\n            }\n            catch (e) {\n                if (typeof FS == 'undefined' || !(e.name === 'ErrnoError'))\n                    throw e;\n                return -e.errno;\n            }\n        }\n        function ___syscall_fstat64(fd, buf) {\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                return SYSCALLS.doStat(FS.stat, stream.path, buf);\n            }\n            catch (e) {\n                if (typeof FS == 'undefined' || !(e.name === 'ErrnoError'))\n                    throw e;\n                return -e.errno;\n            }\n        }\n        var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {\n            assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n            return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n        };\n        function ___syscall_getcwd(buf, size) {\n            try {\n                if (size === 0)\n                    return -28;\n                var cwd = FS.cwd();\n                var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;\n                if (size < cwdLengthInBytes)\n                    return -68;\n                stringToUTF8(cwd, buf, size);\n                return cwdLengthInBytes;\n            }\n            catch (e) {\n                if (typeof FS == 'undefined' || !(e.name === 'ErrnoError'))\n                    throw e;\n                return -e.errno;\n            }\n        }\n        function ___syscall_lstat64(path, buf) {\n            try {\n                path = SYSCALLS.getStr(path);\n                return SYSCALLS.doStat(FS.lstat, path, buf);\n            }\n            catch (e) {\n                if (typeof FS == 'undefined' || !(e.name === 'ErrnoError'))\n                    throw e;\n                return -e.errno;\n            }\n        }\n        function ___syscall_newfstatat(dirfd, path, buf, flags) {\n            try {\n                path = SYSCALLS.getStr(path);\n                var nofollow = flags & 256;\n                var allowEmpty = flags & 4096;\n                flags = flags & (~6400);\n                assert(!flags, `unknown flags in __syscall_newfstatat: ${flags}`);\n                path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);\n                return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);\n            }\n            catch (e) {\n                if (typeof FS == 'undefined' || !(e.name === 'ErrnoError'))\n                    throw e;\n                return -e.errno;\n            }\n        }\n        function ___syscall_openat(dirfd, path, flags, varargs) {\n            SYSCALLS.varargs = varargs;\n            try {\n                path = SYSCALLS.getStr(path);\n                path = SYSCALLS.calculateAt(dirfd, path);\n                var mode = varargs ? SYSCALLS.get() : 0;\n                return FS.open(path, flags, mode).fd;\n            }\n            catch (e) {\n                if (typeof FS == 'undefined' || !(e.name === 'ErrnoError'))\n                    throw e;\n                return -e.errno;\n            }\n        }\n        function ___syscall_readlinkat(dirfd, path, buf, bufsize) {\n            try {\n                path = SYSCALLS.getStr(path);\n                path = SYSCALLS.calculateAt(dirfd, path);\n                if (bufsize <= 0)\n                    return -28;\n                var ret = FS.readlink(path);\n                var len = Math.min(bufsize, lengthBytesUTF8(ret));\n                var endChar = HEAP8[buf + len];\n                stringToUTF8(ret, buf, bufsize + 1);\n                // readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!)\n                // stringToUTF8() always appends a null byte, so restore the character under the null byte after the write.\n                HEAP8[buf + len] = endChar;\n                return len;\n            }\n            catch (e) {\n                if (typeof FS == 'undefined' || !(e.name === 'ErrnoError'))\n                    throw e;\n                return -e.errno;\n            }\n        }\n        function ___syscall_stat64(path, buf) {\n            try {\n                path = SYSCALLS.getStr(path);\n                return SYSCALLS.doStat(FS.stat, path, buf);\n            }\n            catch (e) {\n                if (typeof FS == 'undefined' || !(e.name === 'ErrnoError'))\n                    throw e;\n                return -e.errno;\n            }\n        }\n        var nowIsMonotonic = true;\n        ;\n        var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;\n        var convertI32PairToI53Checked = (lo, hi) => {\n            assert(lo == (lo >>> 0) || lo == (lo | 0)); // lo should either be a i32 or a u32\n            assert(hi === (hi | 0)); // hi should be a i32\n            return ((hi + 0x200000) >>> 0 < 0x400001 - !!lo) ? (lo >>> 0) + hi * 4294967296 : NaN;\n        };\n        function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {\n            var offset = convertI32PairToI53Checked(offset_low, offset_high);\n            ;\n            try {\n                if (isNaN(offset))\n                    return 61;\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                var res = FS.mmap(stream, len, offset, prot, flags);\n                var ptr = res.ptr;\n                HEAP32[((allocated) >> 2)] = res.allocated;\n                HEAPU32[((addr) >> 2)] = ptr;\n                return 0;\n            }\n            catch (e) {\n                if (typeof FS == 'undefined' || !(e.name === 'ErrnoError'))\n                    throw e;\n                return -e.errno;\n            }\n            ;\n        }\n        function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {\n            var offset = convertI32PairToI53Checked(offset_low, offset_high);\n            ;\n            try {\n                if (isNaN(offset))\n                    return 61;\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                if (prot & 2) {\n                    SYSCALLS.doMsync(addr, stream, len, flags, offset);\n                }\n                FS.munmap(stream);\n                // implicitly return 0\n            }\n            catch (e) {\n                if (typeof FS == 'undefined' || !(e.name === 'ErrnoError'))\n                    throw e;\n                return -e.errno;\n            }\n            ;\n        }\n        var _abort = () => {\n            abort('native code called abort()');\n        };\n        var _emscripten_date_now = () => Date.now();\n        var _emscripten_get_now;\n        // Modern environment where performance.now() is supported:\n        // N.B. a shorter form \"_emscripten_get_now = performance.now;\" is\n        // unfortunately not allowed even in current browsers (e.g. FF Nightly 75).\n        _emscripten_get_now = () => performance.now();\n        ;\n        var _emscripten_memcpy_big = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);\n        var getHeapMax = () => HEAPU8.length;\n        var abortOnCannotGrowMemory = (requestedSize) => {\n            abort(`Cannot enlarge memory arrays to size ${requestedSize} bytes (OOM). Either (1) compile with -sINITIAL_MEMORY=X with X higher than the current value ${HEAP8.length}, (2) compile with -sALLOW_MEMORY_GROWTH which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with -sABORTING_MALLOC=0`);\n        };\n        var _emscripten_resize_heap = (requestedSize) => {\n            var oldSize = HEAPU8.length;\n            // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n            requestedSize >>>= 0;\n            abortOnCannotGrowMemory(requestedSize);\n        };\n        var ENV = {};\n        var getExecutableName = () => {\n            return thisProgram || './this.program';\n        };\n        var getEnvStrings = () => {\n            if (!getEnvStrings.strings) {\n                // Default values.\n                // Browser language detection #8751\n                var lang = ((typeof navigator == 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8';\n                var env = {\n                    'USER': 'web_user',\n                    'LOGNAME': 'web_user',\n                    'PATH': '/',\n                    'PWD': '/',\n                    'HOME': '/home/web_user',\n                    'LANG': lang,\n                    '_': getExecutableName()\n                };\n                // Apply the user-provided values, if any.\n                for (var x in ENV) {\n                    // x is a key in ENV; if ENV[x] is undefined, that means it was\n                    // explicitly set to be so. We allow user code to do that to\n                    // force variables with default values to remain unset.\n                    if (ENV[x] === undefined)\n                        delete env[x];\n                    else\n                        env[x] = ENV[x];\n                }\n                var strings = [];\n                for (var x in env) {\n                    strings.push(`${x}=${env[x]}`);\n                }\n                getEnvStrings.strings = strings;\n            }\n            return getEnvStrings.strings;\n        };\n        var stringToAscii = (str, buffer) => {\n            for (var i = 0; i < str.length; ++i) {\n                assert(str.charCodeAt(i) === (str.charCodeAt(i) & 0xff));\n                HEAP8[((buffer++) >> 0)] = str.charCodeAt(i);\n            }\n            // Null-terminate the string\n            HEAP8[((buffer) >> 0)] = 0;\n        };\n        var _environ_get = (__environ, environ_buf) => {\n            var bufSize = 0;\n            getEnvStrings().forEach((string, i) => {\n                var ptr = environ_buf + bufSize;\n                HEAPU32[(((__environ) + (i * 4)) >> 2)] = ptr;\n                stringToAscii(string, ptr);\n                bufSize += string.length + 1;\n            });\n            return 0;\n        };\n        var _environ_sizes_get = (penviron_count, penviron_buf_size) => {\n            var strings = getEnvStrings();\n            HEAPU32[((penviron_count) >> 2)] = strings.length;\n            var bufSize = 0;\n            strings.forEach((string) => bufSize += string.length + 1);\n            HEAPU32[((penviron_buf_size) >> 2)] = bufSize;\n            return 0;\n        };\n        function _fd_close(fd) {\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                FS.close(stream);\n                return 0;\n            }\n            catch (e) {\n                if (typeof FS == 'undefined' || !(e.name === 'ErrnoError'))\n                    throw e;\n                return e.errno;\n            }\n        }\n        function _fd_fdstat_get(fd, pbuf) {\n            try {\n                var rightsBase = 0;\n                var rightsInheriting = 0;\n                var flags = 0;\n                {\n                    var stream = SYSCALLS.getStreamFromFD(fd);\n                    // All character devices are terminals (other things a Linux system would\n                    // assume is a character device, like the mouse, we have special APIs for).\n                    var type = stream.tty ? 2 :\n                        FS.isDir(stream.mode) ? 3 :\n                            FS.isLink(stream.mode) ? 7 :\n                                4;\n                }\n                HEAP8[((pbuf) >> 0)] = type;\n                HEAP16[(((pbuf) + (2)) >> 1)] = flags;\n                (tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, (+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble) / 4294967296.0))) >>> 0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296.0))))) >>> 0) : 0)], HEAP32[(((pbuf) + (8)) >> 2)] = tempI64[0], HEAP32[(((pbuf) + (12)) >> 2)] = tempI64[1]);\n                (tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, (+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble) / 4294967296.0))) >>> 0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296.0))))) >>> 0) : 0)], HEAP32[(((pbuf) + (16)) >> 2)] = tempI64[0], HEAP32[(((pbuf) + (20)) >> 2)] = tempI64[1]);\n                return 0;\n            }\n            catch (e) {\n                if (typeof FS == 'undefined' || !(e.name === 'ErrnoError'))\n                    throw e;\n                return e.errno;\n            }\n        }\n        /** @param {number=} offset */\n        var doReadv = (stream, iov, iovcnt, offset) => {\n            var ret = 0;\n            for (var i = 0; i < iovcnt; i++) {\n                var ptr = HEAPU32[((iov) >> 2)];\n                var len = HEAPU32[(((iov) + (4)) >> 2)];\n                iov += 8;\n                var curr = FS.read(stream, HEAP8, ptr, len, offset);\n                if (curr < 0)\n                    return -1;\n                ret += curr;\n                if (curr < len)\n                    break; // nothing more to read\n                if (typeof offset !== 'undefined') {\n                    offset += curr;\n                }\n            }\n            return ret;\n        };\n        function _fd_read(fd, iov, iovcnt, pnum) {\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                var num = doReadv(stream, iov, iovcnt);\n                HEAPU32[((pnum) >> 2)] = num;\n                return 0;\n            }\n            catch (e) {\n                if (typeof FS == 'undefined' || !(e.name === 'ErrnoError'))\n                    throw e;\n                return e.errno;\n            }\n        }\n        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n            var offset = convertI32PairToI53Checked(offset_low, offset_high);\n            ;\n            try {\n                if (isNaN(offset))\n                    return 61;\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                FS.llseek(stream, offset, whence);\n                (tempI64 = [stream.position >>> 0, (tempDouble = stream.position, (+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble) / 4294967296.0))) >>> 0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296.0))))) >>> 0) : 0)], HEAP32[((newOffset) >> 2)] = tempI64[0], HEAP32[(((newOffset) + (4)) >> 2)] = tempI64[1]);\n                if (stream.getdents && offset === 0 && whence === 0)\n                    stream.getdents = null; // reset readdir state\n                return 0;\n            }\n            catch (e) {\n                if (typeof FS == 'undefined' || !(e.name === 'ErrnoError'))\n                    throw e;\n                return e.errno;\n            }\n            ;\n        }\n        /** @param {number=} offset */\n        var doWritev = (stream, iov, iovcnt, offset) => {\n            var ret = 0;\n            for (var i = 0; i < iovcnt; i++) {\n                var ptr = HEAPU32[((iov) >> 2)];\n                var len = HEAPU32[(((iov) + (4)) >> 2)];\n                iov += 8;\n                var curr = FS.write(stream, HEAP8, ptr, len, offset);\n                if (curr < 0)\n                    return -1;\n                ret += curr;\n                if (typeof offset !== 'undefined') {\n                    offset += curr;\n                }\n            }\n            return ret;\n        };\n        function _fd_write(fd, iov, iovcnt, pnum) {\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                var num = doWritev(stream, iov, iovcnt);\n                HEAPU32[((pnum) >> 2)] = num;\n                return 0;\n            }\n            catch (e) {\n                if (typeof FS == 'undefined' || !(e.name === 'ErrnoError'))\n                    throw e;\n                return e.errno;\n            }\n        }\n        var _llvm_eh_typeid_for = (type) => type;\n        var isLeapYear = (year) => {\n            return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n        };\n        var arraySum = (array, index) => {\n            var sum = 0;\n            for (var i = 0; i <= index; sum += array[i++]) {\n                // no-op\n            }\n            return sum;\n        };\n        var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n        var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n        var addDays = (date, days) => {\n            var newDate = new Date(date.getTime());\n            while (days > 0) {\n                var leap = isLeapYear(newDate.getFullYear());\n                var currentMonth = newDate.getMonth();\n                var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];\n                if (days > daysInCurrentMonth - newDate.getDate()) {\n                    // we spill over to next month\n                    days -= (daysInCurrentMonth - newDate.getDate() + 1);\n                    newDate.setDate(1);\n                    if (currentMonth < 11) {\n                        newDate.setMonth(currentMonth + 1);\n                    }\n                    else {\n                        newDate.setMonth(0);\n                        newDate.setFullYear(newDate.getFullYear() + 1);\n                    }\n                }\n                else {\n                    // we stay in current month\n                    newDate.setDate(newDate.getDate() + days);\n                    return newDate;\n                }\n            }\n            return newDate;\n        };\n        var writeArrayToMemory = (array, buffer) => {\n            assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)');\n            HEAP8.set(array, buffer);\n        };\n        var _strftime = (s, maxsize, format, tm) => {\n            // size_t strftime(char *restrict s, size_t maxsize, const char *restrict format, const struct tm *restrict timeptr);\n            // http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html\n            var tm_zone = HEAPU32[(((tm) + (40)) >> 2)];\n            var date = {\n                tm_sec: HEAP32[((tm) >> 2)],\n                tm_min: HEAP32[(((tm) + (4)) >> 2)],\n                tm_hour: HEAP32[(((tm) + (8)) >> 2)],\n                tm_mday: HEAP32[(((tm) + (12)) >> 2)],\n                tm_mon: HEAP32[(((tm) + (16)) >> 2)],\n                tm_year: HEAP32[(((tm) + (20)) >> 2)],\n                tm_wday: HEAP32[(((tm) + (24)) >> 2)],\n                tm_yday: HEAP32[(((tm) + (28)) >> 2)],\n                tm_isdst: HEAP32[(((tm) + (32)) >> 2)],\n                tm_gmtoff: HEAP32[(((tm) + (36)) >> 2)],\n                tm_zone: tm_zone ? UTF8ToString(tm_zone) : ''\n            };\n            var pattern = UTF8ToString(format);\n            // expand format\n            var EXPANSION_RULES_1 = {\n                '%c': '%a %b %d %H:%M:%S %Y',\n                '%D': '%m/%d/%y',\n                '%F': '%Y-%m-%d',\n                '%h': '%b',\n                '%r': '%I:%M:%S %p',\n                '%R': '%H:%M',\n                '%T': '%H:%M:%S',\n                '%x': '%m/%d/%y',\n                '%X': '%H:%M:%S',\n                // Modified Conversion Specifiers\n                '%Ec': '%c',\n                '%EC': '%C',\n                '%Ex': '%m/%d/%y',\n                '%EX': '%H:%M:%S',\n                '%Ey': '%y',\n                '%EY': '%Y',\n                '%Od': '%d',\n                '%Oe': '%e',\n                '%OH': '%H',\n                '%OI': '%I',\n                '%Om': '%m',\n                '%OM': '%M',\n                '%OS': '%S',\n                '%Ou': '%u',\n                '%OU': '%U',\n                '%OV': '%V',\n                '%Ow': '%w',\n                '%OW': '%W',\n                '%Oy': '%y', // Replaced by the year (offset from %C ) using the locale's alternative numeric symbols.\n            };\n            for (var rule in EXPANSION_RULES_1) {\n                pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_1[rule]);\n            }\n            var WEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n            var MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n            function leadingSomething(value, digits, character) {\n                var str = typeof value == 'number' ? value.toString() : (value || '');\n                while (str.length < digits) {\n                    str = character[0] + str;\n                }\n                return str;\n            }\n            function leadingNulls(value, digits) {\n                return leadingSomething(value, digits, '0');\n            }\n            function compareByDay(date1, date2) {\n                function sgn(value) {\n                    return value < 0 ? -1 : (value > 0 ? 1 : 0);\n                }\n                var compare;\n                if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\n                    if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\n                        compare = sgn(date1.getDate() - date2.getDate());\n                    }\n                }\n                return compare;\n            }\n            function getFirstWeekStartDate(janFourth) {\n                switch (janFourth.getDay()) {\n                    case 0: // Sunday\n                        return new Date(janFourth.getFullYear() - 1, 11, 29);\n                    case 1: // Monday\n                        return janFourth;\n                    case 2: // Tuesday\n                        return new Date(janFourth.getFullYear(), 0, 3);\n                    case 3: // Wednesday\n                        return new Date(janFourth.getFullYear(), 0, 2);\n                    case 4: // Thursday\n                        return new Date(janFourth.getFullYear(), 0, 1);\n                    case 5: // Friday\n                        return new Date(janFourth.getFullYear() - 1, 11, 31);\n                    case 6: // Saturday\n                        return new Date(janFourth.getFullYear() - 1, 11, 30);\n                }\n            }\n            function getWeekBasedYear(date) {\n                var thisDate = addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\n                var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\n                var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\n                var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n                var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n                if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\n                    // this date is after the start of the first week of this year\n                    if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\n                        return thisDate.getFullYear() + 1;\n                    }\n                    return thisDate.getFullYear();\n                }\n                return thisDate.getFullYear() - 1;\n            }\n            var EXPANSION_RULES_2 = {\n                '%a': (date) => WEEKDAYS[date.tm_wday].substring(0, 3),\n                '%A': (date) => WEEKDAYS[date.tm_wday],\n                '%b': (date) => MONTHS[date.tm_mon].substring(0, 3),\n                '%B': (date) => MONTHS[date.tm_mon],\n                '%C': (date) => {\n                    var year = date.tm_year + 1900;\n                    return leadingNulls((year / 100) | 0, 2);\n                },\n                '%d': (date) => leadingNulls(date.tm_mday, 2),\n                '%e': (date) => leadingSomething(date.tm_mday, 2, ' '),\n                '%g': (date) => {\n                    // %g, %G, and %V give values according to the ISO 8601:2000 standard week-based year.\n                    // In this system, weeks begin on a Monday and week 1 of the year is the week that includes\n                    // January 4th, which is also the week that includes the first Thursday of the year, and\n                    // is also the first week that contains at least four days in the year.\n                    // If the first Monday of January is the 2nd, 3rd, or 4th, the preceding days are part of\n                    // the last week of the preceding year; thus, for Saturday 2nd January 1999,\n                    // %G is replaced by 1998 and %V is replaced by 53. If December 29th, 30th,\n                    // or 31st is a Monday, it and any following days are part of week 1 of the following year.\n                    // Thus, for Tuesday 30th December 1997, %G is replaced by 1998 and %V is replaced by 01.\n                    return getWeekBasedYear(date).toString().substring(2);\n                },\n                '%G': (date) => getWeekBasedYear(date),\n                '%H': (date) => leadingNulls(date.tm_hour, 2),\n                '%I': (date) => {\n                    var twelveHour = date.tm_hour;\n                    if (twelveHour == 0)\n                        twelveHour = 12;\n                    else if (twelveHour > 12)\n                        twelveHour -= 12;\n                    return leadingNulls(twelveHour, 2);\n                },\n                '%j': (date) => {\n                    // Day of the year (001-366)\n                    return leadingNulls(date.tm_mday + arraySum(isLeapYear(date.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date.tm_mon - 1), 3);\n                },\n                '%m': (date) => leadingNulls(date.tm_mon + 1, 2),\n                '%M': (date) => leadingNulls(date.tm_min, 2),\n                '%n': () => '\\n',\n                '%p': (date) => {\n                    if (date.tm_hour >= 0 && date.tm_hour < 12) {\n                        return 'AM';\n                    }\n                    return 'PM';\n                },\n                '%S': (date) => leadingNulls(date.tm_sec, 2),\n                '%t': () => '\\t',\n                '%u': (date) => date.tm_wday || 7,\n                '%U': (date) => {\n                    var days = date.tm_yday + 7 - date.tm_wday;\n                    return leadingNulls(Math.floor(days / 7), 2);\n                },\n                '%V': (date) => {\n                    // Replaced by the week number of the year (Monday as the first day of the week)\n                    // as a decimal number [01,53]. If the week containing 1 January has four\n                    // or more days in the new year, then it is considered week 1.\n                    // Otherwise, it is the last week of the previous year, and the next week is week 1.\n                    // Both January 4th and the first Thursday of January are always in week 1. [ tm_year, tm_wday, tm_yday]\n                    var val = Math.floor((date.tm_yday + 7 - (date.tm_wday + 6) % 7) / 7);\n                    // If 1 Jan is just 1-3 days past Monday, the previous week\n                    // is also in this year.\n                    if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {\n                        val++;\n                    }\n                    if (!val) {\n                        val = 52;\n                        // If 31 December of prev year a Thursday, or Friday of a\n                        // leap year, then the prev year has 53 weeks.\n                        var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;\n                        if (dec31 == 4 || (dec31 == 5 && isLeapYear(date.tm_year % 400 - 1))) {\n                            val++;\n                        }\n                    }\n                    else if (val == 53) {\n                        // If 1 January is not a Thursday, and not a Wednesday of a\n                        // leap year, then this year has only 52 weeks.\n                        var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7;\n                        if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date.tm_year)))\n                            val = 1;\n                    }\n                    return leadingNulls(val, 2);\n                },\n                '%w': (date) => date.tm_wday,\n                '%W': (date) => {\n                    var days = date.tm_yday + 7 - ((date.tm_wday + 6) % 7);\n                    return leadingNulls(Math.floor(days / 7), 2);\n                },\n                '%y': (date) => {\n                    // Replaced by the last two digits of the year as a decimal number [00,99]. [ tm_year]\n                    return (date.tm_year + 1900).toString().substring(2);\n                },\n                // Replaced by the year as a decimal number (for example, 1997). [ tm_year]\n                '%Y': (date) => date.tm_year + 1900,\n                '%z': (date) => {\n                    // Replaced by the offset from UTC in the ISO 8601:2000 standard format ( +hhmm or -hhmm ).\n                    // For example, \"-0430\" means 4 hours 30 minutes behind UTC (west of Greenwich).\n                    var off = date.tm_gmtoff;\n                    var ahead = off >= 0;\n                    off = Math.abs(off) / 60;\n                    // convert from minutes into hhmm format (which means 60 minutes = 100 units)\n                    off = (off / 60) * 100 + (off % 60);\n                    return (ahead ? '+' : '-') + String(\"0000\" + off).slice(-4);\n                },\n                '%Z': (date) => date.tm_zone,\n                '%%': () => '%'\n            };\n            // Replace %% with a pair of NULLs (which cannot occur in a C string), then\n            // re-inject them after processing.\n            pattern = pattern.replace(/%%/g, '\\0\\0');\n            for (var rule in EXPANSION_RULES_2) {\n                if (pattern.includes(rule)) {\n                    pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_2[rule](date));\n                }\n            }\n            pattern = pattern.replace(/\\0\\0/g, '%');\n            var bytes = intArrayFromString(pattern, false);\n            if (bytes.length > maxsize) {\n                return 0;\n            }\n            writeArrayToMemory(bytes, s);\n            return bytes.length - 1;\n        };\n        var _strftime_l = (s, maxsize, format, tm, loc) => {\n            return _strftime(s, maxsize, format, tm); // no locale support yet\n        };\n        var wasmTableMirror = [];\n        var getWasmTableEntry = (funcPtr) => {\n            var func = wasmTableMirror[funcPtr];\n            if (!func) {\n                if (funcPtr >= wasmTableMirror.length)\n                    wasmTableMirror.length = funcPtr + 1;\n                wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n            }\n            assert(wasmTable.get(funcPtr) == func, \"JavaScript-side Wasm function table mirror is out of date!\");\n            return func;\n        };\n        var getCFunc = (ident) => {\n            var func = Module['_' + ident]; // closure exported function\n            assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n            return func;\n        };\n        var stringToUTF8OnStack = (str) => {\n            var size = lengthBytesUTF8(str) + 1;\n            var ret = stackAlloc(size);\n            stringToUTF8(str, ret, size);\n            return ret;\n        };\n        /**\n         * @param {string|null=} returnType\n         * @param {Array=} argTypes\n         * @param {Arguments|Array=} args\n         * @param {Object=} opts\n         */\n        var ccall = (ident, returnType, argTypes, args, opts) => {\n            // For fast lookup of conversion functions\n            var toC = {\n                'string': (str) => {\n                    var ret = 0;\n                    if (str !== null && str !== undefined && str !== 0) { // null string\n                        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n                        ret = stringToUTF8OnStack(str);\n                    }\n                    return ret;\n                },\n                'array': (arr) => {\n                    var ret = stackAlloc(arr.length);\n                    writeArrayToMemory(arr, ret);\n                    return ret;\n                }\n            };\n            function convertReturnValue(ret) {\n                if (returnType === 'string') {\n                    return UTF8ToString(ret);\n                }\n                if (returnType === 'boolean')\n                    return Boolean(ret);\n                return ret;\n            }\n            var func = getCFunc(ident);\n            var cArgs = [];\n            var stack = 0;\n            assert(returnType !== 'array', 'Return type should not be \"array\".');\n            if (args) {\n                for (var i = 0; i < args.length; i++) {\n                    var converter = toC[argTypes[i]];\n                    if (converter) {\n                        if (stack === 0)\n                            stack = stackSave();\n                        cArgs[i] = converter(args[i]);\n                    }\n                    else {\n                        cArgs[i] = args[i];\n                    }\n                }\n            }\n            var ret = func.apply(null, cArgs);\n            function onDone(ret) {\n                if (stack !== 0)\n                    stackRestore(stack);\n                return convertReturnValue(ret);\n            }\n            ret = onDone(ret);\n            return ret;\n        };\n        /**\n         * @param {string=} returnType\n         * @param {Array=} argTypes\n         * @param {Object=} opts\n         */\n        var cwrap = (ident, returnType, argTypes, opts) => {\n            return function () {\n                return ccall(ident, returnType, argTypes, arguments, opts);\n            };\n        };\n        var FSNode = /** @constructor */ function (parent, name, mode, rdev) {\n            if (!parent) {\n                parent = this; // root node sets parent to itself\n            }\n            this.parent = parent;\n            this.mount = parent.mount;\n            this.mounted = null;\n            this.id = FS.nextInode++;\n            this.name = name;\n            this.mode = mode;\n            this.node_ops = {};\n            this.stream_ops = {};\n            this.rdev = rdev;\n        };\n        var readMode = 292 /*292*/ | 73 /*73*/;\n        var writeMode = 146 /*146*/;\n        Object.defineProperties(FSNode.prototype, {\n            read: {\n                get: /** @this{FSNode} */ function () {\n                    return (this.mode & readMode) === readMode;\n                },\n                set: /** @this{FSNode} */ function (val) {\n                    val ? this.mode |= readMode : this.mode &= ~readMode;\n                }\n            },\n            write: {\n                get: /** @this{FSNode} */ function () {\n                    return (this.mode & writeMode) === writeMode;\n                },\n                set: /** @this{FSNode} */ function (val) {\n                    val ? this.mode |= writeMode : this.mode &= ~writeMode;\n                }\n            },\n            isFolder: {\n                get: /** @this{FSNode} */ function () {\n                    return FS.isDir(this.mode);\n                }\n            },\n            isDevice: {\n                get: /** @this{FSNode} */ function () {\n                    return FS.isChrdev(this.mode);\n                }\n            }\n        });\n        FS.FSNode = FSNode;\n        FS.createPreloadedFile = FS_createPreloadedFile;\n        FS.staticInit();\n        ;\n        ERRNO_CODES = {\n            'EPERM': 63,\n            'ENOENT': 44,\n            'ESRCH': 71,\n            'EINTR': 27,\n            'EIO': 29,\n            'ENXIO': 60,\n            'E2BIG': 1,\n            'ENOEXEC': 45,\n            'EBADF': 8,\n            'ECHILD': 12,\n            'EAGAIN': 6,\n            'EWOULDBLOCK': 6,\n            'ENOMEM': 48,\n            'EACCES': 2,\n            'EFAULT': 21,\n            'ENOTBLK': 105,\n            'EBUSY': 10,\n            'EEXIST': 20,\n            'EXDEV': 75,\n            'ENODEV': 43,\n            'ENOTDIR': 54,\n            'EISDIR': 31,\n            'EINVAL': 28,\n            'ENFILE': 41,\n            'EMFILE': 33,\n            'ENOTTY': 59,\n            'ETXTBSY': 74,\n            'EFBIG': 22,\n            'ENOSPC': 51,\n            'ESPIPE': 70,\n            'EROFS': 69,\n            'EMLINK': 34,\n            'EPIPE': 64,\n            'EDOM': 18,\n            'ERANGE': 68,\n            'ENOMSG': 49,\n            'EIDRM': 24,\n            'ECHRNG': 106,\n            'EL2NSYNC': 156,\n            'EL3HLT': 107,\n            'EL3RST': 108,\n            'ELNRNG': 109,\n            'EUNATCH': 110,\n            'ENOCSI': 111,\n            'EL2HLT': 112,\n            'EDEADLK': 16,\n            'ENOLCK': 46,\n            'EBADE': 113,\n            'EBADR': 114,\n            'EXFULL': 115,\n            'ENOANO': 104,\n            'EBADRQC': 103,\n            'EBADSLT': 102,\n            'EDEADLOCK': 16,\n            'EBFONT': 101,\n            'ENOSTR': 100,\n            'ENODATA': 116,\n            'ETIME': 117,\n            'ENOSR': 118,\n            'ENONET': 119,\n            'ENOPKG': 120,\n            'EREMOTE': 121,\n            'ENOLINK': 47,\n            'EADV': 122,\n            'ESRMNT': 123,\n            'ECOMM': 124,\n            'EPROTO': 65,\n            'EMULTIHOP': 36,\n            'EDOTDOT': 125,\n            'EBADMSG': 9,\n            'ENOTUNIQ': 126,\n            'EBADFD': 127,\n            'EREMCHG': 128,\n            'ELIBACC': 129,\n            'ELIBBAD': 130,\n            'ELIBSCN': 131,\n            'ELIBMAX': 132,\n            'ELIBEXEC': 133,\n            'ENOSYS': 52,\n            'ENOTEMPTY': 55,\n            'ENAMETOOLONG': 37,\n            'ELOOP': 32,\n            'EOPNOTSUPP': 138,\n            'EPFNOSUPPORT': 139,\n            'ECONNRESET': 15,\n            'ENOBUFS': 42,\n            'EAFNOSUPPORT': 5,\n            'EPROTOTYPE': 67,\n            'ENOTSOCK': 57,\n            'ENOPROTOOPT': 50,\n            'ESHUTDOWN': 140,\n            'ECONNREFUSED': 14,\n            'EADDRINUSE': 3,\n            'ECONNABORTED': 13,\n            'ENETUNREACH': 40,\n            'ENETDOWN': 38,\n            'ETIMEDOUT': 73,\n            'EHOSTDOWN': 142,\n            'EHOSTUNREACH': 23,\n            'EINPROGRESS': 26,\n            'EALREADY': 7,\n            'EDESTADDRREQ': 17,\n            'EMSGSIZE': 35,\n            'EPROTONOSUPPORT': 66,\n            'ESOCKTNOSUPPORT': 137,\n            'EADDRNOTAVAIL': 4,\n            'ENETRESET': 39,\n            'EISCONN': 30,\n            'ENOTCONN': 53,\n            'ETOOMANYREFS': 141,\n            'EUSERS': 136,\n            'EDQUOT': 19,\n            'ESTALE': 72,\n            'ENOTSUP': 138,\n            'ENOMEDIUM': 148,\n            'EILSEQ': 25,\n            'EOVERFLOW': 61,\n            'ECANCELED': 11,\n            'ENOTRECOVERABLE': 56,\n            'EOWNERDEAD': 62,\n            'ESTRPIPE': 135,\n        };\n        ;\n        function checkIncomingModuleAPI() {\n            ignoredModuleProp('fetchSettings');\n        }\n        var wasmImports = {\n            __assert_fail: ___assert_fail,\n            __cxa_begin_catch: ___cxa_begin_catch,\n            __cxa_end_catch: ___cxa_end_catch,\n            __cxa_find_matching_catch_2: ___cxa_find_matching_catch_2,\n            __cxa_find_matching_catch_3: ___cxa_find_matching_catch_3,\n            __cxa_rethrow: ___cxa_rethrow,\n            __cxa_throw: ___cxa_throw,\n            __cxa_uncaught_exceptions: ___cxa_uncaught_exceptions,\n            __resumeException: ___resumeException,\n            __syscall_fcntl64: ___syscall_fcntl64,\n            __syscall_fstat64: ___syscall_fstat64,\n            __syscall_getcwd: ___syscall_getcwd,\n            __syscall_lstat64: ___syscall_lstat64,\n            __syscall_newfstatat: ___syscall_newfstatat,\n            __syscall_openat: ___syscall_openat,\n            __syscall_readlinkat: ___syscall_readlinkat,\n            __syscall_stat64: ___syscall_stat64,\n            _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,\n            _mmap_js: __mmap_js,\n            _munmap_js: __munmap_js,\n            abort: _abort,\n            emscripten_date_now: _emscripten_date_now,\n            emscripten_get_now: _emscripten_get_now,\n            emscripten_memcpy_big: _emscripten_memcpy_big,\n            emscripten_resize_heap: _emscripten_resize_heap,\n            environ_get: _environ_get,\n            environ_sizes_get: _environ_sizes_get,\n            fd_close: _fd_close,\n            fd_fdstat_get: _fd_fdstat_get,\n            fd_read: _fd_read,\n            fd_seek: _fd_seek,\n            fd_write: _fd_write,\n            invoke_diii: invoke_diii,\n            invoke_fiii: invoke_fiii,\n            invoke_i: invoke_i,\n            invoke_ii: invoke_ii,\n            invoke_iii: invoke_iii,\n            invoke_iiii: invoke_iiii,\n            invoke_iiiii: invoke_iiiii,\n            invoke_iiiiii: invoke_iiiiii,\n            invoke_iiiiiii: invoke_iiiiiii,\n            invoke_iiiiiiii: invoke_iiiiiiii,\n            invoke_iiiiiiiii: invoke_iiiiiiiii,\n            invoke_iiiiiiiiiii: invoke_iiiiiiiiiii,\n            invoke_iiiiiiiiiiii: invoke_iiiiiiiiiiii,\n            invoke_iiiiiiiiiiiii: invoke_iiiiiiiiiiiii,\n            invoke_iij: invoke_iij,\n            invoke_iijii: invoke_iijii,\n            invoke_ij: invoke_ij,\n            invoke_j: invoke_j,\n            invoke_jiiii: invoke_jiiii,\n            invoke_v: invoke_v,\n            invoke_vi: invoke_vi,\n            invoke_vii: invoke_vii,\n            invoke_viii: invoke_viii,\n            invoke_viiii: invoke_viiii,\n            invoke_viiiii: invoke_viiiii,\n            invoke_viiiiii: invoke_viiiiii,\n            invoke_viiiiiii: invoke_viiiiiii,\n            invoke_viiiiiiii: invoke_viiiiiiii,\n            invoke_viiiiiiiii: invoke_viiiiiiiii,\n            invoke_viiiiiiiiii: invoke_viiiiiiiiii,\n            invoke_viiiiiiiiiiiiiii: invoke_viiiiiiiiiiiiiii,\n            invoke_viji: invoke_viji,\n            llvm_eh_typeid_for: _llvm_eh_typeid_for,\n            strftime_l: _strftime_l\n        };\n        var wasmExports = createWasm();\n        var ___wasm_call_ctors = createExportWrapper('__wasm_call_ctors');\n        var ___cxa_free_exception = createExportWrapper('__cxa_free_exception');\n        var ___cxa_increment_exception_refcount = createExportWrapper('__cxa_increment_exception_refcount');\n        var ___cxa_decrement_exception_refcount = createExportWrapper('__cxa_decrement_exception_refcount');\n        var ___get_exception_message = Module['___get_exception_message'] = createExportWrapper('__get_exception_message');\n        var ___cxa_can_catch = createExportWrapper('__cxa_can_catch');\n        var ___cxa_is_pointer_type = createExportWrapper('__cxa_is_pointer_type');\n        var _free = Module['_free'] = createExportWrapper('free');\n        var _emscripten_main = Module['_emscripten_main'] = createExportWrapper('emscripten_main');\n        var ___errno_location = createExportWrapper('__errno_location');\n        var _fflush = Module['_fflush'] = createExportWrapper('fflush');\n        var _emscripten_builtin_memalign = createExportWrapper('emscripten_builtin_memalign');\n        var _setThrew = createExportWrapper('setThrew');\n        var setTempRet0 = createExportWrapper('setTempRet0');\n        var _emscripten_stack_init = () => (_emscripten_stack_init = wasmExports['emscripten_stack_init'])();\n        var _emscripten_stack_get_free = () => (_emscripten_stack_get_free = wasmExports['emscripten_stack_get_free'])();\n        var _emscripten_stack_get_base = () => (_emscripten_stack_get_base = wasmExports['emscripten_stack_get_base'])();\n        var _emscripten_stack_get_end = () => (_emscripten_stack_get_end = wasmExports['emscripten_stack_get_end'])();\n        var stackSave = createExportWrapper('stackSave');\n        var stackRestore = createExportWrapper('stackRestore');\n        var stackAlloc = createExportWrapper('stackAlloc');\n        var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports['emscripten_stack_get_current'])();\n        var dynCall_iij = Module['dynCall_iij'] = createExportWrapper('dynCall_iij');\n        var dynCall_viji = Module['dynCall_viji'] = createExportWrapper('dynCall_viji');\n        var dynCall_viij = Module['dynCall_viij'] = createExportWrapper('dynCall_viij');\n        var dynCall_iijii = Module['dynCall_iijii'] = createExportWrapper('dynCall_iijii');\n        var dynCall_ij = Module['dynCall_ij'] = createExportWrapper('dynCall_ij');\n        var dynCall_jiji = Module['dynCall_jiji'] = createExportWrapper('dynCall_jiji');\n        var dynCall_j = Module['dynCall_j'] = createExportWrapper('dynCall_j');\n        var dynCall_viijii = Module['dynCall_viijii'] = createExportWrapper('dynCall_viijii');\n        var dynCall_jiiii = Module['dynCall_jiiii'] = createExportWrapper('dynCall_jiiii');\n        var dynCall_iiiiij = Module['dynCall_iiiiij'] = createExportWrapper('dynCall_iiiiij');\n        var dynCall_iiiiijj = Module['dynCall_iiiiijj'] = createExportWrapper('dynCall_iiiiijj');\n        var dynCall_iiiiiijj = Module['dynCall_iiiiiijj'] = createExportWrapper('dynCall_iiiiiijj');\n        function invoke_vii(index, a1, a2) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiii(index, a1, a2, a3) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_v(index) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)();\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_vi(index, a1) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iii(index, a1, a2) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiii(index, a1, a2, a3, a4) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viii(index, a1, a2, a3) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_ii(index, a1) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_i(index) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)();\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiiii(index, a1, a2, a3, a4, a5) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiiii(index, a1, a2, a3, a4) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3, a4);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiiiii(index, a1, a2, a3, a4, a5) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3, a4, a5);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_fiii(index, a1, a2, a3) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_diii(index, a1, a2, a3) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iij(index, a1, a2, a3) {\n            var sp = stackSave();\n            try {\n                return dynCall_iij(index, a1, a2, a3);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viji(index, a1, a2, a3, a4) {\n            var sp = stackSave();\n            try {\n                dynCall_viji(index, a1, a2, a3, a4);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iijii(index, a1, a2, a3, a4, a5) {\n            var sp = stackSave();\n            try {\n                return dynCall_iijii(index, a1, a2, a3, a4, a5);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_ij(index, a1, a2) {\n            var sp = stackSave();\n            try {\n                return dynCall_ij(index, a1, a2);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_j(index) {\n            var sp = stackSave();\n            try {\n                return dynCall_j(index);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_jiiii(index, a1, a2, a3, a4) {\n            var sp = stackSave();\n            try {\n                return dynCall_jiiii(index, a1, a2, a3, a4);\n            }\n            catch (e) {\n                stackRestore(sp);\n                if (!(e instanceof EmscriptenEH))\n                    throw e;\n                _setThrew(1, 0);\n            }\n        }\n        // include: postamble.js\n        // === Auto-generated postamble setup entry stuff ===\n        Module['ccall'] = ccall;\n        Module['cwrap'] = cwrap;\n        var missingLibrarySymbols = [\n            'writeI53ToI64',\n            'writeI53ToI64Clamped',\n            'writeI53ToI64Signaling',\n            'writeI53ToU64Clamped',\n            'writeI53ToU64Signaling',\n            'readI53FromI64',\n            'readI53FromU64',\n            'convertI32PairToI53',\n            'convertU32PairToI53',\n            'exitJS',\n            'growMemory',\n            'ydayFromDate',\n            'inetPton4',\n            'inetNtop4',\n            'inetPton6',\n            'inetNtop6',\n            'readSockaddr',\n            'writeSockaddr',\n            'getHostByName',\n            'getCallstack',\n            'emscriptenLog',\n            'convertPCtoSourceLocation',\n            'readEmAsmArgs',\n            'jstoi_q',\n            'jstoi_s',\n            'listenOnce',\n            'autoResumeAudioContext',\n            'dynCallLegacy',\n            'getDynCaller',\n            'dynCall',\n            'handleException',\n            'runtimeKeepalivePush',\n            'runtimeKeepalivePop',\n            'callUserCallback',\n            'maybeExit',\n            'safeSetTimeout',\n            'asmjsMangle',\n            'handleAllocatorInit',\n            'HandleAllocator',\n            'getNativeTypeSize',\n            'STACK_SIZE',\n            'STACK_ALIGN',\n            'POINTER_SIZE',\n            'ASSERTIONS',\n            'uleb128Encode',\n            'sigToWasmTypes',\n            'generateFuncType',\n            'convertJsFunctionToWasm',\n            'getEmptyTableSlot',\n            'updateTableMap',\n            'getFunctionAddress',\n            'addFunction',\n            'removeFunction',\n            'reallyNegative',\n            'unSign',\n            'strLen',\n            'reSign',\n            'formatString',\n            'intArrayToString',\n            'AsciiToString',\n            'UTF16ToString',\n            'stringToUTF16',\n            'lengthBytesUTF16',\n            'UTF32ToString',\n            'stringToUTF32',\n            'lengthBytesUTF32',\n            'stringToNewUTF8',\n            'registerKeyEventCallback',\n            'maybeCStringToJsString',\n            'findEventTarget',\n            'findCanvasEventTarget',\n            'getBoundingClientRect',\n            'fillMouseEventData',\n            'registerMouseEventCallback',\n            'registerWheelEventCallback',\n            'registerUiEventCallback',\n            'registerFocusEventCallback',\n            'fillDeviceOrientationEventData',\n            'registerDeviceOrientationEventCallback',\n            'fillDeviceMotionEventData',\n            'registerDeviceMotionEventCallback',\n            'screenOrientation',\n            'fillOrientationChangeEventData',\n            'registerOrientationChangeEventCallback',\n            'fillFullscreenChangeEventData',\n            'registerFullscreenChangeEventCallback',\n            'JSEvents_requestFullscreen',\n            'JSEvents_resizeCanvasForFullscreen',\n            'registerRestoreOldStyle',\n            'hideEverythingExceptGivenElement',\n            'restoreHiddenElements',\n            'setLetterbox',\n            'softFullscreenResizeWebGLRenderTarget',\n            'doRequestFullscreen',\n            'fillPointerlockChangeEventData',\n            'registerPointerlockChangeEventCallback',\n            'registerPointerlockErrorEventCallback',\n            'requestPointerLock',\n            'fillVisibilityChangeEventData',\n            'registerVisibilityChangeEventCallback',\n            'registerTouchEventCallback',\n            'fillGamepadEventData',\n            'registerGamepadEventCallback',\n            'registerBeforeUnloadEventCallback',\n            'fillBatteryEventData',\n            'battery',\n            'registerBatteryEventCallback',\n            'setCanvasElementSize',\n            'getCanvasElementSize',\n            'jsStackTrace',\n            'stackTrace',\n            'checkWasiClock',\n            'wasiRightsToMuslOFlags',\n            'wasiOFlagsToMuslOFlags',\n            'createDyncallWrapper',\n            'setImmediateWrapped',\n            'clearImmediateWrapped',\n            'polyfillSetImmediate',\n            'getPromise',\n            'makePromise',\n            'idsToPromises',\n            'makePromiseCallback',\n            'setMainLoop',\n            'getSocketFromFD',\n            'getSocketAddress',\n            '_setNetworkCallback',\n            'heapObjectForWebGLType',\n            'heapAccessShiftForWebGLHeap',\n            'webgl_enable_ANGLE_instanced_arrays',\n            'webgl_enable_OES_vertex_array_object',\n            'webgl_enable_WEBGL_draw_buffers',\n            'webgl_enable_WEBGL_multi_draw',\n            'emscriptenWebGLGet',\n            'computeUnpackAlignedImageSize',\n            'colorChannelsInGlTextureFormat',\n            'emscriptenWebGLGetTexPixelData',\n            '__glGenObject',\n            'emscriptenWebGLGetUniform',\n            'webglGetUniformLocation',\n            'webglPrepareUniformLocationsBeforeFirstUse',\n            'webglGetLeftBracePos',\n            'emscriptenWebGLGetVertexAttrib',\n            '__glGetActiveAttribOrUniform',\n            'writeGLArray',\n            'registerWebGlEventCallback',\n            'runAndAbortIfError',\n            'SDL_unicode',\n            'SDL_ttfContext',\n            'SDL_audio',\n            'GLFW_Window',\n            'ALLOC_NORMAL',\n            'ALLOC_STACK',\n            'allocate',\n            'writeStringToMemory',\n            'writeAsciiToMemory',\n        ];\n        missingLibrarySymbols.forEach(missingLibrarySymbol);\n        var unexportedSymbols = [\n            'run',\n            'addOnPreRun',\n            'addOnInit',\n            'addOnPreMain',\n            'addOnExit',\n            'addOnPostRun',\n            'addRunDependency',\n            'removeRunDependency',\n            'FS_createFolder',\n            'FS_createPath',\n            'FS_createDataFile',\n            'FS_createLazyFile',\n            'FS_createLink',\n            'FS_createDevice',\n            'FS_readFile',\n            'FS_unlink',\n            'out',\n            'err',\n            'callMain',\n            'abort',\n            'keepRuntimeAlive',\n            'wasmMemory',\n            'wasmTable',\n            'wasmExports',\n            'stackAlloc',\n            'stackSave',\n            'stackRestore',\n            'getTempRet0',\n            'setTempRet0',\n            'writeStackCookie',\n            'checkStackCookie',\n            'convertI32PairToI53Checked',\n            'ptrToString',\n            'zeroMemory',\n            'getHeapMax',\n            'abortOnCannotGrowMemory',\n            'ENV',\n            'MONTH_DAYS_REGULAR',\n            'MONTH_DAYS_LEAP',\n            'MONTH_DAYS_REGULAR_CUMULATIVE',\n            'MONTH_DAYS_LEAP_CUMULATIVE',\n            'isLeapYear',\n            'arraySum',\n            'addDays',\n            'ERRNO_CODES',\n            'ERRNO_MESSAGES',\n            'setErrNo',\n            'DNS',\n            'Protocols',\n            'Sockets',\n            'initRandomFill',\n            'randomFill',\n            'timers',\n            'warnOnce',\n            'UNWIND_CACHE',\n            'readEmAsmArgsArray',\n            'getExecutableName',\n            'asyncLoad',\n            'alignMemory',\n            'mmapAlloc',\n            'getCFunc',\n            'freeTableIndexes',\n            'functionsInTableMap',\n            'setValue',\n            'getValue',\n            'PATH',\n            'PATH_FS',\n            'UTF8Decoder',\n            'UTF8ArrayToString',\n            'UTF8ToString',\n            'stringToUTF8Array',\n            'stringToUTF8',\n            'lengthBytesUTF8',\n            'intArrayFromString',\n            'stringToAscii',\n            'UTF16Decoder',\n            'stringToUTF8OnStack',\n            'writeArrayToMemory',\n            'JSEvents',\n            'specialHTMLTargets',\n            'currentFullscreenStrategy',\n            'restoreOldWindowedStyle',\n            'demangle',\n            'demangleAll',\n            'ExitStatus',\n            'getEnvStrings',\n            'doReadv',\n            'doWritev',\n            'promiseMap',\n            'uncaughtExceptionCount',\n            'exceptionLast',\n            'exceptionCaught',\n            'ExceptionInfo',\n            'findMatchingCatch',\n            'getExceptionMessageCommon',\n            'incrementExceptionRefcount',\n            'decrementExceptionRefcount',\n            'getExceptionMessage',\n            'Browser',\n            'wget',\n            'SYSCALLS',\n            'preloadPlugins',\n            'FS_createPreloadedFile',\n            'FS_modeStringToFlags',\n            'FS_getMode',\n            'FS_stdin_getChar_buffer',\n            'FS_stdin_getChar',\n            'FS',\n            'MEMFS',\n            'TTY',\n            'PIPEFS',\n            'SOCKFS',\n            'tempFixedLengthArray',\n            'miniTempWebGLFloatBuffers',\n            'miniTempWebGLIntBuffers',\n            'GL',\n            'emscripten_webgl_power_preferences',\n            'AL',\n            'GLUT',\n            'EGL',\n            'GLEW',\n            'IDBStore',\n            'SDL',\n            'SDL_gfx',\n            'GLFW',\n            'allocateUTF8',\n            'allocateUTF8OnStack',\n        ];\n        unexportedSymbols.forEach(unexportedRuntimeSymbol);\n        var calledRun;\n        dependenciesFulfilled = function runCaller() {\n            // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n            if (!calledRun)\n                run();\n            if (!calledRun)\n                dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n        };\n        function stackCheckInit() {\n            // This is normally called automatically during __wasm_call_ctors but need to\n            // get these values before even running any of the ctors so we call it redundantly\n            // here.\n            _emscripten_stack_init();\n            // TODO(sbc): Move writeStackCookie to native to to avoid this.\n            writeStackCookie();\n        }\n        function run() {\n            if (runDependencies > 0) {\n                return;\n            }\n            stackCheckInit();\n            preRun();\n            // a preRun added a dependency, run will be called later\n            if (runDependencies > 0) {\n                return;\n            }\n            function doRun() {\n                // run may have just been called through dependencies being fulfilled just in this very frame,\n                // or while the async setStatus time below was happening\n                if (calledRun)\n                    return;\n                calledRun = true;\n                Module['calledRun'] = true;\n                if (ABORT)\n                    return;\n                initRuntime();\n                readyPromiseResolve(Module);\n                if (Module['onRuntimeInitialized'])\n                    Module['onRuntimeInitialized']();\n                assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n                postRun();\n            }\n            if (Module['setStatus']) {\n                Module['setStatus']('Running...');\n                setTimeout(function () {\n                    setTimeout(function () {\n                        Module['setStatus']('');\n                    }, 1);\n                    doRun();\n                }, 1);\n            }\n            else {\n                doRun();\n            }\n            checkStackCookie();\n        }\n        function checkUnflushedContent() {\n            // Compiler settings do not allow exiting the runtime, so flushing\n            // the streams is not possible. but in ASSERTIONS mode we check\n            // if there was something to flush, and if so tell the user they\n            // should request that the runtime be exitable.\n            // Normally we would not even include flush() at all, but in ASSERTIONS\n            // builds we do so just for this check, and here we see if there is any\n            // content to flush, that is, we check if there would have been\n            // something a non-ASSERTIONS build would have not seen.\n            // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\n            // mode (which has its own special function for this; otherwise, all\n            // the code is inside libc)\n            var oldOut = out;\n            var oldErr = err;\n            var has = false;\n            out = err = (x) => {\n                has = true;\n            };\n            try { // it doesn't matter if it fails\n                _fflush(0);\n                // also flush in the JS FS layer\n                ['stdout', 'stderr'].forEach(function (name) {\n                    var info = FS.analyzePath('/dev/' + name);\n                    if (!info)\n                        return;\n                    var stream = info.object;\n                    var rdev = stream.rdev;\n                    var tty = TTY.ttys[rdev];\n                    if (tty && tty.output && tty.output.length) {\n                        has = true;\n                    }\n                });\n            }\n            catch (e) { }\n            out = oldOut;\n            err = oldErr;\n            if (has) {\n                warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.');\n            }\n        }\n        if (Module['preInit']) {\n            if (typeof Module['preInit'] == 'function')\n                Module['preInit'] = [Module['preInit']];\n            while (Module['preInit'].length > 0) {\n                Module['preInit'].pop()();\n            }\n        }\n        run();\n        // end include: postamble.js\n        return moduleArg.ready;\n    });\n})();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Module);\n//# sourceMappingURL=src2json.js.map\n\n//# sourceURL=webpack:///./out/lib/src2json.js?");

/***/ }),

/***/ "./out/s2j/msg.js":
/*!************************!*\
  !*** ./out/s2j/msg.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RequestMessage: () => (/* binding */ RequestMessage)\n/* harmony export */ });\nvar RequestMessage;\n(function (RequestMessage) {\n    RequestMessage[\"MSG_REQUIRE_AST\"] = \"MSG_REQUIRE_AST\";\n    RequestMessage[\"MSG_REQUIRE_TOKENS\"] = \"MSG_REQUIRE_TOKENS\";\n})(RequestMessage || (RequestMessage = {}));\n\n//# sourceMappingURL=msg.js.map\n\n//# sourceURL=webpack:///./out/s2j/msg.js?");

/***/ }),

/***/ "./out/s2j/src2json_worker.js":
/*!************************************!*\
  !*** ./out/s2j/src2json_worker.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_src2json_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/src2json.js */ \"./out/lib/src2json.js\");\n/* harmony import */ var _msg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./msg.js */ \"./out/s2j/msg.js\");\n/// <reference types=\"emscripten\" />\n\n\nconst Module = _lib_src2json_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\nconst msgQueue = [];\n(async () => {\n    globalThis.onmessage = (ev) => {\n        console.time(`msg queueing ${ev.data.jobID}`);\n        msgQueue.push(ev.data);\n    };\n    const textCapture = {\n        stdout: \"\",\n        stderr: \"\",\n    };\n    const onInitalized = (mod) => {\n        const emscripten_main = mod.cwrap(\"emscripten_main\", \"number\", [\"string\"]);\n        const callSrc2JSON = (args) => {\n            let arg = \"\";\n            for (let i = 0; i < args.length; i++) {\n                if (i !== 0)\n                    arg += \" \";\n                arg += encodeURIComponent(args[i]);\n            }\n            return emscripten_main(arg);\n        };\n        const requireSourceCode = (msg, jobID, code) => {\n            if (code === undefined) {\n                const res = {\n                    msg: msg,\n                    jobID: jobID,\n                    err: new Error(\"sourceCode is undefined\"),\n                    code: -1,\n                };\n                postMessage(res);\n                return false;\n            }\n            return true;\n        };\n        const handleMessage = (data) => {\n            const e = data;\n            if (e.msg === _msg_js__WEBPACK_IMPORTED_MODULE_1__.RequestMessage.MSG_REQUIRE_AST) {\n                if (!requireSourceCode(e.msg, e.jobID, e.sourceCode))\n                    return;\n                const id = e.jobID;\n                textCapture.stdout = \"\";\n                textCapture.stderr = \"\";\n                const code = callSrc2JSON([\n                    \"src2json\",\n                    \"--argv\",\n                    e.sourceCode,\n                    \"--no-color\",\n                    \"--print-json\",\n                    \"--print-on-error\",\n                ]);\n                const result = {\n                    msg: e.msg,\n                    stdout: textCapture.stdout,\n                    stderr: textCapture.stderr,\n                    code,\n                    jobID: id,\n                };\n                textCapture.stdout = \"\";\n                textCapture.stderr = \"\";\n                postMessage(result);\n            }\n            else if (e.msg === _msg_js__WEBPACK_IMPORTED_MODULE_1__.RequestMessage.MSG_REQUIRE_TOKENS) {\n                if (!requireSourceCode(e.msg, e.jobID, e.sourceCode))\n                    return;\n                const id = e.jobID;\n                textCapture.stdout = \"\";\n                textCapture.stderr = \"\";\n                const code = callSrc2JSON([\n                    \"src2json\",\n                    \"--argv\",\n                    e.sourceCode,\n                    \"--no-color\",\n                    \"--print-tokens\",\n                    \"--print-on-error\",\n                    \"--lexer\",\n                ]);\n                const result = {\n                    msg: e.msg,\n                    stdout: textCapture.stdout,\n                    stderr: textCapture.stderr,\n                    code,\n                    jobID: id,\n                };\n                textCapture.stdout = \"\";\n                textCapture.stderr = \"\";\n                postMessage(result);\n            }\n            else {\n                const errRes = {\n                    msg: e.msg,\n                    jobID: e.jobID,\n                    err: new Error(\"unknown message type\"),\n                    code: -1\n                };\n                postMessage(errRes);\n            }\n        };\n        const handlingWithTimer = (job) => {\n            console.time(`msg handling ${job.jobID}`);\n            handleMessage(job);\n            console.timeEnd(`msg handling ${job.jobID}`);\n        };\n        for (let i = 0; i < msgQueue.length; i++) {\n            console.timeEnd(`msg queueing ${msgQueue[i].jobID}`);\n            handlingWithTimer(msgQueue[i]);\n        }\n        globalThis.onmessage = (ev) => {\n            handlingWithTimer(ev.data);\n        };\n    };\n    const mod = Module({\n        print: (text) => {\n            textCapture.stdout += text;\n        },\n        printErr: (text) => {\n            textCapture.stderr += text;\n        },\n    }).then((mod) => {\n        console.log(\"src2json worker initialized\");\n        onInitalized(mod);\n        return mod;\n    });\n    globalThis.setTimeout(() => {\n        console.log(mod);\n    }, 10);\n})();\n//# sourceMappingURL=src2json_worker.js.map\n\n//# sourceURL=webpack:///./out/s2j/src2json_worker.js?");

/***/ }),

/***/ "./out/lib/src2json.wasm":
/*!*******************************!*\
  !*** ./out/lib/src2json.wasm ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"src2json.wasm\";\n\n//# sourceURL=webpack:///./out/lib/src2json.wasm?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = self.location + "";
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			"out_s2j_src2json_worker_js": 1
/******/ 		};
/******/ 		
/******/ 		// no chunk install function needed
/******/ 		// no chunk loading
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./out/s2j/src2json_worker.js");
/******/ 	
/******/ })()
;