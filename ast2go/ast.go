// Code generated by gen_ast2go; DO NOT EDIT.

package ast2go

import (
	"encoding/json"
	"fmt"
)

type Node interface {
	isNode()
}

type Expr interface {
	isExpr()
	Node
}

type Literal interface {
	isLiteral()
	Expr
}

type Stmt interface {
	isStmt()
	Node
}

type Member interface {
	isMember()
	Stmt
}

type Type interface {
	isType()
	Node
}

type Program struct {
	StructType  *StructType
	Elements    []Node
	GlobalScope *Scope
	Loc         Loc
}

func (n *Program) isNode() {}

type Binary struct {
	ExprType Type
	Op       BinaryOp
	Left     Expr
	Right    Expr
	Loc      Loc
}

func (n *Binary) isExpr() {}

func (n *Binary) isNode() {}

type Unary struct {
	ExprType Type
	Op       UnaryOp
	Expr     Expr
	Loc      Loc
}

func (n *Unary) isExpr() {}

func (n *Unary) isNode() {}

type Cond struct {
	ExprType Type
	Cond     Expr
	Then     Expr
	ElsLoc   Loc
	Els      Expr
	Loc      Loc
}

func (n *Cond) isExpr() {}

func (n *Cond) isNode() {}

type Ident struct {
	ExprType Type
	Ident    string
	Usage    IdentUsage
	Base     Node
	Scope    *Scope
	Loc      Loc
}

func (n *Ident) isExpr() {}

func (n *Ident) isNode() {}

type Call struct {
	ExprType     Type
	Callee       Expr
	RawArguments Expr
	Arguments    []Expr
	EndLoc       Loc
	Loc          Loc
}

func (n *Call) isExpr() {}

func (n *Call) isNode() {}

type If struct {
	ExprType Type
	Cond     Expr
	Then     *IndentScope
	Els      Node
	Loc      Loc
}

func (n *If) isExpr() {}

func (n *If) isNode() {}

type MemberAccess struct {
	ExprType  Type
	Target    Expr
	Member    string
	MemberLoc Loc
	Loc       Loc
}

func (n *MemberAccess) isExpr() {}

func (n *MemberAccess) isNode() {}

type Paren struct {
	ExprType Type
	Expr     Expr
	EndLoc   Loc
	Loc      Loc
}

func (n *Paren) isExpr() {}

func (n *Paren) isNode() {}

type Index struct {
	ExprType Type
	Expr     Expr
	Index    Expr
	EndLoc   Loc
	Loc      Loc
}

func (n *Index) isExpr() {}

func (n *Index) isNode() {}

type Match struct {
	ExprType Type
	Cond     Expr
	Branch   []*MatchBranch
	Scope    *Scope
	Loc      Loc
}

func (n *Match) isExpr() {}

func (n *Match) isNode() {}

type Range struct {
	ExprType Type
	Op       BinaryOp
	Start    Expr
	End      Expr
	Loc      Loc
}

func (n *Range) isExpr() {}

func (n *Range) isNode() {}

type TmpVar struct {
	ExprType Type
	TmpVar   uint64
	Loc      Loc
}

func (n *TmpVar) isExpr() {}

func (n *TmpVar) isNode() {}

type BlockExpr struct {
	ExprType Type
	Calls    []Node
	Expr     Expr
	Loc      Loc
}

func (n *BlockExpr) isExpr() {}

func (n *BlockExpr) isNode() {}

type Import struct {
	ExprType   Type
	Path       string
	Base       *Call
	ImportDesc *Program
	Loc        Loc
}

func (n *Import) isExpr() {}

func (n *Import) isNode() {}

type IntLiteral struct {
	ExprType Type
	Value    string
	Loc      Loc
}

func (n *IntLiteral) isLiteral() {}

func (n *IntLiteral) isExpr() {}

func (n *IntLiteral) isNode() {}

type BoolLiteral struct {
	ExprType Type
	Value    bool
	Loc      Loc
}

func (n *BoolLiteral) isLiteral() {}

func (n *BoolLiteral) isExpr() {}

func (n *BoolLiteral) isNode() {}

type StrLiteral struct {
	ExprType Type
	Value    string
	Loc      Loc
}

func (n *StrLiteral) isLiteral() {}

func (n *StrLiteral) isExpr() {}

func (n *StrLiteral) isNode() {}

type Input struct {
	ExprType Type
	Loc      Loc
}

func (n *Input) isLiteral() {}

func (n *Input) isExpr() {}

func (n *Input) isNode() {}

type Output struct {
	ExprType Type
	Loc      Loc
}

func (n *Output) isLiteral() {}

func (n *Output) isExpr() {}

func (n *Output) isNode() {}

type Config struct {
	ExprType Type
	Loc      Loc
}

func (n *Config) isLiteral() {}

func (n *Config) isExpr() {}

func (n *Config) isNode() {}

type Loop struct {
	Init Expr
	Cond Expr
	Step Expr
	Body *IndentScope
	Loc  Loc
}

func (n *Loop) isStmt() {}

func (n *Loop) isNode() {}

type IndentScope struct {
	Elements []Node
	Scope    *Scope
	Loc      Loc
}

func (n *IndentScope) isStmt() {}

func (n *IndentScope) isNode() {}

type MatchBranch struct {
	Cond   Expr
	SymLoc Loc
	Then   Node
	Loc    Loc
}

func (n *MatchBranch) isStmt() {}

func (n *MatchBranch) isNode() {}

type Return struct {
	Expr Expr
	Loc  Loc
}

func (n *Return) isStmt() {}

func (n *Return) isNode() {}

type Break struct {
	Loc Loc
}

func (n *Break) isStmt() {}

func (n *Break) isNode() {}

type Continue struct {
	Loc Loc
}

func (n *Continue) isStmt() {}

func (n *Continue) isNode() {}

type Assert struct {
	Cond *Binary
	Loc  Loc
}

func (n *Assert) isStmt() {}

func (n *Assert) isNode() {}

type ImplicitYield struct {
	Expr Expr
	Loc  Loc
}

func (n *ImplicitYield) isStmt() {}

func (n *ImplicitYield) isNode() {}

type Field struct {
	Ident        *Ident
	ColonLoc     Loc
	FieldType    Type
	RawArguments Expr
	Arguments    []Expr
	Belong       *Format
	Loc          Loc
}

func (n *Field) isMember() {}

func (n *Field) isStmt() {}

func (n *Field) isNode() {}

type Format struct {
	IsEnum     bool
	Ident      *Ident
	Body       *IndentScope
	Belong     *Format
	StructType *StructType
	Loc        Loc
}

func (n *Format) isMember() {}

func (n *Format) isStmt() {}

func (n *Format) isNode() {}

type Function struct {
	Ident      *Ident
	Parameters []*Field
	ReturnType Type
	Belong     *Format
	Body       *IndentScope
	FuncType   *FunctionType
	Loc        Loc
}

func (n *Function) isMember() {}

func (n *Function) isStmt() {}

func (n *Function) isNode() {}

type IntType struct {
	BitSize  uint64
	Endian   Endian
	IsSigned bool
	Loc      Loc
}

func (n *IntType) isType() {}

func (n *IntType) isNode() {}

type IdentType struct {
	Ident *Ident
	Base  *Format
	Loc   Loc
}

func (n *IdentType) isType() {}

func (n *IdentType) isNode() {}

type IntLiteralType struct {
	Base *IntLiteral
	Loc  Loc
}

func (n *IntLiteralType) isType() {}

func (n *IntLiteralType) isNode() {}

type StrLiteralType struct {
	Base *StrLiteral
	Loc  Loc
}

func (n *StrLiteralType) isType() {}

func (n *StrLiteralType) isNode() {}

type VoidType struct {
	Loc Loc
}

func (n *VoidType) isType() {}

func (n *VoidType) isNode() {}

type BoolType struct {
	Loc Loc
}

func (n *BoolType) isType() {}

func (n *BoolType) isNode() {}

type ArrayType struct {
	EndLoc   Loc
	BaseType Type
	Length   Expr
	Loc      Loc
}

func (n *ArrayType) isType() {}

func (n *ArrayType) isNode() {}

type FunctionType struct {
	ReturnType Type
	Parameters []Type
	Loc        Loc
}

func (n *FunctionType) isType() {}

func (n *FunctionType) isNode() {}

type StructType struct {
	Fields []Member
	Loc    Loc
}

func (n *StructType) isType() {}

func (n *StructType) isNode() {}

type UnionType struct {
	Fields []*StructType
	Loc    Loc
}

func (n *UnionType) isType() {}

func (n *UnionType) isNode() {}

type Cast struct {
	ExprType Type
	Base     *Call
	Expr     Expr
	Loc      Loc
}

func (n *Cast) isExpr() {}

func (n *Cast) isNode() {}

type UnaryOp int

const (
	UnaryOpNot       UnaryOp = 0
	UnaryOpMinusSign UnaryOp = 1
)

func (n UnaryOp) String() string {
	switch n {
	case UnaryOpNot:
		return "!"
	case UnaryOpMinusSign:
		return "-"
	default:
		return fmt.Sprintf("UnaryOp(%d)", n)
	}
}

func (n UnaryOp) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "!":
		n = UnaryOpNot
	case "-":
		n = UnaryOpMinusSign
	default:
		return fmt.Errorf("unknown UnaryOp: %q", tmp)
	}
	return nil
}

type BinaryOp int

const (
	BinaryOpMul                  BinaryOp = 0
	BinaryOpDiv                  BinaryOp = 1
	BinaryOpMod                  BinaryOp = 2
	BinaryOpLeftArithmeticShift  BinaryOp = 3
	BinaryOpRightArithmeticShift BinaryOp = 4
	BinaryOpLeftLogicalShift     BinaryOp = 5
	BinaryOpRightLogicalShift    BinaryOp = 6
	BinaryOpBitAnd               BinaryOp = 7
	BinaryOpAdd                  BinaryOp = 8
	BinaryOpSub                  BinaryOp = 9
	BinaryOpBitOr                BinaryOp = 10
	BinaryOpBitXor               BinaryOp = 11
	BinaryOpEqual                BinaryOp = 12
	BinaryOpNotEqual             BinaryOp = 13
	BinaryOpLess                 BinaryOp = 14
	BinaryOpLessOrEq             BinaryOp = 15
	BinaryOpGrater               BinaryOp = 16
	BinaryOpGraterOrEq           BinaryOp = 17
	BinaryOpLogicalAnd           BinaryOp = 18
	BinaryOpLogicalOr            BinaryOp = 19
	BinaryOpCondOp1              BinaryOp = 20
	BinaryOpCondOp2              BinaryOp = 21
	BinaryOpRangeExclusive       BinaryOp = 22
	BinaryOpRangeInclusive       BinaryOp = 23
	BinaryOpAssign               BinaryOp = 24
	BinaryOpDefineAssign         BinaryOp = 25
	BinaryOpConstAssign          BinaryOp = 26
	BinaryOpAddAssign            BinaryOp = 27
	BinaryOpSubAssign            BinaryOp = 28
	BinaryOpMulAssign            BinaryOp = 29
	BinaryOpDivAssign            BinaryOp = 30
	BinaryOpModAssign            BinaryOp = 31
	BinaryOpLeftShiftAssign      BinaryOp = 32
	BinaryOpRightShiftAssign     BinaryOp = 33
	BinaryOpBitAndAssign         BinaryOp = 34
	BinaryOpBitOrAssign          BinaryOp = 35
	BinaryOpBitXorAssign         BinaryOp = 36
	BinaryOpComma                BinaryOp = 37
)

func (n BinaryOp) String() string {
	switch n {
	case BinaryOpMul:
		return "*"
	case BinaryOpDiv:
		return "/"
	case BinaryOpMod:
		return "%"
	case BinaryOpLeftArithmeticShift:
		return "<<<"
	case BinaryOpRightArithmeticShift:
		return ">>>"
	case BinaryOpLeftLogicalShift:
		return "<<"
	case BinaryOpRightLogicalShift:
		return ">>"
	case BinaryOpBitAnd:
		return "&"
	case BinaryOpAdd:
		return "+"
	case BinaryOpSub:
		return "-"
	case BinaryOpBitOr:
		return "|"
	case BinaryOpBitXor:
		return "^"
	case BinaryOpEqual:
		return "=="
	case BinaryOpNotEqual:
		return "!="
	case BinaryOpLess:
		return "<"
	case BinaryOpLessOrEq:
		return "<="
	case BinaryOpGrater:
		return ">"
	case BinaryOpGraterOrEq:
		return ">="
	case BinaryOpLogicalAnd:
		return "&&"
	case BinaryOpLogicalOr:
		return "||"
	case BinaryOpCondOp1:
		return "if"
	case BinaryOpCondOp2:
		return "else"
	case BinaryOpRangeExclusive:
		return ".."
	case BinaryOpRangeInclusive:
		return "..="
	case BinaryOpAssign:
		return "="
	case BinaryOpDefineAssign:
		return ":="
	case BinaryOpConstAssign:
		return "::="
	case BinaryOpAddAssign:
		return "+="
	case BinaryOpSubAssign:
		return "-="
	case BinaryOpMulAssign:
		return "*="
	case BinaryOpDivAssign:
		return "/="
	case BinaryOpModAssign:
		return "%="
	case BinaryOpLeftShiftAssign:
		return "<<="
	case BinaryOpRightShiftAssign:
		return ">>="
	case BinaryOpBitAndAssign:
		return "&="
	case BinaryOpBitOrAssign:
		return "|="
	case BinaryOpBitXorAssign:
		return "^="
	case BinaryOpComma:
		return ","
	default:
		return fmt.Sprintf("BinaryOp(%d)", n)
	}
}

func (n BinaryOp) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "*":
		n = BinaryOpMul
	case "/":
		n = BinaryOpDiv
	case "%":
		n = BinaryOpMod
	case "<<<":
		n = BinaryOpLeftArithmeticShift
	case ">>>":
		n = BinaryOpRightArithmeticShift
	case "<<":
		n = BinaryOpLeftLogicalShift
	case ">>":
		n = BinaryOpRightLogicalShift
	case "&":
		n = BinaryOpBitAnd
	case "+":
		n = BinaryOpAdd
	case "-":
		n = BinaryOpSub
	case "|":
		n = BinaryOpBitOr
	case "^":
		n = BinaryOpBitXor
	case "==":
		n = BinaryOpEqual
	case "!=":
		n = BinaryOpNotEqual
	case "<":
		n = BinaryOpLess
	case "<=":
		n = BinaryOpLessOrEq
	case ">":
		n = BinaryOpGrater
	case ">=":
		n = BinaryOpGraterOrEq
	case "&&":
		n = BinaryOpLogicalAnd
	case "||":
		n = BinaryOpLogicalOr
	case "if":
		n = BinaryOpCondOp1
	case "else":
		n = BinaryOpCondOp2
	case "..":
		n = BinaryOpRangeExclusive
	case "..=":
		n = BinaryOpRangeInclusive
	case "=":
		n = BinaryOpAssign
	case ":=":
		n = BinaryOpDefineAssign
	case "::=":
		n = BinaryOpConstAssign
	case "+=":
		n = BinaryOpAddAssign
	case "-=":
		n = BinaryOpSubAssign
	case "*=":
		n = BinaryOpMulAssign
	case "/=":
		n = BinaryOpDivAssign
	case "%=":
		n = BinaryOpModAssign
	case "<<=":
		n = BinaryOpLeftShiftAssign
	case ">>=":
		n = BinaryOpRightShiftAssign
	case "&=":
		n = BinaryOpBitAndAssign
	case "|=":
		n = BinaryOpBitOrAssign
	case "^=":
		n = BinaryOpBitXorAssign
	case ",":
		n = BinaryOpComma
	default:
		return fmt.Errorf("unknown BinaryOp: %q", tmp)
	}
	return nil
}

type IdentUsage int

const (
	IdentUsageUnknown        IdentUsage = 0
	IdentUsageReference      IdentUsage = 1
	IdentUsageDefineVariable IdentUsage = 2
	IdentUsageDefineConst    IdentUsage = 3
	IdentUsageDefineField    IdentUsage = 4
	IdentUsageDefineFormat   IdentUsage = 5
	IdentUsageDefineFn       IdentUsage = 6
	IdentUsageReferenceType  IdentUsage = 7
)

func (n IdentUsage) String() string {
	switch n {
	case IdentUsageUnknown:
		return "unknown"
	case IdentUsageReference:
		return "reference"
	case IdentUsageDefineVariable:
		return "define_variable"
	case IdentUsageDefineConst:
		return "define_const"
	case IdentUsageDefineField:
		return "define_field"
	case IdentUsageDefineFormat:
		return "define_format"
	case IdentUsageDefineFn:
		return "define_fn"
	case IdentUsageReferenceType:
		return "reference_type"
	default:
		return fmt.Sprintf("IdentUsage(%d)", n)
	}
}

func (n IdentUsage) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "unknown":
		n = IdentUsageUnknown
	case "reference":
		n = IdentUsageReference
	case "define_variable":
		n = IdentUsageDefineVariable
	case "define_const":
		n = IdentUsageDefineConst
	case "define_field":
		n = IdentUsageDefineField
	case "define_format":
		n = IdentUsageDefineFormat
	case "define_fn":
		n = IdentUsageDefineFn
	case "reference_type":
		n = IdentUsageReferenceType
	default:
		return fmt.Errorf("unknown IdentUsage: %q", tmp)
	}
	return nil
}

type Endian int

const (
	EndianUnspec Endian = 0
	EndianBig    Endian = 1
	EndianLittle Endian = 2
)

func (n Endian) String() string {
	switch n {
	case EndianUnspec:
		return "unspec"
	case EndianBig:
		return "big"
	case EndianLittle:
		return "little"
	default:
		return fmt.Sprintf("Endian(%d)", n)
	}
}

func (n Endian) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "unspec":
		n = EndianUnspec
	case "big":
		n = EndianBig
	case "little":
		n = EndianLittle
	default:
		return fmt.Errorf("unknown Endian: %q", tmp)
	}
	return nil
}

type TokenTag int

const (
	TokenTagIndent      TokenTag = 0
	TokenTagSpace       TokenTag = 1
	TokenTagLine        TokenTag = 2
	TokenTagPunct       TokenTag = 3
	TokenTagIntLiteral  TokenTag = 4
	TokenTagBoolLiteral TokenTag = 5
	TokenTagStrLiteral  TokenTag = 6
	TokenTagKeyword     TokenTag = 7
	TokenTagIdent       TokenTag = 8
	TokenTagComment     TokenTag = 9
	TokenTagError       TokenTag = 10
	TokenTagUnknown     TokenTag = 11
)

func (n TokenTag) String() string {
	switch n {
	case TokenTagIndent:
		return "indent"
	case TokenTagSpace:
		return "space"
	case TokenTagLine:
		return "line"
	case TokenTagPunct:
		return "punct"
	case TokenTagIntLiteral:
		return "int_literal"
	case TokenTagBoolLiteral:
		return "bool_literal"
	case TokenTagStrLiteral:
		return "str_literal"
	case TokenTagKeyword:
		return "keyword"
	case TokenTagIdent:
		return "ident"
	case TokenTagComment:
		return "comment"
	case TokenTagError:
		return "error"
	case TokenTagUnknown:
		return "unknown"
	default:
		return fmt.Sprintf("TokenTag(%d)", n)
	}
}

func (n TokenTag) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "indent":
		n = TokenTagIndent
	case "space":
		n = TokenTagSpace
	case "line":
		n = TokenTagLine
	case "punct":
		n = TokenTagPunct
	case "int_literal":
		n = TokenTagIntLiteral
	case "bool_literal":
		n = TokenTagBoolLiteral
	case "str_literal":
		n = TokenTagStrLiteral
	case "keyword":
		n = TokenTagKeyword
	case "ident":
		n = TokenTagIdent
	case "comment":
		n = TokenTagComment
	case "error":
		n = TokenTagError
	case "unknown":
		n = TokenTagUnknown
	default:
		return fmt.Errorf("unknown TokenTag: %q", tmp)
	}
	return nil
}

type Scope struct {
	Prev   *Scope
	Next   *Scope
	Branch *Scope
	Ident  []Node
}

type Loc struct {
	Pos  Pos    `json:"pos"`
	File uint64 `json:"file"`
	Line uint64 `json:"line"`
	Col  uint64 `json:"col"`
}

type Pos struct {
	Begin uint64 `json:"begin"`
	End   uint64 `json:"end"`
}

type Token struct {
	Tag   TokenTag `json:"tag"`
	Token string   `json:"token"`
	Loc   Loc      `json:"loc"`
}

type SrcErrorEntry struct {
	Msg  string `json:"msg"`
	File string `json:"file"`
	Loc  Loc    `json:"loc"`
	Src  string `json:"src"`
	Warn bool   `json:"warn"`
}

type SrcError struct {
	Errs []SrcErrorEntry `json:"errs"`
}

type astConstructor struct {
	node  []Node
	scope []*Scope
}
type rawNode struct {
	NodeType string `json:"node_type"`
	Loc      Loc    `json:"loc"`
	Body     json.RawMessage
}
type rawScope struct {
	Prev   *uintptr  `json:"prev"`
	Next   *uintptr  `json:"next"`
	Branch *uintptr  `json:"branch"`
	Ident  []uintptr `json:"ident"`
}
type AST struct {
	*Program
}

func (n *AST) UnmarshalJSON(data []byte) error {
	var tmp astConstructor
	prog, err := tmp.unmarshal(data)
	if err != nil {
		return err
	}
	n.Program = prog
	return nil
}
func (n *astConstructor) unmarshal(data []byte) (prog *Program, err error) {
	defer func() {
		if r := recover(); r != nil {
			err = fmt.Errorf("%v", r)
		}
	}()
	var aux struct {
		Node  []rawNode   `json:"node"`
		Scope []*rawScope `json:"scope"`
	}
	if err = json.Unmarshal(data, &aux); err != nil {
		return nil, err
	}
	n.node = make([]Node, len(aux.Node))
	for _, raw := range aux.Node {
		switch raw.NodeType {
		case "program":
			n.node = append(n.node, &Program{Loc: raw.Loc})
		case "binary":
			n.node = append(n.node, &Binary{Loc: raw.Loc})
		case "unary":
			n.node = append(n.node, &Unary{Loc: raw.Loc})
		case "cond":
			n.node = append(n.node, &Cond{Loc: raw.Loc})
		case "ident":
			n.node = append(n.node, &Ident{Loc: raw.Loc})
		case "call":
			n.node = append(n.node, &Call{Loc: raw.Loc})
		case "if":
			n.node = append(n.node, &If{Loc: raw.Loc})
		case "member_access":
			n.node = append(n.node, &MemberAccess{Loc: raw.Loc})
		case "paren":
			n.node = append(n.node, &Paren{Loc: raw.Loc})
		case "index":
			n.node = append(n.node, &Index{Loc: raw.Loc})
		case "match":
			n.node = append(n.node, &Match{Loc: raw.Loc})
		case "range":
			n.node = append(n.node, &Range{Loc: raw.Loc})
		case "tmp_var":
			n.node = append(n.node, &TmpVar{Loc: raw.Loc})
		case "block_expr":
			n.node = append(n.node, &BlockExpr{Loc: raw.Loc})
		case "import":
			n.node = append(n.node, &Import{Loc: raw.Loc})
		case "int_literal":
			n.node = append(n.node, &IntLiteral{Loc: raw.Loc})
		case "bool_literal":
			n.node = append(n.node, &BoolLiteral{Loc: raw.Loc})
		case "str_literal":
			n.node = append(n.node, &StrLiteral{Loc: raw.Loc})
		case "input":
			n.node = append(n.node, &Input{Loc: raw.Loc})
		case "output":
			n.node = append(n.node, &Output{Loc: raw.Loc})
		case "config":
			n.node = append(n.node, &Config{Loc: raw.Loc})
		case "loop":
			n.node = append(n.node, &Loop{Loc: raw.Loc})
		case "indent_scope":
			n.node = append(n.node, &IndentScope{Loc: raw.Loc})
		case "match_branch":
			n.node = append(n.node, &MatchBranch{Loc: raw.Loc})
		case "return":
			n.node = append(n.node, &Return{Loc: raw.Loc})
		case "break":
			n.node = append(n.node, &Break{Loc: raw.Loc})
		case "continue":
			n.node = append(n.node, &Continue{Loc: raw.Loc})
		case "assert":
			n.node = append(n.node, &Assert{Loc: raw.Loc})
		case "implicit_yield":
			n.node = append(n.node, &ImplicitYield{Loc: raw.Loc})
		case "field":
			n.node = append(n.node, &Field{Loc: raw.Loc})
		case "format":
			n.node = append(n.node, &Format{Loc: raw.Loc})
		case "function":
			n.node = append(n.node, &Function{Loc: raw.Loc})
		case "int_type":
			n.node = append(n.node, &IntType{Loc: raw.Loc})
		case "ident_type":
			n.node = append(n.node, &IdentType{Loc: raw.Loc})
		case "int_literal_type":
			n.node = append(n.node, &IntLiteralType{Loc: raw.Loc})
		case "str_literal_type":
			n.node = append(n.node, &StrLiteralType{Loc: raw.Loc})
		case "void_type":
			n.node = append(n.node, &VoidType{Loc: raw.Loc})
		case "bool_type":
			n.node = append(n.node, &BoolType{Loc: raw.Loc})
		case "array_type":
			n.node = append(n.node, &ArrayType{Loc: raw.Loc})
		case "function_type":
			n.node = append(n.node, &FunctionType{Loc: raw.Loc})
		case "struct_type":
			n.node = append(n.node, &StructType{Loc: raw.Loc})
		case "union_type":
			n.node = append(n.node, &UnionType{Loc: raw.Loc})
		case "cast":
			n.node = append(n.node, &Cast{Loc: raw.Loc})
		default:
			return nil, fmt.Errorf("unknown node type: %q", raw.NodeType)
		}
	}
	n.scope = make([]*Scope, len(aux.Scope))
	for i := range aux.Scope {
		n.scope[i] = &Scope{}
	}
	for i, raw := range aux.Node {
		switch raw.NodeType {
		case "program":
			v := n.node[i].(*Program)
			var tmp struct {
				StructType  *uintptr  `json:"struct_type"`
				Elements    []uintptr `json:"elements"`
				GlobalScope *uintptr  `json:"global_scope"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.StructType != nil {
				v.StructType = n.node[*tmp.StructType].(*StructType)
			}
			v.Elements = make([]Node, len(tmp.Elements))
			for j, k := range tmp.Elements {
				v.Elements[j] = n.node[k].(Node)
			}
			if tmp.GlobalScope != nil {
				v.GlobalScope = n.scope[*tmp.GlobalScope]
			}
		case "binary":
			v := n.node[i].(*Binary)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Op       BinaryOp `json:"op"`
				Left     *uintptr `json:"left"`
				Right    *uintptr `json:"right"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Op = tmp.Op
			if tmp.Left != nil {
				v.Left = n.node[*tmp.Left].(Expr)
			}
			if tmp.Right != nil {
				v.Right = n.node[*tmp.Right].(Expr)
			}
		case "unary":
			v := n.node[i].(*Unary)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Op       UnaryOp  `json:"op"`
				Expr     *uintptr `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Op = tmp.Op
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		case "cond":
			v := n.node[i].(*Cond)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Cond     *uintptr `json:"cond"`
				Then     *uintptr `json:"then"`
				ElsLoc   Loc      `json:"els_loc"`
				Els      *uintptr `json:"els"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			if tmp.Then != nil {
				v.Then = n.node[*tmp.Then].(Expr)
			}
			v.ElsLoc = tmp.ElsLoc
			if tmp.Els != nil {
				v.Els = n.node[*tmp.Els].(Expr)
			}
		case "ident":
			v := n.node[i].(*Ident)
			var tmp struct {
				ExprType *uintptr   `json:"expr_type"`
				Ident    string     `json:"ident"`
				Usage    IdentUsage `json:"usage"`
				Base     *uintptr   `json:"base"`
				Scope    *uintptr   `json:"scope"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Ident = tmp.Ident
			v.Usage = tmp.Usage
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(Node)
			}
			if tmp.Scope != nil {
				v.Scope = n.scope[*tmp.Scope]
			}
		case "call":
			v := n.node[i].(*Call)
			var tmp struct {
				ExprType     *uintptr  `json:"expr_type"`
				Callee       *uintptr  `json:"callee"`
				RawArguments *uintptr  `json:"raw_arguments"`
				Arguments    []uintptr `json:"arguments"`
				EndLoc       Loc       `json:"end_loc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.Callee != nil {
				v.Callee = n.node[*tmp.Callee].(Expr)
			}
			if tmp.RawArguments != nil {
				v.RawArguments = n.node[*tmp.RawArguments].(Expr)
			}
			v.Arguments = make([]Expr, len(tmp.Arguments))
			for j, k := range tmp.Arguments {
				v.Arguments[j] = n.node[k].(Expr)
			}
			v.EndLoc = tmp.EndLoc
		case "if":
			v := n.node[i].(*If)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Cond     *uintptr `json:"cond"`
				Then     *uintptr `json:"then"`
				Els      *uintptr `json:"els"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			if tmp.Then != nil {
				v.Then = n.node[*tmp.Then].(*IndentScope)
			}
			if tmp.Els != nil {
				v.Els = n.node[*tmp.Els].(Node)
			}
		case "member_access":
			v := n.node[i].(*MemberAccess)
			var tmp struct {
				ExprType  *uintptr `json:"expr_type"`
				Target    *uintptr `json:"target"`
				Member    string   `json:"member"`
				MemberLoc Loc      `json:"member_loc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.Target != nil {
				v.Target = n.node[*tmp.Target].(Expr)
			}
			v.Member = tmp.Member
			v.MemberLoc = tmp.MemberLoc
		case "paren":
			v := n.node[i].(*Paren)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Expr     *uintptr `json:"expr"`
				EndLoc   Loc      `json:"end_loc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
			v.EndLoc = tmp.EndLoc
		case "index":
			v := n.node[i].(*Index)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Expr     *uintptr `json:"expr"`
				Index    *uintptr `json:"index"`
				EndLoc   Loc      `json:"end_loc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
			if tmp.Index != nil {
				v.Index = n.node[*tmp.Index].(Expr)
			}
			v.EndLoc = tmp.EndLoc
		case "match":
			v := n.node[i].(*Match)
			var tmp struct {
				ExprType *uintptr  `json:"expr_type"`
				Cond     *uintptr  `json:"cond"`
				Branch   []uintptr `json:"branch"`
				Scope    *uintptr  `json:"scope"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			v.Branch = make([]*MatchBranch, len(tmp.Branch))
			for j, k := range tmp.Branch {
				v.Branch[j] = n.node[k].(*MatchBranch)
			}
			if tmp.Scope != nil {
				v.Scope = n.scope[*tmp.Scope]
			}
		case "range":
			v := n.node[i].(*Range)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Op       BinaryOp `json:"op"`
				Start    *uintptr `json:"start"`
				End      *uintptr `json:"end"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Op = tmp.Op
			if tmp.Start != nil {
				v.Start = n.node[*tmp.Start].(Expr)
			}
			if tmp.End != nil {
				v.End = n.node[*tmp.End].(Expr)
			}
		case "tmp_var":
			v := n.node[i].(*TmpVar)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				TmpVar   uint64   `json:"tmp_var"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.TmpVar = tmp.TmpVar
		case "block_expr":
			v := n.node[i].(*BlockExpr)
			var tmp struct {
				ExprType *uintptr  `json:"expr_type"`
				Calls    []uintptr `json:"calls"`
				Expr     *uintptr  `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Calls = make([]Node, len(tmp.Calls))
			for j, k := range tmp.Calls {
				v.Calls[j] = n.node[k].(Node)
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		case "import":
			v := n.node[i].(*Import)
			var tmp struct {
				ExprType   *uintptr `json:"expr_type"`
				Path       string   `json:"path"`
				Base       *uintptr `json:"base"`
				ImportDesc *uintptr `json:"import_desc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Path = tmp.Path
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*Call)
			}
			if tmp.ImportDesc != nil {
				v.ImportDesc = n.node[*tmp.ImportDesc].(*Program)
			}
		case "int_literal":
			v := n.node[i].(*IntLiteral)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Value    string   `json:"value"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Value = tmp.Value
		case "bool_literal":
			v := n.node[i].(*BoolLiteral)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Value    bool     `json:"value"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Value = tmp.Value
		case "str_literal":
			v := n.node[i].(*StrLiteral)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Value    string   `json:"value"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Value = tmp.Value
		case "input":
			v := n.node[i].(*Input)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
		case "output":
			v := n.node[i].(*Output)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
		case "config":
			v := n.node[i].(*Config)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
		case "loop":
			v := n.node[i].(*Loop)
			var tmp struct {
				Init *uintptr `json:"init"`
				Cond *uintptr `json:"cond"`
				Step *uintptr `json:"step"`
				Body *uintptr `json:"body"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Init != nil {
				v.Init = n.node[*tmp.Init].(Expr)
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			if tmp.Step != nil {
				v.Step = n.node[*tmp.Step].(Expr)
			}
			if tmp.Body != nil {
				v.Body = n.node[*tmp.Body].(*IndentScope)
			}
		case "indent_scope":
			v := n.node[i].(*IndentScope)
			var tmp struct {
				Elements []uintptr `json:"elements"`
				Scope    *uintptr  `json:"scope"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.Elements = make([]Node, len(tmp.Elements))
			for j, k := range tmp.Elements {
				v.Elements[j] = n.node[k].(Node)
			}
			if tmp.Scope != nil {
				v.Scope = n.scope[*tmp.Scope]
			}
		case "match_branch":
			v := n.node[i].(*MatchBranch)
			var tmp struct {
				Cond   *uintptr `json:"cond"`
				SymLoc Loc      `json:"sym_loc"`
				Then   *uintptr `json:"then"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			v.SymLoc = tmp.SymLoc
			if tmp.Then != nil {
				v.Then = n.node[*tmp.Then].(Node)
			}
		case "return":
			v := n.node[i].(*Return)
			var tmp struct {
				Expr *uintptr `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		case "break":
			var tmp struct {
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
		case "continue":
			var tmp struct {
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
		case "assert":
			v := n.node[i].(*Assert)
			var tmp struct {
				Cond *uintptr `json:"cond"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(*Binary)
			}
		case "implicit_yield":
			v := n.node[i].(*ImplicitYield)
			var tmp struct {
				Expr *uintptr `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		case "field":
			v := n.node[i].(*Field)
			var tmp struct {
				Ident        *uintptr  `json:"ident"`
				ColonLoc     Loc       `json:"colon_loc"`
				FieldType    *uintptr  `json:"field_type"`
				RawArguments *uintptr  `json:"raw_arguments"`
				Arguments    []uintptr `json:"arguments"`
				Belong       *uintptr  `json:"belong"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			v.ColonLoc = tmp.ColonLoc
			if tmp.FieldType != nil {
				v.FieldType = n.node[*tmp.FieldType].(Type)
			}
			if tmp.RawArguments != nil {
				v.RawArguments = n.node[*tmp.RawArguments].(Expr)
			}
			v.Arguments = make([]Expr, len(tmp.Arguments))
			for j, k := range tmp.Arguments {
				v.Arguments[j] = n.node[k].(Expr)
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(*Format)
			}
		case "format":
			v := n.node[i].(*Format)
			var tmp struct {
				IsEnum     bool     `json:"is_enum"`
				Ident      *uintptr `json:"ident"`
				Body       *uintptr `json:"body"`
				Belong     *uintptr `json:"belong"`
				StructType *uintptr `json:"struct_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsEnum = tmp.IsEnum
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			if tmp.Body != nil {
				v.Body = n.node[*tmp.Body].(*IndentScope)
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(*Format)
			}
			if tmp.StructType != nil {
				v.StructType = n.node[*tmp.StructType].(*StructType)
			}
		case "function":
			v := n.node[i].(*Function)
			var tmp struct {
				Ident      *uintptr  `json:"ident"`
				Parameters []uintptr `json:"parameters"`
				ReturnType *uintptr  `json:"return_type"`
				Belong     *uintptr  `json:"belong"`
				Body       *uintptr  `json:"body"`
				FuncType   *uintptr  `json:"func_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			v.Parameters = make([]*Field, len(tmp.Parameters))
			for j, k := range tmp.Parameters {
				v.Parameters[j] = n.node[k].(*Field)
			}
			if tmp.ReturnType != nil {
				v.ReturnType = n.node[*tmp.ReturnType].(Type)
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(*Format)
			}
			if tmp.Body != nil {
				v.Body = n.node[*tmp.Body].(*IndentScope)
			}
			if tmp.FuncType != nil {
				v.FuncType = n.node[*tmp.FuncType].(*FunctionType)
			}
		case "int_type":
			v := n.node[i].(*IntType)
			var tmp struct {
				BitSize  uint64 `json:"bit_size"`
				Endian   Endian `json:"endian"`
				IsSigned bool   `json:"is_signed"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.BitSize = tmp.BitSize
			v.Endian = tmp.Endian
			v.IsSigned = tmp.IsSigned
		case "ident_type":
			v := n.node[i].(*IdentType)
			var tmp struct {
				Ident *uintptr `json:"ident"`
				Base  *uintptr `json:"base"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*Format)
			}
		case "int_literal_type":
			v := n.node[i].(*IntLiteralType)
			var tmp struct {
				Base *uintptr `json:"base"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*IntLiteral)
			}
		case "str_literal_type":
			v := n.node[i].(*StrLiteralType)
			var tmp struct {
				Base *uintptr `json:"base"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*StrLiteral)
			}
		case "void_type":
			var tmp struct {
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
		case "bool_type":
			var tmp struct {
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
		case "array_type":
			v := n.node[i].(*ArrayType)
			var tmp struct {
				EndLoc   Loc      `json:"end_loc"`
				BaseType *uintptr `json:"base_type"`
				Length   *uintptr `json:"length"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.EndLoc = tmp.EndLoc
			if tmp.BaseType != nil {
				v.BaseType = n.node[*tmp.BaseType].(Type)
			}
			if tmp.Length != nil {
				v.Length = n.node[*tmp.Length].(Expr)
			}
		case "function_type":
			v := n.node[i].(*FunctionType)
			var tmp struct {
				ReturnType *uintptr  `json:"return_type"`
				Parameters []uintptr `json:"parameters"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ReturnType != nil {
				v.ReturnType = n.node[*tmp.ReturnType].(Type)
			}
			v.Parameters = make([]Type, len(tmp.Parameters))
			for j, k := range tmp.Parameters {
				v.Parameters[j] = n.node[k].(Type)
			}
		case "struct_type":
			v := n.node[i].(*StructType)
			var tmp struct {
				Fields []uintptr `json:"fields"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.Fields = make([]Member, len(tmp.Fields))
			for j, k := range tmp.Fields {
				v.Fields[j] = n.node[k].(Member)
			}
		case "union_type":
			v := n.node[i].(*UnionType)
			var tmp struct {
				Fields []uintptr `json:"fields"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.Fields = make([]*StructType, len(tmp.Fields))
			for j, k := range tmp.Fields {
				v.Fields[j] = n.node[k].(*StructType)
			}
		case "cast":
			v := n.node[i].(*Cast)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Base     *uintptr `json:"base"`
				Expr     *uintptr `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*Call)
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		default:
			return nil, fmt.Errorf("unknown node type: %q", raw.NodeType)
		}
	}
	for i, raw := range aux.Scope {
		if raw.Prev != nil {
			n.scope[i].Prev = n.scope[*raw.Prev]
		}
		if raw.Next != nil {
			n.scope[i].Next = n.scope[*raw.Next]
		}
		if raw.Branch != nil {
			n.scope[i].Branch = n.scope[*raw.Branch]
		}
		n.scope[i].Ident = make([]Node, len(raw.Ident))
		for j, k := range raw.Ident {
			n.scope[i].Ident[j] = n.node[k].(Node)
		}
	}
	return n.node[0].(*Program), nil
}

type AstFile struct {
	Files []string `json:"files"`
	Ast   *AST     `json:"ast"`
	Error string   `json:"error"`
}

type TokenFile struct {
	Files  []string `json:"files"`
	Tokens []*Token `json:"tokens"`
	Error  string   `json:"error"`
}

func Walk(n Node, f func(Node) (cont bool)) {
	if !f(n) {
		return
	}
	switch v := n.(type) {
	case *Program:
		if v.StructType != nil {
			Walk(v.StructType, f)
		}
		for _, w := range v.Elements {
			Walk(w, f)
		}
	case *Binary:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
		if v.Left != nil {
			Walk(v.Left, f)
		}
		if v.Right != nil {
			Walk(v.Right, f)
		}
	case *Unary:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
		if v.Expr != nil {
			Walk(v.Expr, f)
		}
	case *Cond:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
		if v.Cond != nil {
			Walk(v.Cond, f)
		}
		if v.Then != nil {
			Walk(v.Then, f)
		}
		if v.Els != nil {
			Walk(v.Els, f)
		}
	case *Ident:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
	case *Call:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
		if v.Callee != nil {
			Walk(v.Callee, f)
		}
		if v.RawArguments != nil {
			Walk(v.RawArguments, f)
		}
		for _, w := range v.Arguments {
			Walk(w, f)
		}
	case *If:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
		if v.Cond != nil {
			Walk(v.Cond, f)
		}
		if v.Then != nil {
			Walk(v.Then, f)
		}
		if v.Els != nil {
			Walk(v.Els, f)
		}
	case *MemberAccess:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
		if v.Target != nil {
			Walk(v.Target, f)
		}
	case *Paren:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
		if v.Expr != nil {
			Walk(v.Expr, f)
		}
	case *Index:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
		if v.Expr != nil {
			Walk(v.Expr, f)
		}
		if v.Index != nil {
			Walk(v.Index, f)
		}
	case *Match:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
		if v.Cond != nil {
			Walk(v.Cond, f)
		}
		for _, w := range v.Branch {
			Walk(w, f)
		}
	case *Range:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
		if v.Start != nil {
			Walk(v.Start, f)
		}
		if v.End != nil {
			Walk(v.End, f)
		}
	case *TmpVar:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
	case *BlockExpr:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
		for _, w := range v.Calls {
			Walk(w, f)
		}
		if v.Expr != nil {
			Walk(v.Expr, f)
		}
	case *Import:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
		if v.Base != nil {
			Walk(v.Base, f)
		}
		if v.ImportDesc != nil {
			Walk(v.ImportDesc, f)
		}
	case *IntLiteral:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
	case *BoolLiteral:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
	case *StrLiteral:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
	case *Input:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
	case *Output:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
	case *Config:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
	case *Loop:
		if v.Init != nil {
			Walk(v.Init, f)
		}
		if v.Cond != nil {
			Walk(v.Cond, f)
		}
		if v.Step != nil {
			Walk(v.Step, f)
		}
		if v.Body != nil {
			Walk(v.Body, f)
		}
	case *IndentScope:
		for _, w := range v.Elements {
			Walk(w, f)
		}
	case *MatchBranch:
		if v.Cond != nil {
			Walk(v.Cond, f)
		}
		if v.Then != nil {
			Walk(v.Then, f)
		}
	case *Return:
		if v.Expr != nil {
			Walk(v.Expr, f)
		}
	case *Break:
	case *Continue:
	case *Assert:
		if v.Cond != nil {
			Walk(v.Cond, f)
		}
	case *ImplicitYield:
		if v.Expr != nil {
			Walk(v.Expr, f)
		}
	case *Field:
		if v.Ident != nil {
			Walk(v.Ident, f)
		}
		if v.FieldType != nil {
			Walk(v.FieldType, f)
		}
		if v.RawArguments != nil {
			Walk(v.RawArguments, f)
		}
		for _, w := range v.Arguments {
			Walk(w, f)
		}
	case *Format:
		if v.Ident != nil {
			Walk(v.Ident, f)
		}
		if v.Body != nil {
			Walk(v.Body, f)
		}
		if v.StructType != nil {
			Walk(v.StructType, f)
		}
	case *Function:
		if v.Ident != nil {
			Walk(v.Ident, f)
		}
		for _, w := range v.Parameters {
			Walk(w, f)
		}
		if v.ReturnType != nil {
			Walk(v.ReturnType, f)
		}
		if v.Body != nil {
			Walk(v.Body, f)
		}
		if v.FuncType != nil {
			Walk(v.FuncType, f)
		}
	case *IntType:
	case *IdentType:
		if v.Ident != nil {
			Walk(v.Ident, f)
		}
	case *IntLiteralType:
	case *StrLiteralType:
	case *VoidType:
	case *BoolType:
	case *ArrayType:
		if v.BaseType != nil {
			Walk(v.BaseType, f)
		}
		if v.Length != nil {
			Walk(v.Length, f)
		}
	case *FunctionType:
		if v.ReturnType != nil {
			Walk(v.ReturnType, f)
		}
		for _, w := range v.Parameters {
			Walk(w, f)
		}
	case *StructType:
		for _, w := range v.Fields {
			Walk(w, f)
		}
	case *UnionType:
		for _, w := range v.Fields {
			Walk(w, f)
		}
	case *Cast:
		if v.ExprType != nil {
			Walk(v.ExprType, f)
		}
		if v.Base != nil {
			Walk(v.Base, f)
		}
		if v.Expr != nil {
			Walk(v.Expr, f)
		}
	}
}
