// Code generated by gen_ast2go; DO NOT EDIT.

package ast

import (
	"encoding/json"
	"fmt"
)

type Node interface {
	isNode()
}

type Expr interface {
	isExpr()
	Node
}

type Literal interface {
	isLiteral()
	Expr
}

type Stmt interface {
	isStmt()
	Node
}

type Member interface {
	isMember()
	Stmt
}

type Type interface {
	isType()
	Node
}

type Program struct {
	Loc         Loc
	StructType  *StructType
	Elements    []Node
	GlobalScope *Scope
}

func (n *Program) isNode() {}

type Binary struct {
	Loc      Loc
	ExprType Type
	Op       BinaryOp
	Left     Expr
	Right    Expr
}

func (n *Binary) isExpr() {}

func (n *Binary) isNode() {}

type Unary struct {
	Loc      Loc
	ExprType Type
	Op       UnaryOp
	Expr     Expr
}

func (n *Unary) isExpr() {}

func (n *Unary) isNode() {}

type Cond struct {
	Loc      Loc
	ExprType Type
	Cond     Expr
	Then     Expr
	ElsLoc   Loc
	Els      Expr
}

func (n *Cond) isExpr() {}

func (n *Cond) isNode() {}

type Ident struct {
	Loc      Loc
	ExprType Type
	Ident    string
	Usage    IdentUsage
	Base     Node
	Scope    *Scope
}

func (n *Ident) isExpr() {}

func (n *Ident) isNode() {}

type Call struct {
	Loc          Loc
	ExprType     Type
	Callee       Expr
	RawArguments Expr
	Arguments    []Expr
	EndLoc       Loc
}

func (n *Call) isExpr() {}

func (n *Call) isNode() {}

type If struct {
	Loc       Loc
	ExprType  Type
	CondScope *Scope
	Cond      Expr
	Then      *IndentBlock
	Els       Node
}

func (n *If) isExpr() {}

func (n *If) isNode() {}

type MemberAccess struct {
	Loc       Loc
	ExprType  Type
	Target    Expr
	Member    string
	MemberLoc Loc
}

func (n *MemberAccess) isExpr() {}

func (n *MemberAccess) isNode() {}

type Paren struct {
	Loc      Loc
	ExprType Type
	Expr     Expr
	EndLoc   Loc
}

func (n *Paren) isExpr() {}

func (n *Paren) isNode() {}

type Index struct {
	Loc      Loc
	ExprType Type
	Expr     Expr
	Index    Expr
	EndLoc   Loc
}

func (n *Index) isExpr() {}

func (n *Index) isNode() {}

type Match struct {
	Loc       Loc
	ExprType  Type
	CondScope *Scope
	Cond      Expr
	Branch    []Node
}

func (n *Match) isExpr() {}

func (n *Match) isNode() {}

type Range struct {
	Loc      Loc
	ExprType Type
	Op       BinaryOp
	Start    Expr
	End      Expr
}

func (n *Range) isExpr() {}

func (n *Range) isNode() {}

type TmpVar struct {
	Loc      Loc
	ExprType Type
	TmpVar   uint64
}

func (n *TmpVar) isExpr() {}

func (n *TmpVar) isNode() {}

type BlockExpr struct {
	Loc      Loc
	ExprType Type
	Calls    []Node
	Expr     Expr
}

func (n *BlockExpr) isExpr() {}

func (n *BlockExpr) isNode() {}

type Import struct {
	Loc        Loc
	ExprType   Type
	Path       string
	Base       *Call
	ImportDesc *Program
}

func (n *Import) isExpr() {}

func (n *Import) isNode() {}

type IntLiteral struct {
	Loc      Loc
	ExprType Type
	Value    string
}

func (n *IntLiteral) isLiteral() {}

func (n *IntLiteral) isExpr() {}

func (n *IntLiteral) isNode() {}

type BoolLiteral struct {
	Loc      Loc
	ExprType Type
	Value    bool
}

func (n *BoolLiteral) isLiteral() {}

func (n *BoolLiteral) isExpr() {}

func (n *BoolLiteral) isNode() {}

type StrLiteral struct {
	Loc      Loc
	ExprType Type
	Value    string
}

func (n *StrLiteral) isLiteral() {}

func (n *StrLiteral) isExpr() {}

func (n *StrLiteral) isNode() {}

type Input struct {
	Loc      Loc
	ExprType Type
}

func (n *Input) isLiteral() {}

func (n *Input) isExpr() {}

func (n *Input) isNode() {}

type Output struct {
	Loc      Loc
	ExprType Type
}

func (n *Output) isLiteral() {}

func (n *Output) isExpr() {}

func (n *Output) isNode() {}

type Config struct {
	Loc      Loc
	ExprType Type
}

func (n *Config) isLiteral() {}

func (n *Config) isExpr() {}

func (n *Config) isNode() {}

type Loop struct {
	Loc       Loc
	CondScope *Scope
	Init      Expr
	Cond      Expr
	Step      Expr
	Body      *IndentBlock
}

func (n *Loop) isStmt() {}

func (n *Loop) isNode() {}

type IndentBlock struct {
	Loc        Loc
	Elements   []Node
	Scope      *Scope
	StructType *StructType
}

func (n *IndentBlock) isStmt() {}

func (n *IndentBlock) isNode() {}

type MatchBranch struct {
	Loc    Loc
	Cond   Expr
	SymLoc Loc
	Then   Node
}

func (n *MatchBranch) isStmt() {}

func (n *MatchBranch) isNode() {}

type Return struct {
	Loc  Loc
	Expr Expr
}

func (n *Return) isStmt() {}

func (n *Return) isNode() {}

type Break struct {
	Loc Loc
}

func (n *Break) isStmt() {}

func (n *Break) isNode() {}

type Continue struct {
	Loc Loc
}

func (n *Continue) isStmt() {}

func (n *Continue) isNode() {}

type Assert struct {
	Loc  Loc
	Cond *Binary
}

func (n *Assert) isStmt() {}

func (n *Assert) isNode() {}

type ImplicitYield struct {
	Loc  Loc
	Expr Expr
}

func (n *ImplicitYield) isStmt() {}

func (n *ImplicitYield) isNode() {}

type Field struct {
	Loc          Loc
	Belong       Member
	Ident        *Ident
	ColonLoc     Loc
	FieldType    Type
	RawArguments Expr
	Arguments    []Expr
}

func (n *Field) isMember() {}

func (n *Field) isStmt() {}

func (n *Field) isNode() {}

type Format struct {
	Loc    Loc
	Belong Member
	Ident  *Ident
	IsEnum bool
	Body   *IndentBlock
}

func (n *Format) isMember() {}

func (n *Format) isStmt() {}

func (n *Format) isNode() {}

type Function struct {
	Loc        Loc
	Belong     Member
	Ident      *Ident
	Parameters []*Field
	ReturnType Type
	Body       *IndentBlock
	FuncType   *FunctionType
}

func (n *Function) isMember() {}

func (n *Function) isStmt() {}

func (n *Function) isNode() {}

type IntType struct {
	Loc        Loc
	IsExplicit bool
	BitSize    uint64
	Endian     Endian
	IsSigned   bool
}

func (n *IntType) isType() {}

func (n *IntType) isNode() {}

type IdentType struct {
	Loc        Loc
	IsExplicit bool
	Ident      *Ident
	Base       *Format
}

func (n *IdentType) isType() {}

func (n *IdentType) isNode() {}

type IntLiteralType struct {
	Loc        Loc
	IsExplicit bool
	Base       *IntLiteral
}

func (n *IntLiteralType) isType() {}

func (n *IntLiteralType) isNode() {}

type StrLiteralType struct {
	Loc        Loc
	IsExplicit bool
	Base       *StrLiteral
}

func (n *StrLiteralType) isType() {}

func (n *StrLiteralType) isNode() {}

type VoidType struct {
	Loc        Loc
	IsExplicit bool
}

func (n *VoidType) isType() {}

func (n *VoidType) isNode() {}

type BoolType struct {
	Loc        Loc
	IsExplicit bool
}

func (n *BoolType) isType() {}

func (n *BoolType) isNode() {}

type ArrayType struct {
	Loc        Loc
	IsExplicit bool
	EndLoc     Loc
	BaseType   Type
	Length     Expr
}

func (n *ArrayType) isType() {}

func (n *ArrayType) isNode() {}

type FunctionType struct {
	Loc        Loc
	IsExplicit bool
	ReturnType Type
	Parameters []Type
}

func (n *FunctionType) isType() {}

func (n *FunctionType) isNode() {}

type StructType struct {
	Loc        Loc
	IsExplicit bool
	Fields     []Member
}

func (n *StructType) isType() {}

func (n *StructType) isNode() {}

type StructUnionType struct {
	Loc         Loc
	IsExplicit  bool
	Fields      []*StructType
	Base        Expr
	UnionFields []*Field
}

func (n *StructUnionType) isType() {}

func (n *StructUnionType) isNode() {}

type Cast struct {
	Loc      Loc
	ExprType Type
	Base     *Call
	Expr     Expr
}

func (n *Cast) isExpr() {}

func (n *Cast) isNode() {}

type Comment struct {
	Loc     Loc
	Comment string
}

func (n *Comment) isNode() {}

type CommentGroup struct {
	Loc      Loc
	Comments []*Comment
}

func (n *CommentGroup) isNode() {}

type UnionType struct {
	Loc        Loc
	IsExplicit bool
	Cond       Expr
	Candidates []*UnionCandidate
	BaseType   *StructUnionType
}

func (n *UnionType) isType() {}

func (n *UnionType) isNode() {}

type UnionCandidate struct {
	Loc   Loc
	Cond  Expr
	Field Member
}

func (n *UnionCandidate) isStmt() {}

func (n *UnionCandidate) isNode() {}

type RangeType struct {
	Loc        Loc
	IsExplicit bool
	BaseType   Type
	Range      *Range
}

func (n *RangeType) isType() {}

func (n *RangeType) isNode() {}

type Enum struct {
	Loc    Loc
	Belong Member
	Ident  *Ident
}

func (n *Enum) isMember() {}

func (n *Enum) isStmt() {}

func (n *Enum) isNode() {}

type UnaryOp int

const (
	UnaryOpNot       UnaryOp = 0
	UnaryOpMinusSign UnaryOp = 1
)

func (n UnaryOp) String() string {
	switch n {
	case UnaryOpNot:
		return "!"
	case UnaryOpMinusSign:
		return "-"
	default:
		return fmt.Sprintf("UnaryOp(%d)", n)
	}
}

func (n UnaryOp) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "!":
		n = UnaryOpNot
	case "-":
		n = UnaryOpMinusSign
	default:
		return fmt.Errorf("unknown UnaryOp: %q", tmp)
	}
	return nil
}

type BinaryOp int

const (
	BinaryOpMul                  BinaryOp = 0
	BinaryOpDiv                  BinaryOp = 1
	BinaryOpMod                  BinaryOp = 2
	BinaryOpLeftArithmeticShift  BinaryOp = 3
	BinaryOpRightArithmeticShift BinaryOp = 4
	BinaryOpLeftLogicalShift     BinaryOp = 5
	BinaryOpRightLogicalShift    BinaryOp = 6
	BinaryOpBitAnd               BinaryOp = 7
	BinaryOpAdd                  BinaryOp = 8
	BinaryOpSub                  BinaryOp = 9
	BinaryOpBitOr                BinaryOp = 10
	BinaryOpBitXor               BinaryOp = 11
	BinaryOpEqual                BinaryOp = 12
	BinaryOpNotEqual             BinaryOp = 13
	BinaryOpLess                 BinaryOp = 14
	BinaryOpLessOrEq             BinaryOp = 15
	BinaryOpGrater               BinaryOp = 16
	BinaryOpGraterOrEq           BinaryOp = 17
	BinaryOpLogicalAnd           BinaryOp = 18
	BinaryOpLogicalOr            BinaryOp = 19
	BinaryOpCondOp1              BinaryOp = 20
	BinaryOpCondOp2              BinaryOp = 21
	BinaryOpRangeExclusive       BinaryOp = 22
	BinaryOpRangeInclusive       BinaryOp = 23
	BinaryOpAssign               BinaryOp = 24
	BinaryOpDefineAssign         BinaryOp = 25
	BinaryOpConstAssign          BinaryOp = 26
	BinaryOpAddAssign            BinaryOp = 27
	BinaryOpSubAssign            BinaryOp = 28
	BinaryOpMulAssign            BinaryOp = 29
	BinaryOpDivAssign            BinaryOp = 30
	BinaryOpModAssign            BinaryOp = 31
	BinaryOpLeftShiftAssign      BinaryOp = 32
	BinaryOpRightShiftAssign     BinaryOp = 33
	BinaryOpBitAndAssign         BinaryOp = 34
	BinaryOpBitOrAssign          BinaryOp = 35
	BinaryOpBitXorAssign         BinaryOp = 36
	BinaryOpComma                BinaryOp = 37
)

func (n BinaryOp) String() string {
	switch n {
	case BinaryOpMul:
		return "*"
	case BinaryOpDiv:
		return "/"
	case BinaryOpMod:
		return "%"
	case BinaryOpLeftArithmeticShift:
		return "<<<"
	case BinaryOpRightArithmeticShift:
		return ">>>"
	case BinaryOpLeftLogicalShift:
		return "<<"
	case BinaryOpRightLogicalShift:
		return ">>"
	case BinaryOpBitAnd:
		return "&"
	case BinaryOpAdd:
		return "+"
	case BinaryOpSub:
		return "-"
	case BinaryOpBitOr:
		return "|"
	case BinaryOpBitXor:
		return "^"
	case BinaryOpEqual:
		return "=="
	case BinaryOpNotEqual:
		return "!="
	case BinaryOpLess:
		return "<"
	case BinaryOpLessOrEq:
		return "<="
	case BinaryOpGrater:
		return ">"
	case BinaryOpGraterOrEq:
		return ">="
	case BinaryOpLogicalAnd:
		return "&&"
	case BinaryOpLogicalOr:
		return "||"
	case BinaryOpCondOp1:
		return "?"
	case BinaryOpCondOp2:
		return ":"
	case BinaryOpRangeExclusive:
		return ".."
	case BinaryOpRangeInclusive:
		return "..="
	case BinaryOpAssign:
		return "="
	case BinaryOpDefineAssign:
		return ":="
	case BinaryOpConstAssign:
		return "::="
	case BinaryOpAddAssign:
		return "+="
	case BinaryOpSubAssign:
		return "-="
	case BinaryOpMulAssign:
		return "*="
	case BinaryOpDivAssign:
		return "/="
	case BinaryOpModAssign:
		return "%="
	case BinaryOpLeftShiftAssign:
		return "<<="
	case BinaryOpRightShiftAssign:
		return ">>="
	case BinaryOpBitAndAssign:
		return "&="
	case BinaryOpBitOrAssign:
		return "|="
	case BinaryOpBitXorAssign:
		return "^="
	case BinaryOpComma:
		return ","
	default:
		return fmt.Sprintf("BinaryOp(%d)", n)
	}
}

func (n BinaryOp) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "*":
		n = BinaryOpMul
	case "/":
		n = BinaryOpDiv
	case "%":
		n = BinaryOpMod
	case "<<<":
		n = BinaryOpLeftArithmeticShift
	case ">>>":
		n = BinaryOpRightArithmeticShift
	case "<<":
		n = BinaryOpLeftLogicalShift
	case ">>":
		n = BinaryOpRightLogicalShift
	case "&":
		n = BinaryOpBitAnd
	case "+":
		n = BinaryOpAdd
	case "-":
		n = BinaryOpSub
	case "|":
		n = BinaryOpBitOr
	case "^":
		n = BinaryOpBitXor
	case "==":
		n = BinaryOpEqual
	case "!=":
		n = BinaryOpNotEqual
	case "<":
		n = BinaryOpLess
	case "<=":
		n = BinaryOpLessOrEq
	case ">":
		n = BinaryOpGrater
	case ">=":
		n = BinaryOpGraterOrEq
	case "&&":
		n = BinaryOpLogicalAnd
	case "||":
		n = BinaryOpLogicalOr
	case "?":
		n = BinaryOpCondOp1
	case ":":
		n = BinaryOpCondOp2
	case "..":
		n = BinaryOpRangeExclusive
	case "..=":
		n = BinaryOpRangeInclusive
	case "=":
		n = BinaryOpAssign
	case ":=":
		n = BinaryOpDefineAssign
	case "::=":
		n = BinaryOpConstAssign
	case "+=":
		n = BinaryOpAddAssign
	case "-=":
		n = BinaryOpSubAssign
	case "*=":
		n = BinaryOpMulAssign
	case "/=":
		n = BinaryOpDivAssign
	case "%=":
		n = BinaryOpModAssign
	case "<<=":
		n = BinaryOpLeftShiftAssign
	case ">>=":
		n = BinaryOpRightShiftAssign
	case "&=":
		n = BinaryOpBitAndAssign
	case "|=":
		n = BinaryOpBitOrAssign
	case "^=":
		n = BinaryOpBitXorAssign
	case ",":
		n = BinaryOpComma
	default:
		return fmt.Errorf("unknown BinaryOp: %q", tmp)
	}
	return nil
}

type IdentUsage int

const (
	IdentUsageUnknown        IdentUsage = 0
	IdentUsageReference      IdentUsage = 1
	IdentUsageDefineVariable IdentUsage = 2
	IdentUsageDefineConst    IdentUsage = 3
	IdentUsageDefineField    IdentUsage = 4
	IdentUsageDefineFormat   IdentUsage = 5
	IdentUsageDefineEnum     IdentUsage = 6
	IdentUsageDefineFn       IdentUsage = 7
	IdentUsageDefineArg      IdentUsage = 8
	IdentUsageReferenceType  IdentUsage = 9
)

func (n IdentUsage) String() string {
	switch n {
	case IdentUsageUnknown:
		return "unknown"
	case IdentUsageReference:
		return "reference"
	case IdentUsageDefineVariable:
		return "define_variable"
	case IdentUsageDefineConst:
		return "define_const"
	case IdentUsageDefineField:
		return "define_field"
	case IdentUsageDefineFormat:
		return "define_format"
	case IdentUsageDefineEnum:
		return "define_enum"
	case IdentUsageDefineFn:
		return "define_fn"
	case IdentUsageDefineArg:
		return "define_arg"
	case IdentUsageReferenceType:
		return "reference_type"
	default:
		return fmt.Sprintf("IdentUsage(%d)", n)
	}
}

func (n IdentUsage) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "unknown":
		n = IdentUsageUnknown
	case "reference":
		n = IdentUsageReference
	case "define_variable":
		n = IdentUsageDefineVariable
	case "define_const":
		n = IdentUsageDefineConst
	case "define_field":
		n = IdentUsageDefineField
	case "define_format":
		n = IdentUsageDefineFormat
	case "define_enum":
		n = IdentUsageDefineEnum
	case "define_fn":
		n = IdentUsageDefineFn
	case "define_arg":
		n = IdentUsageDefineArg
	case "reference_type":
		n = IdentUsageReferenceType
	default:
		return fmt.Errorf("unknown IdentUsage: %q", tmp)
	}
	return nil
}

type Endian int

const (
	EndianUnspec Endian = 0
	EndianBig    Endian = 1
	EndianLittle Endian = 2
)

func (n Endian) String() string {
	switch n {
	case EndianUnspec:
		return "unspec"
	case EndianBig:
		return "big"
	case EndianLittle:
		return "little"
	default:
		return fmt.Sprintf("Endian(%d)", n)
	}
}

func (n Endian) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "unspec":
		n = EndianUnspec
	case "big":
		n = EndianBig
	case "little":
		n = EndianLittle
	default:
		return fmt.Errorf("unknown Endian: %q", tmp)
	}
	return nil
}

type TokenTag int

const (
	TokenTagIndent      TokenTag = 0
	TokenTagSpace       TokenTag = 1
	TokenTagLine        TokenTag = 2
	TokenTagPunct       TokenTag = 3
	TokenTagIntLiteral  TokenTag = 4
	TokenTagBoolLiteral TokenTag = 5
	TokenTagStrLiteral  TokenTag = 6
	TokenTagKeyword     TokenTag = 7
	TokenTagIdent       TokenTag = 8
	TokenTagComment     TokenTag = 9
	TokenTagError       TokenTag = 10
	TokenTagUnknown     TokenTag = 11
)

func (n TokenTag) String() string {
	switch n {
	case TokenTagIndent:
		return "indent"
	case TokenTagSpace:
		return "space"
	case TokenTagLine:
		return "line"
	case TokenTagPunct:
		return "punct"
	case TokenTagIntLiteral:
		return "int_literal"
	case TokenTagBoolLiteral:
		return "bool_literal"
	case TokenTagStrLiteral:
		return "str_literal"
	case TokenTagKeyword:
		return "keyword"
	case TokenTagIdent:
		return "ident"
	case TokenTagComment:
		return "comment"
	case TokenTagError:
		return "error"
	case TokenTagUnknown:
		return "unknown"
	default:
		return fmt.Sprintf("TokenTag(%d)", n)
	}
}

func (n TokenTag) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "indent":
		n = TokenTagIndent
	case "space":
		n = TokenTagSpace
	case "line":
		n = TokenTagLine
	case "punct":
		n = TokenTagPunct
	case "int_literal":
		n = TokenTagIntLiteral
	case "bool_literal":
		n = TokenTagBoolLiteral
	case "str_literal":
		n = TokenTagStrLiteral
	case "keyword":
		n = TokenTagKeyword
	case "ident":
		n = TokenTagIdent
	case "comment":
		n = TokenTagComment
	case "error":
		n = TokenTagError
	case "unknown":
		n = TokenTagUnknown
	default:
		return fmt.Errorf("unknown TokenTag: %q", tmp)
	}
	return nil
}

type Scope struct {
	Prev     *Scope
	Next     *Scope
	Branch   *Scope
	Ident    []*Ident
	IsGlobal bool
}

type Pos struct {
	Begin uint64 `json:"begin"`
	End   uint64 `json:"end"`
}

type Loc struct {
	Pos  Pos    `json:"pos"`
	File uint64 `json:"file"`
	Line uint64 `json:"line"`
	Col  uint64 `json:"col"`
}

type Token struct {
	Tag   TokenTag `json:"tag"`
	Token string   `json:"token"`
	Loc   Loc      `json:"loc"`
}

type SrcErrorEntry struct {
	Msg  string `json:"msg"`
	File string `json:"file"`
	Loc  Loc    `json:"loc"`
	Src  string `json:"src"`
	Warn bool   `json:"warn"`
}

type SrcError struct {
	Errs []SrcErrorEntry `json:"errs"`
}

type astConstructor struct {
	node  []Node
	scope []*Scope
}
type rawNode struct {
	NodeType string `json:"node_type"`
	Loc      Loc    `json:"loc"`
	Body     json.RawMessage
}
type rawScope struct {
	Prev     *uintptr  `json:"prev"`
	Next     *uintptr  `json:"next"`
	Branch   *uintptr  `json:"branch"`
	Ident    []uintptr `json:"ident"`
	IsGlobal bool      `json:"is_global"`
}
type AST struct {
	*Program
}

func (n *AST) UnmarshalJSON(data []byte) error {
	var tmp astConstructor
	prog, err := tmp.unmarshal(data)
	if err != nil {
		return err
	}
	n.Program = prog
	return nil
}
func (n *astConstructor) unmarshal(data []byte) (prog *Program, err error) {
	defer func() {
		if r := recover(); r != nil {
			err = fmt.Errorf("%v", r)
		}
	}()
	var aux struct {
		Node  []rawNode   `json:"node"`
		Scope []*rawScope `json:"scope"`
	}
	if err = json.Unmarshal(data, &aux); err != nil {
		return nil, err
	}
	n.node = make([]Node, len(aux.Node))
	for i, raw := range aux.Node {
		switch raw.NodeType {
		case "program":
			n.node[i] = &Program{Loc: raw.Loc}
		case "binary":
			n.node[i] = &Binary{Loc: raw.Loc}
		case "unary":
			n.node[i] = &Unary{Loc: raw.Loc}
		case "cond":
			n.node[i] = &Cond{Loc: raw.Loc}
		case "ident":
			n.node[i] = &Ident{Loc: raw.Loc}
		case "call":
			n.node[i] = &Call{Loc: raw.Loc}
		case "if":
			n.node[i] = &If{Loc: raw.Loc}
		case "member_access":
			n.node[i] = &MemberAccess{Loc: raw.Loc}
		case "paren":
			n.node[i] = &Paren{Loc: raw.Loc}
		case "index":
			n.node[i] = &Index{Loc: raw.Loc}
		case "match":
			n.node[i] = &Match{Loc: raw.Loc}
		case "range":
			n.node[i] = &Range{Loc: raw.Loc}
		case "tmp_var":
			n.node[i] = &TmpVar{Loc: raw.Loc}
		case "block_expr":
			n.node[i] = &BlockExpr{Loc: raw.Loc}
		case "import":
			n.node[i] = &Import{Loc: raw.Loc}
		case "int_literal":
			n.node[i] = &IntLiteral{Loc: raw.Loc}
		case "bool_literal":
			n.node[i] = &BoolLiteral{Loc: raw.Loc}
		case "str_literal":
			n.node[i] = &StrLiteral{Loc: raw.Loc}
		case "input":
			n.node[i] = &Input{Loc: raw.Loc}
		case "output":
			n.node[i] = &Output{Loc: raw.Loc}
		case "config":
			n.node[i] = &Config{Loc: raw.Loc}
		case "loop":
			n.node[i] = &Loop{Loc: raw.Loc}
		case "indent_block":
			n.node[i] = &IndentBlock{Loc: raw.Loc}
		case "match_branch":
			n.node[i] = &MatchBranch{Loc: raw.Loc}
		case "return":
			n.node[i] = &Return{Loc: raw.Loc}
		case "break":
			n.node[i] = &Break{Loc: raw.Loc}
		case "continue":
			n.node[i] = &Continue{Loc: raw.Loc}
		case "assert":
			n.node[i] = &Assert{Loc: raw.Loc}
		case "implicit_yield":
			n.node[i] = &ImplicitYield{Loc: raw.Loc}
		case "field":
			n.node[i] = &Field{Loc: raw.Loc}
		case "format":
			n.node[i] = &Format{Loc: raw.Loc}
		case "function":
			n.node[i] = &Function{Loc: raw.Loc}
		case "int_type":
			n.node[i] = &IntType{Loc: raw.Loc}
		case "ident_type":
			n.node[i] = &IdentType{Loc: raw.Loc}
		case "int_literal_type":
			n.node[i] = &IntLiteralType{Loc: raw.Loc}
		case "str_literal_type":
			n.node[i] = &StrLiteralType{Loc: raw.Loc}
		case "void_type":
			n.node[i] = &VoidType{Loc: raw.Loc}
		case "bool_type":
			n.node[i] = &BoolType{Loc: raw.Loc}
		case "array_type":
			n.node[i] = &ArrayType{Loc: raw.Loc}
		case "function_type":
			n.node[i] = &FunctionType{Loc: raw.Loc}
		case "struct_type":
			n.node[i] = &StructType{Loc: raw.Loc}
		case "struct_union_type":
			n.node[i] = &StructUnionType{Loc: raw.Loc}
		case "cast":
			n.node[i] = &Cast{Loc: raw.Loc}
		case "comment":
			n.node[i] = &Comment{Loc: raw.Loc}
		case "comment_group":
			n.node[i] = &CommentGroup{Loc: raw.Loc}
		case "union_type":
			n.node[i] = &UnionType{Loc: raw.Loc}
		case "union_candidate":
			n.node[i] = &UnionCandidate{Loc: raw.Loc}
		case "range_type":
			n.node[i] = &RangeType{Loc: raw.Loc}
		case "enum":
			n.node[i] = &Enum{Loc: raw.Loc}
		default:
			return nil, fmt.Errorf("unknown node type: %q", raw.NodeType)
		}
	}
	n.scope = make([]*Scope, len(aux.Scope))
	for i := range aux.Scope {
		n.scope[i] = &Scope{}
	}
	for i, raw := range aux.Node {
		switch raw.NodeType {
		case "program":
			v := n.node[i].(*Program)
			var tmp struct {
				StructType  *uintptr  `json:"struct_type"`
				Elements    []uintptr `json:"elements"`
				GlobalScope *uintptr  `json:"global_scope"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.StructType != nil {
				v.StructType = n.node[*tmp.StructType].(*StructType)
			}
			v.Elements = make([]Node, len(tmp.Elements))
			for j, k := range tmp.Elements {
				v.Elements[j] = n.node[k].(Node)
			}
			if tmp.GlobalScope != nil {
				v.GlobalScope = n.scope[*tmp.GlobalScope]
			}
		case "binary":
			v := n.node[i].(*Binary)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Op       BinaryOp `json:"op"`
				Left     *uintptr `json:"left"`
				Right    *uintptr `json:"right"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Op = tmp.Op
			if tmp.Left != nil {
				v.Left = n.node[*tmp.Left].(Expr)
			}
			if tmp.Right != nil {
				v.Right = n.node[*tmp.Right].(Expr)
			}
		case "unary":
			v := n.node[i].(*Unary)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Op       UnaryOp  `json:"op"`
				Expr     *uintptr `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Op = tmp.Op
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		case "cond":
			v := n.node[i].(*Cond)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Cond     *uintptr `json:"cond"`
				Then     *uintptr `json:"then"`
				ElsLoc   Loc      `json:"els_loc"`
				Els      *uintptr `json:"els"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			if tmp.Then != nil {
				v.Then = n.node[*tmp.Then].(Expr)
			}
			v.ElsLoc = tmp.ElsLoc
			if tmp.Els != nil {
				v.Els = n.node[*tmp.Els].(Expr)
			}
		case "ident":
			v := n.node[i].(*Ident)
			var tmp struct {
				ExprType *uintptr   `json:"expr_type"`
				Ident    string     `json:"ident"`
				Usage    IdentUsage `json:"usage"`
				Base     *uintptr   `json:"base"`
				Scope    *uintptr   `json:"scope"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Ident = tmp.Ident
			v.Usage = tmp.Usage
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(Node)
			}
			if tmp.Scope != nil {
				v.Scope = n.scope[*tmp.Scope]
			}
		case "call":
			v := n.node[i].(*Call)
			var tmp struct {
				ExprType     *uintptr  `json:"expr_type"`
				Callee       *uintptr  `json:"callee"`
				RawArguments *uintptr  `json:"raw_arguments"`
				Arguments    []uintptr `json:"arguments"`
				EndLoc       Loc       `json:"end_loc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.Callee != nil {
				v.Callee = n.node[*tmp.Callee].(Expr)
			}
			if tmp.RawArguments != nil {
				v.RawArguments = n.node[*tmp.RawArguments].(Expr)
			}
			v.Arguments = make([]Expr, len(tmp.Arguments))
			for j, k := range tmp.Arguments {
				v.Arguments[j] = n.node[k].(Expr)
			}
			v.EndLoc = tmp.EndLoc
		case "if":
			v := n.node[i].(*If)
			var tmp struct {
				ExprType  *uintptr `json:"expr_type"`
				CondScope *uintptr `json:"cond_scope"`
				Cond      *uintptr `json:"cond"`
				Then      *uintptr `json:"then"`
				Els       *uintptr `json:"els"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.CondScope != nil {
				v.CondScope = n.scope[*tmp.CondScope]
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			if tmp.Then != nil {
				v.Then = n.node[*tmp.Then].(*IndentBlock)
			}
			if tmp.Els != nil {
				v.Els = n.node[*tmp.Els].(Node)
			}
		case "member_access":
			v := n.node[i].(*MemberAccess)
			var tmp struct {
				ExprType  *uintptr `json:"expr_type"`
				Target    *uintptr `json:"target"`
				Member    string   `json:"member"`
				MemberLoc Loc      `json:"member_loc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.Target != nil {
				v.Target = n.node[*tmp.Target].(Expr)
			}
			v.Member = tmp.Member
			v.MemberLoc = tmp.MemberLoc
		case "paren":
			v := n.node[i].(*Paren)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Expr     *uintptr `json:"expr"`
				EndLoc   Loc      `json:"end_loc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
			v.EndLoc = tmp.EndLoc
		case "index":
			v := n.node[i].(*Index)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Expr     *uintptr `json:"expr"`
				Index    *uintptr `json:"index"`
				EndLoc   Loc      `json:"end_loc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
			if tmp.Index != nil {
				v.Index = n.node[*tmp.Index].(Expr)
			}
			v.EndLoc = tmp.EndLoc
		case "match":
			v := n.node[i].(*Match)
			var tmp struct {
				ExprType  *uintptr  `json:"expr_type"`
				CondScope *uintptr  `json:"cond_scope"`
				Cond      *uintptr  `json:"cond"`
				Branch    []uintptr `json:"branch"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.CondScope != nil {
				v.CondScope = n.scope[*tmp.CondScope]
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			v.Branch = make([]Node, len(tmp.Branch))
			for j, k := range tmp.Branch {
				v.Branch[j] = n.node[k].(Node)
			}
		case "range":
			v := n.node[i].(*Range)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Op       BinaryOp `json:"op"`
				Start    *uintptr `json:"start"`
				End      *uintptr `json:"end"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Op = tmp.Op
			if tmp.Start != nil {
				v.Start = n.node[*tmp.Start].(Expr)
			}
			if tmp.End != nil {
				v.End = n.node[*tmp.End].(Expr)
			}
		case "tmp_var":
			v := n.node[i].(*TmpVar)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				TmpVar   uint64   `json:"tmp_var"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.TmpVar = tmp.TmpVar
		case "block_expr":
			v := n.node[i].(*BlockExpr)
			var tmp struct {
				ExprType *uintptr  `json:"expr_type"`
				Calls    []uintptr `json:"calls"`
				Expr     *uintptr  `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Calls = make([]Node, len(tmp.Calls))
			for j, k := range tmp.Calls {
				v.Calls[j] = n.node[k].(Node)
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		case "import":
			v := n.node[i].(*Import)
			var tmp struct {
				ExprType   *uintptr `json:"expr_type"`
				Path       string   `json:"path"`
				Base       *uintptr `json:"base"`
				ImportDesc *uintptr `json:"import_desc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Path = tmp.Path
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*Call)
			}
			if tmp.ImportDesc != nil {
				v.ImportDesc = n.node[*tmp.ImportDesc].(*Program)
			}
		case "int_literal":
			v := n.node[i].(*IntLiteral)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Value    string   `json:"value"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Value = tmp.Value
		case "bool_literal":
			v := n.node[i].(*BoolLiteral)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Value    bool     `json:"value"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Value = tmp.Value
		case "str_literal":
			v := n.node[i].(*StrLiteral)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Value    string   `json:"value"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Value = tmp.Value
		case "input":
			v := n.node[i].(*Input)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
		case "output":
			v := n.node[i].(*Output)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
		case "config":
			v := n.node[i].(*Config)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
		case "loop":
			v := n.node[i].(*Loop)
			var tmp struct {
				CondScope *uintptr `json:"cond_scope"`
				Init      *uintptr `json:"init"`
				Cond      *uintptr `json:"cond"`
				Step      *uintptr `json:"step"`
				Body      *uintptr `json:"body"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.CondScope != nil {
				v.CondScope = n.scope[*tmp.CondScope]
			}
			if tmp.Init != nil {
				v.Init = n.node[*tmp.Init].(Expr)
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			if tmp.Step != nil {
				v.Step = n.node[*tmp.Step].(Expr)
			}
			if tmp.Body != nil {
				v.Body = n.node[*tmp.Body].(*IndentBlock)
			}
		case "indent_block":
			v := n.node[i].(*IndentBlock)
			var tmp struct {
				Elements   []uintptr `json:"elements"`
				Scope      *uintptr  `json:"scope"`
				StructType *uintptr  `json:"struct_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.Elements = make([]Node, len(tmp.Elements))
			for j, k := range tmp.Elements {
				v.Elements[j] = n.node[k].(Node)
			}
			if tmp.Scope != nil {
				v.Scope = n.scope[*tmp.Scope]
			}
			if tmp.StructType != nil {
				v.StructType = n.node[*tmp.StructType].(*StructType)
			}
		case "match_branch":
			v := n.node[i].(*MatchBranch)
			var tmp struct {
				Cond   *uintptr `json:"cond"`
				SymLoc Loc      `json:"sym_loc"`
				Then   *uintptr `json:"then"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			v.SymLoc = tmp.SymLoc
			if tmp.Then != nil {
				v.Then = n.node[*tmp.Then].(Node)
			}
		case "return":
			v := n.node[i].(*Return)
			var tmp struct {
				Expr *uintptr `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		case "break":
			var tmp struct {
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
		case "continue":
			var tmp struct {
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
		case "assert":
			v := n.node[i].(*Assert)
			var tmp struct {
				Cond *uintptr `json:"cond"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(*Binary)
			}
		case "implicit_yield":
			v := n.node[i].(*ImplicitYield)
			var tmp struct {
				Expr *uintptr `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		case "field":
			v := n.node[i].(*Field)
			var tmp struct {
				Belong       *uintptr  `json:"belong"`
				Ident        *uintptr  `json:"ident"`
				ColonLoc     Loc       `json:"colon_loc"`
				FieldType    *uintptr  `json:"field_type"`
				RawArguments *uintptr  `json:"raw_arguments"`
				Arguments    []uintptr `json:"arguments"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(Member)
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			v.ColonLoc = tmp.ColonLoc
			if tmp.FieldType != nil {
				v.FieldType = n.node[*tmp.FieldType].(Type)
			}
			if tmp.RawArguments != nil {
				v.RawArguments = n.node[*tmp.RawArguments].(Expr)
			}
			v.Arguments = make([]Expr, len(tmp.Arguments))
			for j, k := range tmp.Arguments {
				v.Arguments[j] = n.node[k].(Expr)
			}
		case "format":
			v := n.node[i].(*Format)
			var tmp struct {
				Belong *uintptr `json:"belong"`
				Ident  *uintptr `json:"ident"`
				IsEnum bool     `json:"is_enum"`
				Body   *uintptr `json:"body"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(Member)
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			v.IsEnum = tmp.IsEnum
			if tmp.Body != nil {
				v.Body = n.node[*tmp.Body].(*IndentBlock)
			}
		case "function":
			v := n.node[i].(*Function)
			var tmp struct {
				Belong     *uintptr  `json:"belong"`
				Ident      *uintptr  `json:"ident"`
				Parameters []uintptr `json:"parameters"`
				ReturnType *uintptr  `json:"return_type"`
				Body       *uintptr  `json:"body"`
				FuncType   *uintptr  `json:"func_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(Member)
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			v.Parameters = make([]*Field, len(tmp.Parameters))
			for j, k := range tmp.Parameters {
				v.Parameters[j] = n.node[k].(*Field)
			}
			if tmp.ReturnType != nil {
				v.ReturnType = n.node[*tmp.ReturnType].(Type)
			}
			if tmp.Body != nil {
				v.Body = n.node[*tmp.Body].(*IndentBlock)
			}
			if tmp.FuncType != nil {
				v.FuncType = n.node[*tmp.FuncType].(*FunctionType)
			}
		case "int_type":
			v := n.node[i].(*IntType)
			var tmp struct {
				IsExplicit bool   `json:"is_explicit"`
				BitSize    uint64 `json:"bit_size"`
				Endian     Endian `json:"endian"`
				IsSigned   bool   `json:"is_signed"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.BitSize = tmp.BitSize
			v.Endian = tmp.Endian
			v.IsSigned = tmp.IsSigned
		case "ident_type":
			v := n.node[i].(*IdentType)
			var tmp struct {
				IsExplicit bool     `json:"is_explicit"`
				Ident      *uintptr `json:"ident"`
				Base       *uintptr `json:"base"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*Format)
			}
		case "int_literal_type":
			v := n.node[i].(*IntLiteralType)
			var tmp struct {
				IsExplicit bool     `json:"is_explicit"`
				Base       *uintptr `json:"base"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*IntLiteral)
			}
		case "str_literal_type":
			v := n.node[i].(*StrLiteralType)
			var tmp struct {
				IsExplicit bool     `json:"is_explicit"`
				Base       *uintptr `json:"base"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*StrLiteral)
			}
		case "void_type":
			v := n.node[i].(*VoidType)
			var tmp struct {
				IsExplicit bool `json:"is_explicit"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
		case "bool_type":
			v := n.node[i].(*BoolType)
			var tmp struct {
				IsExplicit bool `json:"is_explicit"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
		case "array_type":
			v := n.node[i].(*ArrayType)
			var tmp struct {
				IsExplicit bool     `json:"is_explicit"`
				EndLoc     Loc      `json:"end_loc"`
				BaseType   *uintptr `json:"base_type"`
				Length     *uintptr `json:"length"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.EndLoc = tmp.EndLoc
			if tmp.BaseType != nil {
				v.BaseType = n.node[*tmp.BaseType].(Type)
			}
			if tmp.Length != nil {
				v.Length = n.node[*tmp.Length].(Expr)
			}
		case "function_type":
			v := n.node[i].(*FunctionType)
			var tmp struct {
				IsExplicit bool      `json:"is_explicit"`
				ReturnType *uintptr  `json:"return_type"`
				Parameters []uintptr `json:"parameters"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			if tmp.ReturnType != nil {
				v.ReturnType = n.node[*tmp.ReturnType].(Type)
			}
			v.Parameters = make([]Type, len(tmp.Parameters))
			for j, k := range tmp.Parameters {
				v.Parameters[j] = n.node[k].(Type)
			}
		case "struct_type":
			v := n.node[i].(*StructType)
			var tmp struct {
				IsExplicit bool      `json:"is_explicit"`
				Fields     []uintptr `json:"fields"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.Fields = make([]Member, len(tmp.Fields))
			for j, k := range tmp.Fields {
				v.Fields[j] = n.node[k].(Member)
			}
		case "struct_union_type":
			v := n.node[i].(*StructUnionType)
			var tmp struct {
				IsExplicit  bool      `json:"is_explicit"`
				Fields      []uintptr `json:"fields"`
				Base        *uintptr  `json:"base"`
				UnionFields []uintptr `json:"union_fields"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.Fields = make([]*StructType, len(tmp.Fields))
			for j, k := range tmp.Fields {
				v.Fields[j] = n.node[k].(*StructType)
			}
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(Expr)
			}
			v.UnionFields = make([]*Field, len(tmp.UnionFields))
			for j, k := range tmp.UnionFields {
				v.UnionFields[j] = n.node[k].(*Field)
			}
		case "cast":
			v := n.node[i].(*Cast)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Base     *uintptr `json:"base"`
				Expr     *uintptr `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*Call)
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		case "comment":
			v := n.node[i].(*Comment)
			var tmp struct {
				Comment string `json:"comment"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.Comment = tmp.Comment
		case "comment_group":
			v := n.node[i].(*CommentGroup)
			var tmp struct {
				Comments []uintptr `json:"comments"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.Comments = make([]*Comment, len(tmp.Comments))
			for j, k := range tmp.Comments {
				v.Comments[j] = n.node[k].(*Comment)
			}
		case "union_type":
			v := n.node[i].(*UnionType)
			var tmp struct {
				IsExplicit bool      `json:"is_explicit"`
				Cond       *uintptr  `json:"cond"`
				Candidates []uintptr `json:"candidates"`
				BaseType   *uintptr  `json:"base_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			v.Candidates = make([]*UnionCandidate, len(tmp.Candidates))
			for j, k := range tmp.Candidates {
				v.Candidates[j] = n.node[k].(*UnionCandidate)
			}
			if tmp.BaseType != nil {
				v.BaseType = n.node[*tmp.BaseType].(*StructUnionType)
			}
		case "union_candidate":
			v := n.node[i].(*UnionCandidate)
			var tmp struct {
				Cond  *uintptr `json:"cond"`
				Field *uintptr `json:"field"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			if tmp.Field != nil {
				v.Field = n.node[*tmp.Field].(Member)
			}
		case "range_type":
			v := n.node[i].(*RangeType)
			var tmp struct {
				IsExplicit bool     `json:"is_explicit"`
				BaseType   *uintptr `json:"base_type"`
				Range      *uintptr `json:"range"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			if tmp.BaseType != nil {
				v.BaseType = n.node[*tmp.BaseType].(Type)
			}
			if tmp.Range != nil {
				v.Range = n.node[*tmp.Range].(*Range)
			}
		case "enum":
			v := n.node[i].(*Enum)
			var tmp struct {
				Belong *uintptr `json:"belong"`
				Ident  *uintptr `json:"ident"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(Member)
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
		default:
			return nil, fmt.Errorf("unknown node type: %q", raw.NodeType)
		}
	}
	for i, raw := range aux.Scope {
		if raw.Prev != nil {
			n.scope[i].Prev = n.scope[*raw.Prev]
		}
		if raw.Next != nil {
			n.scope[i].Next = n.scope[*raw.Next]
		}
		if raw.Branch != nil {
			n.scope[i].Branch = n.scope[*raw.Branch]
		}
		n.scope[i].Ident = make([]*Ident, len(raw.Ident))
		for j, k := range raw.Ident {
			n.scope[i].Ident[j] = n.node[k].(*Ident)
		}
		n.scope[i].IsGlobal = raw.IsGlobal
	}
	return n.node[0].(*Program), nil
}

type AstFile struct {
	Files []string  `json:"files"`
	Ast   *AST      `json:"ast"`
	Error *SrcError `json:"error"`
}

type TokenFile struct {
	Files  []string  `json:"files"`
	Tokens []*Token  `json:"tokens"`
	Error  *SrcError `json:"error"`
}

type Visitor interface {
	Visit(v Visitor, n Node)
}

type VisitFn func(v Visitor, n Node)

func Walk(n Node, f Visitor) {
	switch v := n.(type) {
	case *Program:
		if v.StructType != nil {
			f.Visit(f, v.StructType)
		}
		for _, w := range v.Elements {
			f.Visit(f, w)
		}
	case *Binary:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
		if v.Left != nil {
			f.Visit(f, v.Left)
		}
		if v.Right != nil {
			f.Visit(f, v.Right)
		}
	case *Unary:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
		if v.Expr != nil {
			f.Visit(f, v.Expr)
		}
	case *Cond:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
		if v.Cond != nil {
			f.Visit(f, v.Cond)
		}
		if v.Then != nil {
			f.Visit(f, v.Then)
		}
		if v.Els != nil {
			f.Visit(f, v.Els)
		}
	case *Ident:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
	case *Call:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
		if v.Callee != nil {
			f.Visit(f, v.Callee)
		}
		if v.RawArguments != nil {
			f.Visit(f, v.RawArguments)
		}
		for _, w := range v.Arguments {
			f.Visit(f, w)
		}
	case *If:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
		if v.Cond != nil {
			f.Visit(f, v.Cond)
		}
		if v.Then != nil {
			f.Visit(f, v.Then)
		}
		if v.Els != nil {
			f.Visit(f, v.Els)
		}
	case *MemberAccess:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
		if v.Target != nil {
			f.Visit(f, v.Target)
		}
	case *Paren:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
		if v.Expr != nil {
			f.Visit(f, v.Expr)
		}
	case *Index:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
		if v.Expr != nil {
			f.Visit(f, v.Expr)
		}
		if v.Index != nil {
			f.Visit(f, v.Index)
		}
	case *Match:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
		if v.Cond != nil {
			f.Visit(f, v.Cond)
		}
		for _, w := range v.Branch {
			f.Visit(f, w)
		}
	case *Range:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
		if v.Start != nil {
			f.Visit(f, v.Start)
		}
		if v.End != nil {
			f.Visit(f, v.End)
		}
	case *TmpVar:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
	case *BlockExpr:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
		for _, w := range v.Calls {
			f.Visit(f, w)
		}
		if v.Expr != nil {
			f.Visit(f, v.Expr)
		}
	case *Import:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
		if v.Base != nil {
			f.Visit(f, v.Base)
		}
		if v.ImportDesc != nil {
			f.Visit(f, v.ImportDesc)
		}
	case *IntLiteral:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
	case *BoolLiteral:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
	case *StrLiteral:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
	case *Input:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
	case *Output:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
	case *Config:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
	case *Loop:
		if v.Init != nil {
			f.Visit(f, v.Init)
		}
		if v.Cond != nil {
			f.Visit(f, v.Cond)
		}
		if v.Step != nil {
			f.Visit(f, v.Step)
		}
		if v.Body != nil {
			f.Visit(f, v.Body)
		}
	case *IndentBlock:
		for _, w := range v.Elements {
			f.Visit(f, w)
		}
		if v.StructType != nil {
			f.Visit(f, v.StructType)
		}
	case *MatchBranch:
		if v.Cond != nil {
			f.Visit(f, v.Cond)
		}
		if v.Then != nil {
			f.Visit(f, v.Then)
		}
	case *Return:
		if v.Expr != nil {
			f.Visit(f, v.Expr)
		}
	case *Break:
	case *Continue:
	case *Assert:
		if v.Cond != nil {
			f.Visit(f, v.Cond)
		}
	case *ImplicitYield:
		if v.Expr != nil {
			f.Visit(f, v.Expr)
		}
	case *Field:
		if v.Ident != nil {
			f.Visit(f, v.Ident)
		}
		if v.FieldType != nil {
			f.Visit(f, v.FieldType)
		}
		if v.RawArguments != nil {
			f.Visit(f, v.RawArguments)
		}
		for _, w := range v.Arguments {
			f.Visit(f, w)
		}
	case *Format:
		if v.Ident != nil {
			f.Visit(f, v.Ident)
		}
		if v.Body != nil {
			f.Visit(f, v.Body)
		}
	case *Function:
		if v.Ident != nil {
			f.Visit(f, v.Ident)
		}
		for _, w := range v.Parameters {
			f.Visit(f, w)
		}
		if v.ReturnType != nil {
			f.Visit(f, v.ReturnType)
		}
		if v.Body != nil {
			f.Visit(f, v.Body)
		}
		if v.FuncType != nil {
			f.Visit(f, v.FuncType)
		}
	case *IntType:
	case *IdentType:
		if v.Ident != nil {
			f.Visit(f, v.Ident)
		}
	case *IntLiteralType:
	case *StrLiteralType:
	case *VoidType:
	case *BoolType:
	case *ArrayType:
		if v.BaseType != nil {
			f.Visit(f, v.BaseType)
		}
		if v.Length != nil {
			f.Visit(f, v.Length)
		}
	case *FunctionType:
		if v.ReturnType != nil {
			f.Visit(f, v.ReturnType)
		}
		for _, w := range v.Parameters {
			f.Visit(f, w)
		}
	case *StructType:
		for _, w := range v.Fields {
			f.Visit(f, w)
		}
	case *StructUnionType:
		for _, w := range v.Fields {
			f.Visit(f, w)
		}
	case *Cast:
		if v.ExprType != nil {
			f.Visit(f, v.ExprType)
		}
		if v.Base != nil {
			f.Visit(f, v.Base)
		}
		if v.Expr != nil {
			f.Visit(f, v.Expr)
		}
	case *Comment:
	case *CommentGroup:
		for _, w := range v.Comments {
			f.Visit(f, w)
		}
	case *UnionType:
		for _, w := range v.Candidates {
			f.Visit(f, w)
		}
	case *UnionCandidate:
	case *RangeType:
		if v.BaseType != nil {
			f.Visit(f, v.BaseType)
		}
	case *Enum:
		if v.Ident != nil {
			f.Visit(f, v.Ident)
		}
	}
}
