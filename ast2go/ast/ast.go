// Code generated by gen_ast2go; DO NOT EDIT.

package ast

import (
	"encoding/json"
	"fmt"
)

type NodeType int

const (
	NodeTypeProgram         NodeType = 0
	NodeTypeComment         NodeType = 1
	NodeTypeCommentGroup    NodeType = 2
	NodeTypeFieldArgument   NodeType = 3
	NodeTypeExpr            NodeType = 4
	NodeTypeBinary          NodeType = 5
	NodeTypeUnary           NodeType = 6
	NodeTypeCond            NodeType = 7
	NodeTypeIdent           NodeType = 8
	NodeTypeCall            NodeType = 9
	NodeTypeIf              NodeType = 10
	NodeTypeMemberAccess    NodeType = 11
	NodeTypeParen           NodeType = 12
	NodeTypeIndex           NodeType = 13
	NodeTypeMatch           NodeType = 14
	NodeTypeRange           NodeType = 15
	NodeTypeTmpVar          NodeType = 16
	NodeTypeImport          NodeType = 17
	NodeTypeCast            NodeType = 18
	NodeTypeAvailable       NodeType = 19
	NodeTypeSpecifyEndian   NodeType = 20
	NodeTypeExplicitError   NodeType = 21
	NodeTypeIoOperation     NodeType = 22
	NodeTypeStmt            NodeType = 23
	NodeTypeLoop            NodeType = 24
	NodeTypeIndentBlock     NodeType = 25
	NodeTypeScopedStatement NodeType = 26
	NodeTypeMatchBranch     NodeType = 27
	NodeTypeUnionCandidate  NodeType = 28
	NodeTypeReturn          NodeType = 29
	NodeTypeBreak           NodeType = 30
	NodeTypeContinue        NodeType = 31
	NodeTypeAssert          NodeType = 32
	NodeTypeImplicitYield   NodeType = 33
	NodeTypeType            NodeType = 34
	NodeTypeIntType         NodeType = 35
	NodeTypeFloatType       NodeType = 36
	NodeTypeIdentType       NodeType = 37
	NodeTypeIntLiteralType  NodeType = 38
	NodeTypeStrLiteralType  NodeType = 39
	NodeTypeVoidType        NodeType = 40
	NodeTypeBoolType        NodeType = 41
	NodeTypeArrayType       NodeType = 42
	NodeTypeFunctionType    NodeType = 43
	NodeTypeStructType      NodeType = 44
	NodeTypeStructUnionType NodeType = 45
	NodeTypeUnionType       NodeType = 46
	NodeTypeRangeType       NodeType = 47
	NodeTypeEnumType        NodeType = 48
	NodeTypeMetaType        NodeType = 49
	NodeTypeOptionalType    NodeType = 50
	NodeTypeLiteral         NodeType = 51
	NodeTypeIntLiteral      NodeType = 52
	NodeTypeBoolLiteral     NodeType = 53
	NodeTypeStrLiteral      NodeType = 54
	NodeTypeTypeLiteral     NodeType = 55
	NodeTypeInput           NodeType = 56
	NodeTypeOutput          NodeType = 57
	NodeTypeConfig          NodeType = 58
	NodeTypeMember          NodeType = 59
	NodeTypeField           NodeType = 60
	NodeTypeFormat          NodeType = 61
	NodeTypeState           NodeType = 62
	NodeTypeEnum            NodeType = 63
	NodeTypeEnumMember      NodeType = 64
	NodeTypeFunction        NodeType = 65
	NodeTypeBuiltinMember   NodeType = 66
	NodeTypeBuiltinFunction NodeType = 67
	NodeTypeBuiltinField    NodeType = 68
	NodeTypeBuiltinObject   NodeType = 69
)

func (n NodeType) String() string {
	switch n {
	case NodeTypeProgram:
		return "program"
	case NodeTypeComment:
		return "comment"
	case NodeTypeCommentGroup:
		return "comment_group"
	case NodeTypeFieldArgument:
		return "field_argument"
	case NodeTypeExpr:
		return "expr"
	case NodeTypeBinary:
		return "binary"
	case NodeTypeUnary:
		return "unary"
	case NodeTypeCond:
		return "cond"
	case NodeTypeIdent:
		return "ident"
	case NodeTypeCall:
		return "call"
	case NodeTypeIf:
		return "if"
	case NodeTypeMemberAccess:
		return "member_access"
	case NodeTypeParen:
		return "paren"
	case NodeTypeIndex:
		return "index"
	case NodeTypeMatch:
		return "match"
	case NodeTypeRange:
		return "range"
	case NodeTypeTmpVar:
		return "tmp_var"
	case NodeTypeImport:
		return "import"
	case NodeTypeCast:
		return "cast"
	case NodeTypeAvailable:
		return "available"
	case NodeTypeSpecifyEndian:
		return "specify_endian"
	case NodeTypeExplicitError:
		return "explicit_error"
	case NodeTypeIoOperation:
		return "io_operation"
	case NodeTypeStmt:
		return "stmt"
	case NodeTypeLoop:
		return "loop"
	case NodeTypeIndentBlock:
		return "indent_block"
	case NodeTypeScopedStatement:
		return "scoped_statement"
	case NodeTypeMatchBranch:
		return "match_branch"
	case NodeTypeUnionCandidate:
		return "union_candidate"
	case NodeTypeReturn:
		return "return"
	case NodeTypeBreak:
		return "break"
	case NodeTypeContinue:
		return "continue"
	case NodeTypeAssert:
		return "assert"
	case NodeTypeImplicitYield:
		return "implicit_yield"
	case NodeTypeType:
		return "type"
	case NodeTypeIntType:
		return "int_type"
	case NodeTypeFloatType:
		return "float_type"
	case NodeTypeIdentType:
		return "ident_type"
	case NodeTypeIntLiteralType:
		return "int_literal_type"
	case NodeTypeStrLiteralType:
		return "str_literal_type"
	case NodeTypeVoidType:
		return "void_type"
	case NodeTypeBoolType:
		return "bool_type"
	case NodeTypeArrayType:
		return "array_type"
	case NodeTypeFunctionType:
		return "function_type"
	case NodeTypeStructType:
		return "struct_type"
	case NodeTypeStructUnionType:
		return "struct_union_type"
	case NodeTypeUnionType:
		return "union_type"
	case NodeTypeRangeType:
		return "range_type"
	case NodeTypeEnumType:
		return "enum_type"
	case NodeTypeMetaType:
		return "meta_type"
	case NodeTypeOptionalType:
		return "optional_type"
	case NodeTypeLiteral:
		return "literal"
	case NodeTypeIntLiteral:
		return "int_literal"
	case NodeTypeBoolLiteral:
		return "bool_literal"
	case NodeTypeStrLiteral:
		return "str_literal"
	case NodeTypeTypeLiteral:
		return "type_literal"
	case NodeTypeInput:
		return "input"
	case NodeTypeOutput:
		return "output"
	case NodeTypeConfig:
		return "config"
	case NodeTypeMember:
		return "member"
	case NodeTypeField:
		return "field"
	case NodeTypeFormat:
		return "format"
	case NodeTypeState:
		return "state"
	case NodeTypeEnum:
		return "enum"
	case NodeTypeEnumMember:
		return "enum_member"
	case NodeTypeFunction:
		return "function"
	case NodeTypeBuiltinMember:
		return "builtin_member"
	case NodeTypeBuiltinFunction:
		return "builtin_function"
	case NodeTypeBuiltinField:
		return "builtin_field"
	case NodeTypeBuiltinObject:
		return "builtin_object"
	default:
		return fmt.Sprintf("NodeType(%d)", n)
	}
}

func (n *NodeType) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "program":
		*n = NodeTypeProgram
	case "comment":
		*n = NodeTypeComment
	case "comment_group":
		*n = NodeTypeCommentGroup
	case "field_argument":
		*n = NodeTypeFieldArgument
	case "expr":
		*n = NodeTypeExpr
	case "binary":
		*n = NodeTypeBinary
	case "unary":
		*n = NodeTypeUnary
	case "cond":
		*n = NodeTypeCond
	case "ident":
		*n = NodeTypeIdent
	case "call":
		*n = NodeTypeCall
	case "if":
		*n = NodeTypeIf
	case "member_access":
		*n = NodeTypeMemberAccess
	case "paren":
		*n = NodeTypeParen
	case "index":
		*n = NodeTypeIndex
	case "match":
		*n = NodeTypeMatch
	case "range":
		*n = NodeTypeRange
	case "tmp_var":
		*n = NodeTypeTmpVar
	case "import":
		*n = NodeTypeImport
	case "cast":
		*n = NodeTypeCast
	case "available":
		*n = NodeTypeAvailable
	case "specify_endian":
		*n = NodeTypeSpecifyEndian
	case "explicit_error":
		*n = NodeTypeExplicitError
	case "io_operation":
		*n = NodeTypeIoOperation
	case "stmt":
		*n = NodeTypeStmt
	case "loop":
		*n = NodeTypeLoop
	case "indent_block":
		*n = NodeTypeIndentBlock
	case "scoped_statement":
		*n = NodeTypeScopedStatement
	case "match_branch":
		*n = NodeTypeMatchBranch
	case "union_candidate":
		*n = NodeTypeUnionCandidate
	case "return":
		*n = NodeTypeReturn
	case "break":
		*n = NodeTypeBreak
	case "continue":
		*n = NodeTypeContinue
	case "assert":
		*n = NodeTypeAssert
	case "implicit_yield":
		*n = NodeTypeImplicitYield
	case "type":
		*n = NodeTypeType
	case "int_type":
		*n = NodeTypeIntType
	case "float_type":
		*n = NodeTypeFloatType
	case "ident_type":
		*n = NodeTypeIdentType
	case "int_literal_type":
		*n = NodeTypeIntLiteralType
	case "str_literal_type":
		*n = NodeTypeStrLiteralType
	case "void_type":
		*n = NodeTypeVoidType
	case "bool_type":
		*n = NodeTypeBoolType
	case "array_type":
		*n = NodeTypeArrayType
	case "function_type":
		*n = NodeTypeFunctionType
	case "struct_type":
		*n = NodeTypeStructType
	case "struct_union_type":
		*n = NodeTypeStructUnionType
	case "union_type":
		*n = NodeTypeUnionType
	case "range_type":
		*n = NodeTypeRangeType
	case "enum_type":
		*n = NodeTypeEnumType
	case "meta_type":
		*n = NodeTypeMetaType
	case "optional_type":
		*n = NodeTypeOptionalType
	case "literal":
		*n = NodeTypeLiteral
	case "int_literal":
		*n = NodeTypeIntLiteral
	case "bool_literal":
		*n = NodeTypeBoolLiteral
	case "str_literal":
		*n = NodeTypeStrLiteral
	case "type_literal":
		*n = NodeTypeTypeLiteral
	case "input":
		*n = NodeTypeInput
	case "output":
		*n = NodeTypeOutput
	case "config":
		*n = NodeTypeConfig
	case "member":
		*n = NodeTypeMember
	case "field":
		*n = NodeTypeField
	case "format":
		*n = NodeTypeFormat
	case "state":
		*n = NodeTypeState
	case "enum":
		*n = NodeTypeEnum
	case "enum_member":
		*n = NodeTypeEnumMember
	case "function":
		*n = NodeTypeFunction
	case "builtin_member":
		*n = NodeTypeBuiltinMember
	case "builtin_function":
		*n = NodeTypeBuiltinFunction
	case "builtin_field":
		*n = NodeTypeBuiltinField
	case "builtin_object":
		*n = NodeTypeBuiltinObject
	default:
		return fmt.Errorf("unknown NodeType: %q", tmp)
	}
	return nil
}

func (n *Program) GetNodeType() NodeType {
	return NodeTypeProgram
}

func (n *Comment) GetNodeType() NodeType {
	return NodeTypeComment
}

func (n *CommentGroup) GetNodeType() NodeType {
	return NodeTypeCommentGroup
}

func (n *FieldArgument) GetNodeType() NodeType {
	return NodeTypeFieldArgument
}

func (n *Binary) GetNodeType() NodeType {
	return NodeTypeBinary
}

func (n *Unary) GetNodeType() NodeType {
	return NodeTypeUnary
}

func (n *Cond) GetNodeType() NodeType {
	return NodeTypeCond
}

func (n *Ident) GetNodeType() NodeType {
	return NodeTypeIdent
}

func (n *Call) GetNodeType() NodeType {
	return NodeTypeCall
}

func (n *If) GetNodeType() NodeType {
	return NodeTypeIf
}

func (n *MemberAccess) GetNodeType() NodeType {
	return NodeTypeMemberAccess
}

func (n *Paren) GetNodeType() NodeType {
	return NodeTypeParen
}

func (n *Index) GetNodeType() NodeType {
	return NodeTypeIndex
}

func (n *Match) GetNodeType() NodeType {
	return NodeTypeMatch
}

func (n *Range) GetNodeType() NodeType {
	return NodeTypeRange
}

func (n *TmpVar) GetNodeType() NodeType {
	return NodeTypeTmpVar
}

func (n *Import) GetNodeType() NodeType {
	return NodeTypeImport
}

func (n *Cast) GetNodeType() NodeType {
	return NodeTypeCast
}

func (n *Available) GetNodeType() NodeType {
	return NodeTypeAvailable
}

func (n *SpecifyEndian) GetNodeType() NodeType {
	return NodeTypeSpecifyEndian
}

func (n *ExplicitError) GetNodeType() NodeType {
	return NodeTypeExplicitError
}

func (n *IoOperation) GetNodeType() NodeType {
	return NodeTypeIoOperation
}

func (n *Loop) GetNodeType() NodeType {
	return NodeTypeLoop
}

func (n *IndentBlock) GetNodeType() NodeType {
	return NodeTypeIndentBlock
}

func (n *ScopedStatement) GetNodeType() NodeType {
	return NodeTypeScopedStatement
}

func (n *MatchBranch) GetNodeType() NodeType {
	return NodeTypeMatchBranch
}

func (n *UnionCandidate) GetNodeType() NodeType {
	return NodeTypeUnionCandidate
}

func (n *Return) GetNodeType() NodeType {
	return NodeTypeReturn
}

func (n *Break) GetNodeType() NodeType {
	return NodeTypeBreak
}

func (n *Continue) GetNodeType() NodeType {
	return NodeTypeContinue
}

func (n *Assert) GetNodeType() NodeType {
	return NodeTypeAssert
}

func (n *ImplicitYield) GetNodeType() NodeType {
	return NodeTypeImplicitYield
}

func (n *IntType) GetNodeType() NodeType {
	return NodeTypeIntType
}

func (n *FloatType) GetNodeType() NodeType {
	return NodeTypeFloatType
}

func (n *IdentType) GetNodeType() NodeType {
	return NodeTypeIdentType
}

func (n *IntLiteralType) GetNodeType() NodeType {
	return NodeTypeIntLiteralType
}

func (n *StrLiteralType) GetNodeType() NodeType {
	return NodeTypeStrLiteralType
}

func (n *VoidType) GetNodeType() NodeType {
	return NodeTypeVoidType
}

func (n *BoolType) GetNodeType() NodeType {
	return NodeTypeBoolType
}

func (n *ArrayType) GetNodeType() NodeType {
	return NodeTypeArrayType
}

func (n *FunctionType) GetNodeType() NodeType {
	return NodeTypeFunctionType
}

func (n *StructType) GetNodeType() NodeType {
	return NodeTypeStructType
}

func (n *StructUnionType) GetNodeType() NodeType {
	return NodeTypeStructUnionType
}

func (n *UnionType) GetNodeType() NodeType {
	return NodeTypeUnionType
}

func (n *RangeType) GetNodeType() NodeType {
	return NodeTypeRangeType
}

func (n *EnumType) GetNodeType() NodeType {
	return NodeTypeEnumType
}

func (n *MetaType) GetNodeType() NodeType {
	return NodeTypeMetaType
}

func (n *OptionalType) GetNodeType() NodeType {
	return NodeTypeOptionalType
}

func (n *IntLiteral) GetNodeType() NodeType {
	return NodeTypeIntLiteral
}

func (n *BoolLiteral) GetNodeType() NodeType {
	return NodeTypeBoolLiteral
}

func (n *StrLiteral) GetNodeType() NodeType {
	return NodeTypeStrLiteral
}

func (n *TypeLiteral) GetNodeType() NodeType {
	return NodeTypeTypeLiteral
}

func (n *Input) GetNodeType() NodeType {
	return NodeTypeInput
}

func (n *Output) GetNodeType() NodeType {
	return NodeTypeOutput
}

func (n *Config) GetNodeType() NodeType {
	return NodeTypeConfig
}

func (n *Field) GetNodeType() NodeType {
	return NodeTypeField
}

func (n *Format) GetNodeType() NodeType {
	return NodeTypeFormat
}

func (n *State) GetNodeType() NodeType {
	return NodeTypeState
}

func (n *Enum) GetNodeType() NodeType {
	return NodeTypeEnum
}

func (n *EnumMember) GetNodeType() NodeType {
	return NodeTypeEnumMember
}

func (n *Function) GetNodeType() NodeType {
	return NodeTypeFunction
}

func (n *BuiltinFunction) GetNodeType() NodeType {
	return NodeTypeBuiltinFunction
}

func (n *BuiltinField) GetNodeType() NodeType {
	return NodeTypeBuiltinField
}

func (n *BuiltinObject) GetNodeType() NodeType {
	return NodeTypeBuiltinObject
}

type TokenTag int

const (
	TokenTagIndent      TokenTag = 0
	TokenTagSpace       TokenTag = 1
	TokenTagLine        TokenTag = 2
	TokenTagPunct       TokenTag = 3
	TokenTagIntLiteral  TokenTag = 4
	TokenTagBoolLiteral TokenTag = 5
	TokenTagStrLiteral  TokenTag = 6
	TokenTagKeyword     TokenTag = 7
	TokenTagIdent       TokenTag = 8
	TokenTagComment     TokenTag = 9
	TokenTagError       TokenTag = 10
	TokenTagUnknown     TokenTag = 11
)

func (n TokenTag) String() string {
	switch n {
	case TokenTagIndent:
		return "indent"
	case TokenTagSpace:
		return "space"
	case TokenTagLine:
		return "line"
	case TokenTagPunct:
		return "punct"
	case TokenTagIntLiteral:
		return "int_literal"
	case TokenTagBoolLiteral:
		return "bool_literal"
	case TokenTagStrLiteral:
		return "str_literal"
	case TokenTagKeyword:
		return "keyword"
	case TokenTagIdent:
		return "ident"
	case TokenTagComment:
		return "comment"
	case TokenTagError:
		return "error"
	case TokenTagUnknown:
		return "unknown"
	default:
		return fmt.Sprintf("TokenTag(%d)", n)
	}
}

func (n *TokenTag) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "indent":
		*n = TokenTagIndent
	case "space":
		*n = TokenTagSpace
	case "line":
		*n = TokenTagLine
	case "punct":
		*n = TokenTagPunct
	case "int_literal":
		*n = TokenTagIntLiteral
	case "bool_literal":
		*n = TokenTagBoolLiteral
	case "str_literal":
		*n = TokenTagStrLiteral
	case "keyword":
		*n = TokenTagKeyword
	case "ident":
		*n = TokenTagIdent
	case "comment":
		*n = TokenTagComment
	case "error":
		*n = TokenTagError
	case "unknown":
		*n = TokenTagUnknown
	default:
		return fmt.Errorf("unknown TokenTag: %q", tmp)
	}
	return nil
}

type UnaryOp int

const (
	UnaryOpNot       UnaryOp = 0
	UnaryOpMinusSign UnaryOp = 1
)

func (n UnaryOp) String() string {
	switch n {
	case UnaryOpNot:
		return "!"
	case UnaryOpMinusSign:
		return "-"
	default:
		return fmt.Sprintf("UnaryOp(%d)", n)
	}
}

func (n *UnaryOp) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "!":
		*n = UnaryOpNot
	case "-":
		*n = UnaryOpMinusSign
	default:
		return fmt.Errorf("unknown UnaryOp: %q", tmp)
	}
	return nil
}

type BinaryOp int

const (
	BinaryOpMul                  BinaryOp = 0
	BinaryOpDiv                  BinaryOp = 1
	BinaryOpMod                  BinaryOp = 2
	BinaryOpLeftArithmeticShift  BinaryOp = 3
	BinaryOpRightArithmeticShift BinaryOp = 4
	BinaryOpLeftLogicalShift     BinaryOp = 5
	BinaryOpRightLogicalShift    BinaryOp = 6
	BinaryOpBitAnd               BinaryOp = 7
	BinaryOpAdd                  BinaryOp = 8
	BinaryOpSub                  BinaryOp = 9
	BinaryOpBitOr                BinaryOp = 10
	BinaryOpBitXor               BinaryOp = 11
	BinaryOpEqual                BinaryOp = 12
	BinaryOpNotEqual             BinaryOp = 13
	BinaryOpLess                 BinaryOp = 14
	BinaryOpLessOrEq             BinaryOp = 15
	BinaryOpGrater               BinaryOp = 16
	BinaryOpGraterOrEq           BinaryOp = 17
	BinaryOpLogicalAnd           BinaryOp = 18
	BinaryOpLogicalOr            BinaryOp = 19
	BinaryOpCondOp1              BinaryOp = 20
	BinaryOpCondOp2              BinaryOp = 21
	BinaryOpRangeExclusive       BinaryOp = 22
	BinaryOpRangeInclusive       BinaryOp = 23
	BinaryOpAssign               BinaryOp = 24
	BinaryOpDefineAssign         BinaryOp = 25
	BinaryOpConstAssign          BinaryOp = 26
	BinaryOpAddAssign            BinaryOp = 27
	BinaryOpSubAssign            BinaryOp = 28
	BinaryOpMulAssign            BinaryOp = 29
	BinaryOpDivAssign            BinaryOp = 30
	BinaryOpModAssign            BinaryOp = 31
	BinaryOpLeftShiftAssign      BinaryOp = 32
	BinaryOpRightShiftAssign     BinaryOp = 33
	BinaryOpBitAndAssign         BinaryOp = 34
	BinaryOpBitOrAssign          BinaryOp = 35
	BinaryOpBitXorAssign         BinaryOp = 36
	BinaryOpComma                BinaryOp = 37
)

func (n BinaryOp) String() string {
	switch n {
	case BinaryOpMul:
		return "*"
	case BinaryOpDiv:
		return "/"
	case BinaryOpMod:
		return "%"
	case BinaryOpLeftArithmeticShift:
		return "<<<"
	case BinaryOpRightArithmeticShift:
		return ">>>"
	case BinaryOpLeftLogicalShift:
		return "<<"
	case BinaryOpRightLogicalShift:
		return ">>"
	case BinaryOpBitAnd:
		return "&"
	case BinaryOpAdd:
		return "+"
	case BinaryOpSub:
		return "-"
	case BinaryOpBitOr:
		return "|"
	case BinaryOpBitXor:
		return "^"
	case BinaryOpEqual:
		return "=="
	case BinaryOpNotEqual:
		return "!="
	case BinaryOpLess:
		return "<"
	case BinaryOpLessOrEq:
		return "<="
	case BinaryOpGrater:
		return ">"
	case BinaryOpGraterOrEq:
		return ">="
	case BinaryOpLogicalAnd:
		return "&&"
	case BinaryOpLogicalOr:
		return "||"
	case BinaryOpCondOp1:
		return "?"
	case BinaryOpCondOp2:
		return ":"
	case BinaryOpRangeExclusive:
		return ".."
	case BinaryOpRangeInclusive:
		return "..="
	case BinaryOpAssign:
		return "="
	case BinaryOpDefineAssign:
		return ":="
	case BinaryOpConstAssign:
		return "::="
	case BinaryOpAddAssign:
		return "+="
	case BinaryOpSubAssign:
		return "-="
	case BinaryOpMulAssign:
		return "*="
	case BinaryOpDivAssign:
		return "/="
	case BinaryOpModAssign:
		return "%="
	case BinaryOpLeftShiftAssign:
		return "<<="
	case BinaryOpRightShiftAssign:
		return ">>="
	case BinaryOpBitAndAssign:
		return "&="
	case BinaryOpBitOrAssign:
		return "|="
	case BinaryOpBitXorAssign:
		return "^="
	case BinaryOpComma:
		return ","
	default:
		return fmt.Sprintf("BinaryOp(%d)", n)
	}
}

func (n *BinaryOp) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "*":
		*n = BinaryOpMul
	case "/":
		*n = BinaryOpDiv
	case "%":
		*n = BinaryOpMod
	case "<<<":
		*n = BinaryOpLeftArithmeticShift
	case ">>>":
		*n = BinaryOpRightArithmeticShift
	case "<<":
		*n = BinaryOpLeftLogicalShift
	case ">>":
		*n = BinaryOpRightLogicalShift
	case "&":
		*n = BinaryOpBitAnd
	case "+":
		*n = BinaryOpAdd
	case "-":
		*n = BinaryOpSub
	case "|":
		*n = BinaryOpBitOr
	case "^":
		*n = BinaryOpBitXor
	case "==":
		*n = BinaryOpEqual
	case "!=":
		*n = BinaryOpNotEqual
	case "<":
		*n = BinaryOpLess
	case "<=":
		*n = BinaryOpLessOrEq
	case ">":
		*n = BinaryOpGrater
	case ">=":
		*n = BinaryOpGraterOrEq
	case "&&":
		*n = BinaryOpLogicalAnd
	case "||":
		*n = BinaryOpLogicalOr
	case "?":
		*n = BinaryOpCondOp1
	case ":":
		*n = BinaryOpCondOp2
	case "..":
		*n = BinaryOpRangeExclusive
	case "..=":
		*n = BinaryOpRangeInclusive
	case "=":
		*n = BinaryOpAssign
	case ":=":
		*n = BinaryOpDefineAssign
	case "::=":
		*n = BinaryOpConstAssign
	case "+=":
		*n = BinaryOpAddAssign
	case "-=":
		*n = BinaryOpSubAssign
	case "*=":
		*n = BinaryOpMulAssign
	case "/=":
		*n = BinaryOpDivAssign
	case "%=":
		*n = BinaryOpModAssign
	case "<<=":
		*n = BinaryOpLeftShiftAssign
	case ">>=":
		*n = BinaryOpRightShiftAssign
	case "&=":
		*n = BinaryOpBitAndAssign
	case "|=":
		*n = BinaryOpBitOrAssign
	case "^=":
		*n = BinaryOpBitXorAssign
	case ",":
		*n = BinaryOpComma
	default:
		return fmt.Errorf("unknown BinaryOp: %q", tmp)
	}
	return nil
}

type IdentUsage int

const (
	IdentUsageUnknown            IdentUsage = 0
	IdentUsageReference          IdentUsage = 1
	IdentUsageDefineVariable     IdentUsage = 2
	IdentUsageDefineConst        IdentUsage = 3
	IdentUsageDefineField        IdentUsage = 4
	IdentUsageDefineFormat       IdentUsage = 5
	IdentUsageDefineState        IdentUsage = 6
	IdentUsageDefineEnum         IdentUsage = 7
	IdentUsageDefineEnumMember   IdentUsage = 8
	IdentUsageDefineFn           IdentUsage = 9
	IdentUsageDefineCastFn       IdentUsage = 10
	IdentUsageDefineArg          IdentUsage = 11
	IdentUsageReferenceType      IdentUsage = 12
	IdentUsageReferenceMember    IdentUsage = 13
	IdentUsageMaybeType          IdentUsage = 14
	IdentUsageReferenceBuiltinFn IdentUsage = 15
)

func (n IdentUsage) String() string {
	switch n {
	case IdentUsageUnknown:
		return "unknown"
	case IdentUsageReference:
		return "reference"
	case IdentUsageDefineVariable:
		return "define_variable"
	case IdentUsageDefineConst:
		return "define_const"
	case IdentUsageDefineField:
		return "define_field"
	case IdentUsageDefineFormat:
		return "define_format"
	case IdentUsageDefineState:
		return "define_state"
	case IdentUsageDefineEnum:
		return "define_enum"
	case IdentUsageDefineEnumMember:
		return "define_enum_member"
	case IdentUsageDefineFn:
		return "define_fn"
	case IdentUsageDefineCastFn:
		return "define_cast_fn"
	case IdentUsageDefineArg:
		return "define_arg"
	case IdentUsageReferenceType:
		return "reference_type"
	case IdentUsageReferenceMember:
		return "reference_member"
	case IdentUsageMaybeType:
		return "maybe_type"
	case IdentUsageReferenceBuiltinFn:
		return "reference_builtin_fn"
	default:
		return fmt.Sprintf("IdentUsage(%d)", n)
	}
}

func (n *IdentUsage) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "unknown":
		*n = IdentUsageUnknown
	case "reference":
		*n = IdentUsageReference
	case "define_variable":
		*n = IdentUsageDefineVariable
	case "define_const":
		*n = IdentUsageDefineConst
	case "define_field":
		*n = IdentUsageDefineField
	case "define_format":
		*n = IdentUsageDefineFormat
	case "define_state":
		*n = IdentUsageDefineState
	case "define_enum":
		*n = IdentUsageDefineEnum
	case "define_enum_member":
		*n = IdentUsageDefineEnumMember
	case "define_fn":
		*n = IdentUsageDefineFn
	case "define_cast_fn":
		*n = IdentUsageDefineCastFn
	case "define_arg":
		*n = IdentUsageDefineArg
	case "reference_type":
		*n = IdentUsageReferenceType
	case "reference_member":
		*n = IdentUsageReferenceMember
	case "maybe_type":
		*n = IdentUsageMaybeType
	case "reference_builtin_fn":
		*n = IdentUsageReferenceBuiltinFn
	default:
		return fmt.Errorf("unknown IdentUsage: %q", tmp)
	}
	return nil
}

type Endian int

const (
	EndianUnspec Endian = 0
	EndianBig    Endian = 1
	EndianLittle Endian = 2
)

func (n Endian) String() string {
	switch n {
	case EndianUnspec:
		return "unspec"
	case EndianBig:
		return "big"
	case EndianLittle:
		return "little"
	default:
		return fmt.Sprintf("Endian(%d)", n)
	}
}

func (n *Endian) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "unspec":
		*n = EndianUnspec
	case "big":
		*n = EndianBig
	case "little":
		*n = EndianLittle
	default:
		return fmt.Errorf("unknown Endian: %q", tmp)
	}
	return nil
}

type ConstantLevel int

const (
	ConstantLevelUnknown       ConstantLevel = 0
	ConstantLevelConstant      ConstantLevel = 1
	ConstantLevelConstVariable ConstantLevel = 2
	ConstantLevelVariable      ConstantLevel = 3
)

func (n ConstantLevel) String() string {
	switch n {
	case ConstantLevelUnknown:
		return "unknown"
	case ConstantLevelConstant:
		return "constant"
	case ConstantLevelConstVariable:
		return "const_variable"
	case ConstantLevelVariable:
		return "variable"
	default:
		return fmt.Sprintf("ConstantLevel(%d)", n)
	}
}

func (n *ConstantLevel) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "unknown":
		*n = ConstantLevelUnknown
	case "constant":
		*n = ConstantLevelConstant
	case "const_variable":
		*n = ConstantLevelConstVariable
	case "variable":
		*n = ConstantLevelVariable
	default:
		return fmt.Errorf("unknown ConstantLevel: %q", tmp)
	}
	return nil
}

type BitAlignment int

const (
	BitAlignmentByteAligned  BitAlignment = 0
	BitAlignmentBit1         BitAlignment = 1
	BitAlignmentBit2         BitAlignment = 2
	BitAlignmentBit3         BitAlignment = 3
	BitAlignmentBit4         BitAlignment = 4
	BitAlignmentBit5         BitAlignment = 5
	BitAlignmentBit6         BitAlignment = 6
	BitAlignmentBit7         BitAlignment = 7
	BitAlignmentNotTarget    BitAlignment = 8
	BitAlignmentNotDecidable BitAlignment = 9
)

func (n BitAlignment) String() string {
	switch n {
	case BitAlignmentByteAligned:
		return "byte_aligned"
	case BitAlignmentBit1:
		return "bit_1"
	case BitAlignmentBit2:
		return "bit_2"
	case BitAlignmentBit3:
		return "bit_3"
	case BitAlignmentBit4:
		return "bit_4"
	case BitAlignmentBit5:
		return "bit_5"
	case BitAlignmentBit6:
		return "bit_6"
	case BitAlignmentBit7:
		return "bit_7"
	case BitAlignmentNotTarget:
		return "not_target"
	case BitAlignmentNotDecidable:
		return "not_decidable"
	default:
		return fmt.Sprintf("BitAlignment(%d)", n)
	}
}

func (n *BitAlignment) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "byte_aligned":
		*n = BitAlignmentByteAligned
	case "bit_1":
		*n = BitAlignmentBit1
	case "bit_2":
		*n = BitAlignmentBit2
	case "bit_3":
		*n = BitAlignmentBit3
	case "bit_4":
		*n = BitAlignmentBit4
	case "bit_5":
		*n = BitAlignmentBit5
	case "bit_6":
		*n = BitAlignmentBit6
	case "bit_7":
		*n = BitAlignmentBit7
	case "not_target":
		*n = BitAlignmentNotTarget
	case "not_decidable":
		*n = BitAlignmentNotDecidable
	default:
		return fmt.Errorf("unknown BitAlignment: %q", tmp)
	}
	return nil
}

type Follow int

const (
	FollowUnknown  Follow = 0
	FollowEnd      Follow = 1
	FollowFixed    Follow = 2
	FollowConstant Follow = 3
	FollowNormal   Follow = 4
)

func (n Follow) String() string {
	switch n {
	case FollowUnknown:
		return "unknown"
	case FollowEnd:
		return "end"
	case FollowFixed:
		return "fixed"
	case FollowConstant:
		return "constant"
	case FollowNormal:
		return "normal"
	default:
		return fmt.Sprintf("Follow(%d)", n)
	}
}

func (n *Follow) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "unknown":
		*n = FollowUnknown
	case "end":
		*n = FollowEnd
	case "fixed":
		*n = FollowFixed
	case "constant":
		*n = FollowConstant
	case "normal":
		*n = FollowNormal
	default:
		return fmt.Errorf("unknown Follow: %q", tmp)
	}
	return nil
}

type IoMethod int

const (
	IoMethodUnspec             IoMethod = 0
	IoMethodOutputPut          IoMethod = 1
	IoMethodInputPeek          IoMethod = 2
	IoMethodInputGet           IoMethod = 3
	IoMethodInputBackward      IoMethod = 4
	IoMethodInputOffset        IoMethod = 5
	IoMethodInputRemain        IoMethod = 6
	IoMethodInputSubrange      IoMethod = 7
	IoMethodConfigEndianLittle IoMethod = 8
	IoMethodConfigEndianBig    IoMethod = 9
	IoMethodConfigEndianNative IoMethod = 10
)

func (n IoMethod) String() string {
	switch n {
	case IoMethodUnspec:
		return "unspec"
	case IoMethodOutputPut:
		return "output_put"
	case IoMethodInputPeek:
		return "input_peek"
	case IoMethodInputGet:
		return "input_get"
	case IoMethodInputBackward:
		return "input_backward"
	case IoMethodInputOffset:
		return "input_offset"
	case IoMethodInputRemain:
		return "input_remain"
	case IoMethodInputSubrange:
		return "input_subrange"
	case IoMethodConfigEndianLittle:
		return "config_endian_little"
	case IoMethodConfigEndianBig:
		return "config_endian_big"
	case IoMethodConfigEndianNative:
		return "config_endian_native"
	default:
		return fmt.Sprintf("IoMethod(%d)", n)
	}
}

func (n *IoMethod) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "unspec":
		*n = IoMethodUnspec
	case "output_put":
		*n = IoMethodOutputPut
	case "input_peek":
		*n = IoMethodInputPeek
	case "input_get":
		*n = IoMethodInputGet
	case "input_backward":
		*n = IoMethodInputBackward
	case "input_offset":
		*n = IoMethodInputOffset
	case "input_remain":
		*n = IoMethodInputRemain
	case "input_subrange":
		*n = IoMethodInputSubrange
	case "config_endian_little":
		*n = IoMethodConfigEndianLittle
	case "config_endian_big":
		*n = IoMethodConfigEndianBig
	case "config_endian_native":
		*n = IoMethodConfigEndianNative
	default:
		return fmt.Errorf("unknown IoMethod: %q", tmp)
	}
	return nil
}

type Node interface {
	isNode()
	GetLoc() Loc
	GetNodeType() NodeType
}

type Expr interface {
	isExpr()
	Node
	GetExprType() Type
	GetConstantLevel() ConstantLevel
}

type Stmt interface {
	isStmt()
	Node
}

type Type interface {
	isType()
	Node
	GetIsExplicit() bool
	GetNonDynamic() bool
	GetBitAlignment() BitAlignment
	GetBitSize() *uint64
}

type Literal interface {
	isLiteral()
	Expr
}

type Member interface {
	isMember()
	Stmt
	GetBelong() Member
	GetBelongStruct() *StructType
	GetIdent() *Ident
}

type BuiltinMember interface {
	isBuiltinMember()
	Member
}

type Program struct {
	Loc         Loc
	StructType  *StructType
	Elements    []Node
	GlobalScope *Scope
}

func (n *Program) isNode() {}

func (n *Program) GetLoc() Loc {
	return n.Loc
}

type Comment struct {
	Loc     Loc
	Comment string
}

func (n *Comment) isNode() {}

func (n *Comment) GetLoc() Loc {
	return n.Loc
}

type CommentGroup struct {
	Loc      Loc
	Comments []*Comment
}

func (n *CommentGroup) isNode() {}

func (n *CommentGroup) GetLoc() Loc {
	return n.Loc
}

type FieldArgument struct {
	Loc                Loc
	RawArguments       Expr
	EndLoc             Loc
	CollectedArguments []Expr
	Arguments          []Expr
	Alignment          Expr
	AlignmentValue     *uint64
	SubByteLength      Expr
	SubByteBegin       Expr
}

func (n *FieldArgument) isNode() {}

func (n *FieldArgument) GetLoc() Loc {
	return n.Loc
}

type Binary struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	Op            BinaryOp
	Left          Expr
	Right         Expr
}

func (n *Binary) isExpr() {}

func (n *Binary) GetExprType() Type {
	return n.ExprType
}

func (n *Binary) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *Binary) isNode() {}

func (n *Binary) GetLoc() Loc {
	return n.Loc
}

type Unary struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	Op            UnaryOp
	Expr          Expr
}

func (n *Unary) isExpr() {}

func (n *Unary) GetExprType() Type {
	return n.ExprType
}

func (n *Unary) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *Unary) isNode() {}

func (n *Unary) GetLoc() Loc {
	return n.Loc
}

type Cond struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	Cond          Expr
	Then          Expr
	ElsLoc        Loc
	Els           Expr
}

func (n *Cond) isExpr() {}

func (n *Cond) GetExprType() Type {
	return n.ExprType
}

func (n *Cond) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *Cond) isNode() {}

func (n *Cond) GetLoc() Loc {
	return n.Loc
}

type Ident struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	Ident         string
	Usage         IdentUsage
	Base          Node
	Scope         *Scope
}

func (n *Ident) isExpr() {}

func (n *Ident) GetExprType() Type {
	return n.ExprType
}

func (n *Ident) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *Ident) isNode() {}

func (n *Ident) GetLoc() Loc {
	return n.Loc
}

type Call struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	Callee        Expr
	RawArguments  Expr
	Arguments     []Expr
	EndLoc        Loc
}

func (n *Call) isExpr() {}

func (n *Call) GetExprType() Type {
	return n.ExprType
}

func (n *Call) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *Call) isNode() {}

func (n *Call) GetLoc() Loc {
	return n.Loc
}

type If struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	CondScope     *Scope
	Cond          Expr
	Then          *IndentBlock
	Els           Node
}

func (n *If) isExpr() {}

func (n *If) GetExprType() Type {
	return n.ExprType
}

func (n *If) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *If) isNode() {}

func (n *If) GetLoc() Loc {
	return n.Loc
}

type MemberAccess struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	Target        Expr
	Member        *Ident
	Base          *Ident
}

func (n *MemberAccess) isExpr() {}

func (n *MemberAccess) GetExprType() Type {
	return n.ExprType
}

func (n *MemberAccess) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *MemberAccess) isNode() {}

func (n *MemberAccess) GetLoc() Loc {
	return n.Loc
}

type Paren struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	Expr          Expr
	EndLoc        Loc
}

func (n *Paren) isExpr() {}

func (n *Paren) GetExprType() Type {
	return n.ExprType
}

func (n *Paren) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *Paren) isNode() {}

func (n *Paren) GetLoc() Loc {
	return n.Loc
}

type Index struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	Expr          Expr
	Index         Expr
	EndLoc        Loc
}

func (n *Index) isExpr() {}

func (n *Index) GetExprType() Type {
	return n.ExprType
}

func (n *Index) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *Index) isNode() {}

func (n *Index) GetLoc() Loc {
	return n.Loc
}

type Match struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	CondScope     *Scope
	Cond          Expr
	Branch        []Node
}

func (n *Match) isExpr() {}

func (n *Match) GetExprType() Type {
	return n.ExprType
}

func (n *Match) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *Match) isNode() {}

func (n *Match) GetLoc() Loc {
	return n.Loc
}

type Range struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	Op            BinaryOp
	Start         Expr
	End           Expr
}

func (n *Range) isExpr() {}

func (n *Range) GetExprType() Type {
	return n.ExprType
}

func (n *Range) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *Range) isNode() {}

func (n *Range) GetLoc() Loc {
	return n.Loc
}

type TmpVar struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	TmpVar        uint64
}

func (n *TmpVar) isExpr() {}

func (n *TmpVar) GetExprType() Type {
	return n.ExprType
}

func (n *TmpVar) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *TmpVar) isNode() {}

func (n *TmpVar) GetLoc() Loc {
	return n.Loc
}

type Import struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	Path          string
	Base          *Call
	ImportDesc    *Program
}

func (n *Import) isExpr() {}

func (n *Import) GetExprType() Type {
	return n.ExprType
}

func (n *Import) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *Import) isNode() {}

func (n *Import) GetLoc() Loc {
	return n.Loc
}

type Cast struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	Base          *Call
	Expr          Expr
}

func (n *Cast) isExpr() {}

func (n *Cast) GetExprType() Type {
	return n.ExprType
}

func (n *Cast) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *Cast) isNode() {}

func (n *Cast) GetLoc() Loc {
	return n.Loc
}

type Available struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	Base          *Call
	Target        Expr
}

func (n *Available) isExpr() {}

func (n *Available) GetExprType() Type {
	return n.ExprType
}

func (n *Available) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *Available) isNode() {}

func (n *Available) GetLoc() Loc {
	return n.Loc
}

type SpecifyEndian struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	Base          *Binary
	Endian        Expr
	EndianValue   *uint64
}

func (n *SpecifyEndian) isExpr() {}

func (n *SpecifyEndian) GetExprType() Type {
	return n.ExprType
}

func (n *SpecifyEndian) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *SpecifyEndian) isNode() {}

func (n *SpecifyEndian) GetLoc() Loc {
	return n.Loc
}

type ExplicitError struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	Base          *Call
	Message       *StrLiteral
}

func (n *ExplicitError) isExpr() {}

func (n *ExplicitError) GetExprType() Type {
	return n.ExprType
}

func (n *ExplicitError) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *ExplicitError) isNode() {}

func (n *ExplicitError) GetLoc() Loc {
	return n.Loc
}

type IoOperation struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	Base          Expr
	Method        IoMethod
	Arguments     []Expr
}

func (n *IoOperation) isExpr() {}

func (n *IoOperation) GetExprType() Type {
	return n.ExprType
}

func (n *IoOperation) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *IoOperation) isNode() {}

func (n *IoOperation) GetLoc() Loc {
	return n.Loc
}

type Loop struct {
	Loc       Loc
	CondScope *Scope
	Init      Expr
	Cond      Expr
	Step      Expr
	Body      *IndentBlock
}

func (n *Loop) isStmt() {}

func (n *Loop) isNode() {}

func (n *Loop) GetLoc() Loc {
	return n.Loc
}

type IndentBlock struct {
	Loc        Loc
	StructType *StructType
	Elements   []Node
	Scope      *Scope
}

func (n *IndentBlock) isStmt() {}

func (n *IndentBlock) isNode() {}

func (n *IndentBlock) GetLoc() Loc {
	return n.Loc
}

type ScopedStatement struct {
	Loc        Loc
	StructType *StructType
	Statement  Node
	Scope      *Scope
}

func (n *ScopedStatement) isStmt() {}

func (n *ScopedStatement) isNode() {}

func (n *ScopedStatement) GetLoc() Loc {
	return n.Loc
}

type MatchBranch struct {
	Loc    Loc
	Belong *Match
	Cond   Expr
	SymLoc Loc
	Then   Node
}

func (n *MatchBranch) isStmt() {}

func (n *MatchBranch) isNode() {}

func (n *MatchBranch) GetLoc() Loc {
	return n.Loc
}

type UnionCandidate struct {
	Loc   Loc
	Cond  Expr
	Field *Field
}

func (n *UnionCandidate) isStmt() {}

func (n *UnionCandidate) isNode() {}

func (n *UnionCandidate) GetLoc() Loc {
	return n.Loc
}

type Return struct {
	Loc  Loc
	Expr Expr
}

func (n *Return) isStmt() {}

func (n *Return) isNode() {}

func (n *Return) GetLoc() Loc {
	return n.Loc
}

type Break struct {
	Loc Loc
}

func (n *Break) isStmt() {}

func (n *Break) isNode() {}

func (n *Break) GetLoc() Loc {
	return n.Loc
}

type Continue struct {
	Loc Loc
}

func (n *Continue) isStmt() {}

func (n *Continue) isNode() {}

func (n *Continue) GetLoc() Loc {
	return n.Loc
}

type Assert struct {
	Loc         Loc
	Cond        *Binary
	IsIoRelated bool
}

func (n *Assert) isStmt() {}

func (n *Assert) isNode() {}

func (n *Assert) GetLoc() Loc {
	return n.Loc
}

type ImplicitYield struct {
	Loc  Loc
	Expr Expr
}

func (n *ImplicitYield) isStmt() {}

func (n *ImplicitYield) isNode() {}

func (n *ImplicitYield) GetLoc() Loc {
	return n.Loc
}

type IntType struct {
	Loc               Loc
	IsExplicit        bool
	NonDynamic        bool
	BitAlignment      BitAlignment
	BitSize           *uint64
	Endian            Endian
	IsSigned          bool
	IsCommonSupported bool
}

func (n *IntType) isType() {}

func (n *IntType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *IntType) GetNonDynamic() bool {
	return n.NonDynamic
}

func (n *IntType) GetBitAlignment() BitAlignment {
	return n.BitAlignment
}

func (n *IntType) GetBitSize() *uint64 {
	return n.BitSize
}

func (n *IntType) isNode() {}

func (n *IntType) GetLoc() Loc {
	return n.Loc
}

type FloatType struct {
	Loc               Loc
	IsExplicit        bool
	NonDynamic        bool
	BitAlignment      BitAlignment
	BitSize           *uint64
	Endian            Endian
	IsCommonSupported bool
}

func (n *FloatType) isType() {}

func (n *FloatType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *FloatType) GetNonDynamic() bool {
	return n.NonDynamic
}

func (n *FloatType) GetBitAlignment() BitAlignment {
	return n.BitAlignment
}

func (n *FloatType) GetBitSize() *uint64 {
	return n.BitSize
}

func (n *FloatType) isNode() {}

func (n *FloatType) GetLoc() Loc {
	return n.Loc
}

type IdentType struct {
	Loc          Loc
	IsExplicit   bool
	NonDynamic   bool
	BitAlignment BitAlignment
	BitSize      *uint64
	Ident        *Ident
	Base         Type
}

func (n *IdentType) isType() {}

func (n *IdentType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *IdentType) GetNonDynamic() bool {
	return n.NonDynamic
}

func (n *IdentType) GetBitAlignment() BitAlignment {
	return n.BitAlignment
}

func (n *IdentType) GetBitSize() *uint64 {
	return n.BitSize
}

func (n *IdentType) isNode() {}

func (n *IdentType) GetLoc() Loc {
	return n.Loc
}

type IntLiteralType struct {
	Loc          Loc
	IsExplicit   bool
	NonDynamic   bool
	BitAlignment BitAlignment
	BitSize      *uint64
	Base         *IntLiteral
}

func (n *IntLiteralType) isType() {}

func (n *IntLiteralType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *IntLiteralType) GetNonDynamic() bool {
	return n.NonDynamic
}

func (n *IntLiteralType) GetBitAlignment() BitAlignment {
	return n.BitAlignment
}

func (n *IntLiteralType) GetBitSize() *uint64 {
	return n.BitSize
}

func (n *IntLiteralType) isNode() {}

func (n *IntLiteralType) GetLoc() Loc {
	return n.Loc
}

type StrLiteralType struct {
	Loc          Loc
	IsExplicit   bool
	NonDynamic   bool
	BitAlignment BitAlignment
	BitSize      *uint64
	Base         *StrLiteral
	StrongRef    *StrLiteral
}

func (n *StrLiteralType) isType() {}

func (n *StrLiteralType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *StrLiteralType) GetNonDynamic() bool {
	return n.NonDynamic
}

func (n *StrLiteralType) GetBitAlignment() BitAlignment {
	return n.BitAlignment
}

func (n *StrLiteralType) GetBitSize() *uint64 {
	return n.BitSize
}

func (n *StrLiteralType) isNode() {}

func (n *StrLiteralType) GetLoc() Loc {
	return n.Loc
}

type VoidType struct {
	Loc          Loc
	IsExplicit   bool
	NonDynamic   bool
	BitAlignment BitAlignment
	BitSize      *uint64
}

func (n *VoidType) isType() {}

func (n *VoidType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *VoidType) GetNonDynamic() bool {
	return n.NonDynamic
}

func (n *VoidType) GetBitAlignment() BitAlignment {
	return n.BitAlignment
}

func (n *VoidType) GetBitSize() *uint64 {
	return n.BitSize
}

func (n *VoidType) isNode() {}

func (n *VoidType) GetLoc() Loc {
	return n.Loc
}

type BoolType struct {
	Loc          Loc
	IsExplicit   bool
	NonDynamic   bool
	BitAlignment BitAlignment
	BitSize      *uint64
}

func (n *BoolType) isType() {}

func (n *BoolType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *BoolType) GetNonDynamic() bool {
	return n.NonDynamic
}

func (n *BoolType) GetBitAlignment() BitAlignment {
	return n.BitAlignment
}

func (n *BoolType) GetBitSize() *uint64 {
	return n.BitSize
}

func (n *BoolType) isNode() {}

func (n *BoolType) GetLoc() Loc {
	return n.Loc
}

type ArrayType struct {
	Loc          Loc
	IsExplicit   bool
	NonDynamic   bool
	BitAlignment BitAlignment
	BitSize      *uint64
	EndLoc       Loc
	BaseType     Type
	Length       Expr
	LengthValue  *uint64
}

func (n *ArrayType) isType() {}

func (n *ArrayType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *ArrayType) GetNonDynamic() bool {
	return n.NonDynamic
}

func (n *ArrayType) GetBitAlignment() BitAlignment {
	return n.BitAlignment
}

func (n *ArrayType) GetBitSize() *uint64 {
	return n.BitSize
}

func (n *ArrayType) isNode() {}

func (n *ArrayType) GetLoc() Loc {
	return n.Loc
}

type FunctionType struct {
	Loc          Loc
	IsExplicit   bool
	NonDynamic   bool
	BitAlignment BitAlignment
	BitSize      *uint64
	ReturnType   Type
	Parameters   []Type
}

func (n *FunctionType) isType() {}

func (n *FunctionType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *FunctionType) GetNonDynamic() bool {
	return n.NonDynamic
}

func (n *FunctionType) GetBitAlignment() BitAlignment {
	return n.BitAlignment
}

func (n *FunctionType) GetBitSize() *uint64 {
	return n.BitSize
}

func (n *FunctionType) isNode() {}

func (n *FunctionType) GetLoc() Loc {
	return n.Loc
}

type StructType struct {
	Loc             Loc
	IsExplicit      bool
	NonDynamic      bool
	BitAlignment    BitAlignment
	BitSize         *uint64
	Fields          []Member
	Base            Node
	Recursive       bool
	FixedHeaderSize uint64
	FixedTailSize   uint64
}

func (n *StructType) isType() {}

func (n *StructType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *StructType) GetNonDynamic() bool {
	return n.NonDynamic
}

func (n *StructType) GetBitAlignment() BitAlignment {
	return n.BitAlignment
}

func (n *StructType) GetBitSize() *uint64 {
	return n.BitSize
}

func (n *StructType) isNode() {}

func (n *StructType) GetLoc() Loc {
	return n.Loc
}

type StructUnionType struct {
	Loc          Loc
	IsExplicit   bool
	NonDynamic   bool
	BitAlignment BitAlignment
	BitSize      *uint64
	Structs      []*StructType
	Base         Expr
	UnionFields  []*Field
}

func (n *StructUnionType) isType() {}

func (n *StructUnionType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *StructUnionType) GetNonDynamic() bool {
	return n.NonDynamic
}

func (n *StructUnionType) GetBitAlignment() BitAlignment {
	return n.BitAlignment
}

func (n *StructUnionType) GetBitSize() *uint64 {
	return n.BitSize
}

func (n *StructUnionType) isNode() {}

func (n *StructUnionType) GetLoc() Loc {
	return n.Loc
}

type UnionType struct {
	Loc          Loc
	IsExplicit   bool
	NonDynamic   bool
	BitAlignment BitAlignment
	BitSize      *uint64
	Cond         Expr
	Candidates   []*UnionCandidate
	BaseType     *StructUnionType
	CommonType   Type
}

func (n *UnionType) isType() {}

func (n *UnionType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *UnionType) GetNonDynamic() bool {
	return n.NonDynamic
}

func (n *UnionType) GetBitAlignment() BitAlignment {
	return n.BitAlignment
}

func (n *UnionType) GetBitSize() *uint64 {
	return n.BitSize
}

func (n *UnionType) isNode() {}

func (n *UnionType) GetLoc() Loc {
	return n.Loc
}

type RangeType struct {
	Loc          Loc
	IsExplicit   bool
	NonDynamic   bool
	BitAlignment BitAlignment
	BitSize      *uint64
	BaseType     Type
	Range        *Range
}

func (n *RangeType) isType() {}

func (n *RangeType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *RangeType) GetNonDynamic() bool {
	return n.NonDynamic
}

func (n *RangeType) GetBitAlignment() BitAlignment {
	return n.BitAlignment
}

func (n *RangeType) GetBitSize() *uint64 {
	return n.BitSize
}

func (n *RangeType) isNode() {}

func (n *RangeType) GetLoc() Loc {
	return n.Loc
}

type EnumType struct {
	Loc          Loc
	IsExplicit   bool
	NonDynamic   bool
	BitAlignment BitAlignment
	BitSize      *uint64
	Base         *Enum
}

func (n *EnumType) isType() {}

func (n *EnumType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *EnumType) GetNonDynamic() bool {
	return n.NonDynamic
}

func (n *EnumType) GetBitAlignment() BitAlignment {
	return n.BitAlignment
}

func (n *EnumType) GetBitSize() *uint64 {
	return n.BitSize
}

func (n *EnumType) isNode() {}

func (n *EnumType) GetLoc() Loc {
	return n.Loc
}

type MetaType struct {
	Loc          Loc
	IsExplicit   bool
	NonDynamic   bool
	BitAlignment BitAlignment
	BitSize      *uint64
}

func (n *MetaType) isType() {}

func (n *MetaType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *MetaType) GetNonDynamic() bool {
	return n.NonDynamic
}

func (n *MetaType) GetBitAlignment() BitAlignment {
	return n.BitAlignment
}

func (n *MetaType) GetBitSize() *uint64 {
	return n.BitSize
}

func (n *MetaType) isNode() {}

func (n *MetaType) GetLoc() Loc {
	return n.Loc
}

type OptionalType struct {
	Loc          Loc
	IsExplicit   bool
	NonDynamic   bool
	BitAlignment BitAlignment
	BitSize      *uint64
	BaseType     Type
}

func (n *OptionalType) isType() {}

func (n *OptionalType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *OptionalType) GetNonDynamic() bool {
	return n.NonDynamic
}

func (n *OptionalType) GetBitAlignment() BitAlignment {
	return n.BitAlignment
}

func (n *OptionalType) GetBitSize() *uint64 {
	return n.BitSize
}

func (n *OptionalType) isNode() {}

func (n *OptionalType) GetLoc() Loc {
	return n.Loc
}

type IntLiteral struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	Value         string
}

func (n *IntLiteral) isLiteral() {}

func (n *IntLiteral) isExpr() {}

func (n *IntLiteral) GetExprType() Type {
	return n.ExprType
}

func (n *IntLiteral) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *IntLiteral) isNode() {}

func (n *IntLiteral) GetLoc() Loc {
	return n.Loc
}

type BoolLiteral struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	Value         bool
}

func (n *BoolLiteral) isLiteral() {}

func (n *BoolLiteral) isExpr() {}

func (n *BoolLiteral) GetExprType() Type {
	return n.ExprType
}

func (n *BoolLiteral) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *BoolLiteral) isNode() {}

func (n *BoolLiteral) GetLoc() Loc {
	return n.Loc
}

type StrLiteral struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	Value         string
	Length        uint64
}

func (n *StrLiteral) isLiteral() {}

func (n *StrLiteral) isExpr() {}

func (n *StrLiteral) GetExprType() Type {
	return n.ExprType
}

func (n *StrLiteral) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *StrLiteral) isNode() {}

func (n *StrLiteral) GetLoc() Loc {
	return n.Loc
}

type TypeLiteral struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
	TypeLiteral   Type
	EndLoc        Loc
}

func (n *TypeLiteral) isLiteral() {}

func (n *TypeLiteral) isExpr() {}

func (n *TypeLiteral) GetExprType() Type {
	return n.ExprType
}

func (n *TypeLiteral) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *TypeLiteral) isNode() {}

func (n *TypeLiteral) GetLoc() Loc {
	return n.Loc
}

type Input struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
}

func (n *Input) isLiteral() {}

func (n *Input) isExpr() {}

func (n *Input) GetExprType() Type {
	return n.ExprType
}

func (n *Input) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *Input) isNode() {}

func (n *Input) GetLoc() Loc {
	return n.Loc
}

type Output struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
}

func (n *Output) isLiteral() {}

func (n *Output) isExpr() {}

func (n *Output) GetExprType() Type {
	return n.ExprType
}

func (n *Output) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *Output) isNode() {}

func (n *Output) GetLoc() Loc {
	return n.Loc
}

type Config struct {
	Loc           Loc
	ExprType      Type
	ConstantLevel ConstantLevel
}

func (n *Config) isLiteral() {}

func (n *Config) isExpr() {}

func (n *Config) GetExprType() Type {
	return n.ExprType
}

func (n *Config) GetConstantLevel() ConstantLevel {
	return n.ConstantLevel
}

func (n *Config) isNode() {}

func (n *Config) GetLoc() Loc {
	return n.Loc
}

type Field struct {
	Loc              Loc
	Belong           Member
	BelongStruct     *StructType
	Ident            *Ident
	ColonLoc         Loc
	FieldType        Type
	Arguments        *FieldArgument
	OffsetBit        *uint64
	OffsetRecent     uint64
	TailOffsetBit    *uint64
	TailOffsetRecent uint64
	BitAlignment     BitAlignment
	Follow           Follow
	EventualFollow   Follow
}

func (n *Field) isMember() {}

func (n *Field) GetBelong() Member {
	return n.Belong
}

func (n *Field) GetBelongStruct() *StructType {
	return n.BelongStruct
}

func (n *Field) GetIdent() *Ident {
	return n.Ident
}

func (n *Field) isStmt() {}

func (n *Field) isNode() {}

func (n *Field) GetLoc() Loc {
	return n.Loc
}

type Format struct {
	Loc          Loc
	Belong       Member
	BelongStruct *StructType
	Ident        *Ident
	Body         *IndentBlock
	EncodeFn     *Function
	DecodeFn     *Function
	CastFns      []*Function
	Depends      []*IdentType
}

func (n *Format) isMember() {}

func (n *Format) GetBelong() Member {
	return n.Belong
}

func (n *Format) GetBelongStruct() *StructType {
	return n.BelongStruct
}

func (n *Format) GetIdent() *Ident {
	return n.Ident
}

func (n *Format) isStmt() {}

func (n *Format) isNode() {}

func (n *Format) GetLoc() Loc {
	return n.Loc
}

type State struct {
	Loc          Loc
	Belong       Member
	BelongStruct *StructType
	Ident        *Ident
	Body         *IndentBlock
}

func (n *State) isMember() {}

func (n *State) GetBelong() Member {
	return n.Belong
}

func (n *State) GetBelongStruct() *StructType {
	return n.BelongStruct
}

func (n *State) GetIdent() *Ident {
	return n.Ident
}

func (n *State) isStmt() {}

func (n *State) isNode() {}

func (n *State) GetLoc() Loc {
	return n.Loc
}

type Enum struct {
	Loc          Loc
	Belong       Member
	BelongStruct *StructType
	Ident        *Ident
	Scope        *Scope
	ColonLoc     Loc
	BaseType     Type
	Members      []*EnumMember
	EnumType     *EnumType
}

func (n *Enum) isMember() {}

func (n *Enum) GetBelong() Member {
	return n.Belong
}

func (n *Enum) GetBelongStruct() *StructType {
	return n.BelongStruct
}

func (n *Enum) GetIdent() *Ident {
	return n.Ident
}

func (n *Enum) isStmt() {}

func (n *Enum) isNode() {}

func (n *Enum) GetLoc() Loc {
	return n.Loc
}

type EnumMember struct {
	Loc          Loc
	Belong       Member
	BelongStruct *StructType
	Ident        *Ident
	Expr         Expr
}

func (n *EnumMember) isMember() {}

func (n *EnumMember) GetBelong() Member {
	return n.Belong
}

func (n *EnumMember) GetBelongStruct() *StructType {
	return n.BelongStruct
}

func (n *EnumMember) GetIdent() *Ident {
	return n.Ident
}

func (n *EnumMember) isStmt() {}

func (n *EnumMember) isNode() {}

func (n *EnumMember) GetLoc() Loc {
	return n.Loc
}

type Function struct {
	Loc          Loc
	Belong       Member
	BelongStruct *StructType
	Ident        *Ident
	Parameters   []*Field
	ReturnType   Type
	Body         *IndentBlock
	FuncType     *FunctionType
	IsCast       bool
	CastLoc      Loc
}

func (n *Function) isMember() {}

func (n *Function) GetBelong() Member {
	return n.Belong
}

func (n *Function) GetBelongStruct() *StructType {
	return n.BelongStruct
}

func (n *Function) GetIdent() *Ident {
	return n.Ident
}

func (n *Function) isStmt() {}

func (n *Function) isNode() {}

func (n *Function) GetLoc() Loc {
	return n.Loc
}

type BuiltinFunction struct {
	Loc          Loc
	Belong       Member
	BelongStruct *StructType
	Ident        *Ident
	FuncType     *FunctionType
}

func (n *BuiltinFunction) isMember() {}

func (n *BuiltinFunction) GetBelong() Member {
	return n.Belong
}

func (n *BuiltinFunction) GetBelongStruct() *StructType {
	return n.BelongStruct
}

func (n *BuiltinFunction) GetIdent() *Ident {
	return n.Ident
}

func (n *BuiltinFunction) isBuiltinMember() {}

func (n *BuiltinFunction) isStmt() {}

func (n *BuiltinFunction) isNode() {}

func (n *BuiltinFunction) GetLoc() Loc {
	return n.Loc
}

type BuiltinField struct {
	Loc          Loc
	Belong       Member
	BelongStruct *StructType
	Ident        *Ident
	FieldType    Type
}

func (n *BuiltinField) isMember() {}

func (n *BuiltinField) GetBelong() Member {
	return n.Belong
}

func (n *BuiltinField) GetBelongStruct() *StructType {
	return n.BelongStruct
}

func (n *BuiltinField) GetIdent() *Ident {
	return n.Ident
}

func (n *BuiltinField) isBuiltinMember() {}

func (n *BuiltinField) isStmt() {}

func (n *BuiltinField) isNode() {}

func (n *BuiltinField) GetLoc() Loc {
	return n.Loc
}

type BuiltinObject struct {
	Loc          Loc
	Belong       Member
	BelongStruct *StructType
	Ident        *Ident
	Members      []BuiltinMember
}

func (n *BuiltinObject) isMember() {}

func (n *BuiltinObject) GetBelong() Member {
	return n.Belong
}

func (n *BuiltinObject) GetBelongStruct() *StructType {
	return n.BelongStruct
}

func (n *BuiltinObject) GetIdent() *Ident {
	return n.Ident
}

func (n *BuiltinObject) isBuiltinMember() {}

func (n *BuiltinObject) isStmt() {}

func (n *BuiltinObject) isNode() {}

func (n *BuiltinObject) GetLoc() Loc {
	return n.Loc
}

type Scope struct {
	Prev       *Scope
	Next       *Scope
	Branch     *Scope
	Ident      []*Ident
	Owner      Node
	BranchRoot bool
}

type Pos struct {
	Begin uint64 `json:"begin"`
	End   uint64 `json:"end"`
}

type Loc struct {
	Pos  Pos    `json:"pos"`
	File uint64 `json:"file"`
	Line uint64 `json:"line"`
	Col  uint64 `json:"col"`
}

type Token struct {
	Tag   TokenTag `json:"tag"`
	Token string   `json:"token"`
	Loc   Loc      `json:"loc"`
}

type RawScope struct {
	Prev       *uintptr  `json:"prev"`
	Next       *uintptr  `json:"next"`
	Branch     *uintptr  `json:"branch"`
	Ident      []uintptr `json:"ident"`
	Owner      *uintptr  `json:"owner"`
	BranchRoot bool      `json:"branch_root"`
}

type RawNode struct {
	NodeType NodeType        `json:"node_type"`
	Loc      Loc             `json:"loc"`
	Body     json.RawMessage `json:"body"`
}

type SrcErrorEntry struct {
	Msg  string `json:"msg"`
	File string `json:"file"`
	Loc  Loc    `json:"loc"`
	Src  string `json:"src"`
	Warn bool   `json:"warn"`
}

type SrcError struct {
	Errs []SrcErrorEntry `json:"errs"`
}

type JsonAst struct {
	Node  []RawNode  `json:"node"`
	Scope []RawScope `json:"scope"`
}

type AstFile struct {
	Files []string  `json:"files"`
	Ast   *JsonAst  `json:"ast"`
	Error *SrcError `json:"error"`
}

type TokenFile struct {
	Files  []string  `json:"files"`
	Tokens []Token   `json:"tokens"`
	Error  *SrcError `json:"error"`
}

type astConstructor struct {
	node  []Node
	scope []*Scope
}

func ParseAST(aux *JsonAst) (prog *Program, err error) {
	defer func() {
		if r := recover(); r != nil {
			err = fmt.Errorf("%v", r)
		}
	}()
	n := &astConstructor{}
	n.node = make([]Node, len(aux.Node))
	for i, raw := range aux.Node {
		switch raw.NodeType {
		case NodeTypeProgram:
			n.node[i] = &Program{Loc: raw.Loc}
		case NodeTypeComment:
			n.node[i] = &Comment{Loc: raw.Loc}
		case NodeTypeCommentGroup:
			n.node[i] = &CommentGroup{Loc: raw.Loc}
		case NodeTypeFieldArgument:
			n.node[i] = &FieldArgument{Loc: raw.Loc}
		case NodeTypeBinary:
			n.node[i] = &Binary{Loc: raw.Loc}
		case NodeTypeUnary:
			n.node[i] = &Unary{Loc: raw.Loc}
		case NodeTypeCond:
			n.node[i] = &Cond{Loc: raw.Loc}
		case NodeTypeIdent:
			n.node[i] = &Ident{Loc: raw.Loc}
		case NodeTypeCall:
			n.node[i] = &Call{Loc: raw.Loc}
		case NodeTypeIf:
			n.node[i] = &If{Loc: raw.Loc}
		case NodeTypeMemberAccess:
			n.node[i] = &MemberAccess{Loc: raw.Loc}
		case NodeTypeParen:
			n.node[i] = &Paren{Loc: raw.Loc}
		case NodeTypeIndex:
			n.node[i] = &Index{Loc: raw.Loc}
		case NodeTypeMatch:
			n.node[i] = &Match{Loc: raw.Loc}
		case NodeTypeRange:
			n.node[i] = &Range{Loc: raw.Loc}
		case NodeTypeTmpVar:
			n.node[i] = &TmpVar{Loc: raw.Loc}
		case NodeTypeImport:
			n.node[i] = &Import{Loc: raw.Loc}
		case NodeTypeCast:
			n.node[i] = &Cast{Loc: raw.Loc}
		case NodeTypeAvailable:
			n.node[i] = &Available{Loc: raw.Loc}
		case NodeTypeSpecifyEndian:
			n.node[i] = &SpecifyEndian{Loc: raw.Loc}
		case NodeTypeExplicitError:
			n.node[i] = &ExplicitError{Loc: raw.Loc}
		case NodeTypeIoOperation:
			n.node[i] = &IoOperation{Loc: raw.Loc}
		case NodeTypeLoop:
			n.node[i] = &Loop{Loc: raw.Loc}
		case NodeTypeIndentBlock:
			n.node[i] = &IndentBlock{Loc: raw.Loc}
		case NodeTypeScopedStatement:
			n.node[i] = &ScopedStatement{Loc: raw.Loc}
		case NodeTypeMatchBranch:
			n.node[i] = &MatchBranch{Loc: raw.Loc}
		case NodeTypeUnionCandidate:
			n.node[i] = &UnionCandidate{Loc: raw.Loc}
		case NodeTypeReturn:
			n.node[i] = &Return{Loc: raw.Loc}
		case NodeTypeBreak:
			n.node[i] = &Break{Loc: raw.Loc}
		case NodeTypeContinue:
			n.node[i] = &Continue{Loc: raw.Loc}
		case NodeTypeAssert:
			n.node[i] = &Assert{Loc: raw.Loc}
		case NodeTypeImplicitYield:
			n.node[i] = &ImplicitYield{Loc: raw.Loc}
		case NodeTypeIntType:
			n.node[i] = &IntType{Loc: raw.Loc}
		case NodeTypeFloatType:
			n.node[i] = &FloatType{Loc: raw.Loc}
		case NodeTypeIdentType:
			n.node[i] = &IdentType{Loc: raw.Loc}
		case NodeTypeIntLiteralType:
			n.node[i] = &IntLiteralType{Loc: raw.Loc}
		case NodeTypeStrLiteralType:
			n.node[i] = &StrLiteralType{Loc: raw.Loc}
		case NodeTypeVoidType:
			n.node[i] = &VoidType{Loc: raw.Loc}
		case NodeTypeBoolType:
			n.node[i] = &BoolType{Loc: raw.Loc}
		case NodeTypeArrayType:
			n.node[i] = &ArrayType{Loc: raw.Loc}
		case NodeTypeFunctionType:
			n.node[i] = &FunctionType{Loc: raw.Loc}
		case NodeTypeStructType:
			n.node[i] = &StructType{Loc: raw.Loc}
		case NodeTypeStructUnionType:
			n.node[i] = &StructUnionType{Loc: raw.Loc}
		case NodeTypeUnionType:
			n.node[i] = &UnionType{Loc: raw.Loc}
		case NodeTypeRangeType:
			n.node[i] = &RangeType{Loc: raw.Loc}
		case NodeTypeEnumType:
			n.node[i] = &EnumType{Loc: raw.Loc}
		case NodeTypeMetaType:
			n.node[i] = &MetaType{Loc: raw.Loc}
		case NodeTypeOptionalType:
			n.node[i] = &OptionalType{Loc: raw.Loc}
		case NodeTypeIntLiteral:
			n.node[i] = &IntLiteral{Loc: raw.Loc}
		case NodeTypeBoolLiteral:
			n.node[i] = &BoolLiteral{Loc: raw.Loc}
		case NodeTypeStrLiteral:
			n.node[i] = &StrLiteral{Loc: raw.Loc}
		case NodeTypeTypeLiteral:
			n.node[i] = &TypeLiteral{Loc: raw.Loc}
		case NodeTypeInput:
			n.node[i] = &Input{Loc: raw.Loc}
		case NodeTypeOutput:
			n.node[i] = &Output{Loc: raw.Loc}
		case NodeTypeConfig:
			n.node[i] = &Config{Loc: raw.Loc}
		case NodeTypeField:
			n.node[i] = &Field{Loc: raw.Loc}
		case NodeTypeFormat:
			n.node[i] = &Format{Loc: raw.Loc}
		case NodeTypeState:
			n.node[i] = &State{Loc: raw.Loc}
		case NodeTypeEnum:
			n.node[i] = &Enum{Loc: raw.Loc}
		case NodeTypeEnumMember:
			n.node[i] = &EnumMember{Loc: raw.Loc}
		case NodeTypeFunction:
			n.node[i] = &Function{Loc: raw.Loc}
		case NodeTypeBuiltinFunction:
			n.node[i] = &BuiltinFunction{Loc: raw.Loc}
		case NodeTypeBuiltinField:
			n.node[i] = &BuiltinField{Loc: raw.Loc}
		case NodeTypeBuiltinObject:
			n.node[i] = &BuiltinObject{Loc: raw.Loc}
		default:
			return nil, fmt.Errorf("unknown node type: %q", raw.NodeType)
		}
	}
	n.scope = make([]*Scope, len(aux.Scope))
	for i := range aux.Scope {
		n.scope[i] = &Scope{}
	}
	for i, raw := range aux.Node {
		switch raw.NodeType {
		case NodeTypeProgram:
			v := n.node[i].(*Program)
			var tmp struct {
				StructType  *uintptr  `json:"struct_type"`
				Elements    []uintptr `json:"elements"`
				GlobalScope *uintptr  `json:"global_scope"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.StructType != nil {
				v.StructType = n.node[*tmp.StructType].(*StructType)
			}
			v.Elements = make([]Node, len(tmp.Elements))
			for j, k := range tmp.Elements {
				v.Elements[j] = n.node[k].(Node)
			}
			if tmp.GlobalScope != nil {
				v.GlobalScope = n.scope[*tmp.GlobalScope]
			}
		case NodeTypeComment:
			v := n.node[i].(*Comment)
			var tmp struct {
				Comment string `json:"comment"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.Comment = tmp.Comment
		case NodeTypeCommentGroup:
			v := n.node[i].(*CommentGroup)
			var tmp struct {
				Comments []uintptr `json:"comments"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.Comments = make([]*Comment, len(tmp.Comments))
			for j, k := range tmp.Comments {
				v.Comments[j] = n.node[k].(*Comment)
			}
		case NodeTypeFieldArgument:
			v := n.node[i].(*FieldArgument)
			var tmp struct {
				RawArguments       *uintptr  `json:"raw_arguments"`
				EndLoc             Loc       `json:"end_loc"`
				CollectedArguments []uintptr `json:"collected_arguments"`
				Arguments          []uintptr `json:"arguments"`
				Alignment          *uintptr  `json:"alignment"`
				AlignmentValue     *uint64   `json:"alignment_value"`
				SubByteLength      *uintptr  `json:"sub_byte_length"`
				SubByteBegin       *uintptr  `json:"sub_byte_begin"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.RawArguments != nil {
				v.RawArguments = n.node[*tmp.RawArguments].(Expr)
			}
			v.EndLoc = tmp.EndLoc
			v.CollectedArguments = make([]Expr, len(tmp.CollectedArguments))
			for j, k := range tmp.CollectedArguments {
				v.CollectedArguments[j] = n.node[k].(Expr)
			}
			v.Arguments = make([]Expr, len(tmp.Arguments))
			for j, k := range tmp.Arguments {
				v.Arguments[j] = n.node[k].(Expr)
			}
			if tmp.Alignment != nil {
				v.Alignment = n.node[*tmp.Alignment].(Expr)
			}
			v.AlignmentValue = tmp.AlignmentValue
			if tmp.SubByteLength != nil {
				v.SubByteLength = n.node[*tmp.SubByteLength].(Expr)
			}
			if tmp.SubByteBegin != nil {
				v.SubByteBegin = n.node[*tmp.SubByteBegin].(Expr)
			}
		case NodeTypeBinary:
			v := n.node[i].(*Binary)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				Op            BinaryOp      `json:"op"`
				Left          *uintptr      `json:"left"`
				Right         *uintptr      `json:"right"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			v.Op = tmp.Op
			if tmp.Left != nil {
				v.Left = n.node[*tmp.Left].(Expr)
			}
			if tmp.Right != nil {
				v.Right = n.node[*tmp.Right].(Expr)
			}
		case NodeTypeUnary:
			v := n.node[i].(*Unary)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				Op            UnaryOp       `json:"op"`
				Expr          *uintptr      `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			v.Op = tmp.Op
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		case NodeTypeCond:
			v := n.node[i].(*Cond)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				Cond          *uintptr      `json:"cond"`
				Then          *uintptr      `json:"then"`
				ElsLoc        Loc           `json:"els_loc"`
				Els           *uintptr      `json:"els"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			if tmp.Then != nil {
				v.Then = n.node[*tmp.Then].(Expr)
			}
			v.ElsLoc = tmp.ElsLoc
			if tmp.Els != nil {
				v.Els = n.node[*tmp.Els].(Expr)
			}
		case NodeTypeIdent:
			v := n.node[i].(*Ident)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				Ident         string        `json:"ident"`
				Usage         IdentUsage    `json:"usage"`
				Base          *uintptr      `json:"base"`
				Scope         *uintptr      `json:"scope"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			v.Ident = tmp.Ident
			v.Usage = tmp.Usage
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(Node)
			}
			if tmp.Scope != nil {
				v.Scope = n.scope[*tmp.Scope]
			}
		case NodeTypeCall:
			v := n.node[i].(*Call)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				Callee        *uintptr      `json:"callee"`
				RawArguments  *uintptr      `json:"raw_arguments"`
				Arguments     []uintptr     `json:"arguments"`
				EndLoc        Loc           `json:"end_loc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			if tmp.Callee != nil {
				v.Callee = n.node[*tmp.Callee].(Expr)
			}
			if tmp.RawArguments != nil {
				v.RawArguments = n.node[*tmp.RawArguments].(Expr)
			}
			v.Arguments = make([]Expr, len(tmp.Arguments))
			for j, k := range tmp.Arguments {
				v.Arguments[j] = n.node[k].(Expr)
			}
			v.EndLoc = tmp.EndLoc
		case NodeTypeIf:
			v := n.node[i].(*If)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				CondScope     *uintptr      `json:"cond_scope"`
				Cond          *uintptr      `json:"cond"`
				Then          *uintptr      `json:"then"`
				Els           *uintptr      `json:"els"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			if tmp.CondScope != nil {
				v.CondScope = n.scope[*tmp.CondScope]
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			if tmp.Then != nil {
				v.Then = n.node[*tmp.Then].(*IndentBlock)
			}
			if tmp.Els != nil {
				v.Els = n.node[*tmp.Els].(Node)
			}
		case NodeTypeMemberAccess:
			v := n.node[i].(*MemberAccess)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				Target        *uintptr      `json:"target"`
				Member        *uintptr      `json:"member"`
				Base          *uintptr      `json:"base"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			if tmp.Target != nil {
				v.Target = n.node[*tmp.Target].(Expr)
			}
			if tmp.Member != nil {
				v.Member = n.node[*tmp.Member].(*Ident)
			}
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*Ident)
			}
		case NodeTypeParen:
			v := n.node[i].(*Paren)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				Expr          *uintptr      `json:"expr"`
				EndLoc        Loc           `json:"end_loc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
			v.EndLoc = tmp.EndLoc
		case NodeTypeIndex:
			v := n.node[i].(*Index)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				Expr          *uintptr      `json:"expr"`
				Index         *uintptr      `json:"index"`
				EndLoc        Loc           `json:"end_loc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
			if tmp.Index != nil {
				v.Index = n.node[*tmp.Index].(Expr)
			}
			v.EndLoc = tmp.EndLoc
		case NodeTypeMatch:
			v := n.node[i].(*Match)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				CondScope     *uintptr      `json:"cond_scope"`
				Cond          *uintptr      `json:"cond"`
				Branch        []uintptr     `json:"branch"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			if tmp.CondScope != nil {
				v.CondScope = n.scope[*tmp.CondScope]
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			v.Branch = make([]Node, len(tmp.Branch))
			for j, k := range tmp.Branch {
				v.Branch[j] = n.node[k].(Node)
			}
		case NodeTypeRange:
			v := n.node[i].(*Range)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				Op            BinaryOp      `json:"op"`
				Start         *uintptr      `json:"start"`
				End           *uintptr      `json:"end"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			v.Op = tmp.Op
			if tmp.Start != nil {
				v.Start = n.node[*tmp.Start].(Expr)
			}
			if tmp.End != nil {
				v.End = n.node[*tmp.End].(Expr)
			}
		case NodeTypeTmpVar:
			v := n.node[i].(*TmpVar)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				TmpVar        uint64        `json:"tmp_var"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			v.TmpVar = tmp.TmpVar
		case NodeTypeImport:
			v := n.node[i].(*Import)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				Path          string        `json:"path"`
				Base          *uintptr      `json:"base"`
				ImportDesc    *uintptr      `json:"import_desc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			v.Path = tmp.Path
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*Call)
			}
			if tmp.ImportDesc != nil {
				v.ImportDesc = n.node[*tmp.ImportDesc].(*Program)
			}
		case NodeTypeCast:
			v := n.node[i].(*Cast)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				Base          *uintptr      `json:"base"`
				Expr          *uintptr      `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*Call)
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		case NodeTypeAvailable:
			v := n.node[i].(*Available)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				Base          *uintptr      `json:"base"`
				Target        *uintptr      `json:"target"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*Call)
			}
			if tmp.Target != nil {
				v.Target = n.node[*tmp.Target].(Expr)
			}
		case NodeTypeSpecifyEndian:
			v := n.node[i].(*SpecifyEndian)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				Base          *uintptr      `json:"base"`
				Endian        *uintptr      `json:"endian"`
				EndianValue   *uint64       `json:"endian_value"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*Binary)
			}
			if tmp.Endian != nil {
				v.Endian = n.node[*tmp.Endian].(Expr)
			}
			v.EndianValue = tmp.EndianValue
		case NodeTypeExplicitError:
			v := n.node[i].(*ExplicitError)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				Base          *uintptr      `json:"base"`
				Message       *uintptr      `json:"message"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*Call)
			}
			if tmp.Message != nil {
				v.Message = n.node[*tmp.Message].(*StrLiteral)
			}
		case NodeTypeIoOperation:
			v := n.node[i].(*IoOperation)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				Base          *uintptr      `json:"base"`
				Method        IoMethod      `json:"method"`
				Arguments     []uintptr     `json:"arguments"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(Expr)
			}
			v.Method = tmp.Method
			v.Arguments = make([]Expr, len(tmp.Arguments))
			for j, k := range tmp.Arguments {
				v.Arguments[j] = n.node[k].(Expr)
			}
		case NodeTypeLoop:
			v := n.node[i].(*Loop)
			var tmp struct {
				CondScope *uintptr `json:"cond_scope"`
				Init      *uintptr `json:"init"`
				Cond      *uintptr `json:"cond"`
				Step      *uintptr `json:"step"`
				Body      *uintptr `json:"body"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.CondScope != nil {
				v.CondScope = n.scope[*tmp.CondScope]
			}
			if tmp.Init != nil {
				v.Init = n.node[*tmp.Init].(Expr)
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			if tmp.Step != nil {
				v.Step = n.node[*tmp.Step].(Expr)
			}
			if tmp.Body != nil {
				v.Body = n.node[*tmp.Body].(*IndentBlock)
			}
		case NodeTypeIndentBlock:
			v := n.node[i].(*IndentBlock)
			var tmp struct {
				StructType *uintptr  `json:"struct_type"`
				Elements   []uintptr `json:"elements"`
				Scope      *uintptr  `json:"scope"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.StructType != nil {
				v.StructType = n.node[*tmp.StructType].(*StructType)
			}
			v.Elements = make([]Node, len(tmp.Elements))
			for j, k := range tmp.Elements {
				v.Elements[j] = n.node[k].(Node)
			}
			if tmp.Scope != nil {
				v.Scope = n.scope[*tmp.Scope]
			}
		case NodeTypeScopedStatement:
			v := n.node[i].(*ScopedStatement)
			var tmp struct {
				StructType *uintptr `json:"struct_type"`
				Statement  *uintptr `json:"statement"`
				Scope      *uintptr `json:"scope"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.StructType != nil {
				v.StructType = n.node[*tmp.StructType].(*StructType)
			}
			if tmp.Statement != nil {
				v.Statement = n.node[*tmp.Statement].(Node)
			}
			if tmp.Scope != nil {
				v.Scope = n.scope[*tmp.Scope]
			}
		case NodeTypeMatchBranch:
			v := n.node[i].(*MatchBranch)
			var tmp struct {
				Belong *uintptr `json:"belong"`
				Cond   *uintptr `json:"cond"`
				SymLoc Loc      `json:"sym_loc"`
				Then   *uintptr `json:"then"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(*Match)
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			v.SymLoc = tmp.SymLoc
			if tmp.Then != nil {
				v.Then = n.node[*tmp.Then].(Node)
			}
		case NodeTypeUnionCandidate:
			v := n.node[i].(*UnionCandidate)
			var tmp struct {
				Cond  *uintptr `json:"cond"`
				Field *uintptr `json:"field"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			if tmp.Field != nil {
				v.Field = n.node[*tmp.Field].(*Field)
			}
		case NodeTypeReturn:
			v := n.node[i].(*Return)
			var tmp struct {
				Expr *uintptr `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		case NodeTypeBreak:
			var tmp struct {
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
		case NodeTypeContinue:
			var tmp struct {
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
		case NodeTypeAssert:
			v := n.node[i].(*Assert)
			var tmp struct {
				Cond        *uintptr `json:"cond"`
				IsIoRelated bool     `json:"is_io_related"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(*Binary)
			}
			v.IsIoRelated = tmp.IsIoRelated
		case NodeTypeImplicitYield:
			v := n.node[i].(*ImplicitYield)
			var tmp struct {
				Expr *uintptr `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		case NodeTypeIntType:
			v := n.node[i].(*IntType)
			var tmp struct {
				IsExplicit        bool         `json:"is_explicit"`
				NonDynamic        bool         `json:"non_dynamic"`
				BitAlignment      BitAlignment `json:"bit_alignment"`
				BitSize           *uint64      `json:"bit_size"`
				Endian            Endian       `json:"endian"`
				IsSigned          bool         `json:"is_signed"`
				IsCommonSupported bool         `json:"is_common_supported"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.NonDynamic = tmp.NonDynamic
			v.BitAlignment = tmp.BitAlignment
			v.BitSize = tmp.BitSize
			v.Endian = tmp.Endian
			v.IsSigned = tmp.IsSigned
			v.IsCommonSupported = tmp.IsCommonSupported
		case NodeTypeFloatType:
			v := n.node[i].(*FloatType)
			var tmp struct {
				IsExplicit        bool         `json:"is_explicit"`
				NonDynamic        bool         `json:"non_dynamic"`
				BitAlignment      BitAlignment `json:"bit_alignment"`
				BitSize           *uint64      `json:"bit_size"`
				Endian            Endian       `json:"endian"`
				IsCommonSupported bool         `json:"is_common_supported"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.NonDynamic = tmp.NonDynamic
			v.BitAlignment = tmp.BitAlignment
			v.BitSize = tmp.BitSize
			v.Endian = tmp.Endian
			v.IsCommonSupported = tmp.IsCommonSupported
		case NodeTypeIdentType:
			v := n.node[i].(*IdentType)
			var tmp struct {
				IsExplicit   bool         `json:"is_explicit"`
				NonDynamic   bool         `json:"non_dynamic"`
				BitAlignment BitAlignment `json:"bit_alignment"`
				BitSize      *uint64      `json:"bit_size"`
				Ident        *uintptr     `json:"ident"`
				Base         *uintptr     `json:"base"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.NonDynamic = tmp.NonDynamic
			v.BitAlignment = tmp.BitAlignment
			v.BitSize = tmp.BitSize
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(Type)
			}
		case NodeTypeIntLiteralType:
			v := n.node[i].(*IntLiteralType)
			var tmp struct {
				IsExplicit   bool         `json:"is_explicit"`
				NonDynamic   bool         `json:"non_dynamic"`
				BitAlignment BitAlignment `json:"bit_alignment"`
				BitSize      *uint64      `json:"bit_size"`
				Base         *uintptr     `json:"base"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.NonDynamic = tmp.NonDynamic
			v.BitAlignment = tmp.BitAlignment
			v.BitSize = tmp.BitSize
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*IntLiteral)
			}
		case NodeTypeStrLiteralType:
			v := n.node[i].(*StrLiteralType)
			var tmp struct {
				IsExplicit   bool         `json:"is_explicit"`
				NonDynamic   bool         `json:"non_dynamic"`
				BitAlignment BitAlignment `json:"bit_alignment"`
				BitSize      *uint64      `json:"bit_size"`
				Base         *uintptr     `json:"base"`
				StrongRef    *uintptr     `json:"strong_ref"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.NonDynamic = tmp.NonDynamic
			v.BitAlignment = tmp.BitAlignment
			v.BitSize = tmp.BitSize
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*StrLiteral)
			}
			if tmp.StrongRef != nil {
				v.StrongRef = n.node[*tmp.StrongRef].(*StrLiteral)
			}
		case NodeTypeVoidType:
			v := n.node[i].(*VoidType)
			var tmp struct {
				IsExplicit   bool         `json:"is_explicit"`
				NonDynamic   bool         `json:"non_dynamic"`
				BitAlignment BitAlignment `json:"bit_alignment"`
				BitSize      *uint64      `json:"bit_size"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.NonDynamic = tmp.NonDynamic
			v.BitAlignment = tmp.BitAlignment
			v.BitSize = tmp.BitSize
		case NodeTypeBoolType:
			v := n.node[i].(*BoolType)
			var tmp struct {
				IsExplicit   bool         `json:"is_explicit"`
				NonDynamic   bool         `json:"non_dynamic"`
				BitAlignment BitAlignment `json:"bit_alignment"`
				BitSize      *uint64      `json:"bit_size"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.NonDynamic = tmp.NonDynamic
			v.BitAlignment = tmp.BitAlignment
			v.BitSize = tmp.BitSize
		case NodeTypeArrayType:
			v := n.node[i].(*ArrayType)
			var tmp struct {
				IsExplicit   bool         `json:"is_explicit"`
				NonDynamic   bool         `json:"non_dynamic"`
				BitAlignment BitAlignment `json:"bit_alignment"`
				BitSize      *uint64      `json:"bit_size"`
				EndLoc       Loc          `json:"end_loc"`
				BaseType     *uintptr     `json:"base_type"`
				Length       *uintptr     `json:"length"`
				LengthValue  *uint64      `json:"length_value"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.NonDynamic = tmp.NonDynamic
			v.BitAlignment = tmp.BitAlignment
			v.BitSize = tmp.BitSize
			v.EndLoc = tmp.EndLoc
			if tmp.BaseType != nil {
				v.BaseType = n.node[*tmp.BaseType].(Type)
			}
			if tmp.Length != nil {
				v.Length = n.node[*tmp.Length].(Expr)
			}
			v.LengthValue = tmp.LengthValue
		case NodeTypeFunctionType:
			v := n.node[i].(*FunctionType)
			var tmp struct {
				IsExplicit   bool         `json:"is_explicit"`
				NonDynamic   bool         `json:"non_dynamic"`
				BitAlignment BitAlignment `json:"bit_alignment"`
				BitSize      *uint64      `json:"bit_size"`
				ReturnType   *uintptr     `json:"return_type"`
				Parameters   []uintptr    `json:"parameters"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.NonDynamic = tmp.NonDynamic
			v.BitAlignment = tmp.BitAlignment
			v.BitSize = tmp.BitSize
			if tmp.ReturnType != nil {
				v.ReturnType = n.node[*tmp.ReturnType].(Type)
			}
			v.Parameters = make([]Type, len(tmp.Parameters))
			for j, k := range tmp.Parameters {
				v.Parameters[j] = n.node[k].(Type)
			}
		case NodeTypeStructType:
			v := n.node[i].(*StructType)
			var tmp struct {
				IsExplicit      bool         `json:"is_explicit"`
				NonDynamic      bool         `json:"non_dynamic"`
				BitAlignment    BitAlignment `json:"bit_alignment"`
				BitSize         *uint64      `json:"bit_size"`
				Fields          []uintptr    `json:"fields"`
				Base            *uintptr     `json:"base"`
				Recursive       bool         `json:"recursive"`
				FixedHeaderSize uint64       `json:"fixed_header_size"`
				FixedTailSize   uint64       `json:"fixed_tail_size"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.NonDynamic = tmp.NonDynamic
			v.BitAlignment = tmp.BitAlignment
			v.BitSize = tmp.BitSize
			v.Fields = make([]Member, len(tmp.Fields))
			for j, k := range tmp.Fields {
				v.Fields[j] = n.node[k].(Member)
			}
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(Node)
			}
			v.Recursive = tmp.Recursive
			v.FixedHeaderSize = tmp.FixedHeaderSize
			v.FixedTailSize = tmp.FixedTailSize
		case NodeTypeStructUnionType:
			v := n.node[i].(*StructUnionType)
			var tmp struct {
				IsExplicit   bool         `json:"is_explicit"`
				NonDynamic   bool         `json:"non_dynamic"`
				BitAlignment BitAlignment `json:"bit_alignment"`
				BitSize      *uint64      `json:"bit_size"`
				Structs      []uintptr    `json:"structs"`
				Base         *uintptr     `json:"base"`
				UnionFields  []uintptr    `json:"union_fields"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.NonDynamic = tmp.NonDynamic
			v.BitAlignment = tmp.BitAlignment
			v.BitSize = tmp.BitSize
			v.Structs = make([]*StructType, len(tmp.Structs))
			for j, k := range tmp.Structs {
				v.Structs[j] = n.node[k].(*StructType)
			}
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(Expr)
			}
			v.UnionFields = make([]*Field, len(tmp.UnionFields))
			for j, k := range tmp.UnionFields {
				v.UnionFields[j] = n.node[k].(*Field)
			}
		case NodeTypeUnionType:
			v := n.node[i].(*UnionType)
			var tmp struct {
				IsExplicit   bool         `json:"is_explicit"`
				NonDynamic   bool         `json:"non_dynamic"`
				BitAlignment BitAlignment `json:"bit_alignment"`
				BitSize      *uint64      `json:"bit_size"`
				Cond         *uintptr     `json:"cond"`
				Candidates   []uintptr    `json:"candidates"`
				BaseType     *uintptr     `json:"base_type"`
				CommonType   *uintptr     `json:"common_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.NonDynamic = tmp.NonDynamic
			v.BitAlignment = tmp.BitAlignment
			v.BitSize = tmp.BitSize
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			v.Candidates = make([]*UnionCandidate, len(tmp.Candidates))
			for j, k := range tmp.Candidates {
				v.Candidates[j] = n.node[k].(*UnionCandidate)
			}
			if tmp.BaseType != nil {
				v.BaseType = n.node[*tmp.BaseType].(*StructUnionType)
			}
			if tmp.CommonType != nil {
				v.CommonType = n.node[*tmp.CommonType].(Type)
			}
		case NodeTypeRangeType:
			v := n.node[i].(*RangeType)
			var tmp struct {
				IsExplicit   bool         `json:"is_explicit"`
				NonDynamic   bool         `json:"non_dynamic"`
				BitAlignment BitAlignment `json:"bit_alignment"`
				BitSize      *uint64      `json:"bit_size"`
				BaseType     *uintptr     `json:"base_type"`
				Range        *uintptr     `json:"range"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.NonDynamic = tmp.NonDynamic
			v.BitAlignment = tmp.BitAlignment
			v.BitSize = tmp.BitSize
			if tmp.BaseType != nil {
				v.BaseType = n.node[*tmp.BaseType].(Type)
			}
			if tmp.Range != nil {
				v.Range = n.node[*tmp.Range].(*Range)
			}
		case NodeTypeEnumType:
			v := n.node[i].(*EnumType)
			var tmp struct {
				IsExplicit   bool         `json:"is_explicit"`
				NonDynamic   bool         `json:"non_dynamic"`
				BitAlignment BitAlignment `json:"bit_alignment"`
				BitSize      *uint64      `json:"bit_size"`
				Base         *uintptr     `json:"base"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.NonDynamic = tmp.NonDynamic
			v.BitAlignment = tmp.BitAlignment
			v.BitSize = tmp.BitSize
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*Enum)
			}
		case NodeTypeMetaType:
			v := n.node[i].(*MetaType)
			var tmp struct {
				IsExplicit   bool         `json:"is_explicit"`
				NonDynamic   bool         `json:"non_dynamic"`
				BitAlignment BitAlignment `json:"bit_alignment"`
				BitSize      *uint64      `json:"bit_size"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.NonDynamic = tmp.NonDynamic
			v.BitAlignment = tmp.BitAlignment
			v.BitSize = tmp.BitSize
		case NodeTypeOptionalType:
			v := n.node[i].(*OptionalType)
			var tmp struct {
				IsExplicit   bool         `json:"is_explicit"`
				NonDynamic   bool         `json:"non_dynamic"`
				BitAlignment BitAlignment `json:"bit_alignment"`
				BitSize      *uint64      `json:"bit_size"`
				BaseType     *uintptr     `json:"base_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.NonDynamic = tmp.NonDynamic
			v.BitAlignment = tmp.BitAlignment
			v.BitSize = tmp.BitSize
			if tmp.BaseType != nil {
				v.BaseType = n.node[*tmp.BaseType].(Type)
			}
		case NodeTypeIntLiteral:
			v := n.node[i].(*IntLiteral)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				Value         string        `json:"value"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			v.Value = tmp.Value
		case NodeTypeBoolLiteral:
			v := n.node[i].(*BoolLiteral)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				Value         bool          `json:"value"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			v.Value = tmp.Value
		case NodeTypeStrLiteral:
			v := n.node[i].(*StrLiteral)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				Value         string        `json:"value"`
				Length        uint64        `json:"length"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			v.Value = tmp.Value
			v.Length = tmp.Length
		case NodeTypeTypeLiteral:
			v := n.node[i].(*TypeLiteral)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
				TypeLiteral   *uintptr      `json:"type_literal"`
				EndLoc        Loc           `json:"end_loc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
			if tmp.TypeLiteral != nil {
				v.TypeLiteral = n.node[*tmp.TypeLiteral].(Type)
			}
			v.EndLoc = tmp.EndLoc
		case NodeTypeInput:
			v := n.node[i].(*Input)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
		case NodeTypeOutput:
			v := n.node[i].(*Output)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
		case NodeTypeConfig:
			v := n.node[i].(*Config)
			var tmp struct {
				ExprType      *uintptr      `json:"expr_type"`
				ConstantLevel ConstantLevel `json:"constant_level"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.ConstantLevel = tmp.ConstantLevel
		case NodeTypeField:
			v := n.node[i].(*Field)
			var tmp struct {
				Belong           *uintptr     `json:"belong"`
				BelongStruct     *uintptr     `json:"belong_struct"`
				Ident            *uintptr     `json:"ident"`
				ColonLoc         Loc          `json:"colon_loc"`
				FieldType        *uintptr     `json:"field_type"`
				Arguments        *uintptr     `json:"arguments"`
				OffsetBit        *uint64      `json:"offset_bit"`
				OffsetRecent     uint64       `json:"offset_recent"`
				TailOffsetBit    *uint64      `json:"tail_offset_bit"`
				TailOffsetRecent uint64       `json:"tail_offset_recent"`
				BitAlignment     BitAlignment `json:"bit_alignment"`
				Follow           Follow       `json:"follow"`
				EventualFollow   Follow       `json:"eventual_follow"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(Member)
			}
			if tmp.BelongStruct != nil {
				v.BelongStruct = n.node[*tmp.BelongStruct].(*StructType)
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			v.ColonLoc = tmp.ColonLoc
			if tmp.FieldType != nil {
				v.FieldType = n.node[*tmp.FieldType].(Type)
			}
			if tmp.Arguments != nil {
				v.Arguments = n.node[*tmp.Arguments].(*FieldArgument)
			}
			v.OffsetBit = tmp.OffsetBit
			v.OffsetRecent = tmp.OffsetRecent
			v.TailOffsetBit = tmp.TailOffsetBit
			v.TailOffsetRecent = tmp.TailOffsetRecent
			v.BitAlignment = tmp.BitAlignment
			v.Follow = tmp.Follow
			v.EventualFollow = tmp.EventualFollow
		case NodeTypeFormat:
			v := n.node[i].(*Format)
			var tmp struct {
				Belong       *uintptr  `json:"belong"`
				BelongStruct *uintptr  `json:"belong_struct"`
				Ident        *uintptr  `json:"ident"`
				Body         *uintptr  `json:"body"`
				EncodeFn     *uintptr  `json:"encode_fn"`
				DecodeFn     *uintptr  `json:"decode_fn"`
				CastFns      []uintptr `json:"cast_fns"`
				Depends      []uintptr `json:"depends"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(Member)
			}
			if tmp.BelongStruct != nil {
				v.BelongStruct = n.node[*tmp.BelongStruct].(*StructType)
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			if tmp.Body != nil {
				v.Body = n.node[*tmp.Body].(*IndentBlock)
			}
			if tmp.EncodeFn != nil {
				v.EncodeFn = n.node[*tmp.EncodeFn].(*Function)
			}
			if tmp.DecodeFn != nil {
				v.DecodeFn = n.node[*tmp.DecodeFn].(*Function)
			}
			v.CastFns = make([]*Function, len(tmp.CastFns))
			for j, k := range tmp.CastFns {
				v.CastFns[j] = n.node[k].(*Function)
			}
			v.Depends = make([]*IdentType, len(tmp.Depends))
			for j, k := range tmp.Depends {
				v.Depends[j] = n.node[k].(*IdentType)
			}
		case NodeTypeState:
			v := n.node[i].(*State)
			var tmp struct {
				Belong       *uintptr `json:"belong"`
				BelongStruct *uintptr `json:"belong_struct"`
				Ident        *uintptr `json:"ident"`
				Body         *uintptr `json:"body"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(Member)
			}
			if tmp.BelongStruct != nil {
				v.BelongStruct = n.node[*tmp.BelongStruct].(*StructType)
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			if tmp.Body != nil {
				v.Body = n.node[*tmp.Body].(*IndentBlock)
			}
		case NodeTypeEnum:
			v := n.node[i].(*Enum)
			var tmp struct {
				Belong       *uintptr  `json:"belong"`
				BelongStruct *uintptr  `json:"belong_struct"`
				Ident        *uintptr  `json:"ident"`
				Scope        *uintptr  `json:"scope"`
				ColonLoc     Loc       `json:"colon_loc"`
				BaseType     *uintptr  `json:"base_type"`
				Members      []uintptr `json:"members"`
				EnumType     *uintptr  `json:"enum_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(Member)
			}
			if tmp.BelongStruct != nil {
				v.BelongStruct = n.node[*tmp.BelongStruct].(*StructType)
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			if tmp.Scope != nil {
				v.Scope = n.scope[*tmp.Scope]
			}
			v.ColonLoc = tmp.ColonLoc
			if tmp.BaseType != nil {
				v.BaseType = n.node[*tmp.BaseType].(Type)
			}
			v.Members = make([]*EnumMember, len(tmp.Members))
			for j, k := range tmp.Members {
				v.Members[j] = n.node[k].(*EnumMember)
			}
			if tmp.EnumType != nil {
				v.EnumType = n.node[*tmp.EnumType].(*EnumType)
			}
		case NodeTypeEnumMember:
			v := n.node[i].(*EnumMember)
			var tmp struct {
				Belong       *uintptr `json:"belong"`
				BelongStruct *uintptr `json:"belong_struct"`
				Ident        *uintptr `json:"ident"`
				Expr         *uintptr `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(Member)
			}
			if tmp.BelongStruct != nil {
				v.BelongStruct = n.node[*tmp.BelongStruct].(*StructType)
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		case NodeTypeFunction:
			v := n.node[i].(*Function)
			var tmp struct {
				Belong       *uintptr  `json:"belong"`
				BelongStruct *uintptr  `json:"belong_struct"`
				Ident        *uintptr  `json:"ident"`
				Parameters   []uintptr `json:"parameters"`
				ReturnType   *uintptr  `json:"return_type"`
				Body         *uintptr  `json:"body"`
				FuncType     *uintptr  `json:"func_type"`
				IsCast       bool      `json:"is_cast"`
				CastLoc      Loc       `json:"cast_loc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(Member)
			}
			if tmp.BelongStruct != nil {
				v.BelongStruct = n.node[*tmp.BelongStruct].(*StructType)
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			v.Parameters = make([]*Field, len(tmp.Parameters))
			for j, k := range tmp.Parameters {
				v.Parameters[j] = n.node[k].(*Field)
			}
			if tmp.ReturnType != nil {
				v.ReturnType = n.node[*tmp.ReturnType].(Type)
			}
			if tmp.Body != nil {
				v.Body = n.node[*tmp.Body].(*IndentBlock)
			}
			if tmp.FuncType != nil {
				v.FuncType = n.node[*tmp.FuncType].(*FunctionType)
			}
			v.IsCast = tmp.IsCast
			v.CastLoc = tmp.CastLoc
		case NodeTypeBuiltinFunction:
			v := n.node[i].(*BuiltinFunction)
			var tmp struct {
				Belong       *uintptr `json:"belong"`
				BelongStruct *uintptr `json:"belong_struct"`
				Ident        *uintptr `json:"ident"`
				FuncType     *uintptr `json:"func_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(Member)
			}
			if tmp.BelongStruct != nil {
				v.BelongStruct = n.node[*tmp.BelongStruct].(*StructType)
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			if tmp.FuncType != nil {
				v.FuncType = n.node[*tmp.FuncType].(*FunctionType)
			}
		case NodeTypeBuiltinField:
			v := n.node[i].(*BuiltinField)
			var tmp struct {
				Belong       *uintptr `json:"belong"`
				BelongStruct *uintptr `json:"belong_struct"`
				Ident        *uintptr `json:"ident"`
				FieldType    *uintptr `json:"field_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(Member)
			}
			if tmp.BelongStruct != nil {
				v.BelongStruct = n.node[*tmp.BelongStruct].(*StructType)
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			if tmp.FieldType != nil {
				v.FieldType = n.node[*tmp.FieldType].(Type)
			}
		case NodeTypeBuiltinObject:
			v := n.node[i].(*BuiltinObject)
			var tmp struct {
				Belong       *uintptr  `json:"belong"`
				BelongStruct *uintptr  `json:"belong_struct"`
				Ident        *uintptr  `json:"ident"`
				Members      []uintptr `json:"members"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(Member)
			}
			if tmp.BelongStruct != nil {
				v.BelongStruct = n.node[*tmp.BelongStruct].(*StructType)
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			v.Members = make([]BuiltinMember, len(tmp.Members))
			for j, k := range tmp.Members {
				v.Members[j] = n.node[k].(BuiltinMember)
			}
		default:
			return nil, fmt.Errorf("unknown node type: %q", raw.NodeType)
		}
	}
	for i, raw := range aux.Scope {
		if raw.Prev != nil {
			n.scope[i].Prev = n.scope[*raw.Prev]
		}
		if raw.Next != nil {
			n.scope[i].Next = n.scope[*raw.Next]
		}
		if raw.Branch != nil {
			n.scope[i].Branch = n.scope[*raw.Branch]
		}
		n.scope[i].Ident = make([]*Ident, len(raw.Ident))
		for j, k := range raw.Ident {
			n.scope[i].Ident[j] = n.node[k].(*Ident)
		}
		if raw.Owner != nil {
			n.scope[i].Owner = n.node[*raw.Owner].(Node)
		}
		n.scope[i].BranchRoot = raw.BranchRoot
	}
	return n.node[0].(*Program), nil
}

type Visitor interface {
	Visit(v Visitor, n Node) bool
}

type VisitFn func(v Visitor, n Node) bool

func (f VisitFn) Visit(v Visitor, n Node) bool {
	return f(v, n)
}

func Walk(n Node, f Visitor) {
	switch v := n.(type) {
	case *Program:
		if v.StructType != nil {
			if !f.Visit(f, v.StructType) {
				return
			}
		}
		for _, w := range v.Elements {
			if !f.Visit(f, w) {
				return
			}
		}
	case *Comment:
	case *CommentGroup:
		for _, w := range v.Comments {
			if !f.Visit(f, w) {
				return
			}
		}
	case *FieldArgument:
		if v.RawArguments != nil {
			if !f.Visit(f, v.RawArguments) {
				return
			}
		}
		for _, w := range v.Arguments {
			if !f.Visit(f, w) {
				return
			}
		}
		if v.Alignment != nil {
			if !f.Visit(f, v.Alignment) {
				return
			}
		}
		if v.SubByteLength != nil {
			if !f.Visit(f, v.SubByteLength) {
				return
			}
		}
		if v.SubByteBegin != nil {
			if !f.Visit(f, v.SubByteBegin) {
				return
			}
		}
	case *Binary:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Left != nil {
			if !f.Visit(f, v.Left) {
				return
			}
		}
		if v.Right != nil {
			if !f.Visit(f, v.Right) {
				return
			}
		}
	case *Unary:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Expr != nil {
			if !f.Visit(f, v.Expr) {
				return
			}
		}
	case *Cond:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Cond != nil {
			if !f.Visit(f, v.Cond) {
				return
			}
		}
		if v.Then != nil {
			if !f.Visit(f, v.Then) {
				return
			}
		}
		if v.Els != nil {
			if !f.Visit(f, v.Els) {
				return
			}
		}
	case *Ident:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
	case *Call:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Callee != nil {
			if !f.Visit(f, v.Callee) {
				return
			}
		}
		if v.RawArguments != nil {
			if !f.Visit(f, v.RawArguments) {
				return
			}
		}
		for _, w := range v.Arguments {
			if !f.Visit(f, w) {
				return
			}
		}
	case *If:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Cond != nil {
			if !f.Visit(f, v.Cond) {
				return
			}
		}
		if v.Then != nil {
			if !f.Visit(f, v.Then) {
				return
			}
		}
		if v.Els != nil {
			if !f.Visit(f, v.Els) {
				return
			}
		}
	case *MemberAccess:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Target != nil {
			if !f.Visit(f, v.Target) {
				return
			}
		}
		if v.Member != nil {
			if !f.Visit(f, v.Member) {
				return
			}
		}
	case *Paren:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Expr != nil {
			if !f.Visit(f, v.Expr) {
				return
			}
		}
	case *Index:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Expr != nil {
			if !f.Visit(f, v.Expr) {
				return
			}
		}
		if v.Index != nil {
			if !f.Visit(f, v.Index) {
				return
			}
		}
	case *Match:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Cond != nil {
			if !f.Visit(f, v.Cond) {
				return
			}
		}
		for _, w := range v.Branch {
			if !f.Visit(f, w) {
				return
			}
		}
	case *Range:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Start != nil {
			if !f.Visit(f, v.Start) {
				return
			}
		}
		if v.End != nil {
			if !f.Visit(f, v.End) {
				return
			}
		}
	case *TmpVar:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
	case *Import:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Base != nil {
			if !f.Visit(f, v.Base) {
				return
			}
		}
		if v.ImportDesc != nil {
			if !f.Visit(f, v.ImportDesc) {
				return
			}
		}
	case *Cast:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Base != nil {
			if !f.Visit(f, v.Base) {
				return
			}
		}
		if v.Expr != nil {
			if !f.Visit(f, v.Expr) {
				return
			}
		}
	case *Available:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Base != nil {
			if !f.Visit(f, v.Base) {
				return
			}
		}
		if v.Target != nil {
			if !f.Visit(f, v.Target) {
				return
			}
		}
	case *SpecifyEndian:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Base != nil {
			if !f.Visit(f, v.Base) {
				return
			}
		}
		if v.Endian != nil {
			if !f.Visit(f, v.Endian) {
				return
			}
		}
	case *ExplicitError:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Base != nil {
			if !f.Visit(f, v.Base) {
				return
			}
		}
		if v.Message != nil {
			if !f.Visit(f, v.Message) {
				return
			}
		}
	case *IoOperation:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Base != nil {
			if !f.Visit(f, v.Base) {
				return
			}
		}
		for _, w := range v.Arguments {
			if !f.Visit(f, w) {
				return
			}
		}
	case *Loop:
		if v.Init != nil {
			if !f.Visit(f, v.Init) {
				return
			}
		}
		if v.Cond != nil {
			if !f.Visit(f, v.Cond) {
				return
			}
		}
		if v.Step != nil {
			if !f.Visit(f, v.Step) {
				return
			}
		}
		if v.Body != nil {
			if !f.Visit(f, v.Body) {
				return
			}
		}
	case *IndentBlock:
		if v.StructType != nil {
			if !f.Visit(f, v.StructType) {
				return
			}
		}
		for _, w := range v.Elements {
			if !f.Visit(f, w) {
				return
			}
		}
	case *ScopedStatement:
		if v.StructType != nil {
			if !f.Visit(f, v.StructType) {
				return
			}
		}
		if v.Statement != nil {
			if !f.Visit(f, v.Statement) {
				return
			}
		}
	case *MatchBranch:
		if v.Cond != nil {
			if !f.Visit(f, v.Cond) {
				return
			}
		}
		if v.Then != nil {
			if !f.Visit(f, v.Then) {
				return
			}
		}
	case *UnionCandidate:
	case *Return:
		if v.Expr != nil {
			if !f.Visit(f, v.Expr) {
				return
			}
		}
	case *Break:
	case *Continue:
	case *Assert:
		if v.Cond != nil {
			if !f.Visit(f, v.Cond) {
				return
			}
		}
	case *ImplicitYield:
		if v.Expr != nil {
			if !f.Visit(f, v.Expr) {
				return
			}
		}
	case *IntType:
	case *FloatType:
	case *IdentType:
		if v.Ident != nil {
			if !f.Visit(f, v.Ident) {
				return
			}
		}
	case *IntLiteralType:
	case *StrLiteralType:
		if v.StrongRef != nil {
			if !f.Visit(f, v.StrongRef) {
				return
			}
		}
	case *VoidType:
	case *BoolType:
	case *ArrayType:
		if v.BaseType != nil {
			if !f.Visit(f, v.BaseType) {
				return
			}
		}
		if v.Length != nil {
			if !f.Visit(f, v.Length) {
				return
			}
		}
	case *FunctionType:
		if v.ReturnType != nil {
			if !f.Visit(f, v.ReturnType) {
				return
			}
		}
		for _, w := range v.Parameters {
			if !f.Visit(f, w) {
				return
			}
		}
	case *StructType:
		for _, w := range v.Fields {
			if !f.Visit(f, w) {
				return
			}
		}
	case *StructUnionType:
		for _, w := range v.Structs {
			if !f.Visit(f, w) {
				return
			}
		}
	case *UnionType:
		for _, w := range v.Candidates {
			if !f.Visit(f, w) {
				return
			}
		}
		if v.CommonType != nil {
			if !f.Visit(f, v.CommonType) {
				return
			}
		}
	case *RangeType:
		if v.BaseType != nil {
			if !f.Visit(f, v.BaseType) {
				return
			}
		}
	case *EnumType:
	case *MetaType:
	case *OptionalType:
		if v.BaseType != nil {
			if !f.Visit(f, v.BaseType) {
				return
			}
		}
	case *IntLiteral:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
	case *BoolLiteral:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
	case *StrLiteral:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
	case *TypeLiteral:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.TypeLiteral != nil {
			if !f.Visit(f, v.TypeLiteral) {
				return
			}
		}
	case *Input:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
	case *Output:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
	case *Config:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
	case *Field:
		if v.Ident != nil {
			if !f.Visit(f, v.Ident) {
				return
			}
		}
		if v.FieldType != nil {
			if !f.Visit(f, v.FieldType) {
				return
			}
		}
		if v.Arguments != nil {
			if !f.Visit(f, v.Arguments) {
				return
			}
		}
	case *Format:
		if v.Ident != nil {
			if !f.Visit(f, v.Ident) {
				return
			}
		}
		if v.Body != nil {
			if !f.Visit(f, v.Body) {
				return
			}
		}
	case *State:
		if v.Ident != nil {
			if !f.Visit(f, v.Ident) {
				return
			}
		}
		if v.Body != nil {
			if !f.Visit(f, v.Body) {
				return
			}
		}
	case *Enum:
		if v.Ident != nil {
			if !f.Visit(f, v.Ident) {
				return
			}
		}
		if v.BaseType != nil {
			if !f.Visit(f, v.BaseType) {
				return
			}
		}
		for _, w := range v.Members {
			if !f.Visit(f, w) {
				return
			}
		}
		if v.EnumType != nil {
			if !f.Visit(f, v.EnumType) {
				return
			}
		}
	case *EnumMember:
		if v.Ident != nil {
			if !f.Visit(f, v.Ident) {
				return
			}
		}
		if v.Expr != nil {
			if !f.Visit(f, v.Expr) {
				return
			}
		}
	case *Function:
		if v.Ident != nil {
			if !f.Visit(f, v.Ident) {
				return
			}
		}
		for _, w := range v.Parameters {
			if !f.Visit(f, w) {
				return
			}
		}
		if v.ReturnType != nil {
			if !f.Visit(f, v.ReturnType) {
				return
			}
		}
		if v.Body != nil {
			if !f.Visit(f, v.Body) {
				return
			}
		}
		if v.FuncType != nil {
			if !f.Visit(f, v.FuncType) {
				return
			}
		}
	case *BuiltinFunction:
		if v.Ident != nil {
			if !f.Visit(f, v.Ident) {
				return
			}
		}
		if v.FuncType != nil {
			if !f.Visit(f, v.FuncType) {
				return
			}
		}
	case *BuiltinField:
		if v.Ident != nil {
			if !f.Visit(f, v.Ident) {
				return
			}
		}
		if v.FieldType != nil {
			if !f.Visit(f, v.FieldType) {
				return
			}
		}
	case *BuiltinObject:
		if v.Ident != nil {
			if !f.Visit(f, v.Ident) {
				return
			}
		}
		for _, w := range v.Members {
			if !f.Visit(f, w) {
				return
			}
		}
	}
}
