// Code generated by gen_ast2go; DO NOT EDIT.

package ast

import (
	"encoding/json"
	"fmt"
)

type NodeType int

const (
	NodeTypeProgram         NodeType = 0
	NodeTypeExpr            NodeType = 1
	NodeTypeBinary          NodeType = 2
	NodeTypeUnary           NodeType = 3
	NodeTypeCond            NodeType = 4
	NodeTypeIdent           NodeType = 5
	NodeTypeCall            NodeType = 6
	NodeTypeIf              NodeType = 7
	NodeTypeMemberAccess    NodeType = 8
	NodeTypeParen           NodeType = 9
	NodeTypeIndex           NodeType = 10
	NodeTypeMatch           NodeType = 11
	NodeTypeRange           NodeType = 12
	NodeTypeTmpVar          NodeType = 13
	NodeTypeBlockExpr       NodeType = 14
	NodeTypeImport          NodeType = 15
	NodeTypeLiteral         NodeType = 16
	NodeTypeIntLiteral      NodeType = 17
	NodeTypeBoolLiteral     NodeType = 18
	NodeTypeStrLiteral      NodeType = 19
	NodeTypeInput           NodeType = 20
	NodeTypeOutput          NodeType = 21
	NodeTypeConfig          NodeType = 22
	NodeTypeStmt            NodeType = 23
	NodeTypeLoop            NodeType = 24
	NodeTypeIndentBlock     NodeType = 25
	NodeTypeMatchBranch     NodeType = 26
	NodeTypeReturn          NodeType = 27
	NodeTypeBreak           NodeType = 28
	NodeTypeContinue        NodeType = 29
	NodeTypeAssert          NodeType = 30
	NodeTypeImplicitYield   NodeType = 31
	NodeTypeMember          NodeType = 32
	NodeTypeField           NodeType = 33
	NodeTypeFormat          NodeType = 34
	NodeTypeFunction        NodeType = 35
	NodeTypeType            NodeType = 36
	NodeTypeIntType         NodeType = 37
	NodeTypeIdentType       NodeType = 38
	NodeTypeIntLiteralType  NodeType = 39
	NodeTypeStrLiteralType  NodeType = 40
	NodeTypeVoidType        NodeType = 41
	NodeTypeBoolType        NodeType = 42
	NodeTypeArrayType       NodeType = 43
	NodeTypeFunctionType    NodeType = 44
	NodeTypeStructType      NodeType = 45
	NodeTypeStructUnionType NodeType = 46
	NodeTypeCast            NodeType = 47
	NodeTypeComment         NodeType = 48
	NodeTypeCommentGroup    NodeType = 49
	NodeTypeUnionType       NodeType = 50
	NodeTypeUnionCandidate  NodeType = 51
	NodeTypeRangeType       NodeType = 52
	NodeTypeEnum            NodeType = 53
	NodeTypeEnumMember      NodeType = 54
	NodeTypeEnumType        NodeType = 55
)

func (n NodeType) String() string {
	switch n {
	case NodeTypeProgram:
		return "program"
	case NodeTypeExpr:
		return "expr"
	case NodeTypeBinary:
		return "binary"
	case NodeTypeUnary:
		return "unary"
	case NodeTypeCond:
		return "cond"
	case NodeTypeIdent:
		return "ident"
	case NodeTypeCall:
		return "call"
	case NodeTypeIf:
		return "if"
	case NodeTypeMemberAccess:
		return "member_access"
	case NodeTypeParen:
		return "paren"
	case NodeTypeIndex:
		return "index"
	case NodeTypeMatch:
		return "match"
	case NodeTypeRange:
		return "range"
	case NodeTypeTmpVar:
		return "tmp_var"
	case NodeTypeBlockExpr:
		return "block_expr"
	case NodeTypeImport:
		return "import"
	case NodeTypeLiteral:
		return "literal"
	case NodeTypeIntLiteral:
		return "int_literal"
	case NodeTypeBoolLiteral:
		return "bool_literal"
	case NodeTypeStrLiteral:
		return "str_literal"
	case NodeTypeInput:
		return "input"
	case NodeTypeOutput:
		return "output"
	case NodeTypeConfig:
		return "config"
	case NodeTypeStmt:
		return "stmt"
	case NodeTypeLoop:
		return "loop"
	case NodeTypeIndentBlock:
		return "indent_block"
	case NodeTypeMatchBranch:
		return "match_branch"
	case NodeTypeReturn:
		return "return"
	case NodeTypeBreak:
		return "break"
	case NodeTypeContinue:
		return "continue"
	case NodeTypeAssert:
		return "assert"
	case NodeTypeImplicitYield:
		return "implicit_yield"
	case NodeTypeMember:
		return "member"
	case NodeTypeField:
		return "field"
	case NodeTypeFormat:
		return "format"
	case NodeTypeFunction:
		return "function"
	case NodeTypeType:
		return "type"
	case NodeTypeIntType:
		return "int_type"
	case NodeTypeIdentType:
		return "ident_type"
	case NodeTypeIntLiteralType:
		return "int_literal_type"
	case NodeTypeStrLiteralType:
		return "str_literal_type"
	case NodeTypeVoidType:
		return "void_type"
	case NodeTypeBoolType:
		return "bool_type"
	case NodeTypeArrayType:
		return "array_type"
	case NodeTypeFunctionType:
		return "function_type"
	case NodeTypeStructType:
		return "struct_type"
	case NodeTypeStructUnionType:
		return "struct_union_type"
	case NodeTypeCast:
		return "cast"
	case NodeTypeComment:
		return "comment"
	case NodeTypeCommentGroup:
		return "comment_group"
	case NodeTypeUnionType:
		return "union_type"
	case NodeTypeUnionCandidate:
		return "union_candidate"
	case NodeTypeRangeType:
		return "range_type"
	case NodeTypeEnum:
		return "enum"
	case NodeTypeEnumMember:
		return "enum_member"
	case NodeTypeEnumType:
		return "enum_type"
	default:
		return fmt.Sprintf("NodeType(%d)", n)
	}
}

func (n NodeType) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "program":
		n = NodeTypeProgram
	case "expr":
		n = NodeTypeExpr
	case "binary":
		n = NodeTypeBinary
	case "unary":
		n = NodeTypeUnary
	case "cond":
		n = NodeTypeCond
	case "ident":
		n = NodeTypeIdent
	case "call":
		n = NodeTypeCall
	case "if":
		n = NodeTypeIf
	case "member_access":
		n = NodeTypeMemberAccess
	case "paren":
		n = NodeTypeParen
	case "index":
		n = NodeTypeIndex
	case "match":
		n = NodeTypeMatch
	case "range":
		n = NodeTypeRange
	case "tmp_var":
		n = NodeTypeTmpVar
	case "block_expr":
		n = NodeTypeBlockExpr
	case "import":
		n = NodeTypeImport
	case "literal":
		n = NodeTypeLiteral
	case "int_literal":
		n = NodeTypeIntLiteral
	case "bool_literal":
		n = NodeTypeBoolLiteral
	case "str_literal":
		n = NodeTypeStrLiteral
	case "input":
		n = NodeTypeInput
	case "output":
		n = NodeTypeOutput
	case "config":
		n = NodeTypeConfig
	case "stmt":
		n = NodeTypeStmt
	case "loop":
		n = NodeTypeLoop
	case "indent_block":
		n = NodeTypeIndentBlock
	case "match_branch":
		n = NodeTypeMatchBranch
	case "return":
		n = NodeTypeReturn
	case "break":
		n = NodeTypeBreak
	case "continue":
		n = NodeTypeContinue
	case "assert":
		n = NodeTypeAssert
	case "implicit_yield":
		n = NodeTypeImplicitYield
	case "member":
		n = NodeTypeMember
	case "field":
		n = NodeTypeField
	case "format":
		n = NodeTypeFormat
	case "function":
		n = NodeTypeFunction
	case "type":
		n = NodeTypeType
	case "int_type":
		n = NodeTypeIntType
	case "ident_type":
		n = NodeTypeIdentType
	case "int_literal_type":
		n = NodeTypeIntLiteralType
	case "str_literal_type":
		n = NodeTypeStrLiteralType
	case "void_type":
		n = NodeTypeVoidType
	case "bool_type":
		n = NodeTypeBoolType
	case "array_type":
		n = NodeTypeArrayType
	case "function_type":
		n = NodeTypeFunctionType
	case "struct_type":
		n = NodeTypeStructType
	case "struct_union_type":
		n = NodeTypeStructUnionType
	case "cast":
		n = NodeTypeCast
	case "comment":
		n = NodeTypeComment
	case "comment_group":
		n = NodeTypeCommentGroup
	case "union_type":
		n = NodeTypeUnionType
	case "union_candidate":
		n = NodeTypeUnionCandidate
	case "range_type":
		n = NodeTypeRangeType
	case "enum":
		n = NodeTypeEnum
	case "enum_member":
		n = NodeTypeEnumMember
	case "enum_type":
		n = NodeTypeEnumType
	default:
		return fmt.Errorf("unknown NodeType: %q", tmp)
	}
	return nil
}

func (n *Program) GetNodeType() NodeType {
	return NodeTypeProgram
}

func (n *Binary) GetNodeType() NodeType {
	return NodeTypeBinary
}

func (n *Unary) GetNodeType() NodeType {
	return NodeTypeUnary
}

func (n *Cond) GetNodeType() NodeType {
	return NodeTypeCond
}

func (n *Ident) GetNodeType() NodeType {
	return NodeTypeIdent
}

func (n *Call) GetNodeType() NodeType {
	return NodeTypeCall
}

func (n *If) GetNodeType() NodeType {
	return NodeTypeIf
}

func (n *MemberAccess) GetNodeType() NodeType {
	return NodeTypeMemberAccess
}

func (n *Paren) GetNodeType() NodeType {
	return NodeTypeParen
}

func (n *Index) GetNodeType() NodeType {
	return NodeTypeIndex
}

func (n *Match) GetNodeType() NodeType {
	return NodeTypeMatch
}

func (n *Range) GetNodeType() NodeType {
	return NodeTypeRange
}

func (n *TmpVar) GetNodeType() NodeType {
	return NodeTypeTmpVar
}

func (n *BlockExpr) GetNodeType() NodeType {
	return NodeTypeBlockExpr
}

func (n *Import) GetNodeType() NodeType {
	return NodeTypeImport
}

func (n *IntLiteral) GetNodeType() NodeType {
	return NodeTypeIntLiteral
}

func (n *BoolLiteral) GetNodeType() NodeType {
	return NodeTypeBoolLiteral
}

func (n *StrLiteral) GetNodeType() NodeType {
	return NodeTypeStrLiteral
}

func (n *Input) GetNodeType() NodeType {
	return NodeTypeInput
}

func (n *Output) GetNodeType() NodeType {
	return NodeTypeOutput
}

func (n *Config) GetNodeType() NodeType {
	return NodeTypeConfig
}

func (n *Loop) GetNodeType() NodeType {
	return NodeTypeLoop
}

func (n *IndentBlock) GetNodeType() NodeType {
	return NodeTypeIndentBlock
}

func (n *MatchBranch) GetNodeType() NodeType {
	return NodeTypeMatchBranch
}

func (n *Return) GetNodeType() NodeType {
	return NodeTypeReturn
}

func (n *Break) GetNodeType() NodeType {
	return NodeTypeBreak
}

func (n *Continue) GetNodeType() NodeType {
	return NodeTypeContinue
}

func (n *Assert) GetNodeType() NodeType {
	return NodeTypeAssert
}

func (n *ImplicitYield) GetNodeType() NodeType {
	return NodeTypeImplicitYield
}

func (n *Field) GetNodeType() NodeType {
	return NodeTypeField
}

func (n *Format) GetNodeType() NodeType {
	return NodeTypeFormat
}

func (n *Function) GetNodeType() NodeType {
	return NodeTypeFunction
}

func (n *IntType) GetNodeType() NodeType {
	return NodeTypeIntType
}

func (n *IdentType) GetNodeType() NodeType {
	return NodeTypeIdentType
}

func (n *IntLiteralType) GetNodeType() NodeType {
	return NodeTypeIntLiteralType
}

func (n *StrLiteralType) GetNodeType() NodeType {
	return NodeTypeStrLiteralType
}

func (n *VoidType) GetNodeType() NodeType {
	return NodeTypeVoidType
}

func (n *BoolType) GetNodeType() NodeType {
	return NodeTypeBoolType
}

func (n *ArrayType) GetNodeType() NodeType {
	return NodeTypeArrayType
}

func (n *FunctionType) GetNodeType() NodeType {
	return NodeTypeFunctionType
}

func (n *StructType) GetNodeType() NodeType {
	return NodeTypeStructType
}

func (n *StructUnionType) GetNodeType() NodeType {
	return NodeTypeStructUnionType
}

func (n *Cast) GetNodeType() NodeType {
	return NodeTypeCast
}

func (n *Comment) GetNodeType() NodeType {
	return NodeTypeComment
}

func (n *CommentGroup) GetNodeType() NodeType {
	return NodeTypeCommentGroup
}

func (n *UnionType) GetNodeType() NodeType {
	return NodeTypeUnionType
}

func (n *UnionCandidate) GetNodeType() NodeType {
	return NodeTypeUnionCandidate
}

func (n *RangeType) GetNodeType() NodeType {
	return NodeTypeRangeType
}

func (n *Enum) GetNodeType() NodeType {
	return NodeTypeEnum
}

func (n *EnumMember) GetNodeType() NodeType {
	return NodeTypeEnumMember
}

func (n *EnumType) GetNodeType() NodeType {
	return NodeTypeEnumType
}

type UnaryOp int

const (
	UnaryOpNot       UnaryOp = 0
	UnaryOpMinusSign UnaryOp = 1
)

func (n UnaryOp) String() string {
	switch n {
	case UnaryOpNot:
		return "!"
	case UnaryOpMinusSign:
		return "-"
	default:
		return fmt.Sprintf("UnaryOp(%d)", n)
	}
}

func (n UnaryOp) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "!":
		n = UnaryOpNot
	case "-":
		n = UnaryOpMinusSign
	default:
		return fmt.Errorf("unknown UnaryOp: %q", tmp)
	}
	return nil
}

type BinaryOp int

const (
	BinaryOpMul                  BinaryOp = 0
	BinaryOpDiv                  BinaryOp = 1
	BinaryOpMod                  BinaryOp = 2
	BinaryOpLeftArithmeticShift  BinaryOp = 3
	BinaryOpRightArithmeticShift BinaryOp = 4
	BinaryOpLeftLogicalShift     BinaryOp = 5
	BinaryOpRightLogicalShift    BinaryOp = 6
	BinaryOpBitAnd               BinaryOp = 7
	BinaryOpAdd                  BinaryOp = 8
	BinaryOpSub                  BinaryOp = 9
	BinaryOpBitOr                BinaryOp = 10
	BinaryOpBitXor               BinaryOp = 11
	BinaryOpEqual                BinaryOp = 12
	BinaryOpNotEqual             BinaryOp = 13
	BinaryOpLess                 BinaryOp = 14
	BinaryOpLessOrEq             BinaryOp = 15
	BinaryOpGrater               BinaryOp = 16
	BinaryOpGraterOrEq           BinaryOp = 17
	BinaryOpLogicalAnd           BinaryOp = 18
	BinaryOpLogicalOr            BinaryOp = 19
	BinaryOpCondOp1              BinaryOp = 20
	BinaryOpCondOp2              BinaryOp = 21
	BinaryOpRangeExclusive       BinaryOp = 22
	BinaryOpRangeInclusive       BinaryOp = 23
	BinaryOpAssign               BinaryOp = 24
	BinaryOpDefineAssign         BinaryOp = 25
	BinaryOpConstAssign          BinaryOp = 26
	BinaryOpAddAssign            BinaryOp = 27
	BinaryOpSubAssign            BinaryOp = 28
	BinaryOpMulAssign            BinaryOp = 29
	BinaryOpDivAssign            BinaryOp = 30
	BinaryOpModAssign            BinaryOp = 31
	BinaryOpLeftShiftAssign      BinaryOp = 32
	BinaryOpRightShiftAssign     BinaryOp = 33
	BinaryOpBitAndAssign         BinaryOp = 34
	BinaryOpBitOrAssign          BinaryOp = 35
	BinaryOpBitXorAssign         BinaryOp = 36
	BinaryOpComma                BinaryOp = 37
)

func (n BinaryOp) String() string {
	switch n {
	case BinaryOpMul:
		return "*"
	case BinaryOpDiv:
		return "/"
	case BinaryOpMod:
		return "%"
	case BinaryOpLeftArithmeticShift:
		return "<<<"
	case BinaryOpRightArithmeticShift:
		return ">>>"
	case BinaryOpLeftLogicalShift:
		return "<<"
	case BinaryOpRightLogicalShift:
		return ">>"
	case BinaryOpBitAnd:
		return "&"
	case BinaryOpAdd:
		return "+"
	case BinaryOpSub:
		return "-"
	case BinaryOpBitOr:
		return "|"
	case BinaryOpBitXor:
		return "^"
	case BinaryOpEqual:
		return "=="
	case BinaryOpNotEqual:
		return "!="
	case BinaryOpLess:
		return "<"
	case BinaryOpLessOrEq:
		return "<="
	case BinaryOpGrater:
		return ">"
	case BinaryOpGraterOrEq:
		return ">="
	case BinaryOpLogicalAnd:
		return "&&"
	case BinaryOpLogicalOr:
		return "||"
	case BinaryOpCondOp1:
		return "?"
	case BinaryOpCondOp2:
		return ":"
	case BinaryOpRangeExclusive:
		return ".."
	case BinaryOpRangeInclusive:
		return "..="
	case BinaryOpAssign:
		return "="
	case BinaryOpDefineAssign:
		return ":="
	case BinaryOpConstAssign:
		return "::="
	case BinaryOpAddAssign:
		return "+="
	case BinaryOpSubAssign:
		return "-="
	case BinaryOpMulAssign:
		return "*="
	case BinaryOpDivAssign:
		return "/="
	case BinaryOpModAssign:
		return "%="
	case BinaryOpLeftShiftAssign:
		return "<<="
	case BinaryOpRightShiftAssign:
		return ">>="
	case BinaryOpBitAndAssign:
		return "&="
	case BinaryOpBitOrAssign:
		return "|="
	case BinaryOpBitXorAssign:
		return "^="
	case BinaryOpComma:
		return ","
	default:
		return fmt.Sprintf("BinaryOp(%d)", n)
	}
}

func (n BinaryOp) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "*":
		n = BinaryOpMul
	case "/":
		n = BinaryOpDiv
	case "%":
		n = BinaryOpMod
	case "<<<":
		n = BinaryOpLeftArithmeticShift
	case ">>>":
		n = BinaryOpRightArithmeticShift
	case "<<":
		n = BinaryOpLeftLogicalShift
	case ">>":
		n = BinaryOpRightLogicalShift
	case "&":
		n = BinaryOpBitAnd
	case "+":
		n = BinaryOpAdd
	case "-":
		n = BinaryOpSub
	case "|":
		n = BinaryOpBitOr
	case "^":
		n = BinaryOpBitXor
	case "==":
		n = BinaryOpEqual
	case "!=":
		n = BinaryOpNotEqual
	case "<":
		n = BinaryOpLess
	case "<=":
		n = BinaryOpLessOrEq
	case ">":
		n = BinaryOpGrater
	case ">=":
		n = BinaryOpGraterOrEq
	case "&&":
		n = BinaryOpLogicalAnd
	case "||":
		n = BinaryOpLogicalOr
	case "?":
		n = BinaryOpCondOp1
	case ":":
		n = BinaryOpCondOp2
	case "..":
		n = BinaryOpRangeExclusive
	case "..=":
		n = BinaryOpRangeInclusive
	case "=":
		n = BinaryOpAssign
	case ":=":
		n = BinaryOpDefineAssign
	case "::=":
		n = BinaryOpConstAssign
	case "+=":
		n = BinaryOpAddAssign
	case "-=":
		n = BinaryOpSubAssign
	case "*=":
		n = BinaryOpMulAssign
	case "/=":
		n = BinaryOpDivAssign
	case "%=":
		n = BinaryOpModAssign
	case "<<=":
		n = BinaryOpLeftShiftAssign
	case ">>=":
		n = BinaryOpRightShiftAssign
	case "&=":
		n = BinaryOpBitAndAssign
	case "|=":
		n = BinaryOpBitOrAssign
	case "^=":
		n = BinaryOpBitXorAssign
	case ",":
		n = BinaryOpComma
	default:
		return fmt.Errorf("unknown BinaryOp: %q", tmp)
	}
	return nil
}

type IdentUsage int

const (
	IdentUsageUnknown          IdentUsage = 0
	IdentUsageReference        IdentUsage = 1
	IdentUsageDefineVariable   IdentUsage = 2
	IdentUsageDefineConst      IdentUsage = 3
	IdentUsageDefineField      IdentUsage = 4
	IdentUsageDefineFormat     IdentUsage = 5
	IdentUsageDefineEnum       IdentUsage = 6
	IdentUsageDefineEnumMember IdentUsage = 7
	IdentUsageDefineFn         IdentUsage = 8
	IdentUsageDefineCastFn     IdentUsage = 9
	IdentUsageDefineArg        IdentUsage = 10
	IdentUsageReferenceType    IdentUsage = 11
	IdentUsageMaybeType        IdentUsage = 12
)

func (n IdentUsage) String() string {
	switch n {
	case IdentUsageUnknown:
		return "unknown"
	case IdentUsageReference:
		return "reference"
	case IdentUsageDefineVariable:
		return "define_variable"
	case IdentUsageDefineConst:
		return "define_const"
	case IdentUsageDefineField:
		return "define_field"
	case IdentUsageDefineFormat:
		return "define_format"
	case IdentUsageDefineEnum:
		return "define_enum"
	case IdentUsageDefineEnumMember:
		return "define_enum_member"
	case IdentUsageDefineFn:
		return "define_fn"
	case IdentUsageDefineCastFn:
		return "define_cast_fn"
	case IdentUsageDefineArg:
		return "define_arg"
	case IdentUsageReferenceType:
		return "reference_type"
	case IdentUsageMaybeType:
		return "maybe_type"
	default:
		return fmt.Sprintf("IdentUsage(%d)", n)
	}
}

func (n IdentUsage) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "unknown":
		n = IdentUsageUnknown
	case "reference":
		n = IdentUsageReference
	case "define_variable":
		n = IdentUsageDefineVariable
	case "define_const":
		n = IdentUsageDefineConst
	case "define_field":
		n = IdentUsageDefineField
	case "define_format":
		n = IdentUsageDefineFormat
	case "define_enum":
		n = IdentUsageDefineEnum
	case "define_enum_member":
		n = IdentUsageDefineEnumMember
	case "define_fn":
		n = IdentUsageDefineFn
	case "define_cast_fn":
		n = IdentUsageDefineCastFn
	case "define_arg":
		n = IdentUsageDefineArg
	case "reference_type":
		n = IdentUsageReferenceType
	case "maybe_type":
		n = IdentUsageMaybeType
	default:
		return fmt.Errorf("unknown IdentUsage: %q", tmp)
	}
	return nil
}

type Endian int

const (
	EndianUnspec Endian = 0
	EndianBig    Endian = 1
	EndianLittle Endian = 2
)

func (n Endian) String() string {
	switch n {
	case EndianUnspec:
		return "unspec"
	case EndianBig:
		return "big"
	case EndianLittle:
		return "little"
	default:
		return fmt.Sprintf("Endian(%d)", n)
	}
}

func (n Endian) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "unspec":
		n = EndianUnspec
	case "big":
		n = EndianBig
	case "little":
		n = EndianLittle
	default:
		return fmt.Errorf("unknown Endian: %q", tmp)
	}
	return nil
}

type TokenTag int

const (
	TokenTagIndent      TokenTag = 0
	TokenTagSpace       TokenTag = 1
	TokenTagLine        TokenTag = 2
	TokenTagPunct       TokenTag = 3
	TokenTagIntLiteral  TokenTag = 4
	TokenTagBoolLiteral TokenTag = 5
	TokenTagStrLiteral  TokenTag = 6
	TokenTagKeyword     TokenTag = 7
	TokenTagIdent       TokenTag = 8
	TokenTagComment     TokenTag = 9
	TokenTagError       TokenTag = 10
	TokenTagUnknown     TokenTag = 11
)

func (n TokenTag) String() string {
	switch n {
	case TokenTagIndent:
		return "indent"
	case TokenTagSpace:
		return "space"
	case TokenTagLine:
		return "line"
	case TokenTagPunct:
		return "punct"
	case TokenTagIntLiteral:
		return "int_literal"
	case TokenTagBoolLiteral:
		return "bool_literal"
	case TokenTagStrLiteral:
		return "str_literal"
	case TokenTagKeyword:
		return "keyword"
	case TokenTagIdent:
		return "ident"
	case TokenTagComment:
		return "comment"
	case TokenTagError:
		return "error"
	case TokenTagUnknown:
		return "unknown"
	default:
		return fmt.Sprintf("TokenTag(%d)", n)
	}
}

func (n TokenTag) UnmarshalJSON(data []byte) error {
	var tmp string
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	switch tmp {
	case "indent":
		n = TokenTagIndent
	case "space":
		n = TokenTagSpace
	case "line":
		n = TokenTagLine
	case "punct":
		n = TokenTagPunct
	case "int_literal":
		n = TokenTagIntLiteral
	case "bool_literal":
		n = TokenTagBoolLiteral
	case "str_literal":
		n = TokenTagStrLiteral
	case "keyword":
		n = TokenTagKeyword
	case "ident":
		n = TokenTagIdent
	case "comment":
		n = TokenTagComment
	case "error":
		n = TokenTagError
	case "unknown":
		n = TokenTagUnknown
	default:
		return fmt.Errorf("unknown TokenTag: %q", tmp)
	}
	return nil
}

type Node interface {
	isNode()
	GetLoc() Loc
	GetNodeType() NodeType
}

type Expr interface {
	isExpr()
	Node
	GetExprType() Type
}

type Literal interface {
	isLiteral()
	Expr
}

type Stmt interface {
	isStmt()
	Node
}

type Member interface {
	isMember()
	Stmt
	GetBelong() Member
	GetIdent() *Ident
}

type Type interface {
	isType()
	Node
	GetIsExplicit() bool
}

type Program struct {
	Loc         Loc
	StructType  *StructType
	Elements    []Node
	GlobalScope *Scope
}

func (n *Program) isNode() {}

func (n *Program) GetLoc() Loc {
	return n.Loc
}

type Binary struct {
	Loc      Loc
	ExprType Type
	Op       BinaryOp
	Left     Expr
	Right    Expr
}

func (n *Binary) isExpr() {}

func (n *Binary) GetExprType() Type {
	return n.ExprType
}

func (n *Binary) isNode() {}

func (n *Binary) GetLoc() Loc {
	return n.Loc
}

type Unary struct {
	Loc      Loc
	ExprType Type
	Op       UnaryOp
	Expr     Expr
}

func (n *Unary) isExpr() {}

func (n *Unary) GetExprType() Type {
	return n.ExprType
}

func (n *Unary) isNode() {}

func (n *Unary) GetLoc() Loc {
	return n.Loc
}

type Cond struct {
	Loc      Loc
	ExprType Type
	Cond     Expr
	Then     Expr
	ElsLoc   Loc
	Els      Expr
}

func (n *Cond) isExpr() {}

func (n *Cond) GetExprType() Type {
	return n.ExprType
}

func (n *Cond) isNode() {}

func (n *Cond) GetLoc() Loc {
	return n.Loc
}

type Ident struct {
	Loc      Loc
	ExprType Type
	Ident    string
	Usage    IdentUsage
	Base     Node
	Scope    *Scope
}

func (n *Ident) isExpr() {}

func (n *Ident) GetExprType() Type {
	return n.ExprType
}

func (n *Ident) isNode() {}

func (n *Ident) GetLoc() Loc {
	return n.Loc
}

type Call struct {
	Loc          Loc
	ExprType     Type
	Callee       Expr
	RawArguments Expr
	Arguments    []Expr
	EndLoc       Loc
}

func (n *Call) isExpr() {}

func (n *Call) GetExprType() Type {
	return n.ExprType
}

func (n *Call) isNode() {}

func (n *Call) GetLoc() Loc {
	return n.Loc
}

type If struct {
	Loc       Loc
	ExprType  Type
	CondScope *Scope
	Cond      Expr
	Then      *IndentBlock
	Els       Node
}

func (n *If) isExpr() {}

func (n *If) GetExprType() Type {
	return n.ExprType
}

func (n *If) isNode() {}

func (n *If) GetLoc() Loc {
	return n.Loc
}

type MemberAccess struct {
	Loc       Loc
	ExprType  Type
	Target    Expr
	Member    string
	MemberLoc Loc
	Base      Node
}

func (n *MemberAccess) isExpr() {}

func (n *MemberAccess) GetExprType() Type {
	return n.ExprType
}

func (n *MemberAccess) isNode() {}

func (n *MemberAccess) GetLoc() Loc {
	return n.Loc
}

type Paren struct {
	Loc      Loc
	ExprType Type
	Expr     Expr
	EndLoc   Loc
}

func (n *Paren) isExpr() {}

func (n *Paren) GetExprType() Type {
	return n.ExprType
}

func (n *Paren) isNode() {}

func (n *Paren) GetLoc() Loc {
	return n.Loc
}

type Index struct {
	Loc      Loc
	ExprType Type
	Expr     Expr
	Index    Expr
	EndLoc   Loc
}

func (n *Index) isExpr() {}

func (n *Index) GetExprType() Type {
	return n.ExprType
}

func (n *Index) isNode() {}

func (n *Index) GetLoc() Loc {
	return n.Loc
}

type Match struct {
	Loc       Loc
	ExprType  Type
	CondScope *Scope
	Cond      Expr
	Branch    []Node
}

func (n *Match) isExpr() {}

func (n *Match) GetExprType() Type {
	return n.ExprType
}

func (n *Match) isNode() {}

func (n *Match) GetLoc() Loc {
	return n.Loc
}

type Range struct {
	Loc      Loc
	ExprType Type
	Op       BinaryOp
	Start    Expr
	End      Expr
}

func (n *Range) isExpr() {}

func (n *Range) GetExprType() Type {
	return n.ExprType
}

func (n *Range) isNode() {}

func (n *Range) GetLoc() Loc {
	return n.Loc
}

type TmpVar struct {
	Loc      Loc
	ExprType Type
	TmpVar   uint64
}

func (n *TmpVar) isExpr() {}

func (n *TmpVar) GetExprType() Type {
	return n.ExprType
}

func (n *TmpVar) isNode() {}

func (n *TmpVar) GetLoc() Loc {
	return n.Loc
}

type BlockExpr struct {
	Loc      Loc
	ExprType Type
	Calls    []Node
	Expr     Expr
}

func (n *BlockExpr) isExpr() {}

func (n *BlockExpr) GetExprType() Type {
	return n.ExprType
}

func (n *BlockExpr) isNode() {}

func (n *BlockExpr) GetLoc() Loc {
	return n.Loc
}

type Import struct {
	Loc        Loc
	ExprType   Type
	Path       string
	Base       *Call
	ImportDesc *Program
}

func (n *Import) isExpr() {}

func (n *Import) GetExprType() Type {
	return n.ExprType
}

func (n *Import) isNode() {}

func (n *Import) GetLoc() Loc {
	return n.Loc
}

type IntLiteral struct {
	Loc      Loc
	ExprType Type
	Value    string
}

func (n *IntLiteral) isLiteral() {}

func (n *IntLiteral) isExpr() {}

func (n *IntLiteral) GetExprType() Type {
	return n.ExprType
}

func (n *IntLiteral) isNode() {}

func (n *IntLiteral) GetLoc() Loc {
	return n.Loc
}

type BoolLiteral struct {
	Loc      Loc
	ExprType Type
	Value    bool
}

func (n *BoolLiteral) isLiteral() {}

func (n *BoolLiteral) isExpr() {}

func (n *BoolLiteral) GetExprType() Type {
	return n.ExprType
}

func (n *BoolLiteral) isNode() {}

func (n *BoolLiteral) GetLoc() Loc {
	return n.Loc
}

type StrLiteral struct {
	Loc      Loc
	ExprType Type
	Value    string
}

func (n *StrLiteral) isLiteral() {}

func (n *StrLiteral) isExpr() {}

func (n *StrLiteral) GetExprType() Type {
	return n.ExprType
}

func (n *StrLiteral) isNode() {}

func (n *StrLiteral) GetLoc() Loc {
	return n.Loc
}

type Input struct {
	Loc      Loc
	ExprType Type
}

func (n *Input) isLiteral() {}

func (n *Input) isExpr() {}

func (n *Input) GetExprType() Type {
	return n.ExprType
}

func (n *Input) isNode() {}

func (n *Input) GetLoc() Loc {
	return n.Loc
}

type Output struct {
	Loc      Loc
	ExprType Type
}

func (n *Output) isLiteral() {}

func (n *Output) isExpr() {}

func (n *Output) GetExprType() Type {
	return n.ExprType
}

func (n *Output) isNode() {}

func (n *Output) GetLoc() Loc {
	return n.Loc
}

type Config struct {
	Loc      Loc
	ExprType Type
}

func (n *Config) isLiteral() {}

func (n *Config) isExpr() {}

func (n *Config) GetExprType() Type {
	return n.ExprType
}

func (n *Config) isNode() {}

func (n *Config) GetLoc() Loc {
	return n.Loc
}

type Loop struct {
	Loc       Loc
	CondScope *Scope
	Init      Expr
	Cond      Expr
	Step      Expr
	Body      *IndentBlock
}

func (n *Loop) isStmt() {}

func (n *Loop) isNode() {}

func (n *Loop) GetLoc() Loc {
	return n.Loc
}

type IndentBlock struct {
	Loc        Loc
	Elements   []Node
	Scope      *Scope
	StructType *StructType
}

func (n *IndentBlock) isStmt() {}

func (n *IndentBlock) isNode() {}

func (n *IndentBlock) GetLoc() Loc {
	return n.Loc
}

type MatchBranch struct {
	Loc    Loc
	Cond   Expr
	SymLoc Loc
	Then   Node
}

func (n *MatchBranch) isStmt() {}

func (n *MatchBranch) isNode() {}

func (n *MatchBranch) GetLoc() Loc {
	return n.Loc
}

type Return struct {
	Loc  Loc
	Expr Expr
}

func (n *Return) isStmt() {}

func (n *Return) isNode() {}

func (n *Return) GetLoc() Loc {
	return n.Loc
}

type Break struct {
	Loc Loc
}

func (n *Break) isStmt() {}

func (n *Break) isNode() {}

func (n *Break) GetLoc() Loc {
	return n.Loc
}

type Continue struct {
	Loc Loc
}

func (n *Continue) isStmt() {}

func (n *Continue) isNode() {}

func (n *Continue) GetLoc() Loc {
	return n.Loc
}

type Assert struct {
	Loc  Loc
	Cond *Binary
}

func (n *Assert) isStmt() {}

func (n *Assert) isNode() {}

func (n *Assert) GetLoc() Loc {
	return n.Loc
}

type ImplicitYield struct {
	Loc  Loc
	Expr Expr
}

func (n *ImplicitYield) isStmt() {}

func (n *ImplicitYield) isNode() {}

func (n *ImplicitYield) GetLoc() Loc {
	return n.Loc
}

type Field struct {
	Loc          Loc
	Belong       Member
	Ident        *Ident
	ColonLoc     Loc
	FieldType    Type
	RawArguments Expr
	Arguments    []Expr
}

func (n *Field) isMember() {}

func (n *Field) GetBelong() Member {
	return n.Belong
}

func (n *Field) GetIdent() *Ident {
	return n.Ident
}

func (n *Field) isStmt() {}

func (n *Field) isNode() {}

func (n *Field) GetLoc() Loc {
	return n.Loc
}

type Format struct {
	Loc    Loc
	Belong Member
	Ident  *Ident
	Body   *IndentBlock
}

func (n *Format) isMember() {}

func (n *Format) GetBelong() Member {
	return n.Belong
}

func (n *Format) GetIdent() *Ident {
	return n.Ident
}

func (n *Format) isStmt() {}

func (n *Format) isNode() {}

func (n *Format) GetLoc() Loc {
	return n.Loc
}

type Function struct {
	Loc        Loc
	Belong     Member
	Ident      *Ident
	Parameters []*Field
	ReturnType Type
	Body       *IndentBlock
	FuncType   *FunctionType
	IsCast     bool
	CastLoc    Loc
}

func (n *Function) isMember() {}

func (n *Function) GetBelong() Member {
	return n.Belong
}

func (n *Function) GetIdent() *Ident {
	return n.Ident
}

func (n *Function) isStmt() {}

func (n *Function) isNode() {}

func (n *Function) GetLoc() Loc {
	return n.Loc
}

type IntType struct {
	Loc        Loc
	IsExplicit bool
	BitSize    uint64
	Endian     Endian
	IsSigned   bool
}

func (n *IntType) isType() {}

func (n *IntType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *IntType) isNode() {}

func (n *IntType) GetLoc() Loc {
	return n.Loc
}

type IdentType struct {
	Loc        Loc
	IsExplicit bool
	Ident      *Ident
	Base       Member
}

func (n *IdentType) isType() {}

func (n *IdentType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *IdentType) isNode() {}

func (n *IdentType) GetLoc() Loc {
	return n.Loc
}

type IntLiteralType struct {
	Loc        Loc
	IsExplicit bool
	Base       *IntLiteral
}

func (n *IntLiteralType) isType() {}

func (n *IntLiteralType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *IntLiteralType) isNode() {}

func (n *IntLiteralType) GetLoc() Loc {
	return n.Loc
}

type StrLiteralType struct {
	Loc        Loc
	IsExplicit bool
	Base       *StrLiteral
}

func (n *StrLiteralType) isType() {}

func (n *StrLiteralType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *StrLiteralType) isNode() {}

func (n *StrLiteralType) GetLoc() Loc {
	return n.Loc
}

type VoidType struct {
	Loc        Loc
	IsExplicit bool
}

func (n *VoidType) isType() {}

func (n *VoidType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *VoidType) isNode() {}

func (n *VoidType) GetLoc() Loc {
	return n.Loc
}

type BoolType struct {
	Loc        Loc
	IsExplicit bool
}

func (n *BoolType) isType() {}

func (n *BoolType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *BoolType) isNode() {}

func (n *BoolType) GetLoc() Loc {
	return n.Loc
}

type ArrayType struct {
	Loc        Loc
	IsExplicit bool
	EndLoc     Loc
	BaseType   Type
	Length     Expr
}

func (n *ArrayType) isType() {}

func (n *ArrayType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *ArrayType) isNode() {}

func (n *ArrayType) GetLoc() Loc {
	return n.Loc
}

type FunctionType struct {
	Loc        Loc
	IsExplicit bool
	ReturnType Type
	Parameters []Type
}

func (n *FunctionType) isType() {}

func (n *FunctionType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *FunctionType) isNode() {}

func (n *FunctionType) GetLoc() Loc {
	return n.Loc
}

type StructType struct {
	Loc        Loc
	IsExplicit bool
	Fields     []Member
}

func (n *StructType) isType() {}

func (n *StructType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *StructType) isNode() {}

func (n *StructType) GetLoc() Loc {
	return n.Loc
}

type StructUnionType struct {
	Loc         Loc
	IsExplicit  bool
	Fields      []*StructType
	Base        Expr
	UnionFields []*Field
}

func (n *StructUnionType) isType() {}

func (n *StructUnionType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *StructUnionType) isNode() {}

func (n *StructUnionType) GetLoc() Loc {
	return n.Loc
}

type Cast struct {
	Loc      Loc
	ExprType Type
	Base     *Call
	Expr     Expr
}

func (n *Cast) isExpr() {}

func (n *Cast) GetExprType() Type {
	return n.ExprType
}

func (n *Cast) isNode() {}

func (n *Cast) GetLoc() Loc {
	return n.Loc
}

type Comment struct {
	Loc     Loc
	Comment string
}

func (n *Comment) isNode() {}

func (n *Comment) GetLoc() Loc {
	return n.Loc
}

type CommentGroup struct {
	Loc      Loc
	Comments []*Comment
}

func (n *CommentGroup) isNode() {}

func (n *CommentGroup) GetLoc() Loc {
	return n.Loc
}

type UnionType struct {
	Loc        Loc
	IsExplicit bool
	Cond       Expr
	Candidates []*UnionCandidate
	BaseType   *StructUnionType
}

func (n *UnionType) isType() {}

func (n *UnionType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *UnionType) isNode() {}

func (n *UnionType) GetLoc() Loc {
	return n.Loc
}

type UnionCandidate struct {
	Loc   Loc
	Cond  Expr
	Field Member
}

func (n *UnionCandidate) isStmt() {}

func (n *UnionCandidate) isNode() {}

func (n *UnionCandidate) GetLoc() Loc {
	return n.Loc
}

type RangeType struct {
	Loc        Loc
	IsExplicit bool
	BaseType   Type
	Range      *Range
}

func (n *RangeType) isType() {}

func (n *RangeType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *RangeType) isNode() {}

func (n *RangeType) GetLoc() Loc {
	return n.Loc
}

type Enum struct {
	Loc      Loc
	Belong   Member
	Ident    *Ident
	Scope    *Scope
	ColonLoc Loc
	BaseType Type
	Members  []*EnumMember
	EnumType *EnumType
}

func (n *Enum) isMember() {}

func (n *Enum) GetBelong() Member {
	return n.Belong
}

func (n *Enum) GetIdent() *Ident {
	return n.Ident
}

func (n *Enum) isStmt() {}

func (n *Enum) isNode() {}

func (n *Enum) GetLoc() Loc {
	return n.Loc
}

type EnumMember struct {
	Loc    Loc
	Belong Member
	Ident  *Ident
	Expr   Expr
}

func (n *EnumMember) isMember() {}

func (n *EnumMember) GetBelong() Member {
	return n.Belong
}

func (n *EnumMember) GetIdent() *Ident {
	return n.Ident
}

func (n *EnumMember) isStmt() {}

func (n *EnumMember) isNode() {}

func (n *EnumMember) GetLoc() Loc {
	return n.Loc
}

type EnumType struct {
	Loc        Loc
	IsExplicit bool
	Base       *Enum
}

func (n *EnumType) isType() {}

func (n *EnumType) GetIsExplicit() bool {
	return n.IsExplicit
}

func (n *EnumType) isNode() {}

func (n *EnumType) GetLoc() Loc {
	return n.Loc
}

type Scope struct {
	Prev       *Scope
	Next       *Scope
	Branch     *Scope
	Ident      []*Ident
	Owner      Node
	BranchRoot bool
}

type Pos struct {
	Begin uint64 `json:"begin"`
	End   uint64 `json:"end"`
}

type Loc struct {
	Pos  Pos    `json:"pos"`
	File uint64 `json:"file"`
	Line uint64 `json:"line"`
	Col  uint64 `json:"col"`
}

type Token struct {
	Tag   TokenTag `json:"tag"`
	Token string   `json:"token"`
	Loc   Loc      `json:"loc"`
}

type RawScope struct {
	Prev       *uintptr  `json:"prev"`
	Next       *uintptr  `json:"next"`
	Branch     *uintptr  `json:"branch"`
	Ident      []uintptr `json:"ident"`
	Owner      *uintptr  `json:"owner"`
	BranchRoot bool      `json:"branch_root"`
}

type RawNode struct {
	NodeType NodeType        `json:"node_type"`
	Loc      Loc             `json:"loc"`
	Body     json.RawMessage `json:"body"`
}

type SrcErrorEntry struct {
	Msg  string `json:"msg"`
	File string `json:"file"`
	Loc  Loc    `json:"loc"`
	Src  string `json:"src"`
	Warn bool   `json:"warn"`
}

type SrcError struct {
	Errs []SrcErrorEntry `json:"errs"`
}

type JsonAst struct {
	Node  []RawNode  `json:"node"`
	Scope []RawScope `json:"scope"`
}

type AstFile struct {
	Files []string  `json:"files"`
	Ast   *JsonAst  `json:"ast"`
	Error *SrcError `json:"error"`
}

type TokenFile struct {
	Files  []string  `json:"files"`
	Tokens []Token   `json:"tokens"`
	Error  *SrcError `json:"error"`
}

type astConstructor struct {
	node  []Node
	scope []*Scope
}

func ParseAST(aux *JsonAst) (prog *Program, err error) {
	defer func() {
		if r := recover(); r != nil {
			err = fmt.Errorf("%v", r)
		}
	}()
	n := &astConstructor{}
	n.node = make([]Node, len(aux.Node))
	for i, raw := range aux.Node {
		switch raw.NodeType {
		case NodeTypeProgram:
			n.node[i] = &Program{Loc: raw.Loc}
		case NodeTypeBinary:
			n.node[i] = &Binary{Loc: raw.Loc}
		case NodeTypeUnary:
			n.node[i] = &Unary{Loc: raw.Loc}
		case NodeTypeCond:
			n.node[i] = &Cond{Loc: raw.Loc}
		case NodeTypeIdent:
			n.node[i] = &Ident{Loc: raw.Loc}
		case NodeTypeCall:
			n.node[i] = &Call{Loc: raw.Loc}
		case NodeTypeIf:
			n.node[i] = &If{Loc: raw.Loc}
		case NodeTypeMemberAccess:
			n.node[i] = &MemberAccess{Loc: raw.Loc}
		case NodeTypeParen:
			n.node[i] = &Paren{Loc: raw.Loc}
		case NodeTypeIndex:
			n.node[i] = &Index{Loc: raw.Loc}
		case NodeTypeMatch:
			n.node[i] = &Match{Loc: raw.Loc}
		case NodeTypeRange:
			n.node[i] = &Range{Loc: raw.Loc}
		case NodeTypeTmpVar:
			n.node[i] = &TmpVar{Loc: raw.Loc}
		case NodeTypeBlockExpr:
			n.node[i] = &BlockExpr{Loc: raw.Loc}
		case NodeTypeImport:
			n.node[i] = &Import{Loc: raw.Loc}
		case NodeTypeIntLiteral:
			n.node[i] = &IntLiteral{Loc: raw.Loc}
		case NodeTypeBoolLiteral:
			n.node[i] = &BoolLiteral{Loc: raw.Loc}
		case NodeTypeStrLiteral:
			n.node[i] = &StrLiteral{Loc: raw.Loc}
		case NodeTypeInput:
			n.node[i] = &Input{Loc: raw.Loc}
		case NodeTypeOutput:
			n.node[i] = &Output{Loc: raw.Loc}
		case NodeTypeConfig:
			n.node[i] = &Config{Loc: raw.Loc}
		case NodeTypeLoop:
			n.node[i] = &Loop{Loc: raw.Loc}
		case NodeTypeIndentBlock:
			n.node[i] = &IndentBlock{Loc: raw.Loc}
		case NodeTypeMatchBranch:
			n.node[i] = &MatchBranch{Loc: raw.Loc}
		case NodeTypeReturn:
			n.node[i] = &Return{Loc: raw.Loc}
		case NodeTypeBreak:
			n.node[i] = &Break{Loc: raw.Loc}
		case NodeTypeContinue:
			n.node[i] = &Continue{Loc: raw.Loc}
		case NodeTypeAssert:
			n.node[i] = &Assert{Loc: raw.Loc}
		case NodeTypeImplicitYield:
			n.node[i] = &ImplicitYield{Loc: raw.Loc}
		case NodeTypeField:
			n.node[i] = &Field{Loc: raw.Loc}
		case NodeTypeFormat:
			n.node[i] = &Format{Loc: raw.Loc}
		case NodeTypeFunction:
			n.node[i] = &Function{Loc: raw.Loc}
		case NodeTypeIntType:
			n.node[i] = &IntType{Loc: raw.Loc}
		case NodeTypeIdentType:
			n.node[i] = &IdentType{Loc: raw.Loc}
		case NodeTypeIntLiteralType:
			n.node[i] = &IntLiteralType{Loc: raw.Loc}
		case NodeTypeStrLiteralType:
			n.node[i] = &StrLiteralType{Loc: raw.Loc}
		case NodeTypeVoidType:
			n.node[i] = &VoidType{Loc: raw.Loc}
		case NodeTypeBoolType:
			n.node[i] = &BoolType{Loc: raw.Loc}
		case NodeTypeArrayType:
			n.node[i] = &ArrayType{Loc: raw.Loc}
		case NodeTypeFunctionType:
			n.node[i] = &FunctionType{Loc: raw.Loc}
		case NodeTypeStructType:
			n.node[i] = &StructType{Loc: raw.Loc}
		case NodeTypeStructUnionType:
			n.node[i] = &StructUnionType{Loc: raw.Loc}
		case NodeTypeCast:
			n.node[i] = &Cast{Loc: raw.Loc}
		case NodeTypeComment:
			n.node[i] = &Comment{Loc: raw.Loc}
		case NodeTypeCommentGroup:
			n.node[i] = &CommentGroup{Loc: raw.Loc}
		case NodeTypeUnionType:
			n.node[i] = &UnionType{Loc: raw.Loc}
		case NodeTypeUnionCandidate:
			n.node[i] = &UnionCandidate{Loc: raw.Loc}
		case NodeTypeRangeType:
			n.node[i] = &RangeType{Loc: raw.Loc}
		case NodeTypeEnum:
			n.node[i] = &Enum{Loc: raw.Loc}
		case NodeTypeEnumMember:
			n.node[i] = &EnumMember{Loc: raw.Loc}
		case NodeTypeEnumType:
			n.node[i] = &EnumType{Loc: raw.Loc}
		default:
			return nil, fmt.Errorf("unknown node type: %q", raw.NodeType)
		}
	}
	n.scope = make([]*Scope, len(aux.Scope))
	for i := range aux.Scope {
		n.scope[i] = &Scope{}
	}
	for i, raw := range aux.Node {
		switch raw.NodeType {
		case NodeTypeProgram:
			v := n.node[i].(*Program)
			var tmp struct {
				StructType  *uintptr  `json:"struct_type"`
				Elements    []uintptr `json:"elements"`
				GlobalScope *uintptr  `json:"global_scope"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.StructType != nil {
				v.StructType = n.node[*tmp.StructType].(*StructType)
			}
			v.Elements = make([]Node, len(tmp.Elements))
			for j, k := range tmp.Elements {
				v.Elements[j] = n.node[k].(Node)
			}
			if tmp.GlobalScope != nil {
				v.GlobalScope = n.scope[*tmp.GlobalScope]
			}
		case NodeTypeBinary:
			v := n.node[i].(*Binary)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Op       BinaryOp `json:"op"`
				Left     *uintptr `json:"left"`
				Right    *uintptr `json:"right"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Op = tmp.Op
			if tmp.Left != nil {
				v.Left = n.node[*tmp.Left].(Expr)
			}
			if tmp.Right != nil {
				v.Right = n.node[*tmp.Right].(Expr)
			}
		case NodeTypeUnary:
			v := n.node[i].(*Unary)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Op       UnaryOp  `json:"op"`
				Expr     *uintptr `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Op = tmp.Op
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		case NodeTypeCond:
			v := n.node[i].(*Cond)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Cond     *uintptr `json:"cond"`
				Then     *uintptr `json:"then"`
				ElsLoc   Loc      `json:"els_loc"`
				Els      *uintptr `json:"els"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			if tmp.Then != nil {
				v.Then = n.node[*tmp.Then].(Expr)
			}
			v.ElsLoc = tmp.ElsLoc
			if tmp.Els != nil {
				v.Els = n.node[*tmp.Els].(Expr)
			}
		case NodeTypeIdent:
			v := n.node[i].(*Ident)
			var tmp struct {
				ExprType *uintptr   `json:"expr_type"`
				Ident    string     `json:"ident"`
				Usage    IdentUsage `json:"usage"`
				Base     *uintptr   `json:"base"`
				Scope    *uintptr   `json:"scope"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Ident = tmp.Ident
			v.Usage = tmp.Usage
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(Node)
			}
			if tmp.Scope != nil {
				v.Scope = n.scope[*tmp.Scope]
			}
		case NodeTypeCall:
			v := n.node[i].(*Call)
			var tmp struct {
				ExprType     *uintptr  `json:"expr_type"`
				Callee       *uintptr  `json:"callee"`
				RawArguments *uintptr  `json:"raw_arguments"`
				Arguments    []uintptr `json:"arguments"`
				EndLoc       Loc       `json:"end_loc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.Callee != nil {
				v.Callee = n.node[*tmp.Callee].(Expr)
			}
			if tmp.RawArguments != nil {
				v.RawArguments = n.node[*tmp.RawArguments].(Expr)
			}
			v.Arguments = make([]Expr, len(tmp.Arguments))
			for j, k := range tmp.Arguments {
				v.Arguments[j] = n.node[k].(Expr)
			}
			v.EndLoc = tmp.EndLoc
		case NodeTypeIf:
			v := n.node[i].(*If)
			var tmp struct {
				ExprType  *uintptr `json:"expr_type"`
				CondScope *uintptr `json:"cond_scope"`
				Cond      *uintptr `json:"cond"`
				Then      *uintptr `json:"then"`
				Els       *uintptr `json:"els"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.CondScope != nil {
				v.CondScope = n.scope[*tmp.CondScope]
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			if tmp.Then != nil {
				v.Then = n.node[*tmp.Then].(*IndentBlock)
			}
			if tmp.Els != nil {
				v.Els = n.node[*tmp.Els].(Node)
			}
		case NodeTypeMemberAccess:
			v := n.node[i].(*MemberAccess)
			var tmp struct {
				ExprType  *uintptr `json:"expr_type"`
				Target    *uintptr `json:"target"`
				Member    string   `json:"member"`
				MemberLoc Loc      `json:"member_loc"`
				Base      *uintptr `json:"base"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.Target != nil {
				v.Target = n.node[*tmp.Target].(Expr)
			}
			v.Member = tmp.Member
			v.MemberLoc = tmp.MemberLoc
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(Node)
			}
		case NodeTypeParen:
			v := n.node[i].(*Paren)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Expr     *uintptr `json:"expr"`
				EndLoc   Loc      `json:"end_loc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
			v.EndLoc = tmp.EndLoc
		case NodeTypeIndex:
			v := n.node[i].(*Index)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Expr     *uintptr `json:"expr"`
				Index    *uintptr `json:"index"`
				EndLoc   Loc      `json:"end_loc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
			if tmp.Index != nil {
				v.Index = n.node[*tmp.Index].(Expr)
			}
			v.EndLoc = tmp.EndLoc
		case NodeTypeMatch:
			v := n.node[i].(*Match)
			var tmp struct {
				ExprType  *uintptr  `json:"expr_type"`
				CondScope *uintptr  `json:"cond_scope"`
				Cond      *uintptr  `json:"cond"`
				Branch    []uintptr `json:"branch"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.CondScope != nil {
				v.CondScope = n.scope[*tmp.CondScope]
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			v.Branch = make([]Node, len(tmp.Branch))
			for j, k := range tmp.Branch {
				v.Branch[j] = n.node[k].(Node)
			}
		case NodeTypeRange:
			v := n.node[i].(*Range)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Op       BinaryOp `json:"op"`
				Start    *uintptr `json:"start"`
				End      *uintptr `json:"end"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Op = tmp.Op
			if tmp.Start != nil {
				v.Start = n.node[*tmp.Start].(Expr)
			}
			if tmp.End != nil {
				v.End = n.node[*tmp.End].(Expr)
			}
		case NodeTypeTmpVar:
			v := n.node[i].(*TmpVar)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				TmpVar   uint64   `json:"tmp_var"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.TmpVar = tmp.TmpVar
		case NodeTypeBlockExpr:
			v := n.node[i].(*BlockExpr)
			var tmp struct {
				ExprType *uintptr  `json:"expr_type"`
				Calls    []uintptr `json:"calls"`
				Expr     *uintptr  `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Calls = make([]Node, len(tmp.Calls))
			for j, k := range tmp.Calls {
				v.Calls[j] = n.node[k].(Node)
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		case NodeTypeImport:
			v := n.node[i].(*Import)
			var tmp struct {
				ExprType   *uintptr `json:"expr_type"`
				Path       string   `json:"path"`
				Base       *uintptr `json:"base"`
				ImportDesc *uintptr `json:"import_desc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Path = tmp.Path
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*Call)
			}
			if tmp.ImportDesc != nil {
				v.ImportDesc = n.node[*tmp.ImportDesc].(*Program)
			}
		case NodeTypeIntLiteral:
			v := n.node[i].(*IntLiteral)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Value    string   `json:"value"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Value = tmp.Value
		case NodeTypeBoolLiteral:
			v := n.node[i].(*BoolLiteral)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Value    bool     `json:"value"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Value = tmp.Value
		case NodeTypeStrLiteral:
			v := n.node[i].(*StrLiteral)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Value    string   `json:"value"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			v.Value = tmp.Value
		case NodeTypeInput:
			v := n.node[i].(*Input)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
		case NodeTypeOutput:
			v := n.node[i].(*Output)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
		case NodeTypeConfig:
			v := n.node[i].(*Config)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
		case NodeTypeLoop:
			v := n.node[i].(*Loop)
			var tmp struct {
				CondScope *uintptr `json:"cond_scope"`
				Init      *uintptr `json:"init"`
				Cond      *uintptr `json:"cond"`
				Step      *uintptr `json:"step"`
				Body      *uintptr `json:"body"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.CondScope != nil {
				v.CondScope = n.scope[*tmp.CondScope]
			}
			if tmp.Init != nil {
				v.Init = n.node[*tmp.Init].(Expr)
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			if tmp.Step != nil {
				v.Step = n.node[*tmp.Step].(Expr)
			}
			if tmp.Body != nil {
				v.Body = n.node[*tmp.Body].(*IndentBlock)
			}
		case NodeTypeIndentBlock:
			v := n.node[i].(*IndentBlock)
			var tmp struct {
				Elements   []uintptr `json:"elements"`
				Scope      *uintptr  `json:"scope"`
				StructType *uintptr  `json:"struct_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.Elements = make([]Node, len(tmp.Elements))
			for j, k := range tmp.Elements {
				v.Elements[j] = n.node[k].(Node)
			}
			if tmp.Scope != nil {
				v.Scope = n.scope[*tmp.Scope]
			}
			if tmp.StructType != nil {
				v.StructType = n.node[*tmp.StructType].(*StructType)
			}
		case NodeTypeMatchBranch:
			v := n.node[i].(*MatchBranch)
			var tmp struct {
				Cond   *uintptr `json:"cond"`
				SymLoc Loc      `json:"sym_loc"`
				Then   *uintptr `json:"then"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			v.SymLoc = tmp.SymLoc
			if tmp.Then != nil {
				v.Then = n.node[*tmp.Then].(Node)
			}
		case NodeTypeReturn:
			v := n.node[i].(*Return)
			var tmp struct {
				Expr *uintptr `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		case NodeTypeBreak:
			var tmp struct {
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
		case NodeTypeContinue:
			var tmp struct {
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
		case NodeTypeAssert:
			v := n.node[i].(*Assert)
			var tmp struct {
				Cond *uintptr `json:"cond"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(*Binary)
			}
		case NodeTypeImplicitYield:
			v := n.node[i].(*ImplicitYield)
			var tmp struct {
				Expr *uintptr `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		case NodeTypeField:
			v := n.node[i].(*Field)
			var tmp struct {
				Belong       *uintptr  `json:"belong"`
				Ident        *uintptr  `json:"ident"`
				ColonLoc     Loc       `json:"colon_loc"`
				FieldType    *uintptr  `json:"field_type"`
				RawArguments *uintptr  `json:"raw_arguments"`
				Arguments    []uintptr `json:"arguments"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(Member)
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			v.ColonLoc = tmp.ColonLoc
			if tmp.FieldType != nil {
				v.FieldType = n.node[*tmp.FieldType].(Type)
			}
			if tmp.RawArguments != nil {
				v.RawArguments = n.node[*tmp.RawArguments].(Expr)
			}
			v.Arguments = make([]Expr, len(tmp.Arguments))
			for j, k := range tmp.Arguments {
				v.Arguments[j] = n.node[k].(Expr)
			}
		case NodeTypeFormat:
			v := n.node[i].(*Format)
			var tmp struct {
				Belong *uintptr `json:"belong"`
				Ident  *uintptr `json:"ident"`
				Body   *uintptr `json:"body"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(Member)
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			if tmp.Body != nil {
				v.Body = n.node[*tmp.Body].(*IndentBlock)
			}
		case NodeTypeFunction:
			v := n.node[i].(*Function)
			var tmp struct {
				Belong     *uintptr  `json:"belong"`
				Ident      *uintptr  `json:"ident"`
				Parameters []uintptr `json:"parameters"`
				ReturnType *uintptr  `json:"return_type"`
				Body       *uintptr  `json:"body"`
				FuncType   *uintptr  `json:"func_type"`
				IsCast     bool      `json:"is_cast"`
				CastLoc    Loc       `json:"cast_loc"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(Member)
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			v.Parameters = make([]*Field, len(tmp.Parameters))
			for j, k := range tmp.Parameters {
				v.Parameters[j] = n.node[k].(*Field)
			}
			if tmp.ReturnType != nil {
				v.ReturnType = n.node[*tmp.ReturnType].(Type)
			}
			if tmp.Body != nil {
				v.Body = n.node[*tmp.Body].(*IndentBlock)
			}
			if tmp.FuncType != nil {
				v.FuncType = n.node[*tmp.FuncType].(*FunctionType)
			}
			v.IsCast = tmp.IsCast
			v.CastLoc = tmp.CastLoc
		case NodeTypeIntType:
			v := n.node[i].(*IntType)
			var tmp struct {
				IsExplicit bool   `json:"is_explicit"`
				BitSize    uint64 `json:"bit_size"`
				Endian     Endian `json:"endian"`
				IsSigned   bool   `json:"is_signed"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.BitSize = tmp.BitSize
			v.Endian = tmp.Endian
			v.IsSigned = tmp.IsSigned
		case NodeTypeIdentType:
			v := n.node[i].(*IdentType)
			var tmp struct {
				IsExplicit bool     `json:"is_explicit"`
				Ident      *uintptr `json:"ident"`
				Base       *uintptr `json:"base"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(Member)
			}
		case NodeTypeIntLiteralType:
			v := n.node[i].(*IntLiteralType)
			var tmp struct {
				IsExplicit bool     `json:"is_explicit"`
				Base       *uintptr `json:"base"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*IntLiteral)
			}
		case NodeTypeStrLiteralType:
			v := n.node[i].(*StrLiteralType)
			var tmp struct {
				IsExplicit bool     `json:"is_explicit"`
				Base       *uintptr `json:"base"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*StrLiteral)
			}
		case NodeTypeVoidType:
			v := n.node[i].(*VoidType)
			var tmp struct {
				IsExplicit bool `json:"is_explicit"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
		case NodeTypeBoolType:
			v := n.node[i].(*BoolType)
			var tmp struct {
				IsExplicit bool `json:"is_explicit"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
		case NodeTypeArrayType:
			v := n.node[i].(*ArrayType)
			var tmp struct {
				IsExplicit bool     `json:"is_explicit"`
				EndLoc     Loc      `json:"end_loc"`
				BaseType   *uintptr `json:"base_type"`
				Length     *uintptr `json:"length"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.EndLoc = tmp.EndLoc
			if tmp.BaseType != nil {
				v.BaseType = n.node[*tmp.BaseType].(Type)
			}
			if tmp.Length != nil {
				v.Length = n.node[*tmp.Length].(Expr)
			}
		case NodeTypeFunctionType:
			v := n.node[i].(*FunctionType)
			var tmp struct {
				IsExplicit bool      `json:"is_explicit"`
				ReturnType *uintptr  `json:"return_type"`
				Parameters []uintptr `json:"parameters"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			if tmp.ReturnType != nil {
				v.ReturnType = n.node[*tmp.ReturnType].(Type)
			}
			v.Parameters = make([]Type, len(tmp.Parameters))
			for j, k := range tmp.Parameters {
				v.Parameters[j] = n.node[k].(Type)
			}
		case NodeTypeStructType:
			v := n.node[i].(*StructType)
			var tmp struct {
				IsExplicit bool      `json:"is_explicit"`
				Fields     []uintptr `json:"fields"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.Fields = make([]Member, len(tmp.Fields))
			for j, k := range tmp.Fields {
				v.Fields[j] = n.node[k].(Member)
			}
		case NodeTypeStructUnionType:
			v := n.node[i].(*StructUnionType)
			var tmp struct {
				IsExplicit  bool      `json:"is_explicit"`
				Fields      []uintptr `json:"fields"`
				Base        *uintptr  `json:"base"`
				UnionFields []uintptr `json:"union_fields"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			v.Fields = make([]*StructType, len(tmp.Fields))
			for j, k := range tmp.Fields {
				v.Fields[j] = n.node[k].(*StructType)
			}
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(Expr)
			}
			v.UnionFields = make([]*Field, len(tmp.UnionFields))
			for j, k := range tmp.UnionFields {
				v.UnionFields[j] = n.node[k].(*Field)
			}
		case NodeTypeCast:
			v := n.node[i].(*Cast)
			var tmp struct {
				ExprType *uintptr `json:"expr_type"`
				Base     *uintptr `json:"base"`
				Expr     *uintptr `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.ExprType != nil {
				v.ExprType = n.node[*tmp.ExprType].(Type)
			}
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*Call)
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		case NodeTypeComment:
			v := n.node[i].(*Comment)
			var tmp struct {
				Comment string `json:"comment"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.Comment = tmp.Comment
		case NodeTypeCommentGroup:
			v := n.node[i].(*CommentGroup)
			var tmp struct {
				Comments []uintptr `json:"comments"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.Comments = make([]*Comment, len(tmp.Comments))
			for j, k := range tmp.Comments {
				v.Comments[j] = n.node[k].(*Comment)
			}
		case NodeTypeUnionType:
			v := n.node[i].(*UnionType)
			var tmp struct {
				IsExplicit bool      `json:"is_explicit"`
				Cond       *uintptr  `json:"cond"`
				Candidates []uintptr `json:"candidates"`
				BaseType   *uintptr  `json:"base_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			v.Candidates = make([]*UnionCandidate, len(tmp.Candidates))
			for j, k := range tmp.Candidates {
				v.Candidates[j] = n.node[k].(*UnionCandidate)
			}
			if tmp.BaseType != nil {
				v.BaseType = n.node[*tmp.BaseType].(*StructUnionType)
			}
		case NodeTypeUnionCandidate:
			v := n.node[i].(*UnionCandidate)
			var tmp struct {
				Cond  *uintptr `json:"cond"`
				Field *uintptr `json:"field"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Cond != nil {
				v.Cond = n.node[*tmp.Cond].(Expr)
			}
			if tmp.Field != nil {
				v.Field = n.node[*tmp.Field].(Member)
			}
		case NodeTypeRangeType:
			v := n.node[i].(*RangeType)
			var tmp struct {
				IsExplicit bool     `json:"is_explicit"`
				BaseType   *uintptr `json:"base_type"`
				Range      *uintptr `json:"range"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			if tmp.BaseType != nil {
				v.BaseType = n.node[*tmp.BaseType].(Type)
			}
			if tmp.Range != nil {
				v.Range = n.node[*tmp.Range].(*Range)
			}
		case NodeTypeEnum:
			v := n.node[i].(*Enum)
			var tmp struct {
				Belong   *uintptr  `json:"belong"`
				Ident    *uintptr  `json:"ident"`
				Scope    *uintptr  `json:"scope"`
				ColonLoc Loc       `json:"colon_loc"`
				BaseType *uintptr  `json:"base_type"`
				Members  []uintptr `json:"members"`
				EnumType *uintptr  `json:"enum_type"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(Member)
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			if tmp.Scope != nil {
				v.Scope = n.scope[*tmp.Scope]
			}
			v.ColonLoc = tmp.ColonLoc
			if tmp.BaseType != nil {
				v.BaseType = n.node[*tmp.BaseType].(Type)
			}
			v.Members = make([]*EnumMember, len(tmp.Members))
			for j, k := range tmp.Members {
				v.Members[j] = n.node[k].(*EnumMember)
			}
			if tmp.EnumType != nil {
				v.EnumType = n.node[*tmp.EnumType].(*EnumType)
			}
		case NodeTypeEnumMember:
			v := n.node[i].(*EnumMember)
			var tmp struct {
				Belong *uintptr `json:"belong"`
				Ident  *uintptr `json:"ident"`
				Expr   *uintptr `json:"expr"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			if tmp.Belong != nil {
				v.Belong = n.node[*tmp.Belong].(Member)
			}
			if tmp.Ident != nil {
				v.Ident = n.node[*tmp.Ident].(*Ident)
			}
			if tmp.Expr != nil {
				v.Expr = n.node[*tmp.Expr].(Expr)
			}
		case NodeTypeEnumType:
			v := n.node[i].(*EnumType)
			var tmp struct {
				IsExplicit bool     `json:"is_explicit"`
				Base       *uintptr `json:"base"`
			}
			if err := json.Unmarshal(raw.Body, &tmp); err != nil {
				return nil, err
			}
			v.IsExplicit = tmp.IsExplicit
			if tmp.Base != nil {
				v.Base = n.node[*tmp.Base].(*Enum)
			}
		default:
			return nil, fmt.Errorf("unknown node type: %q", raw.NodeType)
		}
	}
	for i, raw := range aux.Scope {
		if raw.Prev != nil {
			n.scope[i].Prev = n.scope[*raw.Prev]
		}
		if raw.Next != nil {
			n.scope[i].Next = n.scope[*raw.Next]
		}
		if raw.Branch != nil {
			n.scope[i].Branch = n.scope[*raw.Branch]
		}
		n.scope[i].Ident = make([]*Ident, len(raw.Ident))
		for j, k := range raw.Ident {
			n.scope[i].Ident[j] = n.node[k].(*Ident)
		}
		if raw.Owner != nil {
			n.scope[i].Owner = n.node[*raw.Owner].(Node)
		}
		n.scope[i].BranchRoot = raw.BranchRoot
	}
	return n.node[0].(*Program), nil
}

type Visitor interface {
	Visit(v Visitor, n Node) bool
}

type VisitFn func(v Visitor, n Node) bool

func (f VisitFn) Visit(v Visitor, n Node) bool {
	return f(v, n)
}

func Walk(n Node, f Visitor) {
	switch v := n.(type) {
	case *Program:
		if v.StructType != nil {
			if !f.Visit(f, v.StructType) {
				return
			}
		}
		for _, w := range v.Elements {
			if !f.Visit(f, w) {
				return
			}
		}
	case *Binary:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Left != nil {
			if !f.Visit(f, v.Left) {
				return
			}
		}
		if v.Right != nil {
			if !f.Visit(f, v.Right) {
				return
			}
		}
	case *Unary:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Expr != nil {
			if !f.Visit(f, v.Expr) {
				return
			}
		}
	case *Cond:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Cond != nil {
			if !f.Visit(f, v.Cond) {
				return
			}
		}
		if v.Then != nil {
			if !f.Visit(f, v.Then) {
				return
			}
		}
		if v.Els != nil {
			if !f.Visit(f, v.Els) {
				return
			}
		}
	case *Ident:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
	case *Call:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Callee != nil {
			if !f.Visit(f, v.Callee) {
				return
			}
		}
		if v.RawArguments != nil {
			if !f.Visit(f, v.RawArguments) {
				return
			}
		}
		for _, w := range v.Arguments {
			if !f.Visit(f, w) {
				return
			}
		}
	case *If:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Cond != nil {
			if !f.Visit(f, v.Cond) {
				return
			}
		}
		if v.Then != nil {
			if !f.Visit(f, v.Then) {
				return
			}
		}
		if v.Els != nil {
			if !f.Visit(f, v.Els) {
				return
			}
		}
	case *MemberAccess:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Target != nil {
			if !f.Visit(f, v.Target) {
				return
			}
		}
	case *Paren:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Expr != nil {
			if !f.Visit(f, v.Expr) {
				return
			}
		}
	case *Index:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Expr != nil {
			if !f.Visit(f, v.Expr) {
				return
			}
		}
		if v.Index != nil {
			if !f.Visit(f, v.Index) {
				return
			}
		}
	case *Match:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Cond != nil {
			if !f.Visit(f, v.Cond) {
				return
			}
		}
		for _, w := range v.Branch {
			if !f.Visit(f, w) {
				return
			}
		}
	case *Range:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Start != nil {
			if !f.Visit(f, v.Start) {
				return
			}
		}
		if v.End != nil {
			if !f.Visit(f, v.End) {
				return
			}
		}
	case *TmpVar:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
	case *BlockExpr:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		for _, w := range v.Calls {
			if !f.Visit(f, w) {
				return
			}
		}
		if v.Expr != nil {
			if !f.Visit(f, v.Expr) {
				return
			}
		}
	case *Import:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Base != nil {
			if !f.Visit(f, v.Base) {
				return
			}
		}
		if v.ImportDesc != nil {
			if !f.Visit(f, v.ImportDesc) {
				return
			}
		}
	case *IntLiteral:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
	case *BoolLiteral:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
	case *StrLiteral:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
	case *Input:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
	case *Output:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
	case *Config:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
	case *Loop:
		if v.Init != nil {
			if !f.Visit(f, v.Init) {
				return
			}
		}
		if v.Cond != nil {
			if !f.Visit(f, v.Cond) {
				return
			}
		}
		if v.Step != nil {
			if !f.Visit(f, v.Step) {
				return
			}
		}
		if v.Body != nil {
			if !f.Visit(f, v.Body) {
				return
			}
		}
	case *IndentBlock:
		for _, w := range v.Elements {
			if !f.Visit(f, w) {
				return
			}
		}
		if v.StructType != nil {
			if !f.Visit(f, v.StructType) {
				return
			}
		}
	case *MatchBranch:
		if v.Cond != nil {
			if !f.Visit(f, v.Cond) {
				return
			}
		}
		if v.Then != nil {
			if !f.Visit(f, v.Then) {
				return
			}
		}
	case *Return:
		if v.Expr != nil {
			if !f.Visit(f, v.Expr) {
				return
			}
		}
	case *Break:
	case *Continue:
	case *Assert:
		if v.Cond != nil {
			if !f.Visit(f, v.Cond) {
				return
			}
		}
	case *ImplicitYield:
		if v.Expr != nil {
			if !f.Visit(f, v.Expr) {
				return
			}
		}
	case *Field:
		if v.Ident != nil {
			if !f.Visit(f, v.Ident) {
				return
			}
		}
		if v.FieldType != nil {
			if !f.Visit(f, v.FieldType) {
				return
			}
		}
		if v.RawArguments != nil {
			if !f.Visit(f, v.RawArguments) {
				return
			}
		}
		for _, w := range v.Arguments {
			if !f.Visit(f, w) {
				return
			}
		}
	case *Format:
		if v.Ident != nil {
			if !f.Visit(f, v.Ident) {
				return
			}
		}
		if v.Body != nil {
			if !f.Visit(f, v.Body) {
				return
			}
		}
	case *Function:
		if v.Ident != nil {
			if !f.Visit(f, v.Ident) {
				return
			}
		}
		for _, w := range v.Parameters {
			if !f.Visit(f, w) {
				return
			}
		}
		if v.ReturnType != nil {
			if !f.Visit(f, v.ReturnType) {
				return
			}
		}
		if v.Body != nil {
			if !f.Visit(f, v.Body) {
				return
			}
		}
		if v.FuncType != nil {
			if !f.Visit(f, v.FuncType) {
				return
			}
		}
	case *IntType:
	case *IdentType:
		if v.Ident != nil {
			if !f.Visit(f, v.Ident) {
				return
			}
		}
	case *IntLiteralType:
	case *StrLiteralType:
	case *VoidType:
	case *BoolType:
	case *ArrayType:
		if v.BaseType != nil {
			if !f.Visit(f, v.BaseType) {
				return
			}
		}
		if v.Length != nil {
			if !f.Visit(f, v.Length) {
				return
			}
		}
	case *FunctionType:
		if v.ReturnType != nil {
			if !f.Visit(f, v.ReturnType) {
				return
			}
		}
		for _, w := range v.Parameters {
			if !f.Visit(f, w) {
				return
			}
		}
	case *StructType:
		for _, w := range v.Fields {
			if !f.Visit(f, w) {
				return
			}
		}
	case *StructUnionType:
		for _, w := range v.Fields {
			if !f.Visit(f, w) {
				return
			}
		}
	case *Cast:
		if v.ExprType != nil {
			if !f.Visit(f, v.ExprType) {
				return
			}
		}
		if v.Base != nil {
			if !f.Visit(f, v.Base) {
				return
			}
		}
		if v.Expr != nil {
			if !f.Visit(f, v.Expr) {
				return
			}
		}
	case *Comment:
	case *CommentGroup:
		for _, w := range v.Comments {
			if !f.Visit(f, w) {
				return
			}
		}
	case *UnionType:
		for _, w := range v.Candidates {
			if !f.Visit(f, w) {
				return
			}
		}
	case *UnionCandidate:
	case *RangeType:
		if v.BaseType != nil {
			if !f.Visit(f, v.BaseType) {
				return
			}
		}
	case *Enum:
		if v.Ident != nil {
			if !f.Visit(f, v.Ident) {
				return
			}
		}
		if v.BaseType != nil {
			if !f.Visit(f, v.BaseType) {
				return
			}
		}
		for _, w := range v.Members {
			if !f.Visit(f, w) {
				return
			}
		}
		if v.EnumType != nil {
			if !f.Visit(f, v.EnumType) {
				return
			}
		}
	case *EnumMember:
		if v.Ident != nil {
			if !f.Visit(f, v.Ident) {
				return
			}
		}
		if v.Expr != nil {
			if !f.Visit(f, v.Expr) {
				return
			}
		}
	case *EnumType:
	}
}
