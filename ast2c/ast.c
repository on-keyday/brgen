// Code generated by gen_ast2c.go. DO NOT EDIT.

#include "ast.h"
#include<string.h>

#ifdef __cplusplus
extern "C" {
#else
#include<stdalign.h>
#endif

const char* ast2c_NodeType_to_string(ast2c_NodeType val) {
	switch(val) {
	case AST2C_NODETYPE_PROGRAM: return "program";
	case AST2C_NODETYPE_EXPR: return "expr";
	case AST2C_NODETYPE_BINARY: return "binary";
	case AST2C_NODETYPE_UNARY: return "unary";
	case AST2C_NODETYPE_COND: return "cond";
	case AST2C_NODETYPE_IDENT: return "ident";
	case AST2C_NODETYPE_CALL: return "call";
	case AST2C_NODETYPE_IF: return "if";
	case AST2C_NODETYPE_MEMBER_ACCESS: return "member_access";
	case AST2C_NODETYPE_PAREN: return "paren";
	case AST2C_NODETYPE_INDEX: return "index";
	case AST2C_NODETYPE_MATCH: return "match";
	case AST2C_NODETYPE_RANGE: return "range";
	case AST2C_NODETYPE_TMP_VAR: return "tmp_var";
	case AST2C_NODETYPE_BLOCK_EXPR: return "block_expr";
	case AST2C_NODETYPE_IMPORT: return "import";
	case AST2C_NODETYPE_LITERAL: return "literal";
	case AST2C_NODETYPE_INT_LITERAL: return "int_literal";
	case AST2C_NODETYPE_BOOL_LITERAL: return "bool_literal";
	case AST2C_NODETYPE_STR_LITERAL: return "str_literal";
	case AST2C_NODETYPE_INPUT: return "input";
	case AST2C_NODETYPE_OUTPUT: return "output";
	case AST2C_NODETYPE_CONFIG: return "config";
	case AST2C_NODETYPE_STMT: return "stmt";
	case AST2C_NODETYPE_LOOP: return "loop";
	case AST2C_NODETYPE_INDENT_BLOCK: return "indent_block";
	case AST2C_NODETYPE_MATCH_BRANCH: return "match_branch";
	case AST2C_NODETYPE_RETURN: return "return";
	case AST2C_NODETYPE_BREAK: return "break";
	case AST2C_NODETYPE_CONTINUE: return "continue";
	case AST2C_NODETYPE_ASSERT: return "assert";
	case AST2C_NODETYPE_IMPLICIT_YIELD: return "implicit_yield";
	case AST2C_NODETYPE_MEMBER: return "member";
	case AST2C_NODETYPE_FIELD: return "field";
	case AST2C_NODETYPE_FORMAT: return "format";
	case AST2C_NODETYPE_FUNCTION: return "function";
	case AST2C_NODETYPE_TYPE: return "type";
	case AST2C_NODETYPE_INT_TYPE: return "int_type";
	case AST2C_NODETYPE_IDENT_TYPE: return "ident_type";
	case AST2C_NODETYPE_INT_LITERAL_TYPE: return "int_literal_type";
	case AST2C_NODETYPE_STR_LITERAL_TYPE: return "str_literal_type";
	case AST2C_NODETYPE_VOID_TYPE: return "void_type";
	case AST2C_NODETYPE_BOOL_TYPE: return "bool_type";
	case AST2C_NODETYPE_ARRAY_TYPE: return "array_type";
	case AST2C_NODETYPE_FUNCTION_TYPE: return "function_type";
	case AST2C_NODETYPE_STRUCT_TYPE: return "struct_type";
	case AST2C_NODETYPE_STRUCT_UNION_TYPE: return "struct_union_type";
	case AST2C_NODETYPE_CAST: return "cast";
	case AST2C_NODETYPE_COMMENT: return "comment";
	case AST2C_NODETYPE_COMMENT_GROUP: return "comment_group";
	case AST2C_NODETYPE_UNION_TYPE: return "union_type";
	case AST2C_NODETYPE_UNION_CANDIDATE: return "union_candidate";
	case AST2C_NODETYPE_RANGE_TYPE: return "range_type";
	case AST2C_NODETYPE_ENUM: return "enum";
	case AST2C_NODETYPE_ENUM_MEMBER: return "enum_member";
	case AST2C_NODETYPE_ENUM_TYPE: return "enum_type";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_NodeType_from_string(const char* str, ast2c_NodeType* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "program") == 0) {
		*out = AST2C_NODETYPE_PROGRAM;
		return 1;
	}
	if (strcmp(str, "expr") == 0) {
		*out = AST2C_NODETYPE_EXPR;
		return 1;
	}
	if (strcmp(str, "binary") == 0) {
		*out = AST2C_NODETYPE_BINARY;
		return 1;
	}
	if (strcmp(str, "unary") == 0) {
		*out = AST2C_NODETYPE_UNARY;
		return 1;
	}
	if (strcmp(str, "cond") == 0) {
		*out = AST2C_NODETYPE_COND;
		return 1;
	}
	if (strcmp(str, "ident") == 0) {
		*out = AST2C_NODETYPE_IDENT;
		return 1;
	}
	if (strcmp(str, "call") == 0) {
		*out = AST2C_NODETYPE_CALL;
		return 1;
	}
	if (strcmp(str, "if") == 0) {
		*out = AST2C_NODETYPE_IF;
		return 1;
	}
	if (strcmp(str, "member_access") == 0) {
		*out = AST2C_NODETYPE_MEMBER_ACCESS;
		return 1;
	}
	if (strcmp(str, "paren") == 0) {
		*out = AST2C_NODETYPE_PAREN;
		return 1;
	}
	if (strcmp(str, "index") == 0) {
		*out = AST2C_NODETYPE_INDEX;
		return 1;
	}
	if (strcmp(str, "match") == 0) {
		*out = AST2C_NODETYPE_MATCH;
		return 1;
	}
	if (strcmp(str, "range") == 0) {
		*out = AST2C_NODETYPE_RANGE;
		return 1;
	}
	if (strcmp(str, "tmp_var") == 0) {
		*out = AST2C_NODETYPE_TMP_VAR;
		return 1;
	}
	if (strcmp(str, "block_expr") == 0) {
		*out = AST2C_NODETYPE_BLOCK_EXPR;
		return 1;
	}
	if (strcmp(str, "import") == 0) {
		*out = AST2C_NODETYPE_IMPORT;
		return 1;
	}
	if (strcmp(str, "literal") == 0) {
		*out = AST2C_NODETYPE_LITERAL;
		return 1;
	}
	if (strcmp(str, "int_literal") == 0) {
		*out = AST2C_NODETYPE_INT_LITERAL;
		return 1;
	}
	if (strcmp(str, "bool_literal") == 0) {
		*out = AST2C_NODETYPE_BOOL_LITERAL;
		return 1;
	}
	if (strcmp(str, "str_literal") == 0) {
		*out = AST2C_NODETYPE_STR_LITERAL;
		return 1;
	}
	if (strcmp(str, "input") == 0) {
		*out = AST2C_NODETYPE_INPUT;
		return 1;
	}
	if (strcmp(str, "output") == 0) {
		*out = AST2C_NODETYPE_OUTPUT;
		return 1;
	}
	if (strcmp(str, "config") == 0) {
		*out = AST2C_NODETYPE_CONFIG;
		return 1;
	}
	if (strcmp(str, "stmt") == 0) {
		*out = AST2C_NODETYPE_STMT;
		return 1;
	}
	if (strcmp(str, "loop") == 0) {
		*out = AST2C_NODETYPE_LOOP;
		return 1;
	}
	if (strcmp(str, "indent_block") == 0) {
		*out = AST2C_NODETYPE_INDENT_BLOCK;
		return 1;
	}
	if (strcmp(str, "match_branch") == 0) {
		*out = AST2C_NODETYPE_MATCH_BRANCH;
		return 1;
	}
	if (strcmp(str, "return") == 0) {
		*out = AST2C_NODETYPE_RETURN;
		return 1;
	}
	if (strcmp(str, "break") == 0) {
		*out = AST2C_NODETYPE_BREAK;
		return 1;
	}
	if (strcmp(str, "continue") == 0) {
		*out = AST2C_NODETYPE_CONTINUE;
		return 1;
	}
	if (strcmp(str, "assert") == 0) {
		*out = AST2C_NODETYPE_ASSERT;
		return 1;
	}
	if (strcmp(str, "implicit_yield") == 0) {
		*out = AST2C_NODETYPE_IMPLICIT_YIELD;
		return 1;
	}
	if (strcmp(str, "member") == 0) {
		*out = AST2C_NODETYPE_MEMBER;
		return 1;
	}
	if (strcmp(str, "field") == 0) {
		*out = AST2C_NODETYPE_FIELD;
		return 1;
	}
	if (strcmp(str, "format") == 0) {
		*out = AST2C_NODETYPE_FORMAT;
		return 1;
	}
	if (strcmp(str, "function") == 0) {
		*out = AST2C_NODETYPE_FUNCTION;
		return 1;
	}
	if (strcmp(str, "type") == 0) {
		*out = AST2C_NODETYPE_TYPE;
		return 1;
	}
	if (strcmp(str, "int_type") == 0) {
		*out = AST2C_NODETYPE_INT_TYPE;
		return 1;
	}
	if (strcmp(str, "ident_type") == 0) {
		*out = AST2C_NODETYPE_IDENT_TYPE;
		return 1;
	}
	if (strcmp(str, "int_literal_type") == 0) {
		*out = AST2C_NODETYPE_INT_LITERAL_TYPE;
		return 1;
	}
	if (strcmp(str, "str_literal_type") == 0) {
		*out = AST2C_NODETYPE_STR_LITERAL_TYPE;
		return 1;
	}
	if (strcmp(str, "void_type") == 0) {
		*out = AST2C_NODETYPE_VOID_TYPE;
		return 1;
	}
	if (strcmp(str, "bool_type") == 0) {
		*out = AST2C_NODETYPE_BOOL_TYPE;
		return 1;
	}
	if (strcmp(str, "array_type") == 0) {
		*out = AST2C_NODETYPE_ARRAY_TYPE;
		return 1;
	}
	if (strcmp(str, "function_type") == 0) {
		*out = AST2C_NODETYPE_FUNCTION_TYPE;
		return 1;
	}
	if (strcmp(str, "struct_type") == 0) {
		*out = AST2C_NODETYPE_STRUCT_TYPE;
		return 1;
	}
	if (strcmp(str, "struct_union_type") == 0) {
		*out = AST2C_NODETYPE_STRUCT_UNION_TYPE;
		return 1;
	}
	if (strcmp(str, "cast") == 0) {
		*out = AST2C_NODETYPE_CAST;
		return 1;
	}
	if (strcmp(str, "comment") == 0) {
		*out = AST2C_NODETYPE_COMMENT;
		return 1;
	}
	if (strcmp(str, "comment_group") == 0) {
		*out = AST2C_NODETYPE_COMMENT_GROUP;
		return 1;
	}
	if (strcmp(str, "union_type") == 0) {
		*out = AST2C_NODETYPE_UNION_TYPE;
		return 1;
	}
	if (strcmp(str, "union_candidate") == 0) {
		*out = AST2C_NODETYPE_UNION_CANDIDATE;
		return 1;
	}
	if (strcmp(str, "range_type") == 0) {
		*out = AST2C_NODETYPE_RANGE_TYPE;
		return 1;
	}
	if (strcmp(str, "enum") == 0) {
		*out = AST2C_NODETYPE_ENUM;
		return 1;
	}
	if (strcmp(str, "enum_member") == 0) {
		*out = AST2C_NODETYPE_ENUM_MEMBER;
		return 1;
	}
	if (strcmp(str, "enum_type") == 0) {
		*out = AST2C_NODETYPE_ENUM_TYPE;
		return 1;
	}
	return 0;
}

const char* ast2c_UnaryOp_to_string(ast2c_UnaryOp val) {
	switch(val) {
	case AST2C_UNARYOP_NOT: return "!";
	case AST2C_UNARYOP_MINUS_SIGN: return "-";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_UnaryOp_from_string(const char* str, ast2c_UnaryOp* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "!") == 0) {
		*out = AST2C_UNARYOP_NOT;
		return 1;
	}
	if (strcmp(str, "-") == 0) {
		*out = AST2C_UNARYOP_MINUS_SIGN;
		return 1;
	}
	return 0;
}

const char* ast2c_BinaryOp_to_string(ast2c_BinaryOp val) {
	switch(val) {
	case AST2C_BINARYOP_MUL: return "*";
	case AST2C_BINARYOP_DIV: return "/";
	case AST2C_BINARYOP_MOD: return "%";
	case AST2C_BINARYOP_LEFT_ARITHMETIC_SHIFT: return "<<<";
	case AST2C_BINARYOP_RIGHT_ARITHMETIC_SHIFT: return ">>>";
	case AST2C_BINARYOP_LEFT_LOGICAL_SHIFT: return "<<";
	case AST2C_BINARYOP_RIGHT_LOGICAL_SHIFT: return ">>";
	case AST2C_BINARYOP_BIT_AND: return "&";
	case AST2C_BINARYOP_ADD: return "+";
	case AST2C_BINARYOP_SUB: return "-";
	case AST2C_BINARYOP_BIT_OR: return "|";
	case AST2C_BINARYOP_BIT_XOR: return "^";
	case AST2C_BINARYOP_EQUAL: return "==";
	case AST2C_BINARYOP_NOT_EQUAL: return "!=";
	case AST2C_BINARYOP_LESS: return "<";
	case AST2C_BINARYOP_LESS_OR_EQ: return "<=";
	case AST2C_BINARYOP_GRATER: return ">";
	case AST2C_BINARYOP_GRATER_OR_EQ: return ">=";
	case AST2C_BINARYOP_LOGICAL_AND: return "&&";
	case AST2C_BINARYOP_LOGICAL_OR: return "||";
	case AST2C_BINARYOP_COND_OP_1: return "?";
	case AST2C_BINARYOP_COND_OP_2: return ":";
	case AST2C_BINARYOP_RANGE_EXCLUSIVE: return "..";
	case AST2C_BINARYOP_RANGE_INCLUSIVE: return "..=";
	case AST2C_BINARYOP_ASSIGN: return "=";
	case AST2C_BINARYOP_DEFINE_ASSIGN: return ":=";
	case AST2C_BINARYOP_CONST_ASSIGN: return "::=";
	case AST2C_BINARYOP_ADD_ASSIGN: return "+=";
	case AST2C_BINARYOP_SUB_ASSIGN: return "-=";
	case AST2C_BINARYOP_MUL_ASSIGN: return "*=";
	case AST2C_BINARYOP_DIV_ASSIGN: return "/=";
	case AST2C_BINARYOP_MOD_ASSIGN: return "%=";
	case AST2C_BINARYOP_LEFT_SHIFT_ASSIGN: return "<<=";
	case AST2C_BINARYOP_RIGHT_SHIFT_ASSIGN: return ">>=";
	case AST2C_BINARYOP_BIT_AND_ASSIGN: return "&=";
	case AST2C_BINARYOP_BIT_OR_ASSIGN: return "|=";
	case AST2C_BINARYOP_BIT_XOR_ASSIGN: return "^=";
	case AST2C_BINARYOP_COMMA: return ",";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_BinaryOp_from_string(const char* str, ast2c_BinaryOp* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "*") == 0) {
		*out = AST2C_BINARYOP_MUL;
		return 1;
	}
	if (strcmp(str, "/") == 0) {
		*out = AST2C_BINARYOP_DIV;
		return 1;
	}
	if (strcmp(str, "%") == 0) {
		*out = AST2C_BINARYOP_MOD;
		return 1;
	}
	if (strcmp(str, "<<<") == 0) {
		*out = AST2C_BINARYOP_LEFT_ARITHMETIC_SHIFT;
		return 1;
	}
	if (strcmp(str, ">>>") == 0) {
		*out = AST2C_BINARYOP_RIGHT_ARITHMETIC_SHIFT;
		return 1;
	}
	if (strcmp(str, "<<") == 0) {
		*out = AST2C_BINARYOP_LEFT_LOGICAL_SHIFT;
		return 1;
	}
	if (strcmp(str, ">>") == 0) {
		*out = AST2C_BINARYOP_RIGHT_LOGICAL_SHIFT;
		return 1;
	}
	if (strcmp(str, "&") == 0) {
		*out = AST2C_BINARYOP_BIT_AND;
		return 1;
	}
	if (strcmp(str, "+") == 0) {
		*out = AST2C_BINARYOP_ADD;
		return 1;
	}
	if (strcmp(str, "-") == 0) {
		*out = AST2C_BINARYOP_SUB;
		return 1;
	}
	if (strcmp(str, "|") == 0) {
		*out = AST2C_BINARYOP_BIT_OR;
		return 1;
	}
	if (strcmp(str, "^") == 0) {
		*out = AST2C_BINARYOP_BIT_XOR;
		return 1;
	}
	if (strcmp(str, "==") == 0) {
		*out = AST2C_BINARYOP_EQUAL;
		return 1;
	}
	if (strcmp(str, "!=") == 0) {
		*out = AST2C_BINARYOP_NOT_EQUAL;
		return 1;
	}
	if (strcmp(str, "<") == 0) {
		*out = AST2C_BINARYOP_LESS;
		return 1;
	}
	if (strcmp(str, "<=") == 0) {
		*out = AST2C_BINARYOP_LESS_OR_EQ;
		return 1;
	}
	if (strcmp(str, ">") == 0) {
		*out = AST2C_BINARYOP_GRATER;
		return 1;
	}
	if (strcmp(str, ">=") == 0) {
		*out = AST2C_BINARYOP_GRATER_OR_EQ;
		return 1;
	}
	if (strcmp(str, "&&") == 0) {
		*out = AST2C_BINARYOP_LOGICAL_AND;
		return 1;
	}
	if (strcmp(str, "||") == 0) {
		*out = AST2C_BINARYOP_LOGICAL_OR;
		return 1;
	}
	if (strcmp(str, "?") == 0) {
		*out = AST2C_BINARYOP_COND_OP_1;
		return 1;
	}
	if (strcmp(str, ":") == 0) {
		*out = AST2C_BINARYOP_COND_OP_2;
		return 1;
	}
	if (strcmp(str, "..") == 0) {
		*out = AST2C_BINARYOP_RANGE_EXCLUSIVE;
		return 1;
	}
	if (strcmp(str, "..=") == 0) {
		*out = AST2C_BINARYOP_RANGE_INCLUSIVE;
		return 1;
	}
	if (strcmp(str, "=") == 0) {
		*out = AST2C_BINARYOP_ASSIGN;
		return 1;
	}
	if (strcmp(str, ":=") == 0) {
		*out = AST2C_BINARYOP_DEFINE_ASSIGN;
		return 1;
	}
	if (strcmp(str, "::=") == 0) {
		*out = AST2C_BINARYOP_CONST_ASSIGN;
		return 1;
	}
	if (strcmp(str, "+=") == 0) {
		*out = AST2C_BINARYOP_ADD_ASSIGN;
		return 1;
	}
	if (strcmp(str, "-=") == 0) {
		*out = AST2C_BINARYOP_SUB_ASSIGN;
		return 1;
	}
	if (strcmp(str, "*=") == 0) {
		*out = AST2C_BINARYOP_MUL_ASSIGN;
		return 1;
	}
	if (strcmp(str, "/=") == 0) {
		*out = AST2C_BINARYOP_DIV_ASSIGN;
		return 1;
	}
	if (strcmp(str, "%=") == 0) {
		*out = AST2C_BINARYOP_MOD_ASSIGN;
		return 1;
	}
	if (strcmp(str, "<<=") == 0) {
		*out = AST2C_BINARYOP_LEFT_SHIFT_ASSIGN;
		return 1;
	}
	if (strcmp(str, ">>=") == 0) {
		*out = AST2C_BINARYOP_RIGHT_SHIFT_ASSIGN;
		return 1;
	}
	if (strcmp(str, "&=") == 0) {
		*out = AST2C_BINARYOP_BIT_AND_ASSIGN;
		return 1;
	}
	if (strcmp(str, "|=") == 0) {
		*out = AST2C_BINARYOP_BIT_OR_ASSIGN;
		return 1;
	}
	if (strcmp(str, "^=") == 0) {
		*out = AST2C_BINARYOP_BIT_XOR_ASSIGN;
		return 1;
	}
	if (strcmp(str, ",") == 0) {
		*out = AST2C_BINARYOP_COMMA;
		return 1;
	}
	return 0;
}

const char* ast2c_IdentUsage_to_string(ast2c_IdentUsage val) {
	switch(val) {
	case AST2C_IDENTUSAGE_UNKNOWN: return "unknown";
	case AST2C_IDENTUSAGE_REFERENCE: return "reference";
	case AST2C_IDENTUSAGE_DEFINE_VARIABLE: return "define_variable";
	case AST2C_IDENTUSAGE_DEFINE_CONST: return "define_const";
	case AST2C_IDENTUSAGE_DEFINE_FIELD: return "define_field";
	case AST2C_IDENTUSAGE_DEFINE_FORMAT: return "define_format";
	case AST2C_IDENTUSAGE_DEFINE_ENUM: return "define_enum";
	case AST2C_IDENTUSAGE_DEFINE_ENUM_MEMBER: return "define_enum_member";
	case AST2C_IDENTUSAGE_DEFINE_FN: return "define_fn";
	case AST2C_IDENTUSAGE_DEFINE_CAST_FN: return "define_cast_fn";
	case AST2C_IDENTUSAGE_DEFINE_ARG: return "define_arg";
	case AST2C_IDENTUSAGE_REFERENCE_TYPE: return "reference_type";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_IdentUsage_from_string(const char* str, ast2c_IdentUsage* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "unknown") == 0) {
		*out = AST2C_IDENTUSAGE_UNKNOWN;
		return 1;
	}
	if (strcmp(str, "reference") == 0) {
		*out = AST2C_IDENTUSAGE_REFERENCE;
		return 1;
	}
	if (strcmp(str, "define_variable") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_VARIABLE;
		return 1;
	}
	if (strcmp(str, "define_const") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_CONST;
		return 1;
	}
	if (strcmp(str, "define_field") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_FIELD;
		return 1;
	}
	if (strcmp(str, "define_format") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_FORMAT;
		return 1;
	}
	if (strcmp(str, "define_enum") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_ENUM;
		return 1;
	}
	if (strcmp(str, "define_enum_member") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_ENUM_MEMBER;
		return 1;
	}
	if (strcmp(str, "define_fn") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_FN;
		return 1;
	}
	if (strcmp(str, "define_cast_fn") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_CAST_FN;
		return 1;
	}
	if (strcmp(str, "define_arg") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_ARG;
		return 1;
	}
	if (strcmp(str, "reference_type") == 0) {
		*out = AST2C_IDENTUSAGE_REFERENCE_TYPE;
		return 1;
	}
	return 0;
}

const char* ast2c_Endian_to_string(ast2c_Endian val) {
	switch(val) {
	case AST2C_ENDIAN_UNSPEC: return "unspec";
	case AST2C_ENDIAN_BIG: return "big";
	case AST2C_ENDIAN_LITTLE: return "little";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_Endian_from_string(const char* str, ast2c_Endian* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "unspec") == 0) {
		*out = AST2C_ENDIAN_UNSPEC;
		return 1;
	}
	if (strcmp(str, "big") == 0) {
		*out = AST2C_ENDIAN_BIG;
		return 1;
	}
	if (strcmp(str, "little") == 0) {
		*out = AST2C_ENDIAN_LITTLE;
		return 1;
	}
	return 0;
}

const char* ast2c_TokenTag_to_string(ast2c_TokenTag val) {
	switch(val) {
	case AST2C_TOKENTAG_INDENT: return "indent";
	case AST2C_TOKENTAG_SPACE: return "space";
	case AST2C_TOKENTAG_LINE: return "line";
	case AST2C_TOKENTAG_PUNCT: return "punct";
	case AST2C_TOKENTAG_INT_LITERAL: return "int_literal";
	case AST2C_TOKENTAG_BOOL_LITERAL: return "bool_literal";
	case AST2C_TOKENTAG_STR_LITERAL: return "str_literal";
	case AST2C_TOKENTAG_KEYWORD: return "keyword";
	case AST2C_TOKENTAG_IDENT: return "ident";
	case AST2C_TOKENTAG_COMMENT: return "comment";
	case AST2C_TOKENTAG_ERROR: return "error";
	case AST2C_TOKENTAG_UNKNOWN: return "unknown";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_TokenTag_from_string(const char* str, ast2c_TokenTag* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "indent") == 0) {
		*out = AST2C_TOKENTAG_INDENT;
		return 1;
	}
	if (strcmp(str, "space") == 0) {
		*out = AST2C_TOKENTAG_SPACE;
		return 1;
	}
	if (strcmp(str, "line") == 0) {
		*out = AST2C_TOKENTAG_LINE;
		return 1;
	}
	if (strcmp(str, "punct") == 0) {
		*out = AST2C_TOKENTAG_PUNCT;
		return 1;
	}
	if (strcmp(str, "int_literal") == 0) {
		*out = AST2C_TOKENTAG_INT_LITERAL;
		return 1;
	}
	if (strcmp(str, "bool_literal") == 0) {
		*out = AST2C_TOKENTAG_BOOL_LITERAL;
		return 1;
	}
	if (strcmp(str, "str_literal") == 0) {
		*out = AST2C_TOKENTAG_STR_LITERAL;
		return 1;
	}
	if (strcmp(str, "keyword") == 0) {
		*out = AST2C_TOKENTAG_KEYWORD;
		return 1;
	}
	if (strcmp(str, "ident") == 0) {
		*out = AST2C_TOKENTAG_IDENT;
		return 1;
	}
	if (strcmp(str, "comment") == 0) {
		*out = AST2C_TOKENTAG_COMMENT;
		return 1;
	}
	if (strcmp(str, "error") == 0) {
		*out = AST2C_TOKENTAG_ERROR;
		return 1;
	}
	if (strcmp(str, "unknown") == 0) {
		*out = AST2C_TOKENTAG_UNKNOWN;
		return 1;
	}
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Program_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Program* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->struct_type = NULL;
	s->elements = NULL;
	s->global_scope = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* struct_type = h->object_get(h, obj_body, "struct_type");
	void* elements = h->object_get(h, obj_body, "elements");
	void* global_scope = h->object_get(h, obj_body, "global_scope");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!struct_type) { if(h->error) { h->error(h,struct_type, "struct_type is null"); } return 0; }
	if (!elements) { if(h->error) { h->error(h,elements, "elements is null"); } return 0; }
	if(!h->array_size(h, elements,&s->elements_size)) {
		if(h->error) { h->error(h,elements, "failed to get array size of ast2c_Program::elements"); }
		return NULL;
	}
	if (!global_scope) { if(h->error) { h->error(h,global_scope, "global_scope is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Binary_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Binary* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	s->left = NULL;
	s->right = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* op = h->object_get(h, obj_body, "op");
	void* left = h->object_get(h, obj_body, "left");
	void* right = h->object_get(h, obj_body, "right");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
	if (!op) { if(h->error) { h->error(h,op, "op is null"); } return 0; }
	if (!left) { if(h->error) { h->error(h,left, "left is null"); } return 0; }
	if (!right) { if(h->error) { h->error(h,right, "right is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Unary_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Unary* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	s->expr = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* op = h->object_get(h, obj_body, "op");
	void* expr = h->object_get(h, obj_body, "expr");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
	if (!op) { if(h->error) { h->error(h,op, "op is null"); } return 0; }
	if (!expr) { if(h->error) { h->error(h,expr, "expr is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Cond_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Cond* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	s->cond = NULL;
	s->then = NULL;
	s->els = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* cond = h->object_get(h, obj_body, "cond");
	void* then = h->object_get(h, obj_body, "then");
	void* els_loc = h->object_get(h, obj_body, "els_loc");
	void* els = h->object_get(h, obj_body, "els");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "cond is null"); } return 0; }
	if (!then) { if(h->error) { h->error(h,then, "then is null"); } return 0; }
	if (!els_loc) { if(h->error) { h->error(h,els_loc, "els_loc is null"); } return 0; }
	if (!els) { if(h->error) { h->error(h,els, "els is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Ident_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Ident* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	s->ident = NULL;
	s->base = NULL;
	s->scope = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* ident = h->object_get(h, obj_body, "ident");
	void* usage = h->object_get(h, obj_body, "usage");
	void* base = h->object_get(h, obj_body, "base");
	void* scope = h->object_get(h, obj_body, "scope");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ident is null"); } return 0; }
	if (!usage) { if(h->error) { h->error(h,usage, "usage is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "base is null"); } return 0; }
	if (!scope) { if(h->error) { h->error(h,scope, "scope is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Call_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Call* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	s->callee = NULL;
	s->raw_arguments = NULL;
	s->arguments = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* callee = h->object_get(h, obj_body, "callee");
	void* raw_arguments = h->object_get(h, obj_body, "raw_arguments");
	void* arguments = h->object_get(h, obj_body, "arguments");
	void* end_loc = h->object_get(h, obj_body, "end_loc");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
	if (!callee) { if(h->error) { h->error(h,callee, "callee is null"); } return 0; }
	if (!raw_arguments) { if(h->error) { h->error(h,raw_arguments, "raw_arguments is null"); } return 0; }
	if (!arguments) { if(h->error) { h->error(h,arguments, "arguments is null"); } return 0; }
	if(!h->array_size(h, arguments,&s->arguments_size)) {
		if(h->error) { h->error(h,arguments, "failed to get array size of ast2c_Call::arguments"); }
		return NULL;
	}
	if (!end_loc) { if(h->error) { h->error(h,end_loc, "end_loc is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_If_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_If* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	s->cond_scope = NULL;
	s->cond = NULL;
	s->then = NULL;
	s->els = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* cond_scope = h->object_get(h, obj_body, "cond_scope");
	void* cond = h->object_get(h, obj_body, "cond");
	void* then = h->object_get(h, obj_body, "then");
	void* els = h->object_get(h, obj_body, "els");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
	if (!cond_scope) { if(h->error) { h->error(h,cond_scope, "cond_scope is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "cond is null"); } return 0; }
	if (!then) { if(h->error) { h->error(h,then, "then is null"); } return 0; }
	if (!els) { if(h->error) { h->error(h,els, "els is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_MemberAccess_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_MemberAccess* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	s->target = NULL;
	s->member = NULL;
	s->base = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* target = h->object_get(h, obj_body, "target");
	void* member = h->object_get(h, obj_body, "member");
	void* member_loc = h->object_get(h, obj_body, "member_loc");
	void* base = h->object_get(h, obj_body, "base");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
	if (!target) { if(h->error) { h->error(h,target, "target is null"); } return 0; }
	if (!member) { if(h->error) { h->error(h,member, "member is null"); } return 0; }
	if (!member_loc) { if(h->error) { h->error(h,member_loc, "member_loc is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "base is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Paren_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Paren* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	s->expr = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* expr = h->object_get(h, obj_body, "expr");
	void* end_loc = h->object_get(h, obj_body, "end_loc");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
	if (!expr) { if(h->error) { h->error(h,expr, "expr is null"); } return 0; }
	if (!end_loc) { if(h->error) { h->error(h,end_loc, "end_loc is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Index_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Index* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	s->expr = NULL;
	s->index = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* expr = h->object_get(h, obj_body, "expr");
	void* index = h->object_get(h, obj_body, "index");
	void* end_loc = h->object_get(h, obj_body, "end_loc");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
	if (!expr) { if(h->error) { h->error(h,expr, "expr is null"); } return 0; }
	if (!index) { if(h->error) { h->error(h,index, "index is null"); } return 0; }
	if (!end_loc) { if(h->error) { h->error(h,end_loc, "end_loc is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Match_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Match* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	s->cond_scope = NULL;
	s->cond = NULL;
	s->branch = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* cond_scope = h->object_get(h, obj_body, "cond_scope");
	void* cond = h->object_get(h, obj_body, "cond");
	void* branch = h->object_get(h, obj_body, "branch");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
	if (!cond_scope) { if(h->error) { h->error(h,cond_scope, "cond_scope is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "cond is null"); } return 0; }
	if (!branch) { if(h->error) { h->error(h,branch, "branch is null"); } return 0; }
	if(!h->array_size(h, branch,&s->branch_size)) {
		if(h->error) { h->error(h,branch, "failed to get array size of ast2c_Match::branch"); }
		return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_Range_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Range* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	s->start = NULL;
	s->end = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* op = h->object_get(h, obj_body, "op");
	void* start = h->object_get(h, obj_body, "start");
	void* end = h->object_get(h, obj_body, "end");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
	if (!op) { if(h->error) { h->error(h,op, "op is null"); } return 0; }
	if (!start) { if(h->error) { h->error(h,start, "start is null"); } return 0; }
	if (!end) { if(h->error) { h->error(h,end, "end is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_TmpVar_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_TmpVar* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* tmp_var = h->object_get(h, obj_body, "tmp_var");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
	if (!tmp_var) { if(h->error) { h->error(h,tmp_var, "tmp_var is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_BlockExpr_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_BlockExpr* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	s->calls = NULL;
	s->expr = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* calls = h->object_get(h, obj_body, "calls");
	void* expr = h->object_get(h, obj_body, "expr");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
	if (!calls) { if(h->error) { h->error(h,calls, "calls is null"); } return 0; }
	if(!h->array_size(h, calls,&s->calls_size)) {
		if(h->error) { h->error(h,calls, "failed to get array size of ast2c_BlockExpr::calls"); }
		return NULL;
	}
	if (!expr) { if(h->error) { h->error(h,expr, "expr is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Import_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Import* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	s->path = NULL;
	s->base = NULL;
	s->import_desc = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* path = h->object_get(h, obj_body, "path");
	void* base = h->object_get(h, obj_body, "base");
	void* import_desc = h->object_get(h, obj_body, "import_desc");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
	if (!path) { if(h->error) { h->error(h,path, "path is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "base is null"); } return 0; }
	if (!import_desc) { if(h->error) { h->error(h,import_desc, "import_desc is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_IntLiteral_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_IntLiteral* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	s->value = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* value = h->object_get(h, obj_body, "value");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
	if (!value) { if(h->error) { h->error(h,value, "value is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_BoolLiteral_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_BoolLiteral* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* value = h->object_get(h, obj_body, "value");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
	if (!value) { if(h->error) { h->error(h,value, "value is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_StrLiteral_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_StrLiteral* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	s->value = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* value = h->object_get(h, obj_body, "value");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
	if (!value) { if(h->error) { h->error(h,value, "value is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Input_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Input* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Output_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Output* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Config_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Config* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Loop_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Loop* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->cond_scope = NULL;
	s->init = NULL;
	s->cond = NULL;
	s->step = NULL;
	s->body = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* cond_scope = h->object_get(h, obj_body, "cond_scope");
	void* init = h->object_get(h, obj_body, "init");
	void* cond = h->object_get(h, obj_body, "cond");
	void* step = h->object_get(h, obj_body, "step");
	void* body = h->object_get(h, obj_body, "body");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!cond_scope) { if(h->error) { h->error(h,cond_scope, "cond_scope is null"); } return 0; }
	if (!init) { if(h->error) { h->error(h,init, "init is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "cond is null"); } return 0; }
	if (!step) { if(h->error) { h->error(h,step, "step is null"); } return 0; }
	if (!body) { if(h->error) { h->error(h,body, "body is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_IndentBlock_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_IndentBlock* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->elements = NULL;
	s->scope = NULL;
	s->struct_type = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* elements = h->object_get(h, obj_body, "elements");
	void* scope = h->object_get(h, obj_body, "scope");
	void* struct_type = h->object_get(h, obj_body, "struct_type");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!elements) { if(h->error) { h->error(h,elements, "elements is null"); } return 0; }
	if(!h->array_size(h, elements,&s->elements_size)) {
		if(h->error) { h->error(h,elements, "failed to get array size of ast2c_IndentBlock::elements"); }
		return NULL;
	}
	if (!scope) { if(h->error) { h->error(h,scope, "scope is null"); } return 0; }
	if (!struct_type) { if(h->error) { h->error(h,struct_type, "struct_type is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_MatchBranch_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_MatchBranch* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->cond = NULL;
	s->then = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* cond = h->object_get(h, obj_body, "cond");
	void* sym_loc = h->object_get(h, obj_body, "sym_loc");
	void* then = h->object_get(h, obj_body, "then");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "cond is null"); } return 0; }
	if (!sym_loc) { if(h->error) { h->error(h,sym_loc, "sym_loc is null"); } return 0; }
	if (!then) { if(h->error) { h->error(h,then, "then is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Return_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Return* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr = h->object_get(h, obj_body, "expr");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr) { if(h->error) { h->error(h,expr, "expr is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Break_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Break* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Continue_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Continue* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Assert_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Assert* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->cond = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* cond = h->object_get(h, obj_body, "cond");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "cond is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_ImplicitYield_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_ImplicitYield* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr = h->object_get(h, obj_body, "expr");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr) { if(h->error) { h->error(h,expr, "expr is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Field_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Field* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->belong = NULL;
	s->ident = NULL;
	s->field_type = NULL;
	s->raw_arguments = NULL;
	s->arguments = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* belong = h->object_get(h, obj_body, "belong");
	void* ident = h->object_get(h, obj_body, "ident");
	void* colon_loc = h->object_get(h, obj_body, "colon_loc");
	void* field_type = h->object_get(h, obj_body, "field_type");
	void* raw_arguments = h->object_get(h, obj_body, "raw_arguments");
	void* arguments = h->object_get(h, obj_body, "arguments");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "belong is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ident is null"); } return 0; }
	if (!colon_loc) { if(h->error) { h->error(h,colon_loc, "colon_loc is null"); } return 0; }
	if (!field_type) { if(h->error) { h->error(h,field_type, "field_type is null"); } return 0; }
	if (!raw_arguments) { if(h->error) { h->error(h,raw_arguments, "raw_arguments is null"); } return 0; }
	if (!arguments) { if(h->error) { h->error(h,arguments, "arguments is null"); } return 0; }
	if(!h->array_size(h, arguments,&s->arguments_size)) {
		if(h->error) { h->error(h,arguments, "failed to get array size of ast2c_Field::arguments"); }
		return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_Format_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Format* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->belong = NULL;
	s->ident = NULL;
	s->body = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* belong = h->object_get(h, obj_body, "belong");
	void* ident = h->object_get(h, obj_body, "ident");
	void* body = h->object_get(h, obj_body, "body");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "belong is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ident is null"); } return 0; }
	if (!body) { if(h->error) { h->error(h,body, "body is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Function_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Function* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->belong = NULL;
	s->ident = NULL;
	s->parameters = NULL;
	s->return_type = NULL;
	s->body = NULL;
	s->func_type = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* belong = h->object_get(h, obj_body, "belong");
	void* ident = h->object_get(h, obj_body, "ident");
	void* parameters = h->object_get(h, obj_body, "parameters");
	void* return_type = h->object_get(h, obj_body, "return_type");
	void* body = h->object_get(h, obj_body, "body");
	void* func_type = h->object_get(h, obj_body, "func_type");
	void* is_cast = h->object_get(h, obj_body, "is_cast");
	void* cast_loc = h->object_get(h, obj_body, "cast_loc");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "belong is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ident is null"); } return 0; }
	if (!parameters) { if(h->error) { h->error(h,parameters, "parameters is null"); } return 0; }
	if(!h->array_size(h, parameters,&s->parameters_size)) {
		if(h->error) { h->error(h,parameters, "failed to get array size of ast2c_Function::parameters"); }
		return NULL;
	}
	if (!return_type) { if(h->error) { h->error(h,return_type, "return_type is null"); } return 0; }
	if (!body) { if(h->error) { h->error(h,body, "body is null"); } return 0; }
	if (!func_type) { if(h->error) { h->error(h,func_type, "func_type is null"); } return 0; }
	if (!is_cast) { if(h->error) { h->error(h,is_cast, "is_cast is null"); } return 0; }
	if (!cast_loc) { if(h->error) { h->error(h,cast_loc, "cast_loc is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_IntType_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_IntType* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* endian = h->object_get(h, obj_body, "endian");
	void* is_signed = h->object_get(h, obj_body, "is_signed");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "is_explicit is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "bit_size is null"); } return 0; }
	if (!endian) { if(h->error) { h->error(h,endian, "endian is null"); } return 0; }
	if (!is_signed) { if(h->error) { h->error(h,is_signed, "is_signed is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_IdentType_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_IdentType* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->ident = NULL;
	s->base = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* ident = h->object_get(h, obj_body, "ident");
	void* base = h->object_get(h, obj_body, "base");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "is_explicit is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ident is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "base is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_IntLiteralType_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_IntLiteralType* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->base = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* base = h->object_get(h, obj_body, "base");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "is_explicit is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "base is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_StrLiteralType_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_StrLiteralType* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->base = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* base = h->object_get(h, obj_body, "base");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "is_explicit is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "base is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_VoidType_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_VoidType* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "is_explicit is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_BoolType_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_BoolType* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "is_explicit is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_ArrayType_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_ArrayType* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->base_type = NULL;
	s->length = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* end_loc = h->object_get(h, obj_body, "end_loc");
	void* base_type = h->object_get(h, obj_body, "base_type");
	void* length = h->object_get(h, obj_body, "length");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "is_explicit is null"); } return 0; }
	if (!end_loc) { if(h->error) { h->error(h,end_loc, "end_loc is null"); } return 0; }
	if (!base_type) { if(h->error) { h->error(h,base_type, "base_type is null"); } return 0; }
	if (!length) { if(h->error) { h->error(h,length, "length is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_FunctionType_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_FunctionType* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->return_type = NULL;
	s->parameters = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* return_type = h->object_get(h, obj_body, "return_type");
	void* parameters = h->object_get(h, obj_body, "parameters");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "is_explicit is null"); } return 0; }
	if (!return_type) { if(h->error) { h->error(h,return_type, "return_type is null"); } return 0; }
	if (!parameters) { if(h->error) { h->error(h,parameters, "parameters is null"); } return 0; }
	if(!h->array_size(h, parameters,&s->parameters_size)) {
		if(h->error) { h->error(h,parameters, "failed to get array size of ast2c_FunctionType::parameters"); }
		return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_StructType_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_StructType* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->fields = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* fields = h->object_get(h, obj_body, "fields");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "is_explicit is null"); } return 0; }
	if (!fields) { if(h->error) { h->error(h,fields, "fields is null"); } return 0; }
	if(!h->array_size(h, fields,&s->fields_size)) {
		if(h->error) { h->error(h,fields, "failed to get array size of ast2c_StructType::fields"); }
		return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_StructUnionType_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_StructUnionType* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->fields = NULL;
	s->base = NULL;
	s->union_fields = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* fields = h->object_get(h, obj_body, "fields");
	void* base = h->object_get(h, obj_body, "base");
	void* union_fields = h->object_get(h, obj_body, "union_fields");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "is_explicit is null"); } return 0; }
	if (!fields) { if(h->error) { h->error(h,fields, "fields is null"); } return 0; }
	if(!h->array_size(h, fields,&s->fields_size)) {
		if(h->error) { h->error(h,fields, "failed to get array size of ast2c_StructUnionType::fields"); }
		return NULL;
	}
	if (!base) { if(h->error) { h->error(h,base, "base is null"); } return 0; }
	if (!union_fields) { if(h->error) { h->error(h,union_fields, "union_fields is null"); } return 0; }
	if(!h->array_size(h, union_fields,&s->union_fields_size)) {
		if(h->error) { h->error(h,union_fields, "failed to get array size of ast2c_StructUnionType::union_fields"); }
		return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_Cast_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Cast* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->expr_type = NULL;
	s->base = NULL;
	s->expr = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* base = h->object_get(h, obj_body, "base");
	void* expr = h->object_get(h, obj_body, "expr");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "expr_type is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "base is null"); } return 0; }
	if (!expr) { if(h->error) { h->error(h,expr, "expr is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Comment_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Comment* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->comment = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* comment = h->object_get(h, obj_body, "comment");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!comment) { if(h->error) { h->error(h,comment, "comment is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_CommentGroup_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_CommentGroup* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->comments = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* comments = h->object_get(h, obj_body, "comments");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!comments) { if(h->error) { h->error(h,comments, "comments is null"); } return 0; }
	if(!h->array_size(h, comments,&s->comments_size)) {
		if(h->error) { h->error(h,comments, "failed to get array size of ast2c_CommentGroup::comments"); }
		return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_UnionType_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_UnionType* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->cond = NULL;
	s->candidates = NULL;
	s->base_type = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* cond = h->object_get(h, obj_body, "cond");
	void* candidates = h->object_get(h, obj_body, "candidates");
	void* base_type = h->object_get(h, obj_body, "base_type");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "is_explicit is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "cond is null"); } return 0; }
	if (!candidates) { if(h->error) { h->error(h,candidates, "candidates is null"); } return 0; }
	if(!h->array_size(h, candidates,&s->candidates_size)) {
		if(h->error) { h->error(h,candidates, "failed to get array size of ast2c_UnionType::candidates"); }
		return NULL;
	}
	if (!base_type) { if(h->error) { h->error(h,base_type, "base_type is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_UnionCandidate_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_UnionCandidate* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->cond = NULL;
	s->field = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* cond = h->object_get(h, obj_body, "cond");
	void* field = h->object_get(h, obj_body, "field");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "cond is null"); } return 0; }
	if (!field) { if(h->error) { h->error(h,field, "field is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_RangeType_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_RangeType* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->base_type = NULL;
	s->range = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* base_type = h->object_get(h, obj_body, "base_type");
	void* range = h->object_get(h, obj_body, "range");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "is_explicit is null"); } return 0; }
	if (!base_type) { if(h->error) { h->error(h,base_type, "base_type is null"); } return 0; }
	if (!range) { if(h->error) { h->error(h,range, "range is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_Enum_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_Enum* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->belong = NULL;
	s->ident = NULL;
	s->scope = NULL;
	s->base_type = NULL;
	s->members = NULL;
	s->enum_type = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* belong = h->object_get(h, obj_body, "belong");
	void* ident = h->object_get(h, obj_body, "ident");
	void* scope = h->object_get(h, obj_body, "scope");
	void* colon_loc = h->object_get(h, obj_body, "colon_loc");
	void* base_type = h->object_get(h, obj_body, "base_type");
	void* members = h->object_get(h, obj_body, "members");
	void* enum_type = h->object_get(h, obj_body, "enum_type");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "belong is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ident is null"); } return 0; }
	if (!scope) { if(h->error) { h->error(h,scope, "scope is null"); } return 0; }
	if (!colon_loc) { if(h->error) { h->error(h,colon_loc, "colon_loc is null"); } return 0; }
	if (!base_type) { if(h->error) { h->error(h,base_type, "base_type is null"); } return 0; }
	if (!members) { if(h->error) { h->error(h,members, "members is null"); } return 0; }
	if(!h->array_size(h, members,&s->members_size)) {
		if(h->error) { h->error(h,members, "failed to get array size of ast2c_Enum::members"); }
		return NULL;
	}
	if (!enum_type) { if(h->error) { h->error(h,enum_type, "enum_type is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_EnumMember_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_EnumMember* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->belong = NULL;
	s->ident = NULL;
	s->expr = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* belong = h->object_get(h, obj_body, "belong");
	void* ident = h->object_get(h, obj_body, "ident");
	void* expr = h->object_get(h, obj_body, "expr");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "belong is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ident is null"); } return 0; }
	if (!expr) { if(h->error) { h->error(h,expr, "expr is null"); } return 0; }
}

// returns 1 if succeed 0 if failed
int ast2c_EnumType_parse(ast2c_Node** nodes,ast2c_Scope** scopes,ast2c_EnumType* s,ast2c_json_handlers* h, void* obj) {
	if (!nodes||!scopes||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	s->base = NULL;
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "obj_body is null"); } return 0; }
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* base = h->object_get(h, obj_body, "base");
	void* loc = h->object_get(h, obj, "loc");
	if (!loc) { if(h->error) { h->error(h,loc, "loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "is_explicit is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "base is null"); } return 0; }
}

#ifdef __cplusplus
}
#endif

