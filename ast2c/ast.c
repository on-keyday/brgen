// Code generated by gen_ast2c.go. DO NOT EDIT.

#include "ast.h"
#include<string.h>

#ifdef __cplusplus
extern "C" {
#else
#include<stdalign.h>
#endif

const char* ast2c_NodeType_to_string(ast2c_NodeType val) {
	switch(val) {
	case AST2C_NODETYPE_PROGRAM: return "program";
	case AST2C_NODETYPE_COMMENT: return "comment";
	case AST2C_NODETYPE_COMMENT_GROUP: return "comment_group";
	case AST2C_NODETYPE_EXPR: return "expr";
	case AST2C_NODETYPE_BINARY: return "binary";
	case AST2C_NODETYPE_UNARY: return "unary";
	case AST2C_NODETYPE_COND: return "cond";
	case AST2C_NODETYPE_IDENT: return "ident";
	case AST2C_NODETYPE_CALL: return "call";
	case AST2C_NODETYPE_IF: return "if";
	case AST2C_NODETYPE_MEMBER_ACCESS: return "member_access";
	case AST2C_NODETYPE_PAREN: return "paren";
	case AST2C_NODETYPE_INDEX: return "index";
	case AST2C_NODETYPE_MATCH: return "match";
	case AST2C_NODETYPE_RANGE: return "range";
	case AST2C_NODETYPE_TMP_VAR: return "tmp_var";
	case AST2C_NODETYPE_BLOCK_EXPR: return "block_expr";
	case AST2C_NODETYPE_IMPORT: return "import";
	case AST2C_NODETYPE_CAST: return "cast";
	case AST2C_NODETYPE_STMT: return "stmt";
	case AST2C_NODETYPE_LOOP: return "loop";
	case AST2C_NODETYPE_INDENT_BLOCK: return "indent_block";
	case AST2C_NODETYPE_MATCH_BRANCH: return "match_branch";
	case AST2C_NODETYPE_UNION_CANDIDATE: return "union_candidate";
	case AST2C_NODETYPE_RETURN: return "return";
	case AST2C_NODETYPE_BREAK: return "break";
	case AST2C_NODETYPE_CONTINUE: return "continue";
	case AST2C_NODETYPE_ASSERT: return "assert";
	case AST2C_NODETYPE_IMPLICIT_YIELD: return "implicit_yield";
	case AST2C_NODETYPE_TYPE: return "type";
	case AST2C_NODETYPE_INT_TYPE: return "int_type";
	case AST2C_NODETYPE_IDENT_TYPE: return "ident_type";
	case AST2C_NODETYPE_INT_LITERAL_TYPE: return "int_literal_type";
	case AST2C_NODETYPE_STR_LITERAL_TYPE: return "str_literal_type";
	case AST2C_NODETYPE_VOID_TYPE: return "void_type";
	case AST2C_NODETYPE_BOOL_TYPE: return "bool_type";
	case AST2C_NODETYPE_ARRAY_TYPE: return "array_type";
	case AST2C_NODETYPE_FUNCTION_TYPE: return "function_type";
	case AST2C_NODETYPE_STRUCT_TYPE: return "struct_type";
	case AST2C_NODETYPE_STRUCT_UNION_TYPE: return "struct_union_type";
	case AST2C_NODETYPE_UNION_TYPE: return "union_type";
	case AST2C_NODETYPE_RANGE_TYPE: return "range_type";
	case AST2C_NODETYPE_ENUM_TYPE: return "enum_type";
	case AST2C_NODETYPE_LITERAL: return "literal";
	case AST2C_NODETYPE_INT_LITERAL: return "int_literal";
	case AST2C_NODETYPE_BOOL_LITERAL: return "bool_literal";
	case AST2C_NODETYPE_STR_LITERAL: return "str_literal";
	case AST2C_NODETYPE_INPUT: return "input";
	case AST2C_NODETYPE_OUTPUT: return "output";
	case AST2C_NODETYPE_CONFIG: return "config";
	case AST2C_NODETYPE_MEMBER: return "member";
	case AST2C_NODETYPE_FIELD: return "field";
	case AST2C_NODETYPE_FORMAT: return "format";
	case AST2C_NODETYPE_STATE: return "state";
	case AST2C_NODETYPE_ENUM: return "enum";
	case AST2C_NODETYPE_ENUM_MEMBER: return "enum_member";
	case AST2C_NODETYPE_FUNCTION: return "function";
	case AST2C_NODETYPE_BUILTIN_FUNCTION: return "builtin_function";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_NodeType_from_string(const char* str, ast2c_NodeType* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "program") == 0) {
		*out = AST2C_NODETYPE_PROGRAM;
		return 1;
	}
	if (strcmp(str, "comment") == 0) {
		*out = AST2C_NODETYPE_COMMENT;
		return 1;
	}
	if (strcmp(str, "comment_group") == 0) {
		*out = AST2C_NODETYPE_COMMENT_GROUP;
		return 1;
	}
	if (strcmp(str, "expr") == 0) {
		*out = AST2C_NODETYPE_EXPR;
		return 1;
	}
	if (strcmp(str, "binary") == 0) {
		*out = AST2C_NODETYPE_BINARY;
		return 1;
	}
	if (strcmp(str, "unary") == 0) {
		*out = AST2C_NODETYPE_UNARY;
		return 1;
	}
	if (strcmp(str, "cond") == 0) {
		*out = AST2C_NODETYPE_COND;
		return 1;
	}
	if (strcmp(str, "ident") == 0) {
		*out = AST2C_NODETYPE_IDENT;
		return 1;
	}
	if (strcmp(str, "call") == 0) {
		*out = AST2C_NODETYPE_CALL;
		return 1;
	}
	if (strcmp(str, "if") == 0) {
		*out = AST2C_NODETYPE_IF;
		return 1;
	}
	if (strcmp(str, "member_access") == 0) {
		*out = AST2C_NODETYPE_MEMBER_ACCESS;
		return 1;
	}
	if (strcmp(str, "paren") == 0) {
		*out = AST2C_NODETYPE_PAREN;
		return 1;
	}
	if (strcmp(str, "index") == 0) {
		*out = AST2C_NODETYPE_INDEX;
		return 1;
	}
	if (strcmp(str, "match") == 0) {
		*out = AST2C_NODETYPE_MATCH;
		return 1;
	}
	if (strcmp(str, "range") == 0) {
		*out = AST2C_NODETYPE_RANGE;
		return 1;
	}
	if (strcmp(str, "tmp_var") == 0) {
		*out = AST2C_NODETYPE_TMP_VAR;
		return 1;
	}
	if (strcmp(str, "block_expr") == 0) {
		*out = AST2C_NODETYPE_BLOCK_EXPR;
		return 1;
	}
	if (strcmp(str, "import") == 0) {
		*out = AST2C_NODETYPE_IMPORT;
		return 1;
	}
	if (strcmp(str, "cast") == 0) {
		*out = AST2C_NODETYPE_CAST;
		return 1;
	}
	if (strcmp(str, "stmt") == 0) {
		*out = AST2C_NODETYPE_STMT;
		return 1;
	}
	if (strcmp(str, "loop") == 0) {
		*out = AST2C_NODETYPE_LOOP;
		return 1;
	}
	if (strcmp(str, "indent_block") == 0) {
		*out = AST2C_NODETYPE_INDENT_BLOCK;
		return 1;
	}
	if (strcmp(str, "match_branch") == 0) {
		*out = AST2C_NODETYPE_MATCH_BRANCH;
		return 1;
	}
	if (strcmp(str, "union_candidate") == 0) {
		*out = AST2C_NODETYPE_UNION_CANDIDATE;
		return 1;
	}
	if (strcmp(str, "return") == 0) {
		*out = AST2C_NODETYPE_RETURN;
		return 1;
	}
	if (strcmp(str, "break") == 0) {
		*out = AST2C_NODETYPE_BREAK;
		return 1;
	}
	if (strcmp(str, "continue") == 0) {
		*out = AST2C_NODETYPE_CONTINUE;
		return 1;
	}
	if (strcmp(str, "assert") == 0) {
		*out = AST2C_NODETYPE_ASSERT;
		return 1;
	}
	if (strcmp(str, "implicit_yield") == 0) {
		*out = AST2C_NODETYPE_IMPLICIT_YIELD;
		return 1;
	}
	if (strcmp(str, "type") == 0) {
		*out = AST2C_NODETYPE_TYPE;
		return 1;
	}
	if (strcmp(str, "int_type") == 0) {
		*out = AST2C_NODETYPE_INT_TYPE;
		return 1;
	}
	if (strcmp(str, "ident_type") == 0) {
		*out = AST2C_NODETYPE_IDENT_TYPE;
		return 1;
	}
	if (strcmp(str, "int_literal_type") == 0) {
		*out = AST2C_NODETYPE_INT_LITERAL_TYPE;
		return 1;
	}
	if (strcmp(str, "str_literal_type") == 0) {
		*out = AST2C_NODETYPE_STR_LITERAL_TYPE;
		return 1;
	}
	if (strcmp(str, "void_type") == 0) {
		*out = AST2C_NODETYPE_VOID_TYPE;
		return 1;
	}
	if (strcmp(str, "bool_type") == 0) {
		*out = AST2C_NODETYPE_BOOL_TYPE;
		return 1;
	}
	if (strcmp(str, "array_type") == 0) {
		*out = AST2C_NODETYPE_ARRAY_TYPE;
		return 1;
	}
	if (strcmp(str, "function_type") == 0) {
		*out = AST2C_NODETYPE_FUNCTION_TYPE;
		return 1;
	}
	if (strcmp(str, "struct_type") == 0) {
		*out = AST2C_NODETYPE_STRUCT_TYPE;
		return 1;
	}
	if (strcmp(str, "struct_union_type") == 0) {
		*out = AST2C_NODETYPE_STRUCT_UNION_TYPE;
		return 1;
	}
	if (strcmp(str, "union_type") == 0) {
		*out = AST2C_NODETYPE_UNION_TYPE;
		return 1;
	}
	if (strcmp(str, "range_type") == 0) {
		*out = AST2C_NODETYPE_RANGE_TYPE;
		return 1;
	}
	if (strcmp(str, "enum_type") == 0) {
		*out = AST2C_NODETYPE_ENUM_TYPE;
		return 1;
	}
	if (strcmp(str, "literal") == 0) {
		*out = AST2C_NODETYPE_LITERAL;
		return 1;
	}
	if (strcmp(str, "int_literal") == 0) {
		*out = AST2C_NODETYPE_INT_LITERAL;
		return 1;
	}
	if (strcmp(str, "bool_literal") == 0) {
		*out = AST2C_NODETYPE_BOOL_LITERAL;
		return 1;
	}
	if (strcmp(str, "str_literal") == 0) {
		*out = AST2C_NODETYPE_STR_LITERAL;
		return 1;
	}
	if (strcmp(str, "input") == 0) {
		*out = AST2C_NODETYPE_INPUT;
		return 1;
	}
	if (strcmp(str, "output") == 0) {
		*out = AST2C_NODETYPE_OUTPUT;
		return 1;
	}
	if (strcmp(str, "config") == 0) {
		*out = AST2C_NODETYPE_CONFIG;
		return 1;
	}
	if (strcmp(str, "member") == 0) {
		*out = AST2C_NODETYPE_MEMBER;
		return 1;
	}
	if (strcmp(str, "field") == 0) {
		*out = AST2C_NODETYPE_FIELD;
		return 1;
	}
	if (strcmp(str, "format") == 0) {
		*out = AST2C_NODETYPE_FORMAT;
		return 1;
	}
	if (strcmp(str, "state") == 0) {
		*out = AST2C_NODETYPE_STATE;
		return 1;
	}
	if (strcmp(str, "enum") == 0) {
		*out = AST2C_NODETYPE_ENUM;
		return 1;
	}
	if (strcmp(str, "enum_member") == 0) {
		*out = AST2C_NODETYPE_ENUM_MEMBER;
		return 1;
	}
	if (strcmp(str, "function") == 0) {
		*out = AST2C_NODETYPE_FUNCTION;
		return 1;
	}
	if (strcmp(str, "builtin_function") == 0) {
		*out = AST2C_NODETYPE_BUILTIN_FUNCTION;
		return 1;
	}
	return 0;
}

const char* ast2c_UnaryOp_to_string(ast2c_UnaryOp val) {
	switch(val) {
	case AST2C_UNARYOP_NOT: return "!";
	case AST2C_UNARYOP_MINUS_SIGN: return "-";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_UnaryOp_from_string(const char* str, ast2c_UnaryOp* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "!") == 0) {
		*out = AST2C_UNARYOP_NOT;
		return 1;
	}
	if (strcmp(str, "-") == 0) {
		*out = AST2C_UNARYOP_MINUS_SIGN;
		return 1;
	}
	return 0;
}

const char* ast2c_BinaryOp_to_string(ast2c_BinaryOp val) {
	switch(val) {
	case AST2C_BINARYOP_MUL: return "*";
	case AST2C_BINARYOP_DIV: return "/";
	case AST2C_BINARYOP_MOD: return "%";
	case AST2C_BINARYOP_LEFT_ARITHMETIC_SHIFT: return "<<<";
	case AST2C_BINARYOP_RIGHT_ARITHMETIC_SHIFT: return ">>>";
	case AST2C_BINARYOP_LEFT_LOGICAL_SHIFT: return "<<";
	case AST2C_BINARYOP_RIGHT_LOGICAL_SHIFT: return ">>";
	case AST2C_BINARYOP_BIT_AND: return "&";
	case AST2C_BINARYOP_ADD: return "+";
	case AST2C_BINARYOP_SUB: return "-";
	case AST2C_BINARYOP_BIT_OR: return "|";
	case AST2C_BINARYOP_BIT_XOR: return "^";
	case AST2C_BINARYOP_EQUAL: return "==";
	case AST2C_BINARYOP_NOT_EQUAL: return "!=";
	case AST2C_BINARYOP_LESS: return "<";
	case AST2C_BINARYOP_LESS_OR_EQ: return "<=";
	case AST2C_BINARYOP_GRATER: return ">";
	case AST2C_BINARYOP_GRATER_OR_EQ: return ">=";
	case AST2C_BINARYOP_LOGICAL_AND: return "&&";
	case AST2C_BINARYOP_LOGICAL_OR: return "||";
	case AST2C_BINARYOP_COND_OP_1: return "?";
	case AST2C_BINARYOP_COND_OP_2: return ":";
	case AST2C_BINARYOP_RANGE_EXCLUSIVE: return "..";
	case AST2C_BINARYOP_RANGE_INCLUSIVE: return "..=";
	case AST2C_BINARYOP_ASSIGN: return "=";
	case AST2C_BINARYOP_DEFINE_ASSIGN: return ":=";
	case AST2C_BINARYOP_CONST_ASSIGN: return "::=";
	case AST2C_BINARYOP_ADD_ASSIGN: return "+=";
	case AST2C_BINARYOP_SUB_ASSIGN: return "-=";
	case AST2C_BINARYOP_MUL_ASSIGN: return "*=";
	case AST2C_BINARYOP_DIV_ASSIGN: return "/=";
	case AST2C_BINARYOP_MOD_ASSIGN: return "%=";
	case AST2C_BINARYOP_LEFT_SHIFT_ASSIGN: return "<<=";
	case AST2C_BINARYOP_RIGHT_SHIFT_ASSIGN: return ">>=";
	case AST2C_BINARYOP_BIT_AND_ASSIGN: return "&=";
	case AST2C_BINARYOP_BIT_OR_ASSIGN: return "|=";
	case AST2C_BINARYOP_BIT_XOR_ASSIGN: return "^=";
	case AST2C_BINARYOP_COMMA: return ",";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_BinaryOp_from_string(const char* str, ast2c_BinaryOp* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "*") == 0) {
		*out = AST2C_BINARYOP_MUL;
		return 1;
	}
	if (strcmp(str, "/") == 0) {
		*out = AST2C_BINARYOP_DIV;
		return 1;
	}
	if (strcmp(str, "%") == 0) {
		*out = AST2C_BINARYOP_MOD;
		return 1;
	}
	if (strcmp(str, "<<<") == 0) {
		*out = AST2C_BINARYOP_LEFT_ARITHMETIC_SHIFT;
		return 1;
	}
	if (strcmp(str, ">>>") == 0) {
		*out = AST2C_BINARYOP_RIGHT_ARITHMETIC_SHIFT;
		return 1;
	}
	if (strcmp(str, "<<") == 0) {
		*out = AST2C_BINARYOP_LEFT_LOGICAL_SHIFT;
		return 1;
	}
	if (strcmp(str, ">>") == 0) {
		*out = AST2C_BINARYOP_RIGHT_LOGICAL_SHIFT;
		return 1;
	}
	if (strcmp(str, "&") == 0) {
		*out = AST2C_BINARYOP_BIT_AND;
		return 1;
	}
	if (strcmp(str, "+") == 0) {
		*out = AST2C_BINARYOP_ADD;
		return 1;
	}
	if (strcmp(str, "-") == 0) {
		*out = AST2C_BINARYOP_SUB;
		return 1;
	}
	if (strcmp(str, "|") == 0) {
		*out = AST2C_BINARYOP_BIT_OR;
		return 1;
	}
	if (strcmp(str, "^") == 0) {
		*out = AST2C_BINARYOP_BIT_XOR;
		return 1;
	}
	if (strcmp(str, "==") == 0) {
		*out = AST2C_BINARYOP_EQUAL;
		return 1;
	}
	if (strcmp(str, "!=") == 0) {
		*out = AST2C_BINARYOP_NOT_EQUAL;
		return 1;
	}
	if (strcmp(str, "<") == 0) {
		*out = AST2C_BINARYOP_LESS;
		return 1;
	}
	if (strcmp(str, "<=") == 0) {
		*out = AST2C_BINARYOP_LESS_OR_EQ;
		return 1;
	}
	if (strcmp(str, ">") == 0) {
		*out = AST2C_BINARYOP_GRATER;
		return 1;
	}
	if (strcmp(str, ">=") == 0) {
		*out = AST2C_BINARYOP_GRATER_OR_EQ;
		return 1;
	}
	if (strcmp(str, "&&") == 0) {
		*out = AST2C_BINARYOP_LOGICAL_AND;
		return 1;
	}
	if (strcmp(str, "||") == 0) {
		*out = AST2C_BINARYOP_LOGICAL_OR;
		return 1;
	}
	if (strcmp(str, "?") == 0) {
		*out = AST2C_BINARYOP_COND_OP_1;
		return 1;
	}
	if (strcmp(str, ":") == 0) {
		*out = AST2C_BINARYOP_COND_OP_2;
		return 1;
	}
	if (strcmp(str, "..") == 0) {
		*out = AST2C_BINARYOP_RANGE_EXCLUSIVE;
		return 1;
	}
	if (strcmp(str, "..=") == 0) {
		*out = AST2C_BINARYOP_RANGE_INCLUSIVE;
		return 1;
	}
	if (strcmp(str, "=") == 0) {
		*out = AST2C_BINARYOP_ASSIGN;
		return 1;
	}
	if (strcmp(str, ":=") == 0) {
		*out = AST2C_BINARYOP_DEFINE_ASSIGN;
		return 1;
	}
	if (strcmp(str, "::=") == 0) {
		*out = AST2C_BINARYOP_CONST_ASSIGN;
		return 1;
	}
	if (strcmp(str, "+=") == 0) {
		*out = AST2C_BINARYOP_ADD_ASSIGN;
		return 1;
	}
	if (strcmp(str, "-=") == 0) {
		*out = AST2C_BINARYOP_SUB_ASSIGN;
		return 1;
	}
	if (strcmp(str, "*=") == 0) {
		*out = AST2C_BINARYOP_MUL_ASSIGN;
		return 1;
	}
	if (strcmp(str, "/=") == 0) {
		*out = AST2C_BINARYOP_DIV_ASSIGN;
		return 1;
	}
	if (strcmp(str, "%=") == 0) {
		*out = AST2C_BINARYOP_MOD_ASSIGN;
		return 1;
	}
	if (strcmp(str, "<<=") == 0) {
		*out = AST2C_BINARYOP_LEFT_SHIFT_ASSIGN;
		return 1;
	}
	if (strcmp(str, ">>=") == 0) {
		*out = AST2C_BINARYOP_RIGHT_SHIFT_ASSIGN;
		return 1;
	}
	if (strcmp(str, "&=") == 0) {
		*out = AST2C_BINARYOP_BIT_AND_ASSIGN;
		return 1;
	}
	if (strcmp(str, "|=") == 0) {
		*out = AST2C_BINARYOP_BIT_OR_ASSIGN;
		return 1;
	}
	if (strcmp(str, "^=") == 0) {
		*out = AST2C_BINARYOP_BIT_XOR_ASSIGN;
		return 1;
	}
	if (strcmp(str, ",") == 0) {
		*out = AST2C_BINARYOP_COMMA;
		return 1;
	}
	return 0;
}

const char* ast2c_IdentUsage_to_string(ast2c_IdentUsage val) {
	switch(val) {
	case AST2C_IDENTUSAGE_UNKNOWN: return "unknown";
	case AST2C_IDENTUSAGE_REFERENCE: return "reference";
	case AST2C_IDENTUSAGE_DEFINE_VARIABLE: return "define_variable";
	case AST2C_IDENTUSAGE_DEFINE_CONST: return "define_const";
	case AST2C_IDENTUSAGE_DEFINE_FIELD: return "define_field";
	case AST2C_IDENTUSAGE_DEFINE_FORMAT: return "define_format";
	case AST2C_IDENTUSAGE_DEFINE_STATE: return "define_state";
	case AST2C_IDENTUSAGE_DEFINE_ENUM: return "define_enum";
	case AST2C_IDENTUSAGE_DEFINE_ENUM_MEMBER: return "define_enum_member";
	case AST2C_IDENTUSAGE_DEFINE_FN: return "define_fn";
	case AST2C_IDENTUSAGE_DEFINE_CAST_FN: return "define_cast_fn";
	case AST2C_IDENTUSAGE_DEFINE_ARG: return "define_arg";
	case AST2C_IDENTUSAGE_REFERENCE_TYPE: return "reference_type";
	case AST2C_IDENTUSAGE_REFERENCE_MEMBER: return "reference_member";
	case AST2C_IDENTUSAGE_MAYBE_TYPE: return "maybe_type";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_IdentUsage_from_string(const char* str, ast2c_IdentUsage* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "unknown") == 0) {
		*out = AST2C_IDENTUSAGE_UNKNOWN;
		return 1;
	}
	if (strcmp(str, "reference") == 0) {
		*out = AST2C_IDENTUSAGE_REFERENCE;
		return 1;
	}
	if (strcmp(str, "define_variable") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_VARIABLE;
		return 1;
	}
	if (strcmp(str, "define_const") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_CONST;
		return 1;
	}
	if (strcmp(str, "define_field") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_FIELD;
		return 1;
	}
	if (strcmp(str, "define_format") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_FORMAT;
		return 1;
	}
	if (strcmp(str, "define_state") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_STATE;
		return 1;
	}
	if (strcmp(str, "define_enum") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_ENUM;
		return 1;
	}
	if (strcmp(str, "define_enum_member") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_ENUM_MEMBER;
		return 1;
	}
	if (strcmp(str, "define_fn") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_FN;
		return 1;
	}
	if (strcmp(str, "define_cast_fn") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_CAST_FN;
		return 1;
	}
	if (strcmp(str, "define_arg") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_ARG;
		return 1;
	}
	if (strcmp(str, "reference_type") == 0) {
		*out = AST2C_IDENTUSAGE_REFERENCE_TYPE;
		return 1;
	}
	if (strcmp(str, "reference_member") == 0) {
		*out = AST2C_IDENTUSAGE_REFERENCE_MEMBER;
		return 1;
	}
	if (strcmp(str, "maybe_type") == 0) {
		*out = AST2C_IDENTUSAGE_MAYBE_TYPE;
		return 1;
	}
	return 0;
}

const char* ast2c_Endian_to_string(ast2c_Endian val) {
	switch(val) {
	case AST2C_ENDIAN_UNSPEC: return "unspec";
	case AST2C_ENDIAN_BIG: return "big";
	case AST2C_ENDIAN_LITTLE: return "little";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_Endian_from_string(const char* str, ast2c_Endian* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "unspec") == 0) {
		*out = AST2C_ENDIAN_UNSPEC;
		return 1;
	}
	if (strcmp(str, "big") == 0) {
		*out = AST2C_ENDIAN_BIG;
		return 1;
	}
	if (strcmp(str, "little") == 0) {
		*out = AST2C_ENDIAN_LITTLE;
		return 1;
	}
	return 0;
}

const char* ast2c_TokenTag_to_string(ast2c_TokenTag val) {
	switch(val) {
	case AST2C_TOKENTAG_INDENT: return "indent";
	case AST2C_TOKENTAG_SPACE: return "space";
	case AST2C_TOKENTAG_LINE: return "line";
	case AST2C_TOKENTAG_PUNCT: return "punct";
	case AST2C_TOKENTAG_INT_LITERAL: return "int_literal";
	case AST2C_TOKENTAG_BOOL_LITERAL: return "bool_literal";
	case AST2C_TOKENTAG_STR_LITERAL: return "str_literal";
	case AST2C_TOKENTAG_KEYWORD: return "keyword";
	case AST2C_TOKENTAG_IDENT: return "ident";
	case AST2C_TOKENTAG_COMMENT: return "comment";
	case AST2C_TOKENTAG_ERROR: return "error";
	case AST2C_TOKENTAG_UNKNOWN: return "unknown";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_TokenTag_from_string(const char* str, ast2c_TokenTag* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "indent") == 0) {
		*out = AST2C_TOKENTAG_INDENT;
		return 1;
	}
	if (strcmp(str, "space") == 0) {
		*out = AST2C_TOKENTAG_SPACE;
		return 1;
	}
	if (strcmp(str, "line") == 0) {
		*out = AST2C_TOKENTAG_LINE;
		return 1;
	}
	if (strcmp(str, "punct") == 0) {
		*out = AST2C_TOKENTAG_PUNCT;
		return 1;
	}
	if (strcmp(str, "int_literal") == 0) {
		*out = AST2C_TOKENTAG_INT_LITERAL;
		return 1;
	}
	if (strcmp(str, "bool_literal") == 0) {
		*out = AST2C_TOKENTAG_BOOL_LITERAL;
		return 1;
	}
	if (strcmp(str, "str_literal") == 0) {
		*out = AST2C_TOKENTAG_STR_LITERAL;
		return 1;
	}
	if (strcmp(str, "keyword") == 0) {
		*out = AST2C_TOKENTAG_KEYWORD;
		return 1;
	}
	if (strcmp(str, "ident") == 0) {
		*out = AST2C_TOKENTAG_IDENT;
		return 1;
	}
	if (strcmp(str, "comment") == 0) {
		*out = AST2C_TOKENTAG_COMMENT;
		return 1;
	}
	if (strcmp(str, "error") == 0) {
		*out = AST2C_TOKENTAG_ERROR;
		return 1;
	}
	if (strcmp(str, "unknown") == 0) {
		*out = AST2C_TOKENTAG_UNKNOWN;
		return 1;
	}
	return 0;
}

const char* ast2c_ConstantLevel_to_string(ast2c_ConstantLevel val) {
	switch(val) {
	case AST2C_CONSTANTLEVEL_UNKNOWN: return "unknown";
	case AST2C_CONSTANTLEVEL_CONST_VALUE: return "const_value";
	case AST2C_CONSTANTLEVEL_CONST_VARIABLE: return "const_variable";
	case AST2C_CONSTANTLEVEL_VARIABLE: return "variable";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_ConstantLevel_from_string(const char* str, ast2c_ConstantLevel* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "unknown") == 0) {
		*out = AST2C_CONSTANTLEVEL_UNKNOWN;
		return 1;
	}
	if (strcmp(str, "const_value") == 0) {
		*out = AST2C_CONSTANTLEVEL_CONST_VALUE;
		return 1;
	}
	if (strcmp(str, "const_variable") == 0) {
		*out = AST2C_CONSTANTLEVEL_CONST_VARIABLE;
		return 1;
	}
	if (strcmp(str, "variable") == 0) {
		*out = AST2C_CONSTANTLEVEL_VARIABLE;
		return 1;
	}
	return 0;
}

const char* ast2c_BitAlignment_to_string(ast2c_BitAlignment val) {
	switch(val) {
	case AST2C_BITALIGNMENT_BYTE_ALIGNED: return "byte_aligned";
	case AST2C_BITALIGNMENT_BIT_1: return "bit_1";
	case AST2C_BITALIGNMENT_BIT_2: return "bit_2";
	case AST2C_BITALIGNMENT_BIT_3: return "bit_3";
	case AST2C_BITALIGNMENT_BIT_4: return "bit_4";
	case AST2C_BITALIGNMENT_BIT_5: return "bit_5";
	case AST2C_BITALIGNMENT_BIT_6: return "bit_6";
	case AST2C_BITALIGNMENT_BIT_7: return "bit_7";
	case AST2C_BITALIGNMENT_NOT_TARGET: return "not_target";
	case AST2C_BITALIGNMENT_NOT_DECIDABLE: return "not_decidable";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_BitAlignment_from_string(const char* str, ast2c_BitAlignment* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "byte_aligned") == 0) {
		*out = AST2C_BITALIGNMENT_BYTE_ALIGNED;
		return 1;
	}
	if (strcmp(str, "bit_1") == 0) {
		*out = AST2C_BITALIGNMENT_BIT_1;
		return 1;
	}
	if (strcmp(str, "bit_2") == 0) {
		*out = AST2C_BITALIGNMENT_BIT_2;
		return 1;
	}
	if (strcmp(str, "bit_3") == 0) {
		*out = AST2C_BITALIGNMENT_BIT_3;
		return 1;
	}
	if (strcmp(str, "bit_4") == 0) {
		*out = AST2C_BITALIGNMENT_BIT_4;
		return 1;
	}
	if (strcmp(str, "bit_5") == 0) {
		*out = AST2C_BITALIGNMENT_BIT_5;
		return 1;
	}
	if (strcmp(str, "bit_6") == 0) {
		*out = AST2C_BITALIGNMENT_BIT_6;
		return 1;
	}
	if (strcmp(str, "bit_7") == 0) {
		*out = AST2C_BITALIGNMENT_BIT_7;
		return 1;
	}
	if (strcmp(str, "not_target") == 0) {
		*out = AST2C_BITALIGNMENT_NOT_TARGET;
		return 1;
	}
	if (strcmp(str, "not_decidable") == 0) {
		*out = AST2C_BITALIGNMENT_NOT_DECIDABLE;
		return 1;
	}
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Program_parse(ast2c_Ast* ast,ast2c_Program* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->struct_type = NULL;
	s->elements = NULL;
	s->global_scope = NULL;
	void* struct_type = h->object_get(h, obj_body, "struct_type");
	void* elements = h->object_get(h, obj_body, "elements");
	void* global_scope = h->object_get(h, obj_body, "global_scope");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Program::loc is null"); } return 0; }
	if (!struct_type) { if(h->error) { h->error(h,struct_type, "ast2c_Program::struct_type is null"); } return 0; }
	if (!elements) { if(h->error) { h->error(h,elements, "ast2c_Program::elements is null"); } return 0; }
	if(!h->array_size(h, elements,&s->elements_size)) {
		if(h->error) { h->error(h,elements, "failed to get array size of ast2c_Program::elements"); }
		return NULL;
	}
	if (!global_scope) { if(h->error) { h->error(h,global_scope, "ast2c_Program::global_scope is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Program::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Comment_parse(ast2c_Ast* ast,ast2c_Comment* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->comment = NULL;
	void* comment = h->object_get(h, obj_body, "comment");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Comment::loc is null"); } return 0; }
	if (!comment) { if(h->error) { h->error(h,comment, "ast2c_Comment::comment is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Comment::loc"); }
		goto error;
	}
	s->comment = h->string_get_alloc(h,comment);
	if (!s->comment) {
		if(h->error) { h->error(h,comment, "failed to parse ast2c_Comment::comment"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_CommentGroup_parse(ast2c_Ast* ast,ast2c_CommentGroup* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->comments = NULL;
	void* comments = h->object_get(h, obj_body, "comments");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_CommentGroup::loc is null"); } return 0; }
	if (!comments) { if(h->error) { h->error(h,comments, "ast2c_CommentGroup::comments is null"); } return 0; }
	if(!h->array_size(h, comments,&s->comments_size)) {
		if(h->error) { h->error(h,comments, "failed to get array size of ast2c_CommentGroup::comments"); }
		return NULL;
	}
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_CommentGroup::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Binary_parse(ast2c_Ast* ast,ast2c_Binary* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->left = NULL;
	s->right = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* op = h->object_get(h, obj_body, "op");
	void* left = h->object_get(h, obj_body, "left");
	void* right = h->object_get(h, obj_body, "right");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Binary::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Binary::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Binary::constant_level is null"); } return 0; }
	if (!op) { if(h->error) { h->error(h,op, "ast2c_Binary::op is null"); } return 0; }
	if (!left) { if(h->error) { h->error(h,left, "ast2c_Binary::left is null"); } return 0; }
	if (!right) { if(h->error) { h->error(h,right, "ast2c_Binary::right is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Binary::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Unary_parse(ast2c_Ast* ast,ast2c_Unary* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->expr = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* op = h->object_get(h, obj_body, "op");
	void* expr = h->object_get(h, obj_body, "expr");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Unary::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Unary::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Unary::constant_level is null"); } return 0; }
	if (!op) { if(h->error) { h->error(h,op, "ast2c_Unary::op is null"); } return 0; }
	if (!expr) { if(h->error) { h->error(h,expr, "ast2c_Unary::expr is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Unary::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Cond_parse(ast2c_Ast* ast,ast2c_Cond* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->cond = NULL;
	s->then = NULL;
	s->els = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* cond = h->object_get(h, obj_body, "cond");
	void* then = h->object_get(h, obj_body, "then");
	void* els_loc = h->object_get(h, obj_body, "els_loc");
	void* els = h->object_get(h, obj_body, "els");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Cond::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Cond::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Cond::constant_level is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "ast2c_Cond::cond is null"); } return 0; }
	if (!then) { if(h->error) { h->error(h,then, "ast2c_Cond::then is null"); } return 0; }
	if (!els_loc) { if(h->error) { h->error(h,els_loc, "ast2c_Cond::els_loc is null"); } return 0; }
	if (!els) { if(h->error) { h->error(h,els, "ast2c_Cond::els is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Cond::loc"); }
		goto error;
	}
	if(!ast2c_Loc_parse(&s->els_loc,h,els_loc)) {
		if(h->error) { h->error(h,els_loc, "failed to parse ast2c_Cond::els_loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Ident_parse(ast2c_Ast* ast,ast2c_Ident* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->ident = NULL;
	s->base = NULL;
	s->scope = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* ident = h->object_get(h, obj_body, "ident");
	void* usage = h->object_get(h, obj_body, "usage");
	void* base = h->object_get(h, obj_body, "base");
	void* scope = h->object_get(h, obj_body, "scope");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Ident::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Ident::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Ident::constant_level is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ast2c_Ident::ident is null"); } return 0; }
	if (!usage) { if(h->error) { h->error(h,usage, "ast2c_Ident::usage is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_Ident::base is null"); } return 0; }
	if (!scope) { if(h->error) { h->error(h,scope, "ast2c_Ident::scope is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Ident::loc"); }
		goto error;
	}
	s->ident = h->string_get_alloc(h,ident);
	if (!s->ident) {
		if(h->error) { h->error(h,ident, "failed to parse ast2c_Ident::ident"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Call_parse(ast2c_Ast* ast,ast2c_Call* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->callee = NULL;
	s->raw_arguments = NULL;
	s->arguments = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* callee = h->object_get(h, obj_body, "callee");
	void* raw_arguments = h->object_get(h, obj_body, "raw_arguments");
	void* arguments = h->object_get(h, obj_body, "arguments");
	void* end_loc = h->object_get(h, obj_body, "end_loc");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Call::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Call::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Call::constant_level is null"); } return 0; }
	if (!callee) { if(h->error) { h->error(h,callee, "ast2c_Call::callee is null"); } return 0; }
	if (!raw_arguments) { if(h->error) { h->error(h,raw_arguments, "ast2c_Call::raw_arguments is null"); } return 0; }
	if (!arguments) { if(h->error) { h->error(h,arguments, "ast2c_Call::arguments is null"); } return 0; }
	if(!h->array_size(h, arguments,&s->arguments_size)) {
		if(h->error) { h->error(h,arguments, "failed to get array size of ast2c_Call::arguments"); }
		return NULL;
	}
	if (!end_loc) { if(h->error) { h->error(h,end_loc, "ast2c_Call::end_loc is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Call::loc"); }
		goto error;
	}
	if(!ast2c_Loc_parse(&s->end_loc,h,end_loc)) {
		if(h->error) { h->error(h,end_loc, "failed to parse ast2c_Call::end_loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_If_parse(ast2c_Ast* ast,ast2c_If* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->cond_scope = NULL;
	s->cond = NULL;
	s->then = NULL;
	s->els = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* cond_scope = h->object_get(h, obj_body, "cond_scope");
	void* cond = h->object_get(h, obj_body, "cond");
	void* then = h->object_get(h, obj_body, "then");
	void* els = h->object_get(h, obj_body, "els");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_If::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_If::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_If::constant_level is null"); } return 0; }
	if (!cond_scope) { if(h->error) { h->error(h,cond_scope, "ast2c_If::cond_scope is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "ast2c_If::cond is null"); } return 0; }
	if (!then) { if(h->error) { h->error(h,then, "ast2c_If::then is null"); } return 0; }
	if (!els) { if(h->error) { h->error(h,els, "ast2c_If::els is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_If::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_MemberAccess_parse(ast2c_Ast* ast,ast2c_MemberAccess* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->target = NULL;
	s->member = NULL;
	s->base = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* target = h->object_get(h, obj_body, "target");
	void* member = h->object_get(h, obj_body, "member");
	void* base = h->object_get(h, obj_body, "base");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_MemberAccess::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_MemberAccess::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_MemberAccess::constant_level is null"); } return 0; }
	if (!target) { if(h->error) { h->error(h,target, "ast2c_MemberAccess::target is null"); } return 0; }
	if (!member) { if(h->error) { h->error(h,member, "ast2c_MemberAccess::member is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_MemberAccess::base is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_MemberAccess::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Paren_parse(ast2c_Ast* ast,ast2c_Paren* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->expr = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* expr = h->object_get(h, obj_body, "expr");
	void* end_loc = h->object_get(h, obj_body, "end_loc");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Paren::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Paren::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Paren::constant_level is null"); } return 0; }
	if (!expr) { if(h->error) { h->error(h,expr, "ast2c_Paren::expr is null"); } return 0; }
	if (!end_loc) { if(h->error) { h->error(h,end_loc, "ast2c_Paren::end_loc is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Paren::loc"); }
		goto error;
	}
	if(!ast2c_Loc_parse(&s->end_loc,h,end_loc)) {
		if(h->error) { h->error(h,end_loc, "failed to parse ast2c_Paren::end_loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Index_parse(ast2c_Ast* ast,ast2c_Index* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->expr = NULL;
	s->index = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* expr = h->object_get(h, obj_body, "expr");
	void* index = h->object_get(h, obj_body, "index");
	void* end_loc = h->object_get(h, obj_body, "end_loc");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Index::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Index::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Index::constant_level is null"); } return 0; }
	if (!expr) { if(h->error) { h->error(h,expr, "ast2c_Index::expr is null"); } return 0; }
	if (!index) { if(h->error) { h->error(h,index, "ast2c_Index::index is null"); } return 0; }
	if (!end_loc) { if(h->error) { h->error(h,end_loc, "ast2c_Index::end_loc is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Index::loc"); }
		goto error;
	}
	if(!ast2c_Loc_parse(&s->end_loc,h,end_loc)) {
		if(h->error) { h->error(h,end_loc, "failed to parse ast2c_Index::end_loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Match_parse(ast2c_Ast* ast,ast2c_Match* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->cond_scope = NULL;
	s->cond = NULL;
	s->branch = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* cond_scope = h->object_get(h, obj_body, "cond_scope");
	void* cond = h->object_get(h, obj_body, "cond");
	void* branch = h->object_get(h, obj_body, "branch");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Match::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Match::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Match::constant_level is null"); } return 0; }
	if (!cond_scope) { if(h->error) { h->error(h,cond_scope, "ast2c_Match::cond_scope is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "ast2c_Match::cond is null"); } return 0; }
	if (!branch) { if(h->error) { h->error(h,branch, "ast2c_Match::branch is null"); } return 0; }
	if(!h->array_size(h, branch,&s->branch_size)) {
		if(h->error) { h->error(h,branch, "failed to get array size of ast2c_Match::branch"); }
		return NULL;
	}
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Match::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Range_parse(ast2c_Ast* ast,ast2c_Range* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->start = NULL;
	s->end = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* op = h->object_get(h, obj_body, "op");
	void* start = h->object_get(h, obj_body, "start");
	void* end = h->object_get(h, obj_body, "end");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Range::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Range::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Range::constant_level is null"); } return 0; }
	if (!op) { if(h->error) { h->error(h,op, "ast2c_Range::op is null"); } return 0; }
	if (!start) { if(h->error) { h->error(h,start, "ast2c_Range::start is null"); } return 0; }
	if (!end) { if(h->error) { h->error(h,end, "ast2c_Range::end is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Range::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_TmpVar_parse(ast2c_Ast* ast,ast2c_TmpVar* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* tmp_var = h->object_get(h, obj_body, "tmp_var");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_TmpVar::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_TmpVar::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_TmpVar::constant_level is null"); } return 0; }
	if (!tmp_var) { if(h->error) { h->error(h,tmp_var, "ast2c_TmpVar::tmp_var is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_TmpVar::loc"); }
		goto error;
	}
	if(!h->number_get(h,tmp_var,&s->tmp_var)) {
		if(h->error) { h->error(h,tmp_var, "failed to parse ast2c_TmpVar::tmp_var"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_BlockExpr_parse(ast2c_Ast* ast,ast2c_BlockExpr* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->calls = NULL;
	s->expr = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* calls = h->object_get(h, obj_body, "calls");
	void* expr = h->object_get(h, obj_body, "expr");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_BlockExpr::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_BlockExpr::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_BlockExpr::constant_level is null"); } return 0; }
	if (!calls) { if(h->error) { h->error(h,calls, "ast2c_BlockExpr::calls is null"); } return 0; }
	if(!h->array_size(h, calls,&s->calls_size)) {
		if(h->error) { h->error(h,calls, "failed to get array size of ast2c_BlockExpr::calls"); }
		return NULL;
	}
	if (!expr) { if(h->error) { h->error(h,expr, "ast2c_BlockExpr::expr is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_BlockExpr::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Import_parse(ast2c_Ast* ast,ast2c_Import* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->path = NULL;
	s->base = NULL;
	s->import_desc = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* path = h->object_get(h, obj_body, "path");
	void* base = h->object_get(h, obj_body, "base");
	void* import_desc = h->object_get(h, obj_body, "import_desc");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Import::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Import::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Import::constant_level is null"); } return 0; }
	if (!path) { if(h->error) { h->error(h,path, "ast2c_Import::path is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_Import::base is null"); } return 0; }
	if (!import_desc) { if(h->error) { h->error(h,import_desc, "ast2c_Import::import_desc is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Import::loc"); }
		goto error;
	}
	s->path = h->string_get_alloc(h,path);
	if (!s->path) {
		if(h->error) { h->error(h,path, "failed to parse ast2c_Import::path"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Cast_parse(ast2c_Ast* ast,ast2c_Cast* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->base = NULL;
	s->expr = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* base = h->object_get(h, obj_body, "base");
	void* expr = h->object_get(h, obj_body, "expr");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Cast::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Cast::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Cast::constant_level is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_Cast::base is null"); } return 0; }
	if (!expr) { if(h->error) { h->error(h,expr, "ast2c_Cast::expr is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Cast::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Loop_parse(ast2c_Ast* ast,ast2c_Loop* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->cond_scope = NULL;
	s->init = NULL;
	s->cond = NULL;
	s->step = NULL;
	s->body = NULL;
	void* cond_scope = h->object_get(h, obj_body, "cond_scope");
	void* init = h->object_get(h, obj_body, "init");
	void* cond = h->object_get(h, obj_body, "cond");
	void* step = h->object_get(h, obj_body, "step");
	void* body = h->object_get(h, obj_body, "body");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Loop::loc is null"); } return 0; }
	if (!cond_scope) { if(h->error) { h->error(h,cond_scope, "ast2c_Loop::cond_scope is null"); } return 0; }
	if (!init) { if(h->error) { h->error(h,init, "ast2c_Loop::init is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "ast2c_Loop::cond is null"); } return 0; }
	if (!step) { if(h->error) { h->error(h,step, "ast2c_Loop::step is null"); } return 0; }
	if (!body) { if(h->error) { h->error(h,body, "ast2c_Loop::body is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Loop::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_IndentBlock_parse(ast2c_Ast* ast,ast2c_IndentBlock* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->struct_type = NULL;
	s->elements = NULL;
	s->scope = NULL;
	void* struct_type = h->object_get(h, obj_body, "struct_type");
	void* elements = h->object_get(h, obj_body, "elements");
	void* scope = h->object_get(h, obj_body, "scope");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_IndentBlock::loc is null"); } return 0; }
	if (!struct_type) { if(h->error) { h->error(h,struct_type, "ast2c_IndentBlock::struct_type is null"); } return 0; }
	if (!elements) { if(h->error) { h->error(h,elements, "ast2c_IndentBlock::elements is null"); } return 0; }
	if(!h->array_size(h, elements,&s->elements_size)) {
		if(h->error) { h->error(h,elements, "failed to get array size of ast2c_IndentBlock::elements"); }
		return NULL;
	}
	if (!scope) { if(h->error) { h->error(h,scope, "ast2c_IndentBlock::scope is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_IndentBlock::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_MatchBranch_parse(ast2c_Ast* ast,ast2c_MatchBranch* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->cond = NULL;
	s->then = NULL;
	void* cond = h->object_get(h, obj_body, "cond");
	void* sym_loc = h->object_get(h, obj_body, "sym_loc");
	void* then = h->object_get(h, obj_body, "then");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_MatchBranch::loc is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "ast2c_MatchBranch::cond is null"); } return 0; }
	if (!sym_loc) { if(h->error) { h->error(h,sym_loc, "ast2c_MatchBranch::sym_loc is null"); } return 0; }
	if (!then) { if(h->error) { h->error(h,then, "ast2c_MatchBranch::then is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_MatchBranch::loc"); }
		goto error;
	}
	if(!ast2c_Loc_parse(&s->sym_loc,h,sym_loc)) {
		if(h->error) { h->error(h,sym_loc, "failed to parse ast2c_MatchBranch::sym_loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_UnionCandidate_parse(ast2c_Ast* ast,ast2c_UnionCandidate* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->cond = NULL;
	s->field = NULL;
	void* cond = h->object_get(h, obj_body, "cond");
	void* field = h->object_get(h, obj_body, "field");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_UnionCandidate::loc is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "ast2c_UnionCandidate::cond is null"); } return 0; }
	if (!field) { if(h->error) { h->error(h,field, "ast2c_UnionCandidate::field is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_UnionCandidate::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Return_parse(ast2c_Ast* ast,ast2c_Return* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr = NULL;
	void* expr = h->object_get(h, obj_body, "expr");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Return::loc is null"); } return 0; }
	if (!expr) { if(h->error) { h->error(h,expr, "ast2c_Return::expr is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Return::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Break_parse(ast2c_Ast* ast,ast2c_Break* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Break::loc is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Break::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Continue_parse(ast2c_Ast* ast,ast2c_Continue* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Continue::loc is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Continue::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Assert_parse(ast2c_Ast* ast,ast2c_Assert* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->cond = NULL;
	void* cond = h->object_get(h, obj_body, "cond");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Assert::loc is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "ast2c_Assert::cond is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Assert::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_ImplicitYield_parse(ast2c_Ast* ast,ast2c_ImplicitYield* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr = NULL;
	void* expr = h->object_get(h, obj_body, "expr");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_ImplicitYield::loc is null"); } return 0; }
	if (!expr) { if(h->error) { h->error(h,expr, "ast2c_ImplicitYield::expr is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_ImplicitYield::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_IntType_parse(ast2c_Ast* ast,ast2c_IntType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* is_int_set = h->object_get(h, obj_body, "is_int_set");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* endian = h->object_get(h, obj_body, "endian");
	void* is_signed = h->object_get(h, obj_body, "is_signed");
	void* is_common_supported = h->object_get(h, obj_body, "is_common_supported");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_IntType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_IntType::is_explicit is null"); } return 0; }
	if (!is_int_set) { if(h->error) { h->error(h,is_int_set, "ast2c_IntType::is_int_set is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_IntType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_IntType::bit_size is null"); } return 0; }
	if (!endian) { if(h->error) { h->error(h,endian, "ast2c_IntType::endian is null"); } return 0; }
	if (!is_signed) { if(h->error) { h->error(h,is_signed, "ast2c_IntType::is_signed is null"); } return 0; }
	if (!is_common_supported) { if(h->error) { h->error(h,is_common_supported, "ast2c_IntType::is_common_supported is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_IntType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_IntType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_IdentType_parse(ast2c_Ast* ast,ast2c_IdentType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->ident = NULL;
	s->base = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* is_int_set = h->object_get(h, obj_body, "is_int_set");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* ident = h->object_get(h, obj_body, "ident");
	void* base = h->object_get(h, obj_body, "base");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_IdentType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_IdentType::is_explicit is null"); } return 0; }
	if (!is_int_set) { if(h->error) { h->error(h,is_int_set, "ast2c_IdentType::is_int_set is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_IdentType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_IdentType::bit_size is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ast2c_IdentType::ident is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_IdentType::base is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_IdentType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_IdentType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_IntLiteralType_parse(ast2c_Ast* ast,ast2c_IntLiteralType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->base = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* is_int_set = h->object_get(h, obj_body, "is_int_set");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* base = h->object_get(h, obj_body, "base");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_IntLiteralType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_IntLiteralType::is_explicit is null"); } return 0; }
	if (!is_int_set) { if(h->error) { h->error(h,is_int_set, "ast2c_IntLiteralType::is_int_set is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_IntLiteralType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_IntLiteralType::bit_size is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_IntLiteralType::base is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_IntLiteralType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_IntLiteralType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_StrLiteralType_parse(ast2c_Ast* ast,ast2c_StrLiteralType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->base = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* is_int_set = h->object_get(h, obj_body, "is_int_set");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* base = h->object_get(h, obj_body, "base");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_StrLiteralType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_StrLiteralType::is_explicit is null"); } return 0; }
	if (!is_int_set) { if(h->error) { h->error(h,is_int_set, "ast2c_StrLiteralType::is_int_set is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_StrLiteralType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_StrLiteralType::bit_size is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_StrLiteralType::base is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_StrLiteralType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_StrLiteralType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_VoidType_parse(ast2c_Ast* ast,ast2c_VoidType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* is_int_set = h->object_get(h, obj_body, "is_int_set");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_VoidType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_VoidType::is_explicit is null"); } return 0; }
	if (!is_int_set) { if(h->error) { h->error(h,is_int_set, "ast2c_VoidType::is_int_set is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_VoidType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_VoidType::bit_size is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_VoidType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_VoidType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_BoolType_parse(ast2c_Ast* ast,ast2c_BoolType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* is_int_set = h->object_get(h, obj_body, "is_int_set");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_BoolType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_BoolType::is_explicit is null"); } return 0; }
	if (!is_int_set) { if(h->error) { h->error(h,is_int_set, "ast2c_BoolType::is_int_set is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_BoolType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_BoolType::bit_size is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_BoolType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_BoolType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_ArrayType_parse(ast2c_Ast* ast,ast2c_ArrayType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->base_type = NULL;
	s->length = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* is_int_set = h->object_get(h, obj_body, "is_int_set");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* end_loc = h->object_get(h, obj_body, "end_loc");
	void* base_type = h->object_get(h, obj_body, "base_type");
	void* length = h->object_get(h, obj_body, "length");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_ArrayType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_ArrayType::is_explicit is null"); } return 0; }
	if (!is_int_set) { if(h->error) { h->error(h,is_int_set, "ast2c_ArrayType::is_int_set is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_ArrayType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_ArrayType::bit_size is null"); } return 0; }
	if (!end_loc) { if(h->error) { h->error(h,end_loc, "ast2c_ArrayType::end_loc is null"); } return 0; }
	if (!base_type) { if(h->error) { h->error(h,base_type, "ast2c_ArrayType::base_type is null"); } return 0; }
	if (!length) { if(h->error) { h->error(h,length, "ast2c_ArrayType::length is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_ArrayType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_ArrayType::bit_size"); }
		goto error;
	}
	if(!ast2c_Loc_parse(&s->end_loc,h,end_loc)) {
		if(h->error) { h->error(h,end_loc, "failed to parse ast2c_ArrayType::end_loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_FunctionType_parse(ast2c_Ast* ast,ast2c_FunctionType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->return_type = NULL;
	s->parameters = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* is_int_set = h->object_get(h, obj_body, "is_int_set");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* return_type = h->object_get(h, obj_body, "return_type");
	void* parameters = h->object_get(h, obj_body, "parameters");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_FunctionType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_FunctionType::is_explicit is null"); } return 0; }
	if (!is_int_set) { if(h->error) { h->error(h,is_int_set, "ast2c_FunctionType::is_int_set is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_FunctionType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_FunctionType::bit_size is null"); } return 0; }
	if (!return_type) { if(h->error) { h->error(h,return_type, "ast2c_FunctionType::return_type is null"); } return 0; }
	if (!parameters) { if(h->error) { h->error(h,parameters, "ast2c_FunctionType::parameters is null"); } return 0; }
	if(!h->array_size(h, parameters,&s->parameters_size)) {
		if(h->error) { h->error(h,parameters, "failed to get array size of ast2c_FunctionType::parameters"); }
		return NULL;
	}
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_FunctionType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_FunctionType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_StructType_parse(ast2c_Ast* ast,ast2c_StructType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->fields = NULL;
	s->base = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* is_int_set = h->object_get(h, obj_body, "is_int_set");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* fields = h->object_get(h, obj_body, "fields");
	void* base = h->object_get(h, obj_body, "base");
	void* recursive = h->object_get(h, obj_body, "recursive");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_StructType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_StructType::is_explicit is null"); } return 0; }
	if (!is_int_set) { if(h->error) { h->error(h,is_int_set, "ast2c_StructType::is_int_set is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_StructType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_StructType::bit_size is null"); } return 0; }
	if (!fields) { if(h->error) { h->error(h,fields, "ast2c_StructType::fields is null"); } return 0; }
	if(!h->array_size(h, fields,&s->fields_size)) {
		if(h->error) { h->error(h,fields, "failed to get array size of ast2c_StructType::fields"); }
		return NULL;
	}
	if (!base) { if(h->error) { h->error(h,base, "ast2c_StructType::base is null"); } return 0; }
	if (!recursive) { if(h->error) { h->error(h,recursive, "ast2c_StructType::recursive is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_StructType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_StructType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_StructUnionType_parse(ast2c_Ast* ast,ast2c_StructUnionType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->fields = NULL;
	s->base = NULL;
	s->union_fields = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* is_int_set = h->object_get(h, obj_body, "is_int_set");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* fields = h->object_get(h, obj_body, "fields");
	void* base = h->object_get(h, obj_body, "base");
	void* union_fields = h->object_get(h, obj_body, "union_fields");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_StructUnionType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_StructUnionType::is_explicit is null"); } return 0; }
	if (!is_int_set) { if(h->error) { h->error(h,is_int_set, "ast2c_StructUnionType::is_int_set is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_StructUnionType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_StructUnionType::bit_size is null"); } return 0; }
	if (!fields) { if(h->error) { h->error(h,fields, "ast2c_StructUnionType::fields is null"); } return 0; }
	if(!h->array_size(h, fields,&s->fields_size)) {
		if(h->error) { h->error(h,fields, "failed to get array size of ast2c_StructUnionType::fields"); }
		return NULL;
	}
	if (!base) { if(h->error) { h->error(h,base, "ast2c_StructUnionType::base is null"); } return 0; }
	if (!union_fields) { if(h->error) { h->error(h,union_fields, "ast2c_StructUnionType::union_fields is null"); } return 0; }
	if(!h->array_size(h, union_fields,&s->union_fields_size)) {
		if(h->error) { h->error(h,union_fields, "failed to get array size of ast2c_StructUnionType::union_fields"); }
		return NULL;
	}
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_StructUnionType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_StructUnionType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_UnionType_parse(ast2c_Ast* ast,ast2c_UnionType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->cond = NULL;
	s->candidates = NULL;
	s->base_type = NULL;
	s->common_type = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* is_int_set = h->object_get(h, obj_body, "is_int_set");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* cond = h->object_get(h, obj_body, "cond");
	void* candidates = h->object_get(h, obj_body, "candidates");
	void* base_type = h->object_get(h, obj_body, "base_type");
	void* common_type = h->object_get(h, obj_body, "common_type");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_UnionType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_UnionType::is_explicit is null"); } return 0; }
	if (!is_int_set) { if(h->error) { h->error(h,is_int_set, "ast2c_UnionType::is_int_set is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_UnionType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_UnionType::bit_size is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "ast2c_UnionType::cond is null"); } return 0; }
	if (!candidates) { if(h->error) { h->error(h,candidates, "ast2c_UnionType::candidates is null"); } return 0; }
	if(!h->array_size(h, candidates,&s->candidates_size)) {
		if(h->error) { h->error(h,candidates, "failed to get array size of ast2c_UnionType::candidates"); }
		return NULL;
	}
	if (!base_type) { if(h->error) { h->error(h,base_type, "ast2c_UnionType::base_type is null"); } return 0; }
	if (!common_type) { if(h->error) { h->error(h,common_type, "ast2c_UnionType::common_type is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_UnionType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_UnionType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_RangeType_parse(ast2c_Ast* ast,ast2c_RangeType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->base_type = NULL;
	s->range = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* is_int_set = h->object_get(h, obj_body, "is_int_set");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* base_type = h->object_get(h, obj_body, "base_type");
	void* range = h->object_get(h, obj_body, "range");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_RangeType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_RangeType::is_explicit is null"); } return 0; }
	if (!is_int_set) { if(h->error) { h->error(h,is_int_set, "ast2c_RangeType::is_int_set is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_RangeType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_RangeType::bit_size is null"); } return 0; }
	if (!base_type) { if(h->error) { h->error(h,base_type, "ast2c_RangeType::base_type is null"); } return 0; }
	if (!range) { if(h->error) { h->error(h,range, "ast2c_RangeType::range is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_RangeType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_RangeType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_EnumType_parse(ast2c_Ast* ast,ast2c_EnumType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->base = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* is_int_set = h->object_get(h, obj_body, "is_int_set");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* base = h->object_get(h, obj_body, "base");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_EnumType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_EnumType::is_explicit is null"); } return 0; }
	if (!is_int_set) { if(h->error) { h->error(h,is_int_set, "ast2c_EnumType::is_int_set is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_EnumType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_EnumType::bit_size is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_EnumType::base is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_EnumType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_EnumType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_IntLiteral_parse(ast2c_Ast* ast,ast2c_IntLiteral* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->value = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* value = h->object_get(h, obj_body, "value");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_IntLiteral::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_IntLiteral::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_IntLiteral::constant_level is null"); } return 0; }
	if (!value) { if(h->error) { h->error(h,value, "ast2c_IntLiteral::value is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_IntLiteral::loc"); }
		goto error;
	}
	s->value = h->string_get_alloc(h,value);
	if (!s->value) {
		if(h->error) { h->error(h,value, "failed to parse ast2c_IntLiteral::value"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_BoolLiteral_parse(ast2c_Ast* ast,ast2c_BoolLiteral* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* value = h->object_get(h, obj_body, "value");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_BoolLiteral::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_BoolLiteral::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_BoolLiteral::constant_level is null"); } return 0; }
	if (!value) { if(h->error) { h->error(h,value, "ast2c_BoolLiteral::value is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_BoolLiteral::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_StrLiteral_parse(ast2c_Ast* ast,ast2c_StrLiteral* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->value = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* value = h->object_get(h, obj_body, "value");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_StrLiteral::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_StrLiteral::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_StrLiteral::constant_level is null"); } return 0; }
	if (!value) { if(h->error) { h->error(h,value, "ast2c_StrLiteral::value is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_StrLiteral::loc"); }
		goto error;
	}
	s->value = h->string_get_alloc(h,value);
	if (!s->value) {
		if(h->error) { h->error(h,value, "failed to parse ast2c_StrLiteral::value"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Input_parse(ast2c_Ast* ast,ast2c_Input* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Input::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Input::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Input::constant_level is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Input::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Output_parse(ast2c_Ast* ast,ast2c_Output* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Output::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Output::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Output::constant_level is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Output::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Config_parse(ast2c_Ast* ast,ast2c_Config* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Config::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Config::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Config::constant_level is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Config::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Field_parse(ast2c_Ast* ast,ast2c_Field* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->belong = NULL;
	s->ident = NULL;
	s->field_type = NULL;
	s->raw_arguments = NULL;
	s->arguments = NULL;
	void* belong = h->object_get(h, obj_body, "belong");
	void* ident = h->object_get(h, obj_body, "ident");
	void* colon_loc = h->object_get(h, obj_body, "colon_loc");
	void* field_type = h->object_get(h, obj_body, "field_type");
	void* raw_arguments = h->object_get(h, obj_body, "raw_arguments");
	void* arguments = h->object_get(h, obj_body, "arguments");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Field::loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "ast2c_Field::belong is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ast2c_Field::ident is null"); } return 0; }
	if (!colon_loc) { if(h->error) { h->error(h,colon_loc, "ast2c_Field::colon_loc is null"); } return 0; }
	if (!field_type) { if(h->error) { h->error(h,field_type, "ast2c_Field::field_type is null"); } return 0; }
	if (!raw_arguments) { if(h->error) { h->error(h,raw_arguments, "ast2c_Field::raw_arguments is null"); } return 0; }
	if (!arguments) { if(h->error) { h->error(h,arguments, "ast2c_Field::arguments is null"); } return 0; }
	if(!h->array_size(h, arguments,&s->arguments_size)) {
		if(h->error) { h->error(h,arguments, "failed to get array size of ast2c_Field::arguments"); }
		return NULL;
	}
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_Field::bit_alignment is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Field::loc"); }
		goto error;
	}
	if(!ast2c_Loc_parse(&s->colon_loc,h,colon_loc)) {
		if(h->error) { h->error(h,colon_loc, "failed to parse ast2c_Field::colon_loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Format_parse(ast2c_Ast* ast,ast2c_Format* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->belong = NULL;
	s->ident = NULL;
	s->body = NULL;
	void* belong = h->object_get(h, obj_body, "belong");
	void* ident = h->object_get(h, obj_body, "ident");
	void* body = h->object_get(h, obj_body, "body");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Format::loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "ast2c_Format::belong is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ast2c_Format::ident is null"); } return 0; }
	if (!body) { if(h->error) { h->error(h,body, "ast2c_Format::body is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Format::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_State_parse(ast2c_Ast* ast,ast2c_State* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->belong = NULL;
	s->ident = NULL;
	s->body = NULL;
	void* belong = h->object_get(h, obj_body, "belong");
	void* ident = h->object_get(h, obj_body, "ident");
	void* body = h->object_get(h, obj_body, "body");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_State::loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "ast2c_State::belong is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ast2c_State::ident is null"); } return 0; }
	if (!body) { if(h->error) { h->error(h,body, "ast2c_State::body is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_State::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Enum_parse(ast2c_Ast* ast,ast2c_Enum* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->belong = NULL;
	s->ident = NULL;
	s->scope = NULL;
	s->base_type = NULL;
	s->members = NULL;
	s->enum_type = NULL;
	void* belong = h->object_get(h, obj_body, "belong");
	void* ident = h->object_get(h, obj_body, "ident");
	void* scope = h->object_get(h, obj_body, "scope");
	void* colon_loc = h->object_get(h, obj_body, "colon_loc");
	void* base_type = h->object_get(h, obj_body, "base_type");
	void* members = h->object_get(h, obj_body, "members");
	void* enum_type = h->object_get(h, obj_body, "enum_type");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Enum::loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "ast2c_Enum::belong is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ast2c_Enum::ident is null"); } return 0; }
	if (!scope) { if(h->error) { h->error(h,scope, "ast2c_Enum::scope is null"); } return 0; }
	if (!colon_loc) { if(h->error) { h->error(h,colon_loc, "ast2c_Enum::colon_loc is null"); } return 0; }
	if (!base_type) { if(h->error) { h->error(h,base_type, "ast2c_Enum::base_type is null"); } return 0; }
	if (!members) { if(h->error) { h->error(h,members, "ast2c_Enum::members is null"); } return 0; }
	if(!h->array_size(h, members,&s->members_size)) {
		if(h->error) { h->error(h,members, "failed to get array size of ast2c_Enum::members"); }
		return NULL;
	}
	if (!enum_type) { if(h->error) { h->error(h,enum_type, "ast2c_Enum::enum_type is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Enum::loc"); }
		goto error;
	}
	if(!ast2c_Loc_parse(&s->colon_loc,h,colon_loc)) {
		if(h->error) { h->error(h,colon_loc, "failed to parse ast2c_Enum::colon_loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_EnumMember_parse(ast2c_Ast* ast,ast2c_EnumMember* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->belong = NULL;
	s->ident = NULL;
	s->expr = NULL;
	void* belong = h->object_get(h, obj_body, "belong");
	void* ident = h->object_get(h, obj_body, "ident");
	void* expr = h->object_get(h, obj_body, "expr");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_EnumMember::loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "ast2c_EnumMember::belong is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ast2c_EnumMember::ident is null"); } return 0; }
	if (!expr) { if(h->error) { h->error(h,expr, "ast2c_EnumMember::expr is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_EnumMember::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Function_parse(ast2c_Ast* ast,ast2c_Function* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->belong = NULL;
	s->ident = NULL;
	s->parameters = NULL;
	s->return_type = NULL;
	s->body = NULL;
	s->func_type = NULL;
	void* belong = h->object_get(h, obj_body, "belong");
	void* ident = h->object_get(h, obj_body, "ident");
	void* parameters = h->object_get(h, obj_body, "parameters");
	void* return_type = h->object_get(h, obj_body, "return_type");
	void* body = h->object_get(h, obj_body, "body");
	void* func_type = h->object_get(h, obj_body, "func_type");
	void* is_cast = h->object_get(h, obj_body, "is_cast");
	void* cast_loc = h->object_get(h, obj_body, "cast_loc");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Function::loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "ast2c_Function::belong is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ast2c_Function::ident is null"); } return 0; }
	if (!parameters) { if(h->error) { h->error(h,parameters, "ast2c_Function::parameters is null"); } return 0; }
	if(!h->array_size(h, parameters,&s->parameters_size)) {
		if(h->error) { h->error(h,parameters, "failed to get array size of ast2c_Function::parameters"); }
		return NULL;
	}
	if (!return_type) { if(h->error) { h->error(h,return_type, "ast2c_Function::return_type is null"); } return 0; }
	if (!body) { if(h->error) { h->error(h,body, "ast2c_Function::body is null"); } return 0; }
	if (!func_type) { if(h->error) { h->error(h,func_type, "ast2c_Function::func_type is null"); } return 0; }
	if (!is_cast) { if(h->error) { h->error(h,is_cast, "ast2c_Function::is_cast is null"); } return 0; }
	if (!cast_loc) { if(h->error) { h->error(h,cast_loc, "ast2c_Function::cast_loc is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Function::loc"); }
		goto error;
	}
	if(!ast2c_Loc_parse(&s->cast_loc,h,cast_loc)) {
		if(h->error) { h->error(h,cast_loc, "failed to parse ast2c_Function::cast_loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_BuiltinFunction_parse(ast2c_Ast* ast,ast2c_BuiltinFunction* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->belong = NULL;
	s->ident = NULL;
	s->func_type = NULL;
	void* belong = h->object_get(h, obj_body, "belong");
	void* ident = h->object_get(h, obj_body, "ident");
	void* func_type = h->object_get(h, obj_body, "func_type");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_BuiltinFunction::loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "ast2c_BuiltinFunction::belong is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ast2c_BuiltinFunction::ident is null"); } return 0; }
	if (!func_type) { if(h->error) { h->error(h,func_type, "ast2c_BuiltinFunction::func_type is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_BuiltinFunction::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Pos_parse(ast2c_Pos* s,ast2c_json_handlers* h, void* obj) {
	void* begin = h->object_get(h, obj, "begin");
	void* end = h->object_get(h, obj, "end");
	if (!begin) { if(h->error) { h->error(h,begin, "ast2c_Pos::begin is null"); } return 0; }
	if (!end) { if(h->error) { h->error(h,end, "ast2c_Pos::end is null"); } return 0; }
	if(!h->number_get(h,begin,&s->begin)) {
		if(h->error) { h->error(h,begin, "failed to parse ast2c_Pos::begin"); }
		goto error;
	}
	if(!h->number_get(h,end,&s->end)) {
		if(h->error) { h->error(h,end, "failed to parse ast2c_Pos::end"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Loc_parse(ast2c_Loc* s,ast2c_json_handlers* h, void* obj) {
	void* pos = h->object_get(h, obj, "pos");
	void* file = h->object_get(h, obj, "file");
	void* line = h->object_get(h, obj, "line");
	void* col = h->object_get(h, obj, "col");
	if (!pos) { if(h->error) { h->error(h,pos, "ast2c_Loc::pos is null"); } return 0; }
	if (!file) { if(h->error) { h->error(h,file, "ast2c_Loc::file is null"); } return 0; }
	if (!line) { if(h->error) { h->error(h,line, "ast2c_Loc::line is null"); } return 0; }
	if (!col) { if(h->error) { h->error(h,col, "ast2c_Loc::col is null"); } return 0; }
	if(!ast2c_Pos_parse(&s->pos,h,pos)) {
		if(h->error) { h->error(h,pos, "failed to parse ast2c_Loc::pos"); }
		goto error;
	}
	if(!h->number_get(h,file,&s->file)) {
		if(h->error) { h->error(h,file, "failed to parse ast2c_Loc::file"); }
		goto error;
	}
	if(!h->number_get(h,line,&s->line)) {
		if(h->error) { h->error(h,line, "failed to parse ast2c_Loc::line"); }
		goto error;
	}
	if(!h->number_get(h,col,&s->col)) {
		if(h->error) { h->error(h,col, "failed to parse ast2c_Loc::col"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

#ifdef __cplusplus
}
#endif

