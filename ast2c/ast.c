// Code generated by gen_ast2c.go. DO NOT EDIT.

#include "ast.h"
#include<string.h>

#ifdef __cplusplus
extern "C" {
#else
#include<stdalign.h>
#endif

const char* ast2c_NodeType_to_string(ast2c_NodeType val) {
	switch(val) {
	case AST2C_NODETYPE_PROGRAM: return "program";
	case AST2C_NODETYPE_COMMENT: return "comment";
	case AST2C_NODETYPE_COMMENT_GROUP: return "comment_group";
	case AST2C_NODETYPE_FIELD_ARGUMENT: return "field_argument";
	case AST2C_NODETYPE_EXPR: return "expr";
	case AST2C_NODETYPE_BINARY: return "binary";
	case AST2C_NODETYPE_UNARY: return "unary";
	case AST2C_NODETYPE_COND: return "cond";
	case AST2C_NODETYPE_IDENT: return "ident";
	case AST2C_NODETYPE_CALL: return "call";
	case AST2C_NODETYPE_IF: return "if";
	case AST2C_NODETYPE_MEMBER_ACCESS: return "member_access";
	case AST2C_NODETYPE_PAREN: return "paren";
	case AST2C_NODETYPE_INDEX: return "index";
	case AST2C_NODETYPE_MATCH: return "match";
	case AST2C_NODETYPE_RANGE: return "range";
	case AST2C_NODETYPE_TMP_VAR: return "tmp_var";
	case AST2C_NODETYPE_IMPORT: return "import";
	case AST2C_NODETYPE_CAST: return "cast";
	case AST2C_NODETYPE_AVAILABLE: return "available";
	case AST2C_NODETYPE_SPECIFY_ORDER: return "specify_order";
	case AST2C_NODETYPE_EXPLICIT_ERROR: return "explicit_error";
	case AST2C_NODETYPE_IO_OPERATION: return "io_operation";
	case AST2C_NODETYPE_BAD_EXPR: return "bad_expr";
	case AST2C_NODETYPE_STMT: return "stmt";
	case AST2C_NODETYPE_LOOP: return "loop";
	case AST2C_NODETYPE_INDENT_BLOCK: return "indent_block";
	case AST2C_NODETYPE_SCOPED_STATEMENT: return "scoped_statement";
	case AST2C_NODETYPE_MATCH_BRANCH: return "match_branch";
	case AST2C_NODETYPE_UNION_CANDIDATE: return "union_candidate";
	case AST2C_NODETYPE_RETURN: return "return";
	case AST2C_NODETYPE_BREAK: return "break";
	case AST2C_NODETYPE_CONTINUE: return "continue";
	case AST2C_NODETYPE_ASSERT: return "assert";
	case AST2C_NODETYPE_IMPLICIT_YIELD: return "implicit_yield";
	case AST2C_NODETYPE_METADATA: return "metadata";
	case AST2C_NODETYPE_TYPE: return "type";
	case AST2C_NODETYPE_INT_TYPE: return "int_type";
	case AST2C_NODETYPE_FLOAT_TYPE: return "float_type";
	case AST2C_NODETYPE_IDENT_TYPE: return "ident_type";
	case AST2C_NODETYPE_INT_LITERAL_TYPE: return "int_literal_type";
	case AST2C_NODETYPE_STR_LITERAL_TYPE: return "str_literal_type";
	case AST2C_NODETYPE_VOID_TYPE: return "void_type";
	case AST2C_NODETYPE_BOOL_TYPE: return "bool_type";
	case AST2C_NODETYPE_ARRAY_TYPE: return "array_type";
	case AST2C_NODETYPE_FUNCTION_TYPE: return "function_type";
	case AST2C_NODETYPE_STRUCT_TYPE: return "struct_type";
	case AST2C_NODETYPE_STRUCT_UNION_TYPE: return "struct_union_type";
	case AST2C_NODETYPE_UNION_TYPE: return "union_type";
	case AST2C_NODETYPE_RANGE_TYPE: return "range_type";
	case AST2C_NODETYPE_ENUM_TYPE: return "enum_type";
	case AST2C_NODETYPE_META_TYPE: return "meta_type";
	case AST2C_NODETYPE_OPTIONAL_TYPE: return "optional_type";
	case AST2C_NODETYPE_GENERIC_TYPE: return "generic_type";
	case AST2C_NODETYPE_LITERAL: return "literal";
	case AST2C_NODETYPE_INT_LITERAL: return "int_literal";
	case AST2C_NODETYPE_BOOL_LITERAL: return "bool_literal";
	case AST2C_NODETYPE_STR_LITERAL: return "str_literal";
	case AST2C_NODETYPE_CHAR_LITERAL: return "char_literal";
	case AST2C_NODETYPE_TYPE_LITERAL: return "type_literal";
	case AST2C_NODETYPE_SPECIAL_LITERAL: return "special_literal";
	case AST2C_NODETYPE_MEMBER: return "member";
	case AST2C_NODETYPE_FIELD: return "field";
	case AST2C_NODETYPE_FORMAT: return "format";
	case AST2C_NODETYPE_STATE: return "state";
	case AST2C_NODETYPE_ENUM: return "enum";
	case AST2C_NODETYPE_ENUM_MEMBER: return "enum_member";
	case AST2C_NODETYPE_FUNCTION: return "function";
	case AST2C_NODETYPE_BUILTIN_MEMBER: return "builtin_member";
	case AST2C_NODETYPE_BUILTIN_FUNCTION: return "builtin_function";
	case AST2C_NODETYPE_BUILTIN_FIELD: return "builtin_field";
	case AST2C_NODETYPE_BUILTIN_OBJECT: return "builtin_object";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_NodeType_from_string(const char* str, ast2c_NodeType* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "program") == 0) {
		*out = AST2C_NODETYPE_PROGRAM;
		return 1;
	}
	if (strcmp(str, "comment") == 0) {
		*out = AST2C_NODETYPE_COMMENT;
		return 1;
	}
	if (strcmp(str, "comment_group") == 0) {
		*out = AST2C_NODETYPE_COMMENT_GROUP;
		return 1;
	}
	if (strcmp(str, "field_argument") == 0) {
		*out = AST2C_NODETYPE_FIELD_ARGUMENT;
		return 1;
	}
	if (strcmp(str, "expr") == 0) {
		*out = AST2C_NODETYPE_EXPR;
		return 1;
	}
	if (strcmp(str, "binary") == 0) {
		*out = AST2C_NODETYPE_BINARY;
		return 1;
	}
	if (strcmp(str, "unary") == 0) {
		*out = AST2C_NODETYPE_UNARY;
		return 1;
	}
	if (strcmp(str, "cond") == 0) {
		*out = AST2C_NODETYPE_COND;
		return 1;
	}
	if (strcmp(str, "ident") == 0) {
		*out = AST2C_NODETYPE_IDENT;
		return 1;
	}
	if (strcmp(str, "call") == 0) {
		*out = AST2C_NODETYPE_CALL;
		return 1;
	}
	if (strcmp(str, "if") == 0) {
		*out = AST2C_NODETYPE_IF;
		return 1;
	}
	if (strcmp(str, "member_access") == 0) {
		*out = AST2C_NODETYPE_MEMBER_ACCESS;
		return 1;
	}
	if (strcmp(str, "paren") == 0) {
		*out = AST2C_NODETYPE_PAREN;
		return 1;
	}
	if (strcmp(str, "index") == 0) {
		*out = AST2C_NODETYPE_INDEX;
		return 1;
	}
	if (strcmp(str, "match") == 0) {
		*out = AST2C_NODETYPE_MATCH;
		return 1;
	}
	if (strcmp(str, "range") == 0) {
		*out = AST2C_NODETYPE_RANGE;
		return 1;
	}
	if (strcmp(str, "tmp_var") == 0) {
		*out = AST2C_NODETYPE_TMP_VAR;
		return 1;
	}
	if (strcmp(str, "import") == 0) {
		*out = AST2C_NODETYPE_IMPORT;
		return 1;
	}
	if (strcmp(str, "cast") == 0) {
		*out = AST2C_NODETYPE_CAST;
		return 1;
	}
	if (strcmp(str, "available") == 0) {
		*out = AST2C_NODETYPE_AVAILABLE;
		return 1;
	}
	if (strcmp(str, "specify_order") == 0) {
		*out = AST2C_NODETYPE_SPECIFY_ORDER;
		return 1;
	}
	if (strcmp(str, "explicit_error") == 0) {
		*out = AST2C_NODETYPE_EXPLICIT_ERROR;
		return 1;
	}
	if (strcmp(str, "io_operation") == 0) {
		*out = AST2C_NODETYPE_IO_OPERATION;
		return 1;
	}
	if (strcmp(str, "bad_expr") == 0) {
		*out = AST2C_NODETYPE_BAD_EXPR;
		return 1;
	}
	if (strcmp(str, "stmt") == 0) {
		*out = AST2C_NODETYPE_STMT;
		return 1;
	}
	if (strcmp(str, "loop") == 0) {
		*out = AST2C_NODETYPE_LOOP;
		return 1;
	}
	if (strcmp(str, "indent_block") == 0) {
		*out = AST2C_NODETYPE_INDENT_BLOCK;
		return 1;
	}
	if (strcmp(str, "scoped_statement") == 0) {
		*out = AST2C_NODETYPE_SCOPED_STATEMENT;
		return 1;
	}
	if (strcmp(str, "match_branch") == 0) {
		*out = AST2C_NODETYPE_MATCH_BRANCH;
		return 1;
	}
	if (strcmp(str, "union_candidate") == 0) {
		*out = AST2C_NODETYPE_UNION_CANDIDATE;
		return 1;
	}
	if (strcmp(str, "return") == 0) {
		*out = AST2C_NODETYPE_RETURN;
		return 1;
	}
	if (strcmp(str, "break") == 0) {
		*out = AST2C_NODETYPE_BREAK;
		return 1;
	}
	if (strcmp(str, "continue") == 0) {
		*out = AST2C_NODETYPE_CONTINUE;
		return 1;
	}
	if (strcmp(str, "assert") == 0) {
		*out = AST2C_NODETYPE_ASSERT;
		return 1;
	}
	if (strcmp(str, "implicit_yield") == 0) {
		*out = AST2C_NODETYPE_IMPLICIT_YIELD;
		return 1;
	}
	if (strcmp(str, "metadata") == 0) {
		*out = AST2C_NODETYPE_METADATA;
		return 1;
	}
	if (strcmp(str, "type") == 0) {
		*out = AST2C_NODETYPE_TYPE;
		return 1;
	}
	if (strcmp(str, "int_type") == 0) {
		*out = AST2C_NODETYPE_INT_TYPE;
		return 1;
	}
	if (strcmp(str, "float_type") == 0) {
		*out = AST2C_NODETYPE_FLOAT_TYPE;
		return 1;
	}
	if (strcmp(str, "ident_type") == 0) {
		*out = AST2C_NODETYPE_IDENT_TYPE;
		return 1;
	}
	if (strcmp(str, "int_literal_type") == 0) {
		*out = AST2C_NODETYPE_INT_LITERAL_TYPE;
		return 1;
	}
	if (strcmp(str, "str_literal_type") == 0) {
		*out = AST2C_NODETYPE_STR_LITERAL_TYPE;
		return 1;
	}
	if (strcmp(str, "void_type") == 0) {
		*out = AST2C_NODETYPE_VOID_TYPE;
		return 1;
	}
	if (strcmp(str, "bool_type") == 0) {
		*out = AST2C_NODETYPE_BOOL_TYPE;
		return 1;
	}
	if (strcmp(str, "array_type") == 0) {
		*out = AST2C_NODETYPE_ARRAY_TYPE;
		return 1;
	}
	if (strcmp(str, "function_type") == 0) {
		*out = AST2C_NODETYPE_FUNCTION_TYPE;
		return 1;
	}
	if (strcmp(str, "struct_type") == 0) {
		*out = AST2C_NODETYPE_STRUCT_TYPE;
		return 1;
	}
	if (strcmp(str, "struct_union_type") == 0) {
		*out = AST2C_NODETYPE_STRUCT_UNION_TYPE;
		return 1;
	}
	if (strcmp(str, "union_type") == 0) {
		*out = AST2C_NODETYPE_UNION_TYPE;
		return 1;
	}
	if (strcmp(str, "range_type") == 0) {
		*out = AST2C_NODETYPE_RANGE_TYPE;
		return 1;
	}
	if (strcmp(str, "enum_type") == 0) {
		*out = AST2C_NODETYPE_ENUM_TYPE;
		return 1;
	}
	if (strcmp(str, "meta_type") == 0) {
		*out = AST2C_NODETYPE_META_TYPE;
		return 1;
	}
	if (strcmp(str, "optional_type") == 0) {
		*out = AST2C_NODETYPE_OPTIONAL_TYPE;
		return 1;
	}
	if (strcmp(str, "generic_type") == 0) {
		*out = AST2C_NODETYPE_GENERIC_TYPE;
		return 1;
	}
	if (strcmp(str, "literal") == 0) {
		*out = AST2C_NODETYPE_LITERAL;
		return 1;
	}
	if (strcmp(str, "int_literal") == 0) {
		*out = AST2C_NODETYPE_INT_LITERAL;
		return 1;
	}
	if (strcmp(str, "bool_literal") == 0) {
		*out = AST2C_NODETYPE_BOOL_LITERAL;
		return 1;
	}
	if (strcmp(str, "str_literal") == 0) {
		*out = AST2C_NODETYPE_STR_LITERAL;
		return 1;
	}
	if (strcmp(str, "char_literal") == 0) {
		*out = AST2C_NODETYPE_CHAR_LITERAL;
		return 1;
	}
	if (strcmp(str, "type_literal") == 0) {
		*out = AST2C_NODETYPE_TYPE_LITERAL;
		return 1;
	}
	if (strcmp(str, "special_literal") == 0) {
		*out = AST2C_NODETYPE_SPECIAL_LITERAL;
		return 1;
	}
	if (strcmp(str, "member") == 0) {
		*out = AST2C_NODETYPE_MEMBER;
		return 1;
	}
	if (strcmp(str, "field") == 0) {
		*out = AST2C_NODETYPE_FIELD;
		return 1;
	}
	if (strcmp(str, "format") == 0) {
		*out = AST2C_NODETYPE_FORMAT;
		return 1;
	}
	if (strcmp(str, "state") == 0) {
		*out = AST2C_NODETYPE_STATE;
		return 1;
	}
	if (strcmp(str, "enum") == 0) {
		*out = AST2C_NODETYPE_ENUM;
		return 1;
	}
	if (strcmp(str, "enum_member") == 0) {
		*out = AST2C_NODETYPE_ENUM_MEMBER;
		return 1;
	}
	if (strcmp(str, "function") == 0) {
		*out = AST2C_NODETYPE_FUNCTION;
		return 1;
	}
	if (strcmp(str, "builtin_member") == 0) {
		*out = AST2C_NODETYPE_BUILTIN_MEMBER;
		return 1;
	}
	if (strcmp(str, "builtin_function") == 0) {
		*out = AST2C_NODETYPE_BUILTIN_FUNCTION;
		return 1;
	}
	if (strcmp(str, "builtin_field") == 0) {
		*out = AST2C_NODETYPE_BUILTIN_FIELD;
		return 1;
	}
	if (strcmp(str, "builtin_object") == 0) {
		*out = AST2C_NODETYPE_BUILTIN_OBJECT;
		return 1;
	}
	return 0;
}

const char* ast2c_TokenTag_to_string(ast2c_TokenTag val) {
	switch(val) {
	case AST2C_TOKENTAG_INDENT: return "indent";
	case AST2C_TOKENTAG_SPACE: return "space";
	case AST2C_TOKENTAG_LINE: return "line";
	case AST2C_TOKENTAG_PUNCT: return "punct";
	case AST2C_TOKENTAG_INT_LITERAL: return "int_literal";
	case AST2C_TOKENTAG_BOOL_LITERAL: return "bool_literal";
	case AST2C_TOKENTAG_STR_LITERAL: return "str_literal";
	case AST2C_TOKENTAG_CHAR_LITERAL: return "char_literal";
	case AST2C_TOKENTAG_KEYWORD: return "keyword";
	case AST2C_TOKENTAG_IDENT: return "ident";
	case AST2C_TOKENTAG_COMMENT: return "comment";
	case AST2C_TOKENTAG_ERROR: return "error";
	case AST2C_TOKENTAG_UNKNOWN: return "unknown";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_TokenTag_from_string(const char* str, ast2c_TokenTag* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "indent") == 0) {
		*out = AST2C_TOKENTAG_INDENT;
		return 1;
	}
	if (strcmp(str, "space") == 0) {
		*out = AST2C_TOKENTAG_SPACE;
		return 1;
	}
	if (strcmp(str, "line") == 0) {
		*out = AST2C_TOKENTAG_LINE;
		return 1;
	}
	if (strcmp(str, "punct") == 0) {
		*out = AST2C_TOKENTAG_PUNCT;
		return 1;
	}
	if (strcmp(str, "int_literal") == 0) {
		*out = AST2C_TOKENTAG_INT_LITERAL;
		return 1;
	}
	if (strcmp(str, "bool_literal") == 0) {
		*out = AST2C_TOKENTAG_BOOL_LITERAL;
		return 1;
	}
	if (strcmp(str, "str_literal") == 0) {
		*out = AST2C_TOKENTAG_STR_LITERAL;
		return 1;
	}
	if (strcmp(str, "char_literal") == 0) {
		*out = AST2C_TOKENTAG_CHAR_LITERAL;
		return 1;
	}
	if (strcmp(str, "keyword") == 0) {
		*out = AST2C_TOKENTAG_KEYWORD;
		return 1;
	}
	if (strcmp(str, "ident") == 0) {
		*out = AST2C_TOKENTAG_IDENT;
		return 1;
	}
	if (strcmp(str, "comment") == 0) {
		*out = AST2C_TOKENTAG_COMMENT;
		return 1;
	}
	if (strcmp(str, "error") == 0) {
		*out = AST2C_TOKENTAG_ERROR;
		return 1;
	}
	if (strcmp(str, "unknown") == 0) {
		*out = AST2C_TOKENTAG_UNKNOWN;
		return 1;
	}
	return 0;
}

const char* ast2c_UnaryOp_to_string(ast2c_UnaryOp val) {
	switch(val) {
	case AST2C_UNARYOP_NOT: return "!";
	case AST2C_UNARYOP_MINUS_SIGN: return "-";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_UnaryOp_from_string(const char* str, ast2c_UnaryOp* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "!") == 0) {
		*out = AST2C_UNARYOP_NOT;
		return 1;
	}
	if (strcmp(str, "-") == 0) {
		*out = AST2C_UNARYOP_MINUS_SIGN;
		return 1;
	}
	return 0;
}

const char* ast2c_BinaryOp_to_string(ast2c_BinaryOp val) {
	switch(val) {
	case AST2C_BINARYOP_MUL: return "*";
	case AST2C_BINARYOP_DIV: return "/";
	case AST2C_BINARYOP_MOD: return "%";
	case AST2C_BINARYOP_LEFT_ARITHMETIC_SHIFT: return "<<<";
	case AST2C_BINARYOP_RIGHT_ARITHMETIC_SHIFT: return ">>>";
	case AST2C_BINARYOP_LEFT_LOGICAL_SHIFT: return "<<";
	case AST2C_BINARYOP_RIGHT_LOGICAL_SHIFT: return ">>";
	case AST2C_BINARYOP_BIT_AND: return "&";
	case AST2C_BINARYOP_ADD: return "+";
	case AST2C_BINARYOP_SUB: return "-";
	case AST2C_BINARYOP_BIT_OR: return "|";
	case AST2C_BINARYOP_BIT_XOR: return "^";
	case AST2C_BINARYOP_EQUAL: return "==";
	case AST2C_BINARYOP_NOT_EQUAL: return "!=";
	case AST2C_BINARYOP_LESS: return "<";
	case AST2C_BINARYOP_LESS_OR_EQ: return "<=";
	case AST2C_BINARYOP_GRATER: return ">";
	case AST2C_BINARYOP_GRATER_OR_EQ: return ">=";
	case AST2C_BINARYOP_LOGICAL_AND: return "&&";
	case AST2C_BINARYOP_LOGICAL_OR: return "||";
	case AST2C_BINARYOP_COND_OP_1: return "?";
	case AST2C_BINARYOP_COND_OP_2: return ":";
	case AST2C_BINARYOP_RANGE_EXCLUSIVE: return "..";
	case AST2C_BINARYOP_RANGE_INCLUSIVE: return "..=";
	case AST2C_BINARYOP_ASSIGN: return "=";
	case AST2C_BINARYOP_DEFINE_ASSIGN: return ":=";
	case AST2C_BINARYOP_CONST_ASSIGN: return "::=";
	case AST2C_BINARYOP_ADD_ASSIGN: return "+=";
	case AST2C_BINARYOP_SUB_ASSIGN: return "-=";
	case AST2C_BINARYOP_MUL_ASSIGN: return "*=";
	case AST2C_BINARYOP_DIV_ASSIGN: return "/=";
	case AST2C_BINARYOP_MOD_ASSIGN: return "%=";
	case AST2C_BINARYOP_LEFT_SHIFT_ASSIGN: return "<<=";
	case AST2C_BINARYOP_RIGHT_SHIFT_ASSIGN: return ">>=";
	case AST2C_BINARYOP_BIT_AND_ASSIGN: return "&=";
	case AST2C_BINARYOP_BIT_OR_ASSIGN: return "|=";
	case AST2C_BINARYOP_BIT_XOR_ASSIGN: return "^=";
	case AST2C_BINARYOP_COMMA: return ",";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_BinaryOp_from_string(const char* str, ast2c_BinaryOp* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "*") == 0) {
		*out = AST2C_BINARYOP_MUL;
		return 1;
	}
	if (strcmp(str, "/") == 0) {
		*out = AST2C_BINARYOP_DIV;
		return 1;
	}
	if (strcmp(str, "%") == 0) {
		*out = AST2C_BINARYOP_MOD;
		return 1;
	}
	if (strcmp(str, "<<<") == 0) {
		*out = AST2C_BINARYOP_LEFT_ARITHMETIC_SHIFT;
		return 1;
	}
	if (strcmp(str, ">>>") == 0) {
		*out = AST2C_BINARYOP_RIGHT_ARITHMETIC_SHIFT;
		return 1;
	}
	if (strcmp(str, "<<") == 0) {
		*out = AST2C_BINARYOP_LEFT_LOGICAL_SHIFT;
		return 1;
	}
	if (strcmp(str, ">>") == 0) {
		*out = AST2C_BINARYOP_RIGHT_LOGICAL_SHIFT;
		return 1;
	}
	if (strcmp(str, "&") == 0) {
		*out = AST2C_BINARYOP_BIT_AND;
		return 1;
	}
	if (strcmp(str, "+") == 0) {
		*out = AST2C_BINARYOP_ADD;
		return 1;
	}
	if (strcmp(str, "-") == 0) {
		*out = AST2C_BINARYOP_SUB;
		return 1;
	}
	if (strcmp(str, "|") == 0) {
		*out = AST2C_BINARYOP_BIT_OR;
		return 1;
	}
	if (strcmp(str, "^") == 0) {
		*out = AST2C_BINARYOP_BIT_XOR;
		return 1;
	}
	if (strcmp(str, "==") == 0) {
		*out = AST2C_BINARYOP_EQUAL;
		return 1;
	}
	if (strcmp(str, "!=") == 0) {
		*out = AST2C_BINARYOP_NOT_EQUAL;
		return 1;
	}
	if (strcmp(str, "<") == 0) {
		*out = AST2C_BINARYOP_LESS;
		return 1;
	}
	if (strcmp(str, "<=") == 0) {
		*out = AST2C_BINARYOP_LESS_OR_EQ;
		return 1;
	}
	if (strcmp(str, ">") == 0) {
		*out = AST2C_BINARYOP_GRATER;
		return 1;
	}
	if (strcmp(str, ">=") == 0) {
		*out = AST2C_BINARYOP_GRATER_OR_EQ;
		return 1;
	}
	if (strcmp(str, "&&") == 0) {
		*out = AST2C_BINARYOP_LOGICAL_AND;
		return 1;
	}
	if (strcmp(str, "||") == 0) {
		*out = AST2C_BINARYOP_LOGICAL_OR;
		return 1;
	}
	if (strcmp(str, "?") == 0) {
		*out = AST2C_BINARYOP_COND_OP_1;
		return 1;
	}
	if (strcmp(str, ":") == 0) {
		*out = AST2C_BINARYOP_COND_OP_2;
		return 1;
	}
	if (strcmp(str, "..") == 0) {
		*out = AST2C_BINARYOP_RANGE_EXCLUSIVE;
		return 1;
	}
	if (strcmp(str, "..=") == 0) {
		*out = AST2C_BINARYOP_RANGE_INCLUSIVE;
		return 1;
	}
	if (strcmp(str, "=") == 0) {
		*out = AST2C_BINARYOP_ASSIGN;
		return 1;
	}
	if (strcmp(str, ":=") == 0) {
		*out = AST2C_BINARYOP_DEFINE_ASSIGN;
		return 1;
	}
	if (strcmp(str, "::=") == 0) {
		*out = AST2C_BINARYOP_CONST_ASSIGN;
		return 1;
	}
	if (strcmp(str, "+=") == 0) {
		*out = AST2C_BINARYOP_ADD_ASSIGN;
		return 1;
	}
	if (strcmp(str, "-=") == 0) {
		*out = AST2C_BINARYOP_SUB_ASSIGN;
		return 1;
	}
	if (strcmp(str, "*=") == 0) {
		*out = AST2C_BINARYOP_MUL_ASSIGN;
		return 1;
	}
	if (strcmp(str, "/=") == 0) {
		*out = AST2C_BINARYOP_DIV_ASSIGN;
		return 1;
	}
	if (strcmp(str, "%=") == 0) {
		*out = AST2C_BINARYOP_MOD_ASSIGN;
		return 1;
	}
	if (strcmp(str, "<<=") == 0) {
		*out = AST2C_BINARYOP_LEFT_SHIFT_ASSIGN;
		return 1;
	}
	if (strcmp(str, ">>=") == 0) {
		*out = AST2C_BINARYOP_RIGHT_SHIFT_ASSIGN;
		return 1;
	}
	if (strcmp(str, "&=") == 0) {
		*out = AST2C_BINARYOP_BIT_AND_ASSIGN;
		return 1;
	}
	if (strcmp(str, "|=") == 0) {
		*out = AST2C_BINARYOP_BIT_OR_ASSIGN;
		return 1;
	}
	if (strcmp(str, "^=") == 0) {
		*out = AST2C_BINARYOP_BIT_XOR_ASSIGN;
		return 1;
	}
	if (strcmp(str, ",") == 0) {
		*out = AST2C_BINARYOP_COMMA;
		return 1;
	}
	return 0;
}

const char* ast2c_IdentUsage_to_string(ast2c_IdentUsage val) {
	switch(val) {
	case AST2C_IDENTUSAGE_UNKNOWN: return "unknown";
	case AST2C_IDENTUSAGE_REFERENCE: return "reference";
	case AST2C_IDENTUSAGE_DEFINE_VARIABLE: return "define_variable";
	case AST2C_IDENTUSAGE_DEFINE_CONST: return "define_const";
	case AST2C_IDENTUSAGE_DEFINE_FIELD: return "define_field";
	case AST2C_IDENTUSAGE_DEFINE_FORMAT: return "define_format";
	case AST2C_IDENTUSAGE_DEFINE_STATE: return "define_state";
	case AST2C_IDENTUSAGE_DEFINE_ENUM: return "define_enum";
	case AST2C_IDENTUSAGE_DEFINE_ENUM_MEMBER: return "define_enum_member";
	case AST2C_IDENTUSAGE_DEFINE_FN: return "define_fn";
	case AST2C_IDENTUSAGE_DEFINE_CAST_FN: return "define_cast_fn";
	case AST2C_IDENTUSAGE_DEFINE_ARG: return "define_arg";
	case AST2C_IDENTUSAGE_REFERENCE_TYPE: return "reference_type";
	case AST2C_IDENTUSAGE_REFERENCE_MEMBER: return "reference_member";
	case AST2C_IDENTUSAGE_REFERENCE_MEMBER_TYPE: return "reference_member_type";
	case AST2C_IDENTUSAGE_MAYBE_TYPE: return "maybe_type";
	case AST2C_IDENTUSAGE_REFERENCE_BUILTIN_FN: return "reference_builtin_fn";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_IdentUsage_from_string(const char* str, ast2c_IdentUsage* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "unknown") == 0) {
		*out = AST2C_IDENTUSAGE_UNKNOWN;
		return 1;
	}
	if (strcmp(str, "reference") == 0) {
		*out = AST2C_IDENTUSAGE_REFERENCE;
		return 1;
	}
	if (strcmp(str, "define_variable") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_VARIABLE;
		return 1;
	}
	if (strcmp(str, "define_const") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_CONST;
		return 1;
	}
	if (strcmp(str, "define_field") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_FIELD;
		return 1;
	}
	if (strcmp(str, "define_format") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_FORMAT;
		return 1;
	}
	if (strcmp(str, "define_state") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_STATE;
		return 1;
	}
	if (strcmp(str, "define_enum") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_ENUM;
		return 1;
	}
	if (strcmp(str, "define_enum_member") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_ENUM_MEMBER;
		return 1;
	}
	if (strcmp(str, "define_fn") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_FN;
		return 1;
	}
	if (strcmp(str, "define_cast_fn") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_CAST_FN;
		return 1;
	}
	if (strcmp(str, "define_arg") == 0) {
		*out = AST2C_IDENTUSAGE_DEFINE_ARG;
		return 1;
	}
	if (strcmp(str, "reference_type") == 0) {
		*out = AST2C_IDENTUSAGE_REFERENCE_TYPE;
		return 1;
	}
	if (strcmp(str, "reference_member") == 0) {
		*out = AST2C_IDENTUSAGE_REFERENCE_MEMBER;
		return 1;
	}
	if (strcmp(str, "reference_member_type") == 0) {
		*out = AST2C_IDENTUSAGE_REFERENCE_MEMBER_TYPE;
		return 1;
	}
	if (strcmp(str, "maybe_type") == 0) {
		*out = AST2C_IDENTUSAGE_MAYBE_TYPE;
		return 1;
	}
	if (strcmp(str, "reference_builtin_fn") == 0) {
		*out = AST2C_IDENTUSAGE_REFERENCE_BUILTIN_FN;
		return 1;
	}
	return 0;
}

const char* ast2c_Endian_to_string(ast2c_Endian val) {
	switch(val) {
	case AST2C_ENDIAN_UNSPEC: return "unspec";
	case AST2C_ENDIAN_BIG: return "big";
	case AST2C_ENDIAN_LITTLE: return "little";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_Endian_from_string(const char* str, ast2c_Endian* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "unspec") == 0) {
		*out = AST2C_ENDIAN_UNSPEC;
		return 1;
	}
	if (strcmp(str, "big") == 0) {
		*out = AST2C_ENDIAN_BIG;
		return 1;
	}
	if (strcmp(str, "little") == 0) {
		*out = AST2C_ENDIAN_LITTLE;
		return 1;
	}
	return 0;
}

const char* ast2c_ConstantLevel_to_string(ast2c_ConstantLevel val) {
	switch(val) {
	case AST2C_CONSTANTLEVEL_UNKNOWN: return "unknown";
	case AST2C_CONSTANTLEVEL_CONSTANT: return "constant";
	case AST2C_CONSTANTLEVEL_IMMUTABLE_VARIABLE: return "immutable_variable";
	case AST2C_CONSTANTLEVEL_VARIABLE: return "variable";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_ConstantLevel_from_string(const char* str, ast2c_ConstantLevel* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "unknown") == 0) {
		*out = AST2C_CONSTANTLEVEL_UNKNOWN;
		return 1;
	}
	if (strcmp(str, "constant") == 0) {
		*out = AST2C_CONSTANTLEVEL_CONSTANT;
		return 1;
	}
	if (strcmp(str, "immutable_variable") == 0) {
		*out = AST2C_CONSTANTLEVEL_IMMUTABLE_VARIABLE;
		return 1;
	}
	if (strcmp(str, "variable") == 0) {
		*out = AST2C_CONSTANTLEVEL_VARIABLE;
		return 1;
	}
	return 0;
}

const char* ast2c_BitAlignment_to_string(ast2c_BitAlignment val) {
	switch(val) {
	case AST2C_BITALIGNMENT_BYTE_ALIGNED: return "byte_aligned";
	case AST2C_BITALIGNMENT_BIT_1: return "bit_1";
	case AST2C_BITALIGNMENT_BIT_2: return "bit_2";
	case AST2C_BITALIGNMENT_BIT_3: return "bit_3";
	case AST2C_BITALIGNMENT_BIT_4: return "bit_4";
	case AST2C_BITALIGNMENT_BIT_5: return "bit_5";
	case AST2C_BITALIGNMENT_BIT_6: return "bit_6";
	case AST2C_BITALIGNMENT_BIT_7: return "bit_7";
	case AST2C_BITALIGNMENT_NOT_TARGET: return "not_target";
	case AST2C_BITALIGNMENT_NOT_DECIDABLE: return "not_decidable";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_BitAlignment_from_string(const char* str, ast2c_BitAlignment* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "byte_aligned") == 0) {
		*out = AST2C_BITALIGNMENT_BYTE_ALIGNED;
		return 1;
	}
	if (strcmp(str, "bit_1") == 0) {
		*out = AST2C_BITALIGNMENT_BIT_1;
		return 1;
	}
	if (strcmp(str, "bit_2") == 0) {
		*out = AST2C_BITALIGNMENT_BIT_2;
		return 1;
	}
	if (strcmp(str, "bit_3") == 0) {
		*out = AST2C_BITALIGNMENT_BIT_3;
		return 1;
	}
	if (strcmp(str, "bit_4") == 0) {
		*out = AST2C_BITALIGNMENT_BIT_4;
		return 1;
	}
	if (strcmp(str, "bit_5") == 0) {
		*out = AST2C_BITALIGNMENT_BIT_5;
		return 1;
	}
	if (strcmp(str, "bit_6") == 0) {
		*out = AST2C_BITALIGNMENT_BIT_6;
		return 1;
	}
	if (strcmp(str, "bit_7") == 0) {
		*out = AST2C_BITALIGNMENT_BIT_7;
		return 1;
	}
	if (strcmp(str, "not_target") == 0) {
		*out = AST2C_BITALIGNMENT_NOT_TARGET;
		return 1;
	}
	if (strcmp(str, "not_decidable") == 0) {
		*out = AST2C_BITALIGNMENT_NOT_DECIDABLE;
		return 1;
	}
	return 0;
}

const char* ast2c_Follow_to_string(ast2c_Follow val) {
	switch(val) {
	case AST2C_FOLLOW_UNKNOWN: return "unknown";
	case AST2C_FOLLOW_END: return "end";
	case AST2C_FOLLOW_FIXED: return "fixed";
	case AST2C_FOLLOW_CONSTANT: return "constant";
	case AST2C_FOLLOW_NORMAL: return "normal";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_Follow_from_string(const char* str, ast2c_Follow* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "unknown") == 0) {
		*out = AST2C_FOLLOW_UNKNOWN;
		return 1;
	}
	if (strcmp(str, "end") == 0) {
		*out = AST2C_FOLLOW_END;
		return 1;
	}
	if (strcmp(str, "fixed") == 0) {
		*out = AST2C_FOLLOW_FIXED;
		return 1;
	}
	if (strcmp(str, "constant") == 0) {
		*out = AST2C_FOLLOW_CONSTANT;
		return 1;
	}
	if (strcmp(str, "normal") == 0) {
		*out = AST2C_FOLLOW_NORMAL;
		return 1;
	}
	return 0;
}

const char* ast2c_IoMethod_to_string(ast2c_IoMethod val) {
	switch(val) {
	case AST2C_IOMETHOD_UNSPEC: return "unspec";
	case AST2C_IOMETHOD_OUTPUT_PUT: return "output_put";
	case AST2C_IOMETHOD_INPUT_PEEK: return "input_peek";
	case AST2C_IOMETHOD_INPUT_GET: return "input_get";
	case AST2C_IOMETHOD_INPUT_BACKWARD: return "input_backward";
	case AST2C_IOMETHOD_INPUT_OFFSET: return "input_offset";
	case AST2C_IOMETHOD_INPUT_REMAIN: return "input_remain";
	case AST2C_IOMETHOD_INPUT_SUBRANGE: return "input_subrange";
	case AST2C_IOMETHOD_CONFIG_ENDIAN_LITTLE: return "config_endian_little";
	case AST2C_IOMETHOD_CONFIG_ENDIAN_BIG: return "config_endian_big";
	case AST2C_IOMETHOD_CONFIG_ENDIAN_NATIVE: return "config_endian_native";
	case AST2C_IOMETHOD_CONFIG_BIT_ORDER_LSB: return "config_bit_order_lsb";
	case AST2C_IOMETHOD_CONFIG_BIT_ORDER_MSB: return "config_bit_order_msb";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_IoMethod_from_string(const char* str, ast2c_IoMethod* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "unspec") == 0) {
		*out = AST2C_IOMETHOD_UNSPEC;
		return 1;
	}
	if (strcmp(str, "output_put") == 0) {
		*out = AST2C_IOMETHOD_OUTPUT_PUT;
		return 1;
	}
	if (strcmp(str, "input_peek") == 0) {
		*out = AST2C_IOMETHOD_INPUT_PEEK;
		return 1;
	}
	if (strcmp(str, "input_get") == 0) {
		*out = AST2C_IOMETHOD_INPUT_GET;
		return 1;
	}
	if (strcmp(str, "input_backward") == 0) {
		*out = AST2C_IOMETHOD_INPUT_BACKWARD;
		return 1;
	}
	if (strcmp(str, "input_offset") == 0) {
		*out = AST2C_IOMETHOD_INPUT_OFFSET;
		return 1;
	}
	if (strcmp(str, "input_remain") == 0) {
		*out = AST2C_IOMETHOD_INPUT_REMAIN;
		return 1;
	}
	if (strcmp(str, "input_subrange") == 0) {
		*out = AST2C_IOMETHOD_INPUT_SUBRANGE;
		return 1;
	}
	if (strcmp(str, "config_endian_little") == 0) {
		*out = AST2C_IOMETHOD_CONFIG_ENDIAN_LITTLE;
		return 1;
	}
	if (strcmp(str, "config_endian_big") == 0) {
		*out = AST2C_IOMETHOD_CONFIG_ENDIAN_BIG;
		return 1;
	}
	if (strcmp(str, "config_endian_native") == 0) {
		*out = AST2C_IOMETHOD_CONFIG_ENDIAN_NATIVE;
		return 1;
	}
	if (strcmp(str, "config_bit_order_lsb") == 0) {
		*out = AST2C_IOMETHOD_CONFIG_BIT_ORDER_LSB;
		return 1;
	}
	if (strcmp(str, "config_bit_order_msb") == 0) {
		*out = AST2C_IOMETHOD_CONFIG_BIT_ORDER_MSB;
		return 1;
	}
	return 0;
}

const char* ast2c_SpecialLiteralKind_to_string(ast2c_SpecialLiteralKind val) {
	switch(val) {
	case AST2C_SPECIALLITERALKIND_INPUT: return "input";
	case AST2C_SPECIALLITERALKIND_OUTPUT: return "output";
	case AST2C_SPECIALLITERALKIND_CONFIG: return "config";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_SpecialLiteralKind_from_string(const char* str, ast2c_SpecialLiteralKind* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "input") == 0) {
		*out = AST2C_SPECIALLITERALKIND_INPUT;
		return 1;
	}
	if (strcmp(str, "output") == 0) {
		*out = AST2C_SPECIALLITERALKIND_OUTPUT;
		return 1;
	}
	if (strcmp(str, "config") == 0) {
		*out = AST2C_SPECIALLITERALKIND_CONFIG;
		return 1;
	}
	return 0;
}

const char* ast2c_OrderType_to_string(ast2c_OrderType val) {
	switch(val) {
	case AST2C_ORDERTYPE_BYTE: return "byte";
	case AST2C_ORDERTYPE_BIT: return "bit";
	default: return NULL;
	}
}

// returns 1 if succeed 0 if failed
int ast2c_OrderType_from_string(const char* str, ast2c_OrderType* out) {
	if (!str||!out) return 0;
	if (strcmp(str, "byte") == 0) {
		*out = AST2C_ORDERTYPE_BYTE;
		return 1;
	}
	if (strcmp(str, "bit") == 0) {
		*out = AST2C_ORDERTYPE_BIT;
		return 1;
	}
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Program_parse(ast2c_Ast* ast,ast2c_Program* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->struct_type = NULL;
	s->elements = NULL;
	s->global_scope = NULL;
	void* struct_type = h->object_get(h, obj_body, "struct_type");
	void* elements = h->object_get(h, obj_body, "elements");
	void* global_scope = h->object_get(h, obj_body, "global_scope");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Program::loc is null"); } return 0; }
	if (!struct_type) { if(h->error) { h->error(h,struct_type, "ast2c_Program::struct_type is null"); } return 0; }
	if (!elements) { if(h->error) { h->error(h,elements, "ast2c_Program::elements is null"); } return 0; }
	if(!h->array_size(h, elements,&s->elements_size)) {
		if(h->error) { h->error(h,elements, "failed to get array size of ast2c_Program::elements"); }
		return NULL;
	}
	if (!global_scope) { if(h->error) { h->error(h,global_scope, "ast2c_Program::global_scope is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Program::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Comment_parse(ast2c_Ast* ast,ast2c_Comment* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->comment = NULL;
	void* comment = h->object_get(h, obj_body, "comment");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Comment::loc is null"); } return 0; }
	if (!comment) { if(h->error) { h->error(h,comment, "ast2c_Comment::comment is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Comment::loc"); }
		goto error;
	}
	s->comment = h->string_get_alloc(h,comment);
	if (!s->comment) {
		if(h->error) { h->error(h,comment, "failed to parse ast2c_Comment::comment"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_CommentGroup_parse(ast2c_Ast* ast,ast2c_CommentGroup* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->comments = NULL;
	void* comments = h->object_get(h, obj_body, "comments");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_CommentGroup::loc is null"); } return 0; }
	if (!comments) { if(h->error) { h->error(h,comments, "ast2c_CommentGroup::comments is null"); } return 0; }
	if(!h->array_size(h, comments,&s->comments_size)) {
		if(h->error) { h->error(h,comments, "failed to get array size of ast2c_CommentGroup::comments"); }
		return NULL;
	}
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_CommentGroup::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_FieldArgument_parse(ast2c_Ast* ast,ast2c_FieldArgument* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->raw_arguments = NULL;
	s->collected_arguments = NULL;
	s->arguments = NULL;
	s->alignment = NULL;
	s->alignment_value = NULL;
	s->sub_byte_length = NULL;
	s->sub_byte_begin = NULL;
	void* raw_arguments = h->object_get(h, obj_body, "raw_arguments");
	void* end_loc = h->object_get(h, obj_body, "end_loc");
	void* collected_arguments = h->object_get(h, obj_body, "collected_arguments");
	void* arguments = h->object_get(h, obj_body, "arguments");
	void* alignment = h->object_get(h, obj_body, "alignment");
	void* alignment_value = h->object_get(h, obj_body, "alignment_value");
	void* sub_byte_length = h->object_get(h, obj_body, "sub_byte_length");
	void* sub_byte_begin = h->object_get(h, obj_body, "sub_byte_begin");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_FieldArgument::loc is null"); } return 0; }
	if (!raw_arguments) { if(h->error) { h->error(h,raw_arguments, "ast2c_FieldArgument::raw_arguments is null"); } return 0; }
	if (!end_loc) { if(h->error) { h->error(h,end_loc, "ast2c_FieldArgument::end_loc is null"); } return 0; }
	if (!collected_arguments) { if(h->error) { h->error(h,collected_arguments, "ast2c_FieldArgument::collected_arguments is null"); } return 0; }
	if(!h->array_size(h, collected_arguments,&s->collected_arguments_size)) {
		if(h->error) { h->error(h,collected_arguments, "failed to get array size of ast2c_FieldArgument::collected_arguments"); }
		return NULL;
	}
	if (!arguments) { if(h->error) { h->error(h,arguments, "ast2c_FieldArgument::arguments is null"); } return 0; }
	if(!h->array_size(h, arguments,&s->arguments_size)) {
		if(h->error) { h->error(h,arguments, "failed to get array size of ast2c_FieldArgument::arguments"); }
		return NULL;
	}
	if (!alignment) { if(h->error) { h->error(h,alignment, "ast2c_FieldArgument::alignment is null"); } return 0; }
	if (!alignment_value) { if(h->error) { h->error(h,alignment_value, "ast2c_FieldArgument::alignment_value is null"); } return 0; }
	if (!sub_byte_length) { if(h->error) { h->error(h,sub_byte_length, "ast2c_FieldArgument::sub_byte_length is null"); } return 0; }
	if (!sub_byte_begin) { if(h->error) { h->error(h,sub_byte_begin, "ast2c_FieldArgument::sub_byte_begin is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_FieldArgument::loc"); }
		goto error;
	}
	if(!ast2c_Loc_parse(&s->end_loc,h,end_loc)) {
		if(h->error) { h->error(h,end_loc, "failed to parse ast2c_FieldArgument::end_loc"); }
		goto error;
	}
	if(!h->number_get(h,alignment_value,&s->alignment_value)) {
		if(h->error) { h->error(h,alignment_value, "failed to parse ast2c_FieldArgument::alignment_value"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Binary_parse(ast2c_Ast* ast,ast2c_Binary* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->left = NULL;
	s->right = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* op = h->object_get(h, obj_body, "op");
	void* left = h->object_get(h, obj_body, "left");
	void* right = h->object_get(h, obj_body, "right");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Binary::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Binary::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Binary::constant_level is null"); } return 0; }
	if (!op) { if(h->error) { h->error(h,op, "ast2c_Binary::op is null"); } return 0; }
	if (!left) { if(h->error) { h->error(h,left, "ast2c_Binary::left is null"); } return 0; }
	if (!right) { if(h->error) { h->error(h,right, "ast2c_Binary::right is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Binary::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Unary_parse(ast2c_Ast* ast,ast2c_Unary* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->expr = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* op = h->object_get(h, obj_body, "op");
	void* expr = h->object_get(h, obj_body, "expr");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Unary::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Unary::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Unary::constant_level is null"); } return 0; }
	if (!op) { if(h->error) { h->error(h,op, "ast2c_Unary::op is null"); } return 0; }
	if (!expr) { if(h->error) { h->error(h,expr, "ast2c_Unary::expr is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Unary::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Cond_parse(ast2c_Ast* ast,ast2c_Cond* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->cond = NULL;
	s->then = NULL;
	s->els = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* cond = h->object_get(h, obj_body, "cond");
	void* then = h->object_get(h, obj_body, "then");
	void* els_loc = h->object_get(h, obj_body, "els_loc");
	void* els = h->object_get(h, obj_body, "els");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Cond::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Cond::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Cond::constant_level is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "ast2c_Cond::cond is null"); } return 0; }
	if (!then) { if(h->error) { h->error(h,then, "ast2c_Cond::then is null"); } return 0; }
	if (!els_loc) { if(h->error) { h->error(h,els_loc, "ast2c_Cond::els_loc is null"); } return 0; }
	if (!els) { if(h->error) { h->error(h,els, "ast2c_Cond::els is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Cond::loc"); }
		goto error;
	}
	if(!ast2c_Loc_parse(&s->els_loc,h,els_loc)) {
		if(h->error) { h->error(h,els_loc, "failed to parse ast2c_Cond::els_loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Ident_parse(ast2c_Ast* ast,ast2c_Ident* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->ident = NULL;
	s->base = NULL;
	s->scope = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* ident = h->object_get(h, obj_body, "ident");
	void* usage = h->object_get(h, obj_body, "usage");
	void* base = h->object_get(h, obj_body, "base");
	void* scope = h->object_get(h, obj_body, "scope");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Ident::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Ident::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Ident::constant_level is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ast2c_Ident::ident is null"); } return 0; }
	if (!usage) { if(h->error) { h->error(h,usage, "ast2c_Ident::usage is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_Ident::base is null"); } return 0; }
	if (!scope) { if(h->error) { h->error(h,scope, "ast2c_Ident::scope is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Ident::loc"); }
		goto error;
	}
	s->ident = h->string_get_alloc(h,ident);
	if (!s->ident) {
		if(h->error) { h->error(h,ident, "failed to parse ast2c_Ident::ident"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Call_parse(ast2c_Ast* ast,ast2c_Call* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->callee = NULL;
	s->raw_arguments = NULL;
	s->arguments = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* callee = h->object_get(h, obj_body, "callee");
	void* raw_arguments = h->object_get(h, obj_body, "raw_arguments");
	void* arguments = h->object_get(h, obj_body, "arguments");
	void* end_loc = h->object_get(h, obj_body, "end_loc");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Call::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Call::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Call::constant_level is null"); } return 0; }
	if (!callee) { if(h->error) { h->error(h,callee, "ast2c_Call::callee is null"); } return 0; }
	if (!raw_arguments) { if(h->error) { h->error(h,raw_arguments, "ast2c_Call::raw_arguments is null"); } return 0; }
	if (!arguments) { if(h->error) { h->error(h,arguments, "ast2c_Call::arguments is null"); } return 0; }
	if(!h->array_size(h, arguments,&s->arguments_size)) {
		if(h->error) { h->error(h,arguments, "failed to get array size of ast2c_Call::arguments"); }
		return NULL;
	}
	if (!end_loc) { if(h->error) { h->error(h,end_loc, "ast2c_Call::end_loc is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Call::loc"); }
		goto error;
	}
	if(!ast2c_Loc_parse(&s->end_loc,h,end_loc)) {
		if(h->error) { h->error(h,end_loc, "failed to parse ast2c_Call::end_loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_If_parse(ast2c_Ast* ast,ast2c_If* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->struct_union_type = NULL;
	s->cond_scope = NULL;
	s->cond = NULL;
	s->then = NULL;
	s->els = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* struct_union_type = h->object_get(h, obj_body, "struct_union_type");
	void* cond_scope = h->object_get(h, obj_body, "cond_scope");
	void* cond = h->object_get(h, obj_body, "cond");
	void* then = h->object_get(h, obj_body, "then");
	void* els = h->object_get(h, obj_body, "els");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_If::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_If::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_If::constant_level is null"); } return 0; }
	if (!struct_union_type) { if(h->error) { h->error(h,struct_union_type, "ast2c_If::struct_union_type is null"); } return 0; }
	if (!cond_scope) { if(h->error) { h->error(h,cond_scope, "ast2c_If::cond_scope is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "ast2c_If::cond is null"); } return 0; }
	if (!then) { if(h->error) { h->error(h,then, "ast2c_If::then is null"); } return 0; }
	if (!els) { if(h->error) { h->error(h,els, "ast2c_If::els is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_If::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_MemberAccess_parse(ast2c_Ast* ast,ast2c_MemberAccess* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->target = NULL;
	s->member = NULL;
	s->base = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* target = h->object_get(h, obj_body, "target");
	void* member = h->object_get(h, obj_body, "member");
	void* base = h->object_get(h, obj_body, "base");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_MemberAccess::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_MemberAccess::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_MemberAccess::constant_level is null"); } return 0; }
	if (!target) { if(h->error) { h->error(h,target, "ast2c_MemberAccess::target is null"); } return 0; }
	if (!member) { if(h->error) { h->error(h,member, "ast2c_MemberAccess::member is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_MemberAccess::base is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_MemberAccess::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Paren_parse(ast2c_Ast* ast,ast2c_Paren* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->expr = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* expr = h->object_get(h, obj_body, "expr");
	void* end_loc = h->object_get(h, obj_body, "end_loc");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Paren::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Paren::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Paren::constant_level is null"); } return 0; }
	if (!expr) { if(h->error) { h->error(h,expr, "ast2c_Paren::expr is null"); } return 0; }
	if (!end_loc) { if(h->error) { h->error(h,end_loc, "ast2c_Paren::end_loc is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Paren::loc"); }
		goto error;
	}
	if(!ast2c_Loc_parse(&s->end_loc,h,end_loc)) {
		if(h->error) { h->error(h,end_loc, "failed to parse ast2c_Paren::end_loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Index_parse(ast2c_Ast* ast,ast2c_Index* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->expr = NULL;
	s->index = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* expr = h->object_get(h, obj_body, "expr");
	void* index = h->object_get(h, obj_body, "index");
	void* end_loc = h->object_get(h, obj_body, "end_loc");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Index::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Index::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Index::constant_level is null"); } return 0; }
	if (!expr) { if(h->error) { h->error(h,expr, "ast2c_Index::expr is null"); } return 0; }
	if (!index) { if(h->error) { h->error(h,index, "ast2c_Index::index is null"); } return 0; }
	if (!end_loc) { if(h->error) { h->error(h,end_loc, "ast2c_Index::end_loc is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Index::loc"); }
		goto error;
	}
	if(!ast2c_Loc_parse(&s->end_loc,h,end_loc)) {
		if(h->error) { h->error(h,end_loc, "failed to parse ast2c_Index::end_loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Match_parse(ast2c_Ast* ast,ast2c_Match* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->struct_union_type = NULL;
	s->cond_scope = NULL;
	s->cond = NULL;
	s->branch = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* struct_union_type = h->object_get(h, obj_body, "struct_union_type");
	void* cond_scope = h->object_get(h, obj_body, "cond_scope");
	void* cond = h->object_get(h, obj_body, "cond");
	void* branch = h->object_get(h, obj_body, "branch");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Match::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Match::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Match::constant_level is null"); } return 0; }
	if (!struct_union_type) { if(h->error) { h->error(h,struct_union_type, "ast2c_Match::struct_union_type is null"); } return 0; }
	if (!cond_scope) { if(h->error) { h->error(h,cond_scope, "ast2c_Match::cond_scope is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "ast2c_Match::cond is null"); } return 0; }
	if (!branch) { if(h->error) { h->error(h,branch, "ast2c_Match::branch is null"); } return 0; }
	if(!h->array_size(h, branch,&s->branch_size)) {
		if(h->error) { h->error(h,branch, "failed to get array size of ast2c_Match::branch"); }
		return NULL;
	}
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Match::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Range_parse(ast2c_Ast* ast,ast2c_Range* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->start = NULL;
	s->end = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* op = h->object_get(h, obj_body, "op");
	void* start = h->object_get(h, obj_body, "start");
	void* end = h->object_get(h, obj_body, "end");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Range::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Range::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Range::constant_level is null"); } return 0; }
	if (!op) { if(h->error) { h->error(h,op, "ast2c_Range::op is null"); } return 0; }
	if (!start) { if(h->error) { h->error(h,start, "ast2c_Range::start is null"); } return 0; }
	if (!end) { if(h->error) { h->error(h,end, "ast2c_Range::end is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Range::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_TmpVar_parse(ast2c_Ast* ast,ast2c_TmpVar* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* tmp_var = h->object_get(h, obj_body, "tmp_var");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_TmpVar::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_TmpVar::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_TmpVar::constant_level is null"); } return 0; }
	if (!tmp_var) { if(h->error) { h->error(h,tmp_var, "ast2c_TmpVar::tmp_var is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_TmpVar::loc"); }
		goto error;
	}
	if(!h->number_get(h,tmp_var,&s->tmp_var)) {
		if(h->error) { h->error(h,tmp_var, "failed to parse ast2c_TmpVar::tmp_var"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Import_parse(ast2c_Ast* ast,ast2c_Import* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->path = NULL;
	s->base = NULL;
	s->import_desc = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* path = h->object_get(h, obj_body, "path");
	void* base = h->object_get(h, obj_body, "base");
	void* import_desc = h->object_get(h, obj_body, "import_desc");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Import::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Import::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Import::constant_level is null"); } return 0; }
	if (!path) { if(h->error) { h->error(h,path, "ast2c_Import::path is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_Import::base is null"); } return 0; }
	if (!import_desc) { if(h->error) { h->error(h,import_desc, "ast2c_Import::import_desc is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Import::loc"); }
		goto error;
	}
	s->path = h->string_get_alloc(h,path);
	if (!s->path) {
		if(h->error) { h->error(h,path, "failed to parse ast2c_Import::path"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Cast_parse(ast2c_Ast* ast,ast2c_Cast* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->base = NULL;
	s->expr = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* base = h->object_get(h, obj_body, "base");
	void* expr = h->object_get(h, obj_body, "expr");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Cast::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Cast::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Cast::constant_level is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_Cast::base is null"); } return 0; }
	if (!expr) { if(h->error) { h->error(h,expr, "ast2c_Cast::expr is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Cast::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Available_parse(ast2c_Ast* ast,ast2c_Available* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->base = NULL;
	s->target = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* base = h->object_get(h, obj_body, "base");
	void* target = h->object_get(h, obj_body, "target");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Available::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_Available::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_Available::constant_level is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_Available::base is null"); } return 0; }
	if (!target) { if(h->error) { h->error(h,target, "ast2c_Available::target is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Available::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_SpecifyOrder_parse(ast2c_Ast* ast,ast2c_SpecifyOrder* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->base = NULL;
	s->order = NULL;
	s->order_value = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* base = h->object_get(h, obj_body, "base");
	void* order_type = h->object_get(h, obj_body, "order_type");
	void* order = h->object_get(h, obj_body, "order");
	void* order_value = h->object_get(h, obj_body, "order_value");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_SpecifyOrder::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_SpecifyOrder::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_SpecifyOrder::constant_level is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_SpecifyOrder::base is null"); } return 0; }
	if (!order_type) { if(h->error) { h->error(h,order_type, "ast2c_SpecifyOrder::order_type is null"); } return 0; }
	if (!order) { if(h->error) { h->error(h,order, "ast2c_SpecifyOrder::order is null"); } return 0; }
	if (!order_value) { if(h->error) { h->error(h,order_value, "ast2c_SpecifyOrder::order_value is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_SpecifyOrder::loc"); }
		goto error;
	}
	if(!h->number_get(h,order_value,&s->order_value)) {
		if(h->error) { h->error(h,order_value, "failed to parse ast2c_SpecifyOrder::order_value"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_ExplicitError_parse(ast2c_Ast* ast,ast2c_ExplicitError* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->base = NULL;
	s->message = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* base = h->object_get(h, obj_body, "base");
	void* message = h->object_get(h, obj_body, "message");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_ExplicitError::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_ExplicitError::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_ExplicitError::constant_level is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_ExplicitError::base is null"); } return 0; }
	if (!message) { if(h->error) { h->error(h,message, "ast2c_ExplicitError::message is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_ExplicitError::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_IoOperation_parse(ast2c_Ast* ast,ast2c_IoOperation* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->base = NULL;
	s->arguments = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* base = h->object_get(h, obj_body, "base");
	void* method = h->object_get(h, obj_body, "method");
	void* arguments = h->object_get(h, obj_body, "arguments");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_IoOperation::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_IoOperation::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_IoOperation::constant_level is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_IoOperation::base is null"); } return 0; }
	if (!method) { if(h->error) { h->error(h,method, "ast2c_IoOperation::method is null"); } return 0; }
	if (!arguments) { if(h->error) { h->error(h,arguments, "ast2c_IoOperation::arguments is null"); } return 0; }
	if(!h->array_size(h, arguments,&s->arguments_size)) {
		if(h->error) { h->error(h,arguments, "failed to get array size of ast2c_IoOperation::arguments"); }
		return NULL;
	}
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_IoOperation::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_BadExpr_parse(ast2c_Ast* ast,ast2c_BadExpr* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->content = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* content = h->object_get(h, obj_body, "content");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_BadExpr::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_BadExpr::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_BadExpr::constant_level is null"); } return 0; }
	if (!content) { if(h->error) { h->error(h,content, "ast2c_BadExpr::content is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_BadExpr::loc"); }
		goto error;
	}
	s->content = h->string_get_alloc(h,content);
	if (!s->content) {
		if(h->error) { h->error(h,content, "failed to parse ast2c_BadExpr::content"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Loop_parse(ast2c_Ast* ast,ast2c_Loop* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->cond_scope = NULL;
	s->init = NULL;
	s->cond = NULL;
	s->step = NULL;
	s->body = NULL;
	void* cond_scope = h->object_get(h, obj_body, "cond_scope");
	void* init = h->object_get(h, obj_body, "init");
	void* cond = h->object_get(h, obj_body, "cond");
	void* step = h->object_get(h, obj_body, "step");
	void* body = h->object_get(h, obj_body, "body");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Loop::loc is null"); } return 0; }
	if (!cond_scope) { if(h->error) { h->error(h,cond_scope, "ast2c_Loop::cond_scope is null"); } return 0; }
	if (!init) { if(h->error) { h->error(h,init, "ast2c_Loop::init is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "ast2c_Loop::cond is null"); } return 0; }
	if (!step) { if(h->error) { h->error(h,step, "ast2c_Loop::step is null"); } return 0; }
	if (!body) { if(h->error) { h->error(h,body, "ast2c_Loop::body is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Loop::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_IndentBlock_parse(ast2c_Ast* ast,ast2c_IndentBlock* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->struct_type = NULL;
	s->elements = NULL;
	s->scope = NULL;
	void* struct_type = h->object_get(h, obj_body, "struct_type");
	void* elements = h->object_get(h, obj_body, "elements");
	void* scope = h->object_get(h, obj_body, "scope");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_IndentBlock::loc is null"); } return 0; }
	if (!struct_type) { if(h->error) { h->error(h,struct_type, "ast2c_IndentBlock::struct_type is null"); } return 0; }
	if (!elements) { if(h->error) { h->error(h,elements, "ast2c_IndentBlock::elements is null"); } return 0; }
	if(!h->array_size(h, elements,&s->elements_size)) {
		if(h->error) { h->error(h,elements, "failed to get array size of ast2c_IndentBlock::elements"); }
		return NULL;
	}
	if (!scope) { if(h->error) { h->error(h,scope, "ast2c_IndentBlock::scope is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_IndentBlock::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_ScopedStatement_parse(ast2c_Ast* ast,ast2c_ScopedStatement* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->struct_type = NULL;
	s->statement = NULL;
	s->scope = NULL;
	void* struct_type = h->object_get(h, obj_body, "struct_type");
	void* statement = h->object_get(h, obj_body, "statement");
	void* scope = h->object_get(h, obj_body, "scope");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_ScopedStatement::loc is null"); } return 0; }
	if (!struct_type) { if(h->error) { h->error(h,struct_type, "ast2c_ScopedStatement::struct_type is null"); } return 0; }
	if (!statement) { if(h->error) { h->error(h,statement, "ast2c_ScopedStatement::statement is null"); } return 0; }
	if (!scope) { if(h->error) { h->error(h,scope, "ast2c_ScopedStatement::scope is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_ScopedStatement::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_MatchBranch_parse(ast2c_Ast* ast,ast2c_MatchBranch* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->belong = NULL;
	s->cond = NULL;
	s->then = NULL;
	void* belong = h->object_get(h, obj_body, "belong");
	void* cond = h->object_get(h, obj_body, "cond");
	void* sym_loc = h->object_get(h, obj_body, "sym_loc");
	void* then = h->object_get(h, obj_body, "then");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_MatchBranch::loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "ast2c_MatchBranch::belong is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "ast2c_MatchBranch::cond is null"); } return 0; }
	if (!sym_loc) { if(h->error) { h->error(h,sym_loc, "ast2c_MatchBranch::sym_loc is null"); } return 0; }
	if (!then) { if(h->error) { h->error(h,then, "ast2c_MatchBranch::then is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_MatchBranch::loc"); }
		goto error;
	}
	if(!ast2c_Loc_parse(&s->sym_loc,h,sym_loc)) {
		if(h->error) { h->error(h,sym_loc, "failed to parse ast2c_MatchBranch::sym_loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_UnionCandidate_parse(ast2c_Ast* ast,ast2c_UnionCandidate* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->cond = NULL;
	s->field = NULL;
	void* cond = h->object_get(h, obj_body, "cond");
	void* field = h->object_get(h, obj_body, "field");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_UnionCandidate::loc is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "ast2c_UnionCandidate::cond is null"); } return 0; }
	if (!field) { if(h->error) { h->error(h,field, "ast2c_UnionCandidate::field is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_UnionCandidate::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Return_parse(ast2c_Ast* ast,ast2c_Return* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr = NULL;
	void* expr = h->object_get(h, obj_body, "expr");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Return::loc is null"); } return 0; }
	if (!expr) { if(h->error) { h->error(h,expr, "ast2c_Return::expr is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Return::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Break_parse(ast2c_Ast* ast,ast2c_Break* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Break::loc is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Break::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Continue_parse(ast2c_Ast* ast,ast2c_Continue* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Continue::loc is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Continue::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Assert_parse(ast2c_Ast* ast,ast2c_Assert* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->cond = NULL;
	void* cond = h->object_get(h, obj_body, "cond");
	void* is_io_related = h->object_get(h, obj_body, "is_io_related");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Assert::loc is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "ast2c_Assert::cond is null"); } return 0; }
	if (!is_io_related) { if(h->error) { h->error(h,is_io_related, "ast2c_Assert::is_io_related is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Assert::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_ImplicitYield_parse(ast2c_Ast* ast,ast2c_ImplicitYield* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr = NULL;
	void* expr = h->object_get(h, obj_body, "expr");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_ImplicitYield::loc is null"); } return 0; }
	if (!expr) { if(h->error) { h->error(h,expr, "ast2c_ImplicitYield::expr is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_ImplicitYield::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Metadata_parse(ast2c_Ast* ast,ast2c_Metadata* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->base = NULL;
	s->name = NULL;
	s->values = NULL;
	void* base = h->object_get(h, obj_body, "base");
	void* name = h->object_get(h, obj_body, "name");
	void* values = h->object_get(h, obj_body, "values");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Metadata::loc is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_Metadata::base is null"); } return 0; }
	if (!name) { if(h->error) { h->error(h,name, "ast2c_Metadata::name is null"); } return 0; }
	if (!values) { if(h->error) { h->error(h,values, "ast2c_Metadata::values is null"); } return 0; }
	if(!h->array_size(h, values,&s->values_size)) {
		if(h->error) { h->error(h,values, "failed to get array size of ast2c_Metadata::values"); }
		return NULL;
	}
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Metadata::loc"); }
		goto error;
	}
	s->name = h->string_get_alloc(h,name);
	if (!s->name) {
		if(h->error) { h->error(h,name, "failed to parse ast2c_Metadata::name"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_IntType_parse(ast2c_Ast* ast,ast2c_IntType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->bit_size = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* non_dynamic_allocation = h->object_get(h, obj_body, "non_dynamic_allocation");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* endian = h->object_get(h, obj_body, "endian");
	void* is_signed = h->object_get(h, obj_body, "is_signed");
	void* is_common_supported = h->object_get(h, obj_body, "is_common_supported");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_IntType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_IntType::is_explicit is null"); } return 0; }
	if (!non_dynamic_allocation) { if(h->error) { h->error(h,non_dynamic_allocation, "ast2c_IntType::non_dynamic_allocation is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_IntType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_IntType::bit_size is null"); } return 0; }
	if (!endian) { if(h->error) { h->error(h,endian, "ast2c_IntType::endian is null"); } return 0; }
	if (!is_signed) { if(h->error) { h->error(h,is_signed, "ast2c_IntType::is_signed is null"); } return 0; }
	if (!is_common_supported) { if(h->error) { h->error(h,is_common_supported, "ast2c_IntType::is_common_supported is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_IntType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_IntType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_FloatType_parse(ast2c_Ast* ast,ast2c_FloatType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->bit_size = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* non_dynamic_allocation = h->object_get(h, obj_body, "non_dynamic_allocation");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* endian = h->object_get(h, obj_body, "endian");
	void* is_common_supported = h->object_get(h, obj_body, "is_common_supported");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_FloatType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_FloatType::is_explicit is null"); } return 0; }
	if (!non_dynamic_allocation) { if(h->error) { h->error(h,non_dynamic_allocation, "ast2c_FloatType::non_dynamic_allocation is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_FloatType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_FloatType::bit_size is null"); } return 0; }
	if (!endian) { if(h->error) { h->error(h,endian, "ast2c_FloatType::endian is null"); } return 0; }
	if (!is_common_supported) { if(h->error) { h->error(h,is_common_supported, "ast2c_FloatType::is_common_supported is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_FloatType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_FloatType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_IdentType_parse(ast2c_Ast* ast,ast2c_IdentType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->bit_size = NULL;
	s->import_ref = NULL;
	s->ident = NULL;
	s->base = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* non_dynamic_allocation = h->object_get(h, obj_body, "non_dynamic_allocation");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* import_ref = h->object_get(h, obj_body, "import_ref");
	void* ident = h->object_get(h, obj_body, "ident");
	void* base = h->object_get(h, obj_body, "base");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_IdentType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_IdentType::is_explicit is null"); } return 0; }
	if (!non_dynamic_allocation) { if(h->error) { h->error(h,non_dynamic_allocation, "ast2c_IdentType::non_dynamic_allocation is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_IdentType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_IdentType::bit_size is null"); } return 0; }
	if (!import_ref) { if(h->error) { h->error(h,import_ref, "ast2c_IdentType::import_ref is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ast2c_IdentType::ident is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_IdentType::base is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_IdentType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_IdentType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_IntLiteralType_parse(ast2c_Ast* ast,ast2c_IntLiteralType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->bit_size = NULL;
	s->base = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* non_dynamic_allocation = h->object_get(h, obj_body, "non_dynamic_allocation");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* base = h->object_get(h, obj_body, "base");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_IntLiteralType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_IntLiteralType::is_explicit is null"); } return 0; }
	if (!non_dynamic_allocation) { if(h->error) { h->error(h,non_dynamic_allocation, "ast2c_IntLiteralType::non_dynamic_allocation is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_IntLiteralType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_IntLiteralType::bit_size is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_IntLiteralType::base is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_IntLiteralType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_IntLiteralType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_StrLiteralType_parse(ast2c_Ast* ast,ast2c_StrLiteralType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->bit_size = NULL;
	s->base = NULL;
	s->strong_ref = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* non_dynamic_allocation = h->object_get(h, obj_body, "non_dynamic_allocation");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* base = h->object_get(h, obj_body, "base");
	void* strong_ref = h->object_get(h, obj_body, "strong_ref");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_StrLiteralType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_StrLiteralType::is_explicit is null"); } return 0; }
	if (!non_dynamic_allocation) { if(h->error) { h->error(h,non_dynamic_allocation, "ast2c_StrLiteralType::non_dynamic_allocation is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_StrLiteralType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_StrLiteralType::bit_size is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_StrLiteralType::base is null"); } return 0; }
	if (!strong_ref) { if(h->error) { h->error(h,strong_ref, "ast2c_StrLiteralType::strong_ref is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_StrLiteralType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_StrLiteralType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_VoidType_parse(ast2c_Ast* ast,ast2c_VoidType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->bit_size = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* non_dynamic_allocation = h->object_get(h, obj_body, "non_dynamic_allocation");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_VoidType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_VoidType::is_explicit is null"); } return 0; }
	if (!non_dynamic_allocation) { if(h->error) { h->error(h,non_dynamic_allocation, "ast2c_VoidType::non_dynamic_allocation is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_VoidType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_VoidType::bit_size is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_VoidType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_VoidType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_BoolType_parse(ast2c_Ast* ast,ast2c_BoolType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->bit_size = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* non_dynamic_allocation = h->object_get(h, obj_body, "non_dynamic_allocation");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_BoolType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_BoolType::is_explicit is null"); } return 0; }
	if (!non_dynamic_allocation) { if(h->error) { h->error(h,non_dynamic_allocation, "ast2c_BoolType::non_dynamic_allocation is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_BoolType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_BoolType::bit_size is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_BoolType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_BoolType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_ArrayType_parse(ast2c_Ast* ast,ast2c_ArrayType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->bit_size = NULL;
	s->element_type = NULL;
	s->length = NULL;
	s->length_value = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* non_dynamic_allocation = h->object_get(h, obj_body, "non_dynamic_allocation");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* end_loc = h->object_get(h, obj_body, "end_loc");
	void* element_type = h->object_get(h, obj_body, "element_type");
	void* length = h->object_get(h, obj_body, "length");
	void* length_value = h->object_get(h, obj_body, "length_value");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_ArrayType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_ArrayType::is_explicit is null"); } return 0; }
	if (!non_dynamic_allocation) { if(h->error) { h->error(h,non_dynamic_allocation, "ast2c_ArrayType::non_dynamic_allocation is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_ArrayType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_ArrayType::bit_size is null"); } return 0; }
	if (!end_loc) { if(h->error) { h->error(h,end_loc, "ast2c_ArrayType::end_loc is null"); } return 0; }
	if (!element_type) { if(h->error) { h->error(h,element_type, "ast2c_ArrayType::element_type is null"); } return 0; }
	if (!length) { if(h->error) { h->error(h,length, "ast2c_ArrayType::length is null"); } return 0; }
	if (!length_value) { if(h->error) { h->error(h,length_value, "ast2c_ArrayType::length_value is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_ArrayType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_ArrayType::bit_size"); }
		goto error;
	}
	if(!ast2c_Loc_parse(&s->end_loc,h,end_loc)) {
		if(h->error) { h->error(h,end_loc, "failed to parse ast2c_ArrayType::end_loc"); }
		goto error;
	}
	if(!h->number_get(h,length_value,&s->length_value)) {
		if(h->error) { h->error(h,length_value, "failed to parse ast2c_ArrayType::length_value"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_FunctionType_parse(ast2c_Ast* ast,ast2c_FunctionType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->bit_size = NULL;
	s->return_type = NULL;
	s->parameters = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* non_dynamic_allocation = h->object_get(h, obj_body, "non_dynamic_allocation");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* return_type = h->object_get(h, obj_body, "return_type");
	void* parameters = h->object_get(h, obj_body, "parameters");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_FunctionType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_FunctionType::is_explicit is null"); } return 0; }
	if (!non_dynamic_allocation) { if(h->error) { h->error(h,non_dynamic_allocation, "ast2c_FunctionType::non_dynamic_allocation is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_FunctionType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_FunctionType::bit_size is null"); } return 0; }
	if (!return_type) { if(h->error) { h->error(h,return_type, "ast2c_FunctionType::return_type is null"); } return 0; }
	if (!parameters) { if(h->error) { h->error(h,parameters, "ast2c_FunctionType::parameters is null"); } return 0; }
	if(!h->array_size(h, parameters,&s->parameters_size)) {
		if(h->error) { h->error(h,parameters, "failed to get array size of ast2c_FunctionType::parameters"); }
		return NULL;
	}
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_FunctionType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_FunctionType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_StructType_parse(ast2c_Ast* ast,ast2c_StructType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->bit_size = NULL;
	s->fields = NULL;
	s->base = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* non_dynamic_allocation = h->object_get(h, obj_body, "non_dynamic_allocation");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* fields = h->object_get(h, obj_body, "fields");
	void* base = h->object_get(h, obj_body, "base");
	void* recursive = h->object_get(h, obj_body, "recursive");
	void* fixed_header_size = h->object_get(h, obj_body, "fixed_header_size");
	void* fixed_tail_size = h->object_get(h, obj_body, "fixed_tail_size");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_StructType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_StructType::is_explicit is null"); } return 0; }
	if (!non_dynamic_allocation) { if(h->error) { h->error(h,non_dynamic_allocation, "ast2c_StructType::non_dynamic_allocation is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_StructType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_StructType::bit_size is null"); } return 0; }
	if (!fields) { if(h->error) { h->error(h,fields, "ast2c_StructType::fields is null"); } return 0; }
	if(!h->array_size(h, fields,&s->fields_size)) {
		if(h->error) { h->error(h,fields, "failed to get array size of ast2c_StructType::fields"); }
		return NULL;
	}
	if (!base) { if(h->error) { h->error(h,base, "ast2c_StructType::base is null"); } return 0; }
	if (!recursive) { if(h->error) { h->error(h,recursive, "ast2c_StructType::recursive is null"); } return 0; }
	if (!fixed_header_size) { if(h->error) { h->error(h,fixed_header_size, "ast2c_StructType::fixed_header_size is null"); } return 0; }
	if (!fixed_tail_size) { if(h->error) { h->error(h,fixed_tail_size, "ast2c_StructType::fixed_tail_size is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_StructType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_StructType::bit_size"); }
		goto error;
	}
	if(!h->number_get(h,fixed_header_size,&s->fixed_header_size)) {
		if(h->error) { h->error(h,fixed_header_size, "failed to parse ast2c_StructType::fixed_header_size"); }
		goto error;
	}
	if(!h->number_get(h,fixed_tail_size,&s->fixed_tail_size)) {
		if(h->error) { h->error(h,fixed_tail_size, "failed to parse ast2c_StructType::fixed_tail_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_StructUnionType_parse(ast2c_Ast* ast,ast2c_StructUnionType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->bit_size = NULL;
	s->cond = NULL;
	s->conds = NULL;
	s->structs = NULL;
	s->base = NULL;
	s->union_fields = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* non_dynamic_allocation = h->object_get(h, obj_body, "non_dynamic_allocation");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* cond = h->object_get(h, obj_body, "cond");
	void* conds = h->object_get(h, obj_body, "conds");
	void* structs = h->object_get(h, obj_body, "structs");
	void* base = h->object_get(h, obj_body, "base");
	void* union_fields = h->object_get(h, obj_body, "union_fields");
	void* exhaustive = h->object_get(h, obj_body, "exhaustive");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_StructUnionType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_StructUnionType::is_explicit is null"); } return 0; }
	if (!non_dynamic_allocation) { if(h->error) { h->error(h,non_dynamic_allocation, "ast2c_StructUnionType::non_dynamic_allocation is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_StructUnionType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_StructUnionType::bit_size is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "ast2c_StructUnionType::cond is null"); } return 0; }
	if (!conds) { if(h->error) { h->error(h,conds, "ast2c_StructUnionType::conds is null"); } return 0; }
	if(!h->array_size(h, conds,&s->conds_size)) {
		if(h->error) { h->error(h,conds, "failed to get array size of ast2c_StructUnionType::conds"); }
		return NULL;
	}
	if (!structs) { if(h->error) { h->error(h,structs, "ast2c_StructUnionType::structs is null"); } return 0; }
	if(!h->array_size(h, structs,&s->structs_size)) {
		if(h->error) { h->error(h,structs, "failed to get array size of ast2c_StructUnionType::structs"); }
		return NULL;
	}
	if (!base) { if(h->error) { h->error(h,base, "ast2c_StructUnionType::base is null"); } return 0; }
	if (!union_fields) { if(h->error) { h->error(h,union_fields, "ast2c_StructUnionType::union_fields is null"); } return 0; }
	if(!h->array_size(h, union_fields,&s->union_fields_size)) {
		if(h->error) { h->error(h,union_fields, "failed to get array size of ast2c_StructUnionType::union_fields"); }
		return NULL;
	}
	if (!exhaustive) { if(h->error) { h->error(h,exhaustive, "ast2c_StructUnionType::exhaustive is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_StructUnionType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_StructUnionType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_UnionType_parse(ast2c_Ast* ast,ast2c_UnionType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->bit_size = NULL;
	s->cond = NULL;
	s->candidates = NULL;
	s->base_type = NULL;
	s->common_type = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* non_dynamic_allocation = h->object_get(h, obj_body, "non_dynamic_allocation");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* cond = h->object_get(h, obj_body, "cond");
	void* candidates = h->object_get(h, obj_body, "candidates");
	void* base_type = h->object_get(h, obj_body, "base_type");
	void* common_type = h->object_get(h, obj_body, "common_type");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_UnionType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_UnionType::is_explicit is null"); } return 0; }
	if (!non_dynamic_allocation) { if(h->error) { h->error(h,non_dynamic_allocation, "ast2c_UnionType::non_dynamic_allocation is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_UnionType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_UnionType::bit_size is null"); } return 0; }
	if (!cond) { if(h->error) { h->error(h,cond, "ast2c_UnionType::cond is null"); } return 0; }
	if (!candidates) { if(h->error) { h->error(h,candidates, "ast2c_UnionType::candidates is null"); } return 0; }
	if(!h->array_size(h, candidates,&s->candidates_size)) {
		if(h->error) { h->error(h,candidates, "failed to get array size of ast2c_UnionType::candidates"); }
		return NULL;
	}
	if (!base_type) { if(h->error) { h->error(h,base_type, "ast2c_UnionType::base_type is null"); } return 0; }
	if (!common_type) { if(h->error) { h->error(h,common_type, "ast2c_UnionType::common_type is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_UnionType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_UnionType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_RangeType_parse(ast2c_Ast* ast,ast2c_RangeType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->bit_size = NULL;
	s->base_type = NULL;
	s->range = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* non_dynamic_allocation = h->object_get(h, obj_body, "non_dynamic_allocation");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* base_type = h->object_get(h, obj_body, "base_type");
	void* range = h->object_get(h, obj_body, "range");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_RangeType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_RangeType::is_explicit is null"); } return 0; }
	if (!non_dynamic_allocation) { if(h->error) { h->error(h,non_dynamic_allocation, "ast2c_RangeType::non_dynamic_allocation is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_RangeType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_RangeType::bit_size is null"); } return 0; }
	if (!base_type) { if(h->error) { h->error(h,base_type, "ast2c_RangeType::base_type is null"); } return 0; }
	if (!range) { if(h->error) { h->error(h,range, "ast2c_RangeType::range is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_RangeType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_RangeType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_EnumType_parse(ast2c_Ast* ast,ast2c_EnumType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->bit_size = NULL;
	s->base = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* non_dynamic_allocation = h->object_get(h, obj_body, "non_dynamic_allocation");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* base = h->object_get(h, obj_body, "base");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_EnumType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_EnumType::is_explicit is null"); } return 0; }
	if (!non_dynamic_allocation) { if(h->error) { h->error(h,non_dynamic_allocation, "ast2c_EnumType::non_dynamic_allocation is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_EnumType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_EnumType::bit_size is null"); } return 0; }
	if (!base) { if(h->error) { h->error(h,base, "ast2c_EnumType::base is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_EnumType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_EnumType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_MetaType_parse(ast2c_Ast* ast,ast2c_MetaType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->bit_size = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* non_dynamic_allocation = h->object_get(h, obj_body, "non_dynamic_allocation");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_MetaType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_MetaType::is_explicit is null"); } return 0; }
	if (!non_dynamic_allocation) { if(h->error) { h->error(h,non_dynamic_allocation, "ast2c_MetaType::non_dynamic_allocation is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_MetaType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_MetaType::bit_size is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_MetaType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_MetaType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_OptionalType_parse(ast2c_Ast* ast,ast2c_OptionalType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->bit_size = NULL;
	s->base_type = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* non_dynamic_allocation = h->object_get(h, obj_body, "non_dynamic_allocation");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* base_type = h->object_get(h, obj_body, "base_type");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_OptionalType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_OptionalType::is_explicit is null"); } return 0; }
	if (!non_dynamic_allocation) { if(h->error) { h->error(h,non_dynamic_allocation, "ast2c_OptionalType::non_dynamic_allocation is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_OptionalType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_OptionalType::bit_size is null"); } return 0; }
	if (!base_type) { if(h->error) { h->error(h,base_type, "ast2c_OptionalType::base_type is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_OptionalType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_OptionalType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_GenericType_parse(ast2c_Ast* ast,ast2c_GenericType* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->bit_size = NULL;
	s->belong = NULL;
	void* is_explicit = h->object_get(h, obj_body, "is_explicit");
	void* non_dynamic_allocation = h->object_get(h, obj_body, "non_dynamic_allocation");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* bit_size = h->object_get(h, obj_body, "bit_size");
	void* belong = h->object_get(h, obj_body, "belong");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_GenericType::loc is null"); } return 0; }
	if (!is_explicit) { if(h->error) { h->error(h,is_explicit, "ast2c_GenericType::is_explicit is null"); } return 0; }
	if (!non_dynamic_allocation) { if(h->error) { h->error(h,non_dynamic_allocation, "ast2c_GenericType::non_dynamic_allocation is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_GenericType::bit_alignment is null"); } return 0; }
	if (!bit_size) { if(h->error) { h->error(h,bit_size, "ast2c_GenericType::bit_size is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "ast2c_GenericType::belong is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_GenericType::loc"); }
		goto error;
	}
	if(!h->number_get(h,bit_size,&s->bit_size)) {
		if(h->error) { h->error(h,bit_size, "failed to parse ast2c_GenericType::bit_size"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_IntLiteral_parse(ast2c_Ast* ast,ast2c_IntLiteral* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->value = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* value = h->object_get(h, obj_body, "value");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_IntLiteral::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_IntLiteral::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_IntLiteral::constant_level is null"); } return 0; }
	if (!value) { if(h->error) { h->error(h,value, "ast2c_IntLiteral::value is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_IntLiteral::loc"); }
		goto error;
	}
	s->value = h->string_get_alloc(h,value);
	if (!s->value) {
		if(h->error) { h->error(h,value, "failed to parse ast2c_IntLiteral::value"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_BoolLiteral_parse(ast2c_Ast* ast,ast2c_BoolLiteral* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* value = h->object_get(h, obj_body, "value");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_BoolLiteral::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_BoolLiteral::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_BoolLiteral::constant_level is null"); } return 0; }
	if (!value) { if(h->error) { h->error(h,value, "ast2c_BoolLiteral::value is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_BoolLiteral::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_StrLiteral_parse(ast2c_Ast* ast,ast2c_StrLiteral* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->value = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* value = h->object_get(h, obj_body, "value");
	void* length = h->object_get(h, obj_body, "length");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_StrLiteral::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_StrLiteral::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_StrLiteral::constant_level is null"); } return 0; }
	if (!value) { if(h->error) { h->error(h,value, "ast2c_StrLiteral::value is null"); } return 0; }
	if (!length) { if(h->error) { h->error(h,length, "ast2c_StrLiteral::length is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_StrLiteral::loc"); }
		goto error;
	}
	s->value = h->string_get_alloc(h,value);
	if (!s->value) {
		if(h->error) { h->error(h,value, "failed to parse ast2c_StrLiteral::value"); }
		goto error;
	}
	if(!h->number_get(h,length,&s->length)) {
		if(h->error) { h->error(h,length, "failed to parse ast2c_StrLiteral::length"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_CharLiteral_parse(ast2c_Ast* ast,ast2c_CharLiteral* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->value = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* value = h->object_get(h, obj_body, "value");
	void* code = h->object_get(h, obj_body, "code");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_CharLiteral::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_CharLiteral::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_CharLiteral::constant_level is null"); } return 0; }
	if (!value) { if(h->error) { h->error(h,value, "ast2c_CharLiteral::value is null"); } return 0; }
	if (!code) { if(h->error) { h->error(h,code, "ast2c_CharLiteral::code is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_CharLiteral::loc"); }
		goto error;
	}
	s->value = h->string_get_alloc(h,value);
	if (!s->value) {
		if(h->error) { h->error(h,value, "failed to parse ast2c_CharLiteral::value"); }
		goto error;
	}
	if(!h->number_get(h,code,&s->code)) {
		if(h->error) { h->error(h,code, "failed to parse ast2c_CharLiteral::code"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_TypeLiteral_parse(ast2c_Ast* ast,ast2c_TypeLiteral* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	s->type_literal = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* type_literal = h->object_get(h, obj_body, "type_literal");
	void* end_loc = h->object_get(h, obj_body, "end_loc");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_TypeLiteral::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_TypeLiteral::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_TypeLiteral::constant_level is null"); } return 0; }
	if (!type_literal) { if(h->error) { h->error(h,type_literal, "ast2c_TypeLiteral::type_literal is null"); } return 0; }
	if (!end_loc) { if(h->error) { h->error(h,end_loc, "ast2c_TypeLiteral::end_loc is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_TypeLiteral::loc"); }
		goto error;
	}
	if(!ast2c_Loc_parse(&s->end_loc,h,end_loc)) {
		if(h->error) { h->error(h,end_loc, "failed to parse ast2c_TypeLiteral::end_loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_SpecialLiteral_parse(ast2c_Ast* ast,ast2c_SpecialLiteral* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->expr_type = NULL;
	void* expr_type = h->object_get(h, obj_body, "expr_type");
	void* constant_level = h->object_get(h, obj_body, "constant_level");
	void* kind = h->object_get(h, obj_body, "kind");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_SpecialLiteral::loc is null"); } return 0; }
	if (!expr_type) { if(h->error) { h->error(h,expr_type, "ast2c_SpecialLiteral::expr_type is null"); } return 0; }
	if (!constant_level) { if(h->error) { h->error(h,constant_level, "ast2c_SpecialLiteral::constant_level is null"); } return 0; }
	if (!kind) { if(h->error) { h->error(h,kind, "ast2c_SpecialLiteral::kind is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_SpecialLiteral::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Field_parse(ast2c_Ast* ast,ast2c_Field* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->belong = NULL;
	s->belong_struct = NULL;
	s->ident = NULL;
	s->field_type = NULL;
	s->arguments = NULL;
	s->offset_bit = NULL;
	s->tail_offset_bit = NULL;
	s->next = NULL;
	void* belong = h->object_get(h, obj_body, "belong");
	void* belong_struct = h->object_get(h, obj_body, "belong_struct");
	void* ident = h->object_get(h, obj_body, "ident");
	void* colon_loc = h->object_get(h, obj_body, "colon_loc");
	void* is_state_variable = h->object_get(h, obj_body, "is_state_variable");
	void* field_type = h->object_get(h, obj_body, "field_type");
	void* arguments = h->object_get(h, obj_body, "arguments");
	void* offset_bit = h->object_get(h, obj_body, "offset_bit");
	void* offset_recent = h->object_get(h, obj_body, "offset_recent");
	void* tail_offset_bit = h->object_get(h, obj_body, "tail_offset_bit");
	void* tail_offset_recent = h->object_get(h, obj_body, "tail_offset_recent");
	void* bit_alignment = h->object_get(h, obj_body, "bit_alignment");
	void* eventual_bit_alignment = h->object_get(h, obj_body, "eventual_bit_alignment");
	void* follow = h->object_get(h, obj_body, "follow");
	void* eventual_follow = h->object_get(h, obj_body, "eventual_follow");
	void* next = h->object_get(h, obj_body, "next");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Field::loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "ast2c_Field::belong is null"); } return 0; }
	if (!belong_struct) { if(h->error) { h->error(h,belong_struct, "ast2c_Field::belong_struct is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ast2c_Field::ident is null"); } return 0; }
	if (!colon_loc) { if(h->error) { h->error(h,colon_loc, "ast2c_Field::colon_loc is null"); } return 0; }
	if (!is_state_variable) { if(h->error) { h->error(h,is_state_variable, "ast2c_Field::is_state_variable is null"); } return 0; }
	if (!field_type) { if(h->error) { h->error(h,field_type, "ast2c_Field::field_type is null"); } return 0; }
	if (!arguments) { if(h->error) { h->error(h,arguments, "ast2c_Field::arguments is null"); } return 0; }
	if (!offset_bit) { if(h->error) { h->error(h,offset_bit, "ast2c_Field::offset_bit is null"); } return 0; }
	if (!offset_recent) { if(h->error) { h->error(h,offset_recent, "ast2c_Field::offset_recent is null"); } return 0; }
	if (!tail_offset_bit) { if(h->error) { h->error(h,tail_offset_bit, "ast2c_Field::tail_offset_bit is null"); } return 0; }
	if (!tail_offset_recent) { if(h->error) { h->error(h,tail_offset_recent, "ast2c_Field::tail_offset_recent is null"); } return 0; }
	if (!bit_alignment) { if(h->error) { h->error(h,bit_alignment, "ast2c_Field::bit_alignment is null"); } return 0; }
	if (!eventual_bit_alignment) { if(h->error) { h->error(h,eventual_bit_alignment, "ast2c_Field::eventual_bit_alignment is null"); } return 0; }
	if (!follow) { if(h->error) { h->error(h,follow, "ast2c_Field::follow is null"); } return 0; }
	if (!eventual_follow) { if(h->error) { h->error(h,eventual_follow, "ast2c_Field::eventual_follow is null"); } return 0; }
	if (!next) { if(h->error) { h->error(h,next, "ast2c_Field::next is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Field::loc"); }
		goto error;
	}
	if(!ast2c_Loc_parse(&s->colon_loc,h,colon_loc)) {
		if(h->error) { h->error(h,colon_loc, "failed to parse ast2c_Field::colon_loc"); }
		goto error;
	}
	if(!h->number_get(h,offset_bit,&s->offset_bit)) {
		if(h->error) { h->error(h,offset_bit, "failed to parse ast2c_Field::offset_bit"); }
		goto error;
	}
	if(!h->number_get(h,offset_recent,&s->offset_recent)) {
		if(h->error) { h->error(h,offset_recent, "failed to parse ast2c_Field::offset_recent"); }
		goto error;
	}
	if(!h->number_get(h,tail_offset_bit,&s->tail_offset_bit)) {
		if(h->error) { h->error(h,tail_offset_bit, "failed to parse ast2c_Field::tail_offset_bit"); }
		goto error;
	}
	if(!h->number_get(h,tail_offset_recent,&s->tail_offset_recent)) {
		if(h->error) { h->error(h,tail_offset_recent, "failed to parse ast2c_Field::tail_offset_recent"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Format_parse(ast2c_Ast* ast,ast2c_Format* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->belong = NULL;
	s->belong_struct = NULL;
	s->ident = NULL;
	s->body = NULL;
	s->encode_fn = NULL;
	s->decode_fn = NULL;
	s->cast_fns = NULL;
	s->depends = NULL;
	s->state_variables = NULL;
	void* belong = h->object_get(h, obj_body, "belong");
	void* belong_struct = h->object_get(h, obj_body, "belong_struct");
	void* ident = h->object_get(h, obj_body, "ident");
	void* body = h->object_get(h, obj_body, "body");
	void* encode_fn = h->object_get(h, obj_body, "encode_fn");
	void* decode_fn = h->object_get(h, obj_body, "decode_fn");
	void* cast_fns = h->object_get(h, obj_body, "cast_fns");
	void* depends = h->object_get(h, obj_body, "depends");
	void* state_variables = h->object_get(h, obj_body, "state_variables");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Format::loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "ast2c_Format::belong is null"); } return 0; }
	if (!belong_struct) { if(h->error) { h->error(h,belong_struct, "ast2c_Format::belong_struct is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ast2c_Format::ident is null"); } return 0; }
	if (!body) { if(h->error) { h->error(h,body, "ast2c_Format::body is null"); } return 0; }
	if (!encode_fn) { if(h->error) { h->error(h,encode_fn, "ast2c_Format::encode_fn is null"); } return 0; }
	if (!decode_fn) { if(h->error) { h->error(h,decode_fn, "ast2c_Format::decode_fn is null"); } return 0; }
	if (!cast_fns) { if(h->error) { h->error(h,cast_fns, "ast2c_Format::cast_fns is null"); } return 0; }
	if(!h->array_size(h, cast_fns,&s->cast_fns_size)) {
		if(h->error) { h->error(h,cast_fns, "failed to get array size of ast2c_Format::cast_fns"); }
		return NULL;
	}
	if (!depends) { if(h->error) { h->error(h,depends, "ast2c_Format::depends is null"); } return 0; }
	if(!h->array_size(h, depends,&s->depends_size)) {
		if(h->error) { h->error(h,depends, "failed to get array size of ast2c_Format::depends"); }
		return NULL;
	}
	if (!state_variables) { if(h->error) { h->error(h,state_variables, "ast2c_Format::state_variables is null"); } return 0; }
	if(!h->array_size(h, state_variables,&s->state_variables_size)) {
		if(h->error) { h->error(h,state_variables, "failed to get array size of ast2c_Format::state_variables"); }
		return NULL;
	}
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Format::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_State_parse(ast2c_Ast* ast,ast2c_State* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->belong = NULL;
	s->belong_struct = NULL;
	s->ident = NULL;
	s->body = NULL;
	void* belong = h->object_get(h, obj_body, "belong");
	void* belong_struct = h->object_get(h, obj_body, "belong_struct");
	void* ident = h->object_get(h, obj_body, "ident");
	void* body = h->object_get(h, obj_body, "body");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_State::loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "ast2c_State::belong is null"); } return 0; }
	if (!belong_struct) { if(h->error) { h->error(h,belong_struct, "ast2c_State::belong_struct is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ast2c_State::ident is null"); } return 0; }
	if (!body) { if(h->error) { h->error(h,body, "ast2c_State::body is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_State::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Enum_parse(ast2c_Ast* ast,ast2c_Enum* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->belong = NULL;
	s->belong_struct = NULL;
	s->ident = NULL;
	s->scope = NULL;
	s->base_type = NULL;
	s->members = NULL;
	s->enum_type = NULL;
	void* belong = h->object_get(h, obj_body, "belong");
	void* belong_struct = h->object_get(h, obj_body, "belong_struct");
	void* ident = h->object_get(h, obj_body, "ident");
	void* scope = h->object_get(h, obj_body, "scope");
	void* colon_loc = h->object_get(h, obj_body, "colon_loc");
	void* base_type = h->object_get(h, obj_body, "base_type");
	void* members = h->object_get(h, obj_body, "members");
	void* enum_type = h->object_get(h, obj_body, "enum_type");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Enum::loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "ast2c_Enum::belong is null"); } return 0; }
	if (!belong_struct) { if(h->error) { h->error(h,belong_struct, "ast2c_Enum::belong_struct is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ast2c_Enum::ident is null"); } return 0; }
	if (!scope) { if(h->error) { h->error(h,scope, "ast2c_Enum::scope is null"); } return 0; }
	if (!colon_loc) { if(h->error) { h->error(h,colon_loc, "ast2c_Enum::colon_loc is null"); } return 0; }
	if (!base_type) { if(h->error) { h->error(h,base_type, "ast2c_Enum::base_type is null"); } return 0; }
	if (!members) { if(h->error) { h->error(h,members, "ast2c_Enum::members is null"); } return 0; }
	if(!h->array_size(h, members,&s->members_size)) {
		if(h->error) { h->error(h,members, "failed to get array size of ast2c_Enum::members"); }
		return NULL;
	}
	if (!enum_type) { if(h->error) { h->error(h,enum_type, "ast2c_Enum::enum_type is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Enum::loc"); }
		goto error;
	}
	if(!ast2c_Loc_parse(&s->colon_loc,h,colon_loc)) {
		if(h->error) { h->error(h,colon_loc, "failed to parse ast2c_Enum::colon_loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_EnumMember_parse(ast2c_Ast* ast,ast2c_EnumMember* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->belong = NULL;
	s->belong_struct = NULL;
	s->ident = NULL;
	s->raw_expr = NULL;
	s->value = NULL;
	s->str_literal = NULL;
	void* belong = h->object_get(h, obj_body, "belong");
	void* belong_struct = h->object_get(h, obj_body, "belong_struct");
	void* ident = h->object_get(h, obj_body, "ident");
	void* raw_expr = h->object_get(h, obj_body, "raw_expr");
	void* value = h->object_get(h, obj_body, "value");
	void* str_literal = h->object_get(h, obj_body, "str_literal");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_EnumMember::loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "ast2c_EnumMember::belong is null"); } return 0; }
	if (!belong_struct) { if(h->error) { h->error(h,belong_struct, "ast2c_EnumMember::belong_struct is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ast2c_EnumMember::ident is null"); } return 0; }
	if (!raw_expr) { if(h->error) { h->error(h,raw_expr, "ast2c_EnumMember::raw_expr is null"); } return 0; }
	if (!value) { if(h->error) { h->error(h,value, "ast2c_EnumMember::value is null"); } return 0; }
	if (!str_literal) { if(h->error) { h->error(h,str_literal, "ast2c_EnumMember::str_literal is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_EnumMember::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Function_parse(ast2c_Ast* ast,ast2c_Function* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->belong = NULL;
	s->belong_struct = NULL;
	s->ident = NULL;
	s->parameters = NULL;
	s->return_type = NULL;
	s->body = NULL;
	s->func_type = NULL;
	void* belong = h->object_get(h, obj_body, "belong");
	void* belong_struct = h->object_get(h, obj_body, "belong_struct");
	void* ident = h->object_get(h, obj_body, "ident");
	void* parameters = h->object_get(h, obj_body, "parameters");
	void* return_type = h->object_get(h, obj_body, "return_type");
	void* body = h->object_get(h, obj_body, "body");
	void* func_type = h->object_get(h, obj_body, "func_type");
	void* is_cast = h->object_get(h, obj_body, "is_cast");
	void* cast_loc = h->object_get(h, obj_body, "cast_loc");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_Function::loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "ast2c_Function::belong is null"); } return 0; }
	if (!belong_struct) { if(h->error) { h->error(h,belong_struct, "ast2c_Function::belong_struct is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ast2c_Function::ident is null"); } return 0; }
	if (!parameters) { if(h->error) { h->error(h,parameters, "ast2c_Function::parameters is null"); } return 0; }
	if(!h->array_size(h, parameters,&s->parameters_size)) {
		if(h->error) { h->error(h,parameters, "failed to get array size of ast2c_Function::parameters"); }
		return NULL;
	}
	if (!return_type) { if(h->error) { h->error(h,return_type, "ast2c_Function::return_type is null"); } return 0; }
	if (!body) { if(h->error) { h->error(h,body, "ast2c_Function::body is null"); } return 0; }
	if (!func_type) { if(h->error) { h->error(h,func_type, "ast2c_Function::func_type is null"); } return 0; }
	if (!is_cast) { if(h->error) { h->error(h,is_cast, "ast2c_Function::is_cast is null"); } return 0; }
	if (!cast_loc) { if(h->error) { h->error(h,cast_loc, "ast2c_Function::cast_loc is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_Function::loc"); }
		goto error;
	}
	if(!ast2c_Loc_parse(&s->cast_loc,h,cast_loc)) {
		if(h->error) { h->error(h,cast_loc, "failed to parse ast2c_Function::cast_loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_BuiltinFunction_parse(ast2c_Ast* ast,ast2c_BuiltinFunction* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->belong = NULL;
	s->belong_struct = NULL;
	s->ident = NULL;
	s->func_type = NULL;
	void* belong = h->object_get(h, obj_body, "belong");
	void* belong_struct = h->object_get(h, obj_body, "belong_struct");
	void* ident = h->object_get(h, obj_body, "ident");
	void* func_type = h->object_get(h, obj_body, "func_type");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_BuiltinFunction::loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "ast2c_BuiltinFunction::belong is null"); } return 0; }
	if (!belong_struct) { if(h->error) { h->error(h,belong_struct, "ast2c_BuiltinFunction::belong_struct is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ast2c_BuiltinFunction::ident is null"); } return 0; }
	if (!func_type) { if(h->error) { h->error(h,func_type, "ast2c_BuiltinFunction::func_type is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_BuiltinFunction::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_BuiltinField_parse(ast2c_Ast* ast,ast2c_BuiltinField* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->belong = NULL;
	s->belong_struct = NULL;
	s->ident = NULL;
	s->field_type = NULL;
	void* belong = h->object_get(h, obj_body, "belong");
	void* belong_struct = h->object_get(h, obj_body, "belong_struct");
	void* ident = h->object_get(h, obj_body, "ident");
	void* field_type = h->object_get(h, obj_body, "field_type");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_BuiltinField::loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "ast2c_BuiltinField::belong is null"); } return 0; }
	if (!belong_struct) { if(h->error) { h->error(h,belong_struct, "ast2c_BuiltinField::belong_struct is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ast2c_BuiltinField::ident is null"); } return 0; }
	if (!field_type) { if(h->error) { h->error(h,field_type, "ast2c_BuiltinField::field_type is null"); } return 0; }
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_BuiltinField::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_BuiltinObject_parse(ast2c_Ast* ast,ast2c_BuiltinObject* s,ast2c_json_handlers* h, void* obj) {
	if (!ast||!s||!h||!obj) {
		if(h->error) { h->error(h,NULL, "invalid argument"); }
		return 0;
	}
	void* loc = h->object_get(h, obj, "loc");
	void* obj_body = h->object_get(h, obj, "body");
	if (!obj_body) { if(h->error) { h->error(h,obj_body, "RawNode::obj_body is null"); } return 0; }
	s->belong = NULL;
	s->belong_struct = NULL;
	s->ident = NULL;
	s->members = NULL;
	void* belong = h->object_get(h, obj_body, "belong");
	void* belong_struct = h->object_get(h, obj_body, "belong_struct");
	void* ident = h->object_get(h, obj_body, "ident");
	void* members = h->object_get(h, obj_body, "members");
	if (!loc) { if(h->error) { h->error(h,loc, "ast2c_BuiltinObject::loc is null"); } return 0; }
	if (!belong) { if(h->error) { h->error(h,belong, "ast2c_BuiltinObject::belong is null"); } return 0; }
	if (!belong_struct) { if(h->error) { h->error(h,belong_struct, "ast2c_BuiltinObject::belong_struct is null"); } return 0; }
	if (!ident) { if(h->error) { h->error(h,ident, "ast2c_BuiltinObject::ident is null"); } return 0; }
	if (!members) { if(h->error) { h->error(h,members, "ast2c_BuiltinObject::members is null"); } return 0; }
	if(!h->array_size(h, members,&s->members_size)) {
		if(h->error) { h->error(h,members, "failed to get array size of ast2c_BuiltinObject::members"); }
		return NULL;
	}
	if(!ast2c_Loc_parse(&s->loc,h,loc)) {
		if(h->error) { h->error(h,loc, "failed to parse ast2c_BuiltinObject::loc"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Pos_parse(ast2c_Pos* s,ast2c_json_handlers* h, void* obj) {
	void* begin = h->object_get(h, obj, "begin");
	void* end = h->object_get(h, obj, "end");
	if (!begin) { if(h->error) { h->error(h,begin, "ast2c_Pos::begin is null"); } return 0; }
	if (!end) { if(h->error) { h->error(h,end, "ast2c_Pos::end is null"); } return 0; }
	if(!h->number_get(h,begin,&s->begin)) {
		if(h->error) { h->error(h,begin, "failed to parse ast2c_Pos::begin"); }
		goto error;
	}
	if(!h->number_get(h,end,&s->end)) {
		if(h->error) { h->error(h,end, "failed to parse ast2c_Pos::end"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

// returns 1 if succeed 0 if failed
int ast2c_Loc_parse(ast2c_Loc* s,ast2c_json_handlers* h, void* obj) {
	void* pos = h->object_get(h, obj, "pos");
	void* file = h->object_get(h, obj, "file");
	void* line = h->object_get(h, obj, "line");
	void* col = h->object_get(h, obj, "col");
	if (!pos) { if(h->error) { h->error(h,pos, "ast2c_Loc::pos is null"); } return 0; }
	if (!file) { if(h->error) { h->error(h,file, "ast2c_Loc::file is null"); } return 0; }
	if (!line) { if(h->error) { h->error(h,line, "ast2c_Loc::line is null"); } return 0; }
	if (!col) { if(h->error) { h->error(h,col, "ast2c_Loc::col is null"); } return 0; }
	if(!ast2c_Pos_parse(&s->pos,h,pos)) {
		if(h->error) { h->error(h,pos, "failed to parse ast2c_Loc::pos"); }
		goto error;
	}
	if(!h->number_get(h,file,&s->file)) {
		if(h->error) { h->error(h,file, "failed to parse ast2c_Loc::file"); }
		goto error;
	}
	if(!h->number_get(h,line,&s->line)) {
		if(h->error) { h->error(h,line, "failed to parse ast2c_Loc::line"); }
		goto error;
	}
	if(!h->number_get(h,col,&s->col)) {
		if(h->error) { h->error(h,col, "failed to parse ast2c_Loc::col"); }
		goto error;
	}
	return 1;
error:
	return 0;
}

#ifdef __cplusplus
}
#endif

