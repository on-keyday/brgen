// Code generated by ast2rust. DO NOT EDIT.
use std::rc::{Rc,Weak};
use std::cell::RefCell;
use std::convert::TryFrom;
use serde_derive::{Serialize,Deserialize};

use std::collections::HashMap;

pub enum JSONType {
	Null,
	Bool,
	Number,
	String,
	Array,
	Object,
}

impl From<&serde_json::Value> for JSONType {
	fn from(v:&serde_json::Value)->Self{
		match v{
			serde_json::Value::Null=>Self::Null,
			serde_json::Value::Bool(_)=>Self::Bool,
			serde_json::Value::Number(_)=>Self::Number,
			serde_json::Value::String(_)=>Self::String,
			serde_json::Value::Array(_)=>Self::Array,
			serde_json::Value::Object(_)=>Self::Object,
		}
	}
}

pub enum Error {
	UnknownNodeType(NodeType),
	MismatchNodeType(NodeType,NodeType),
	JSONError(serde_json::Error),
	MissingField(NodeType,&'static str),
	MismatchJSONType(JSONType,JSONType),
	InvalidNodeType(NodeType),
	IndexOutOfBounds(usize),
	InvalidEnumValue(String),
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case",untagged)]
pub enum NodeType {
	Node,
	Program,
	Expr,
	Binary,
	Unary,
	Cond,
	Ident,
	Call,
	If,
	MemberAccess,
	Paren,
	Index,
	Match,
	Range,
	TmpVar,
	BlockExpr,
	Import,
	Literal,
	IntLiteral,
	BoolLiteral,
	StrLiteral,
	Input,
	Output,
	Config,
	Stmt,
	Loop,
	IndentScope,
	MatchBranch,
	Return,
	Break,
	Continue,
	Assert,
	ImplicitYield,
	Member,
	Field,
	Format,
	Function,
	Type,
	IntType,
	IdentType,
	IntLiteralType,
	StrLiteralType,
	VoidType,
	BoolType,
	ArrayType,
	FunctionType,
	StructType,
	UnionType,
	Cast,
}

impl TryFrom<&str> for NodeType {
	type Error = ();
	fn try_from(s:&str)->Result<Self,Self::Error>{
		match s{
			"node" =>Ok(Self::Node),
			"program" =>Ok(Self::Program),
			"expr" =>Ok(Self::Expr),
			"binary" =>Ok(Self::Binary),
			"unary" =>Ok(Self::Unary),
			"cond" =>Ok(Self::Cond),
			"ident" =>Ok(Self::Ident),
			"call" =>Ok(Self::Call),
			"if" =>Ok(Self::If),
			"member_access" =>Ok(Self::MemberAccess),
			"paren" =>Ok(Self::Paren),
			"index" =>Ok(Self::Index),
			"match" =>Ok(Self::Match),
			"range" =>Ok(Self::Range),
			"tmp_var" =>Ok(Self::TmpVar),
			"block_expr" =>Ok(Self::BlockExpr),
			"import" =>Ok(Self::Import),
			"literal" =>Ok(Self::Literal),
			"int_literal" =>Ok(Self::IntLiteral),
			"bool_literal" =>Ok(Self::BoolLiteral),
			"str_literal" =>Ok(Self::StrLiteral),
			"input" =>Ok(Self::Input),
			"output" =>Ok(Self::Output),
			"config" =>Ok(Self::Config),
			"stmt" =>Ok(Self::Stmt),
			"loop" =>Ok(Self::Loop),
			"indent_scope" =>Ok(Self::IndentScope),
			"match_branch" =>Ok(Self::MatchBranch),
			"return" =>Ok(Self::Return),
			"break" =>Ok(Self::Break),
			"continue" =>Ok(Self::Continue),
			"assert" =>Ok(Self::Assert),
			"implicit_yield" =>Ok(Self::ImplicitYield),
			"member" =>Ok(Self::Member),
			"field" =>Ok(Self::Field),
			"format" =>Ok(Self::Format),
			"function" =>Ok(Self::Function),
			"type" =>Ok(Self::Type),
			"int_type" =>Ok(Self::IntType),
			"ident_type" =>Ok(Self::IdentType),
			"int_literal_type" =>Ok(Self::IntLiteralType),
			"str_literal_type" =>Ok(Self::StrLiteralType),
			"void_type" =>Ok(Self::VoidType),
			"bool_type" =>Ok(Self::BoolType),
			"array_type" =>Ok(Self::ArrayType),
			"function_type" =>Ok(Self::FunctionType),
			"struct_type" =>Ok(Self::StructType),
			"union_type" =>Ok(Self::UnionType),
			"cast" =>Ok(Self::Cast),
			_=> Err(()),
		}
	}
}

impl From<&Node> for NodeType {
	fn from(node:&Node)-> Self{
		match node {
			Node::Program(_) => Self::Program,
			Node::Binary(_) => Self::Binary,
			Node::Unary(_) => Self::Unary,
			Node::Cond(_) => Self::Cond,
			Node::Ident(_) => Self::Ident,
			Node::Call(_) => Self::Call,
			Node::If(_) => Self::If,
			Node::MemberAccess(_) => Self::MemberAccess,
			Node::Paren(_) => Self::Paren,
			Node::Index(_) => Self::Index,
			Node::Match(_) => Self::Match,
			Node::Range(_) => Self::Range,
			Node::TmpVar(_) => Self::TmpVar,
			Node::BlockExpr(_) => Self::BlockExpr,
			Node::Import(_) => Self::Import,
			Node::IntLiteral(_) => Self::IntLiteral,
			Node::BoolLiteral(_) => Self::BoolLiteral,
			Node::StrLiteral(_) => Self::StrLiteral,
			Node::Input(_) => Self::Input,
			Node::Output(_) => Self::Output,
			Node::Config(_) => Self::Config,
			Node::Loop(_) => Self::Loop,
			Node::IndentScope(_) => Self::IndentScope,
			Node::MatchBranch(_) => Self::MatchBranch,
			Node::Return(_) => Self::Return,
			Node::Break(_) => Self::Break,
			Node::Continue(_) => Self::Continue,
			Node::Assert(_) => Self::Assert,
			Node::ImplicitYield(_) => Self::ImplicitYield,
			Node::Field(_) => Self::Field,
			Node::Format(_) => Self::Format,
			Node::Function(_) => Self::Function,
			Node::IntType(_) => Self::IntType,
			Node::IdentType(_) => Self::IdentType,
			Node::IntLiteralType(_) => Self::IntLiteralType,
			Node::StrLiteralType(_) => Self::StrLiteralType,
			Node::VoidType(_) => Self::VoidType,
			Node::BoolType(_) => Self::BoolType,
			Node::ArrayType(_) => Self::ArrayType,
			Node::FunctionType(_) => Self::FunctionType,
			Node::StructType(_) => Self::StructType,
			Node::UnionType(_) => Self::UnionType,
			Node::Cast(_) => Self::Cast,
		}
	}
}

impl From<Node> for NodeType {
	fn from(node:Node)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub enum Node {
	Program(Rc<RefCell<Program>>),
	Binary(Rc<RefCell<Binary>>),
	Unary(Rc<RefCell<Unary>>),
	Cond(Rc<RefCell<Cond>>),
	Ident(Rc<RefCell<Ident>>),
	Call(Rc<RefCell<Call>>),
	If(Rc<RefCell<If>>),
	MemberAccess(Rc<RefCell<MemberAccess>>),
	Paren(Rc<RefCell<Paren>>),
	Index(Rc<RefCell<Index>>),
	Match(Rc<RefCell<Match>>),
	Range(Rc<RefCell<Range>>),
	TmpVar(Rc<RefCell<TmpVar>>),
	BlockExpr(Rc<RefCell<BlockExpr>>),
	Import(Rc<RefCell<Import>>),
	IntLiteral(Rc<RefCell<IntLiteral>>),
	BoolLiteral(Rc<RefCell<BoolLiteral>>),
	StrLiteral(Rc<RefCell<StrLiteral>>),
	Input(Rc<RefCell<Input>>),
	Output(Rc<RefCell<Output>>),
	Config(Rc<RefCell<Config>>),
	Loop(Rc<RefCell<Loop>>),
	IndentScope(Rc<RefCell<IndentScope>>),
	MatchBranch(Rc<RefCell<MatchBranch>>),
	Return(Rc<RefCell<Return>>),
	Break(Rc<RefCell<Break>>),
	Continue(Rc<RefCell<Continue>>),
	Assert(Rc<RefCell<Assert>>),
	ImplicitYield(Rc<RefCell<ImplicitYield>>),
	Field(Rc<RefCell<Field>>),
	Format(Rc<RefCell<Format>>),
	Function(Rc<RefCell<Function>>),
	IntType(Rc<RefCell<IntType>>),
	IdentType(Rc<RefCell<IdentType>>),
	IntLiteralType(Rc<RefCell<IntLiteralType>>),
	StrLiteralType(Rc<RefCell<StrLiteralType>>),
	VoidType(Rc<RefCell<VoidType>>),
	BoolType(Rc<RefCell<BoolType>>),
	ArrayType(Rc<RefCell<ArrayType>>),
	FunctionType(Rc<RefCell<FunctionType>>),
	StructType(Rc<RefCell<StructType>>),
	UnionType(Rc<RefCell<UnionType>>),
	Cast(Rc<RefCell<Cast>>),
}

#[derive(Debug,Clone)]
pub enum Expr {
	Binary(Rc<RefCell<Binary>>),
	Unary(Rc<RefCell<Unary>>),
	Cond(Rc<RefCell<Cond>>),
	Ident(Rc<RefCell<Ident>>),
	Call(Rc<RefCell<Call>>),
	If(Rc<RefCell<If>>),
	MemberAccess(Rc<RefCell<MemberAccess>>),
	Paren(Rc<RefCell<Paren>>),
	Index(Rc<RefCell<Index>>),
	Match(Rc<RefCell<Match>>),
	Range(Rc<RefCell<Range>>),
	TmpVar(Rc<RefCell<TmpVar>>),
	BlockExpr(Rc<RefCell<BlockExpr>>),
	Import(Rc<RefCell<Import>>),
	IntLiteral(Rc<RefCell<IntLiteral>>),
	BoolLiteral(Rc<RefCell<BoolLiteral>>),
	StrLiteral(Rc<RefCell<StrLiteral>>),
	Input(Rc<RefCell<Input>>),
	Output(Rc<RefCell<Output>>),
	Config(Rc<RefCell<Config>>),
	Cast(Rc<RefCell<Cast>>),
}

impl TryFrom<&Node> for Expr {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Binary(node)=>Ok(Self::Binary(node.clone())),
			Node::Unary(node)=>Ok(Self::Unary(node.clone())),
			Node::Cond(node)=>Ok(Self::Cond(node.clone())),
			Node::Ident(node)=>Ok(Self::Ident(node.clone())),
			Node::Call(node)=>Ok(Self::Call(node.clone())),
			Node::If(node)=>Ok(Self::If(node.clone())),
			Node::MemberAccess(node)=>Ok(Self::MemberAccess(node.clone())),
			Node::Paren(node)=>Ok(Self::Paren(node.clone())),
			Node::Index(node)=>Ok(Self::Index(node.clone())),
			Node::Match(node)=>Ok(Self::Match(node.clone())),
			Node::Range(node)=>Ok(Self::Range(node.clone())),
			Node::TmpVar(node)=>Ok(Self::TmpVar(node.clone())),
			Node::BlockExpr(node)=>Ok(Self::BlockExpr(node.clone())),
			Node::Import(node)=>Ok(Self::Import(node.clone())),
			Node::IntLiteral(node)=>Ok(Self::IntLiteral(node.clone())),
			Node::BoolLiteral(node)=>Ok(Self::BoolLiteral(node.clone())),
			Node::StrLiteral(node)=>Ok(Self::StrLiteral(node.clone())),
			Node::Input(node)=>Ok(Self::Input(node.clone())),
			Node::Output(node)=>Ok(Self::Output(node.clone())),
			Node::Config(node)=>Ok(Self::Config(node.clone())),
			Node::Cast(node)=>Ok(Self::Cast(node.clone())),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Expr {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Expr> for Node {
	fn from(node:&Expr)-> Self{
		match node {
			Expr::Binary(node)=>Self::Binary(node.clone()),
			Expr::Unary(node)=>Self::Unary(node.clone()),
			Expr::Cond(node)=>Self::Cond(node.clone()),
			Expr::Ident(node)=>Self::Ident(node.clone()),
			Expr::Call(node)=>Self::Call(node.clone()),
			Expr::If(node)=>Self::If(node.clone()),
			Expr::MemberAccess(node)=>Self::MemberAccess(node.clone()),
			Expr::Paren(node)=>Self::Paren(node.clone()),
			Expr::Index(node)=>Self::Index(node.clone()),
			Expr::Match(node)=>Self::Match(node.clone()),
			Expr::Range(node)=>Self::Range(node.clone()),
			Expr::TmpVar(node)=>Self::TmpVar(node.clone()),
			Expr::BlockExpr(node)=>Self::BlockExpr(node.clone()),
			Expr::Import(node)=>Self::Import(node.clone()),
			Expr::IntLiteral(node)=>Self::IntLiteral(node.clone()),
			Expr::BoolLiteral(node)=>Self::BoolLiteral(node.clone()),
			Expr::StrLiteral(node)=>Self::StrLiteral(node.clone()),
			Expr::Input(node)=>Self::Input(node.clone()),
			Expr::Output(node)=>Self::Output(node.clone()),
			Expr::Config(node)=>Self::Config(node.clone()),
			Expr::Cast(node)=>Self::Cast(node.clone()),
		}
	}
}

impl From<Expr> for Node {
	fn from(node:Expr)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub enum Literal {
	IntLiteral(Rc<RefCell<IntLiteral>>),
	BoolLiteral(Rc<RefCell<BoolLiteral>>),
	StrLiteral(Rc<RefCell<StrLiteral>>),
	Input(Rc<RefCell<Input>>),
	Output(Rc<RefCell<Output>>),
	Config(Rc<RefCell<Config>>),
}

impl TryFrom<&Node> for Literal {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::IntLiteral(node)=>Ok(Self::IntLiteral(node.clone())),
			Node::BoolLiteral(node)=>Ok(Self::BoolLiteral(node.clone())),
			Node::StrLiteral(node)=>Ok(Self::StrLiteral(node.clone())),
			Node::Input(node)=>Ok(Self::Input(node.clone())),
			Node::Output(node)=>Ok(Self::Output(node.clone())),
			Node::Config(node)=>Ok(Self::Config(node.clone())),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Literal {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Literal> for Node {
	fn from(node:&Literal)-> Self{
		match node {
			Literal::IntLiteral(node)=>Self::IntLiteral(node.clone()),
			Literal::BoolLiteral(node)=>Self::BoolLiteral(node.clone()),
			Literal::StrLiteral(node)=>Self::StrLiteral(node.clone()),
			Literal::Input(node)=>Self::Input(node.clone()),
			Literal::Output(node)=>Self::Output(node.clone()),
			Literal::Config(node)=>Self::Config(node.clone()),
		}
	}
}

impl From<Literal> for Node {
	fn from(node:Literal)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub enum Stmt {
	Loop(Rc<RefCell<Loop>>),
	IndentScope(Rc<RefCell<IndentScope>>),
	MatchBranch(Rc<RefCell<MatchBranch>>),
	Return(Rc<RefCell<Return>>),
	Break(Rc<RefCell<Break>>),
	Continue(Rc<RefCell<Continue>>),
	Assert(Rc<RefCell<Assert>>),
	ImplicitYield(Rc<RefCell<ImplicitYield>>),
	Field(Rc<RefCell<Field>>),
	Format(Rc<RefCell<Format>>),
	Function(Rc<RefCell<Function>>),
}

impl TryFrom<&Node> for Stmt {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Loop(node)=>Ok(Self::Loop(node.clone())),
			Node::IndentScope(node)=>Ok(Self::IndentScope(node.clone())),
			Node::MatchBranch(node)=>Ok(Self::MatchBranch(node.clone())),
			Node::Return(node)=>Ok(Self::Return(node.clone())),
			Node::Break(node)=>Ok(Self::Break(node.clone())),
			Node::Continue(node)=>Ok(Self::Continue(node.clone())),
			Node::Assert(node)=>Ok(Self::Assert(node.clone())),
			Node::ImplicitYield(node)=>Ok(Self::ImplicitYield(node.clone())),
			Node::Field(node)=>Ok(Self::Field(node.clone())),
			Node::Format(node)=>Ok(Self::Format(node.clone())),
			Node::Function(node)=>Ok(Self::Function(node.clone())),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Stmt {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Stmt> for Node {
	fn from(node:&Stmt)-> Self{
		match node {
			Stmt::Loop(node)=>Self::Loop(node.clone()),
			Stmt::IndentScope(node)=>Self::IndentScope(node.clone()),
			Stmt::MatchBranch(node)=>Self::MatchBranch(node.clone()),
			Stmt::Return(node)=>Self::Return(node.clone()),
			Stmt::Break(node)=>Self::Break(node.clone()),
			Stmt::Continue(node)=>Self::Continue(node.clone()),
			Stmt::Assert(node)=>Self::Assert(node.clone()),
			Stmt::ImplicitYield(node)=>Self::ImplicitYield(node.clone()),
			Stmt::Field(node)=>Self::Field(node.clone()),
			Stmt::Format(node)=>Self::Format(node.clone()),
			Stmt::Function(node)=>Self::Function(node.clone()),
		}
	}
}

impl From<Stmt> for Node {
	fn from(node:Stmt)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub enum Member {
	Field(Rc<RefCell<Field>>),
	Format(Rc<RefCell<Format>>),
	Function(Rc<RefCell<Function>>),
}

impl TryFrom<&Node> for Member {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Field(node)=>Ok(Self::Field(node.clone())),
			Node::Format(node)=>Ok(Self::Format(node.clone())),
			Node::Function(node)=>Ok(Self::Function(node.clone())),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Member {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Member> for Node {
	fn from(node:&Member)-> Self{
		match node {
			Member::Field(node)=>Self::Field(node.clone()),
			Member::Format(node)=>Self::Format(node.clone()),
			Member::Function(node)=>Self::Function(node.clone()),
		}
	}
}

impl From<Member> for Node {
	fn from(node:Member)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub enum Type {
	IntType(Rc<RefCell<IntType>>),
	IdentType(Rc<RefCell<IdentType>>),
	IntLiteralType(Rc<RefCell<IntLiteralType>>),
	StrLiteralType(Rc<RefCell<StrLiteralType>>),
	VoidType(Rc<RefCell<VoidType>>),
	BoolType(Rc<RefCell<BoolType>>),
	ArrayType(Rc<RefCell<ArrayType>>),
	FunctionType(Rc<RefCell<FunctionType>>),
	StructType(Rc<RefCell<StructType>>),
	UnionType(Rc<RefCell<UnionType>>),
}

impl TryFrom<&Node> for Type {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::IntType(node)=>Ok(Self::IntType(node.clone())),
			Node::IdentType(node)=>Ok(Self::IdentType(node.clone())),
			Node::IntLiteralType(node)=>Ok(Self::IntLiteralType(node.clone())),
			Node::StrLiteralType(node)=>Ok(Self::StrLiteralType(node.clone())),
			Node::VoidType(node)=>Ok(Self::VoidType(node.clone())),
			Node::BoolType(node)=>Ok(Self::BoolType(node.clone())),
			Node::ArrayType(node)=>Ok(Self::ArrayType(node.clone())),
			Node::FunctionType(node)=>Ok(Self::FunctionType(node.clone())),
			Node::StructType(node)=>Ok(Self::StructType(node.clone())),
			Node::UnionType(node)=>Ok(Self::UnionType(node.clone())),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Type {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Type> for Node {
	fn from(node:&Type)-> Self{
		match node {
			Type::IntType(node)=>Self::IntType(node.clone()),
			Type::IdentType(node)=>Self::IdentType(node.clone()),
			Type::IntLiteralType(node)=>Self::IntLiteralType(node.clone()),
			Type::StrLiteralType(node)=>Self::StrLiteralType(node.clone()),
			Type::VoidType(node)=>Self::VoidType(node.clone()),
			Type::BoolType(node)=>Self::BoolType(node.clone()),
			Type::ArrayType(node)=>Self::ArrayType(node.clone()),
			Type::FunctionType(node)=>Self::FunctionType(node.clone()),
			Type::StructType(node)=>Self::StructType(node.clone()),
			Type::UnionType(node)=>Self::UnionType(node.clone()),
		}
	}
}

impl From<Type> for Node {
	fn from(node:Type)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Program {
	pub struct_type: Option<Rc<RefCell<StructType>>>,
	pub elements: Vec<Node>,
	pub global_scope: Option<Rc<RefCell<Scope>>>,
	pub loc: Loc,
}

impl TryFrom<&Node> for Rc<RefCell<Program>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Program(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Program>>> for Node {
	fn from(node:&Rc<RefCell<Program>>)-> Self{
		Node::Program(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Binary {
	pub expr_type: Option<Type>,
	pub op: BinaryOp,
	pub left: Option<Expr>,
	pub right: Option<Expr>,
	pub loc: Loc,
}

impl TryFrom<&Expr> for Rc<RefCell<Binary>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Binary(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Binary>>> for Expr {
	fn from(node:&Rc<RefCell<Binary>>)-> Self{
		Expr::Binary(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Binary>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Binary(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Binary>>> for Node {
	fn from(node:&Rc<RefCell<Binary>>)-> Self{
		Node::Binary(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Unary {
	pub expr_type: Option<Type>,
	pub op: UnaryOp,
	pub expr: Option<Expr>,
	pub loc: Loc,
}

impl TryFrom<&Expr> for Rc<RefCell<Unary>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Unary(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Unary>>> for Expr {
	fn from(node:&Rc<RefCell<Unary>>)-> Self{
		Expr::Unary(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Unary>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Unary(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Unary>>> for Node {
	fn from(node:&Rc<RefCell<Unary>>)-> Self{
		Node::Unary(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Cond {
	pub expr_type: Option<Type>,
	pub cond: Option<Expr>,
	pub then: Option<Expr>,
	pub els_loc: Loc,
	pub els: Option<Expr>,
	pub loc: Loc,
}

impl TryFrom<&Expr> for Rc<RefCell<Cond>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Cond(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Cond>>> for Expr {
	fn from(node:&Rc<RefCell<Cond>>)-> Self{
		Expr::Cond(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Cond>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Cond(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Cond>>> for Node {
	fn from(node:&Rc<RefCell<Cond>>)-> Self{
		Node::Cond(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Ident {
	pub expr_type: Option<Type>,
	pub ident: String,
	pub usage: IdentUsage,
	pub base: Option<Node>,
	pub scope: Option<Rc<RefCell<Scope>>>,
	pub loc: Loc,
}

impl TryFrom<&Expr> for Rc<RefCell<Ident>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Ident(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Ident>>> for Expr {
	fn from(node:&Rc<RefCell<Ident>>)-> Self{
		Expr::Ident(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Ident>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Ident(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Ident>>> for Node {
	fn from(node:&Rc<RefCell<Ident>>)-> Self{
		Node::Ident(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Call {
	pub expr_type: Option<Type>,
	pub callee: Option<Expr>,
	pub raw_arguments: Option<Expr>,
	pub arguments: Vec<Expr>,
	pub end_loc: Loc,
	pub loc: Loc,
}

impl TryFrom<&Expr> for Rc<RefCell<Call>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Call(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Call>>> for Expr {
	fn from(node:&Rc<RefCell<Call>>)-> Self{
		Expr::Call(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Call>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Call(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Call>>> for Node {
	fn from(node:&Rc<RefCell<Call>>)-> Self{
		Node::Call(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct If {
	pub expr_type: Option<Type>,
	pub cond: Option<Expr>,
	pub then: Option<Rc<RefCell<IndentScope>>>,
	pub els: Option<Node>,
	pub loc: Loc,
}

impl TryFrom<&Expr> for Rc<RefCell<If>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::If(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<If>>> for Expr {
	fn from(node:&Rc<RefCell<If>>)-> Self{
		Expr::If(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<If>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::If(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<If>>> for Node {
	fn from(node:&Rc<RefCell<If>>)-> Self{
		Node::If(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct MemberAccess {
	pub expr_type: Option<Type>,
	pub target: Option<Expr>,
	pub member: String,
	pub member_loc: Loc,
	pub loc: Loc,
}

impl TryFrom<&Expr> for Rc<RefCell<MemberAccess>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::MemberAccess(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<MemberAccess>>> for Expr {
	fn from(node:&Rc<RefCell<MemberAccess>>)-> Self{
		Expr::MemberAccess(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<MemberAccess>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::MemberAccess(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<MemberAccess>>> for Node {
	fn from(node:&Rc<RefCell<MemberAccess>>)-> Self{
		Node::MemberAccess(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Paren {
	pub expr_type: Option<Type>,
	pub expr: Option<Expr>,
	pub end_loc: Loc,
	pub loc: Loc,
}

impl TryFrom<&Expr> for Rc<RefCell<Paren>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Paren(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Paren>>> for Expr {
	fn from(node:&Rc<RefCell<Paren>>)-> Self{
		Expr::Paren(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Paren>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Paren(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Paren>>> for Node {
	fn from(node:&Rc<RefCell<Paren>>)-> Self{
		Node::Paren(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Index {
	pub expr_type: Option<Type>,
	pub expr: Option<Expr>,
	pub index: Option<Expr>,
	pub end_loc: Loc,
	pub loc: Loc,
}

impl TryFrom<&Expr> for Rc<RefCell<Index>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Index(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Index>>> for Expr {
	fn from(node:&Rc<RefCell<Index>>)-> Self{
		Expr::Index(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Index>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Index(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Index>>> for Node {
	fn from(node:&Rc<RefCell<Index>>)-> Self{
		Node::Index(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Match {
	pub expr_type: Option<Type>,
	pub cond: Option<Expr>,
	pub branch: Vec<Rc<RefCell<MatchBranch>>>,
	pub scope: Option<Rc<RefCell<Scope>>>,
	pub loc: Loc,
}

impl TryFrom<&Expr> for Rc<RefCell<Match>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Match(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Match>>> for Expr {
	fn from(node:&Rc<RefCell<Match>>)-> Self{
		Expr::Match(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Match>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Match(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Match>>> for Node {
	fn from(node:&Rc<RefCell<Match>>)-> Self{
		Node::Match(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Range {
	pub expr_type: Option<Type>,
	pub op: BinaryOp,
	pub start: Option<Expr>,
	pub end: Option<Expr>,
	pub loc: Loc,
}

impl TryFrom<&Expr> for Rc<RefCell<Range>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Range(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Range>>> for Expr {
	fn from(node:&Rc<RefCell<Range>>)-> Self{
		Expr::Range(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Range>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Range(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Range>>> for Node {
	fn from(node:&Rc<RefCell<Range>>)-> Self{
		Node::Range(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct TmpVar {
	pub expr_type: Option<Type>,
	pub tmp_var: u64,
	pub loc: Loc,
}

impl TryFrom<&Expr> for Rc<RefCell<TmpVar>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::TmpVar(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<TmpVar>>> for Expr {
	fn from(node:&Rc<RefCell<TmpVar>>)-> Self{
		Expr::TmpVar(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<TmpVar>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::TmpVar(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<TmpVar>>> for Node {
	fn from(node:&Rc<RefCell<TmpVar>>)-> Self{
		Node::TmpVar(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct BlockExpr {
	pub expr_type: Option<Type>,
	pub calls: Vec<Node>,
	pub expr: Option<Expr>,
	pub loc: Loc,
}

impl TryFrom<&Expr> for Rc<RefCell<BlockExpr>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::BlockExpr(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<BlockExpr>>> for Expr {
	fn from(node:&Rc<RefCell<BlockExpr>>)-> Self{
		Expr::BlockExpr(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<BlockExpr>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::BlockExpr(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<BlockExpr>>> for Node {
	fn from(node:&Rc<RefCell<BlockExpr>>)-> Self{
		Node::BlockExpr(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Import {
	pub expr_type: Option<Type>,
	pub path: String,
	pub base: Option<Rc<RefCell<Call>>>,
	pub import_desc: Option<Rc<RefCell<Program>>>,
	pub loc: Loc,
}

impl TryFrom<&Expr> for Rc<RefCell<Import>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Import(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Import>>> for Expr {
	fn from(node:&Rc<RefCell<Import>>)-> Self{
		Expr::Import(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Import>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Import(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Import>>> for Node {
	fn from(node:&Rc<RefCell<Import>>)-> Self{
		Node::Import(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct IntLiteral {
	pub expr_type: Option<Type>,
	pub value: String,
	pub loc: Loc,
}

impl TryFrom<&Literal> for Rc<RefCell<IntLiteral>> {
	type Error = Error;
	fn try_from(node:&Literal)->Result<Self,Self::Error>{
		match node {
			Literal::IntLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<IntLiteral>>> for Literal {
	fn from(node:&Rc<RefCell<IntLiteral>>)-> Self{
		Literal::IntLiteral(node.clone())
	}
}

impl TryFrom<&Expr> for Rc<RefCell<IntLiteral>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::IntLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<IntLiteral>>> for Expr {
	fn from(node:&Rc<RefCell<IntLiteral>>)-> Self{
		Expr::IntLiteral(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<IntLiteral>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::IntLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<IntLiteral>>> for Node {
	fn from(node:&Rc<RefCell<IntLiteral>>)-> Self{
		Node::IntLiteral(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct BoolLiteral {
	pub expr_type: Option<Type>,
	pub value: bool,
	pub loc: Loc,
}

impl TryFrom<&Literal> for Rc<RefCell<BoolLiteral>> {
	type Error = Error;
	fn try_from(node:&Literal)->Result<Self,Self::Error>{
		match node {
			Literal::BoolLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<BoolLiteral>>> for Literal {
	fn from(node:&Rc<RefCell<BoolLiteral>>)-> Self{
		Literal::BoolLiteral(node.clone())
	}
}

impl TryFrom<&Expr> for Rc<RefCell<BoolLiteral>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::BoolLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<BoolLiteral>>> for Expr {
	fn from(node:&Rc<RefCell<BoolLiteral>>)-> Self{
		Expr::BoolLiteral(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<BoolLiteral>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::BoolLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<BoolLiteral>>> for Node {
	fn from(node:&Rc<RefCell<BoolLiteral>>)-> Self{
		Node::BoolLiteral(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct StrLiteral {
	pub expr_type: Option<Type>,
	pub value: String,
	pub loc: Loc,
}

impl TryFrom<&Literal> for Rc<RefCell<StrLiteral>> {
	type Error = Error;
	fn try_from(node:&Literal)->Result<Self,Self::Error>{
		match node {
			Literal::StrLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<StrLiteral>>> for Literal {
	fn from(node:&Rc<RefCell<StrLiteral>>)-> Self{
		Literal::StrLiteral(node.clone())
	}
}

impl TryFrom<&Expr> for Rc<RefCell<StrLiteral>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::StrLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<StrLiteral>>> for Expr {
	fn from(node:&Rc<RefCell<StrLiteral>>)-> Self{
		Expr::StrLiteral(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<StrLiteral>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::StrLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<StrLiteral>>> for Node {
	fn from(node:&Rc<RefCell<StrLiteral>>)-> Self{
		Node::StrLiteral(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Input {
	pub expr_type: Option<Type>,
	pub loc: Loc,
}

impl TryFrom<&Literal> for Rc<RefCell<Input>> {
	type Error = Error;
	fn try_from(node:&Literal)->Result<Self,Self::Error>{
		match node {
			Literal::Input(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Input>>> for Literal {
	fn from(node:&Rc<RefCell<Input>>)-> Self{
		Literal::Input(node.clone())
	}
}

impl TryFrom<&Expr> for Rc<RefCell<Input>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Input(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Input>>> for Expr {
	fn from(node:&Rc<RefCell<Input>>)-> Self{
		Expr::Input(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Input>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Input(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Input>>> for Node {
	fn from(node:&Rc<RefCell<Input>>)-> Self{
		Node::Input(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Output {
	pub expr_type: Option<Type>,
	pub loc: Loc,
}

impl TryFrom<&Literal> for Rc<RefCell<Output>> {
	type Error = Error;
	fn try_from(node:&Literal)->Result<Self,Self::Error>{
		match node {
			Literal::Output(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Output>>> for Literal {
	fn from(node:&Rc<RefCell<Output>>)-> Self{
		Literal::Output(node.clone())
	}
}

impl TryFrom<&Expr> for Rc<RefCell<Output>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Output(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Output>>> for Expr {
	fn from(node:&Rc<RefCell<Output>>)-> Self{
		Expr::Output(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Output>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Output(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Output>>> for Node {
	fn from(node:&Rc<RefCell<Output>>)-> Self{
		Node::Output(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Config {
	pub expr_type: Option<Type>,
	pub loc: Loc,
}

impl TryFrom<&Literal> for Rc<RefCell<Config>> {
	type Error = Error;
	fn try_from(node:&Literal)->Result<Self,Self::Error>{
		match node {
			Literal::Config(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Config>>> for Literal {
	fn from(node:&Rc<RefCell<Config>>)-> Self{
		Literal::Config(node.clone())
	}
}

impl TryFrom<&Expr> for Rc<RefCell<Config>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Config(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Config>>> for Expr {
	fn from(node:&Rc<RefCell<Config>>)-> Self{
		Expr::Config(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Config>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Config(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Config>>> for Node {
	fn from(node:&Rc<RefCell<Config>>)-> Self{
		Node::Config(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Loop {
	pub init: Option<Expr>,
	pub cond: Option<Expr>,
	pub step: Option<Expr>,
	pub body: Option<Rc<RefCell<IndentScope>>>,
	pub loc: Loc,
}

impl TryFrom<&Stmt> for Rc<RefCell<Loop>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::Loop(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Loop>>> for Stmt {
	fn from(node:&Rc<RefCell<Loop>>)-> Self{
		Stmt::Loop(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Loop>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Loop(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Loop>>> for Node {
	fn from(node:&Rc<RefCell<Loop>>)-> Self{
		Node::Loop(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct IndentScope {
	pub elements: Vec<Node>,
	pub scope: Option<Rc<RefCell<Scope>>>,
	pub loc: Loc,
}

impl TryFrom<&Stmt> for Rc<RefCell<IndentScope>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::IndentScope(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<IndentScope>>> for Stmt {
	fn from(node:&Rc<RefCell<IndentScope>>)-> Self{
		Stmt::IndentScope(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<IndentScope>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::IndentScope(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<IndentScope>>> for Node {
	fn from(node:&Rc<RefCell<IndentScope>>)-> Self{
		Node::IndentScope(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct MatchBranch {
	pub cond: Option<Expr>,
	pub sym_loc: Loc,
	pub then: Option<Node>,
	pub loc: Loc,
}

impl TryFrom<&Stmt> for Rc<RefCell<MatchBranch>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::MatchBranch(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<MatchBranch>>> for Stmt {
	fn from(node:&Rc<RefCell<MatchBranch>>)-> Self{
		Stmt::MatchBranch(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<MatchBranch>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::MatchBranch(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<MatchBranch>>> for Node {
	fn from(node:&Rc<RefCell<MatchBranch>>)-> Self{
		Node::MatchBranch(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Return {
	pub expr: Option<Expr>,
	pub loc: Loc,
}

impl TryFrom<&Stmt> for Rc<RefCell<Return>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::Return(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Return>>> for Stmt {
	fn from(node:&Rc<RefCell<Return>>)-> Self{
		Stmt::Return(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Return>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Return(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Return>>> for Node {
	fn from(node:&Rc<RefCell<Return>>)-> Self{
		Node::Return(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Break {
	pub loc: Loc,
}

impl TryFrom<&Stmt> for Rc<RefCell<Break>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::Break(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Break>>> for Stmt {
	fn from(node:&Rc<RefCell<Break>>)-> Self{
		Stmt::Break(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Break>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Break(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Break>>> for Node {
	fn from(node:&Rc<RefCell<Break>>)-> Self{
		Node::Break(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Continue {
	pub loc: Loc,
}

impl TryFrom<&Stmt> for Rc<RefCell<Continue>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::Continue(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Continue>>> for Stmt {
	fn from(node:&Rc<RefCell<Continue>>)-> Self{
		Stmt::Continue(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Continue>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Continue(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Continue>>> for Node {
	fn from(node:&Rc<RefCell<Continue>>)-> Self{
		Node::Continue(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Assert {
	pub cond: Option<Rc<RefCell<Binary>>>,
	pub loc: Loc,
}

impl TryFrom<&Stmt> for Rc<RefCell<Assert>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::Assert(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Assert>>> for Stmt {
	fn from(node:&Rc<RefCell<Assert>>)-> Self{
		Stmt::Assert(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Assert>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Assert(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Assert>>> for Node {
	fn from(node:&Rc<RefCell<Assert>>)-> Self{
		Node::Assert(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct ImplicitYield {
	pub expr: Option<Expr>,
	pub loc: Loc,
}

impl TryFrom<&Stmt> for Rc<RefCell<ImplicitYield>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::ImplicitYield(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<ImplicitYield>>> for Stmt {
	fn from(node:&Rc<RefCell<ImplicitYield>>)-> Self{
		Stmt::ImplicitYield(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<ImplicitYield>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::ImplicitYield(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<ImplicitYield>>> for Node {
	fn from(node:&Rc<RefCell<ImplicitYield>>)-> Self{
		Node::ImplicitYield(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Field {
	pub ident: Option<Rc<RefCell<Ident>>>,
	pub colon_loc: Loc,
	pub field_type: Option<Type>,
	pub raw_arguments: Option<Expr>,
	pub arguments: Vec<Expr>,
	pub belong: Option<Weak<RefCell<Format>>>,
	pub loc: Loc,
}

impl TryFrom<&Member> for Rc<RefCell<Field>> {
	type Error = Error;
	fn try_from(node:&Member)->Result<Self,Self::Error>{
		match node {
			Member::Field(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Field>>> for Member {
	fn from(node:&Rc<RefCell<Field>>)-> Self{
		Member::Field(node.clone())
	}
}

impl TryFrom<&Stmt> for Rc<RefCell<Field>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::Field(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Field>>> for Stmt {
	fn from(node:&Rc<RefCell<Field>>)-> Self{
		Stmt::Field(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Field>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Field(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Field>>> for Node {
	fn from(node:&Rc<RefCell<Field>>)-> Self{
		Node::Field(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Format {
	pub is_enum: bool,
	pub ident: Option<Rc<RefCell<Ident>>>,
	pub body: Option<Rc<RefCell<IndentScope>>>,
	pub belong: Option<Weak<RefCell<Format>>>,
	pub struct_type: Option<Rc<RefCell<StructType>>>,
	pub loc: Loc,
}

impl TryFrom<&Member> for Rc<RefCell<Format>> {
	type Error = Error;
	fn try_from(node:&Member)->Result<Self,Self::Error>{
		match node {
			Member::Format(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Format>>> for Member {
	fn from(node:&Rc<RefCell<Format>>)-> Self{
		Member::Format(node.clone())
	}
}

impl TryFrom<&Stmt> for Rc<RefCell<Format>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::Format(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Format>>> for Stmt {
	fn from(node:&Rc<RefCell<Format>>)-> Self{
		Stmt::Format(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Format>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Format(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Format>>> for Node {
	fn from(node:&Rc<RefCell<Format>>)-> Self{
		Node::Format(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Function {
	pub ident: Option<Rc<RefCell<Ident>>>,
	pub parameters: Vec<Rc<RefCell<Field>>>,
	pub return_type: Option<Type>,
	pub belong: Option<Weak<RefCell<Format>>>,
	pub body: Option<Rc<RefCell<IndentScope>>>,
	pub func_type: Option<Rc<RefCell<FunctionType>>>,
	pub loc: Loc,
}

impl TryFrom<&Member> for Rc<RefCell<Function>> {
	type Error = Error;
	fn try_from(node:&Member)->Result<Self,Self::Error>{
		match node {
			Member::Function(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Function>>> for Member {
	fn from(node:&Rc<RefCell<Function>>)-> Self{
		Member::Function(node.clone())
	}
}

impl TryFrom<&Stmt> for Rc<RefCell<Function>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::Function(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Function>>> for Stmt {
	fn from(node:&Rc<RefCell<Function>>)-> Self{
		Stmt::Function(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Function>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Function(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Function>>> for Node {
	fn from(node:&Rc<RefCell<Function>>)-> Self{
		Node::Function(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct IntType {
	pub bit_size: u64,
	pub endian: Endian,
	pub is_signed: bool,
	pub loc: Loc,
}

impl TryFrom<&Type> for Rc<RefCell<IntType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::IntType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<IntType>>> for Type {
	fn from(node:&Rc<RefCell<IntType>>)-> Self{
		Type::IntType(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<IntType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::IntType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<IntType>>> for Node {
	fn from(node:&Rc<RefCell<IntType>>)-> Self{
		Node::IntType(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct IdentType {
	pub ident: Option<Rc<RefCell<Ident>>>,
	pub base: Option<Weak<RefCell<Format>>>,
	pub loc: Loc,
}

impl TryFrom<&Type> for Rc<RefCell<IdentType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::IdentType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<IdentType>>> for Type {
	fn from(node:&Rc<RefCell<IdentType>>)-> Self{
		Type::IdentType(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<IdentType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::IdentType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<IdentType>>> for Node {
	fn from(node:&Rc<RefCell<IdentType>>)-> Self{
		Node::IdentType(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct IntLiteralType {
	pub base: Option<Weak<RefCell<IntLiteral>>>,
	pub loc: Loc,
}

impl TryFrom<&Type> for Rc<RefCell<IntLiteralType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::IntLiteralType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<IntLiteralType>>> for Type {
	fn from(node:&Rc<RefCell<IntLiteralType>>)-> Self{
		Type::IntLiteralType(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<IntLiteralType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::IntLiteralType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<IntLiteralType>>> for Node {
	fn from(node:&Rc<RefCell<IntLiteralType>>)-> Self{
		Node::IntLiteralType(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct StrLiteralType {
	pub base: Option<Weak<RefCell<StrLiteral>>>,
	pub loc: Loc,
}

impl TryFrom<&Type> for Rc<RefCell<StrLiteralType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::StrLiteralType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<StrLiteralType>>> for Type {
	fn from(node:&Rc<RefCell<StrLiteralType>>)-> Self{
		Type::StrLiteralType(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<StrLiteralType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::StrLiteralType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<StrLiteralType>>> for Node {
	fn from(node:&Rc<RefCell<StrLiteralType>>)-> Self{
		Node::StrLiteralType(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct VoidType {
	pub loc: Loc,
}

impl TryFrom<&Type> for Rc<RefCell<VoidType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::VoidType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<VoidType>>> for Type {
	fn from(node:&Rc<RefCell<VoidType>>)-> Self{
		Type::VoidType(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<VoidType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::VoidType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<VoidType>>> for Node {
	fn from(node:&Rc<RefCell<VoidType>>)-> Self{
		Node::VoidType(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct BoolType {
	pub loc: Loc,
}

impl TryFrom<&Type> for Rc<RefCell<BoolType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::BoolType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<BoolType>>> for Type {
	fn from(node:&Rc<RefCell<BoolType>>)-> Self{
		Type::BoolType(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<BoolType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::BoolType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<BoolType>>> for Node {
	fn from(node:&Rc<RefCell<BoolType>>)-> Self{
		Node::BoolType(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct ArrayType {
	pub end_loc: Loc,
	pub base_type: Option<Type>,
	pub length: Option<Expr>,
	pub loc: Loc,
}

impl TryFrom<&Type> for Rc<RefCell<ArrayType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::ArrayType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<ArrayType>>> for Type {
	fn from(node:&Rc<RefCell<ArrayType>>)-> Self{
		Type::ArrayType(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<ArrayType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::ArrayType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<ArrayType>>> for Node {
	fn from(node:&Rc<RefCell<ArrayType>>)-> Self{
		Node::ArrayType(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct FunctionType {
	pub return_type: Option<Type>,
	pub parameters: Vec<Type>,
	pub loc: Loc,
}

impl TryFrom<&Type> for Rc<RefCell<FunctionType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::FunctionType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<FunctionType>>> for Type {
	fn from(node:&Rc<RefCell<FunctionType>>)-> Self{
		Type::FunctionType(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<FunctionType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::FunctionType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<FunctionType>>> for Node {
	fn from(node:&Rc<RefCell<FunctionType>>)-> Self{
		Node::FunctionType(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct StructType {
	pub fields: Vec<Member>,
	pub loc: Loc,
}

impl TryFrom<&Type> for Rc<RefCell<StructType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::StructType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<StructType>>> for Type {
	fn from(node:&Rc<RefCell<StructType>>)-> Self{
		Type::StructType(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<StructType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::StructType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<StructType>>> for Node {
	fn from(node:&Rc<RefCell<StructType>>)-> Self{
		Node::StructType(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct UnionType {
	pub fields: Vec<Rc<RefCell<StructType>>>,
	pub loc: Loc,
}

impl TryFrom<&Type> for Rc<RefCell<UnionType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::UnionType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<UnionType>>> for Type {
	fn from(node:&Rc<RefCell<UnionType>>)-> Self{
		Type::UnionType(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<UnionType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::UnionType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<UnionType>>> for Node {
	fn from(node:&Rc<RefCell<UnionType>>)-> Self{
		Node::UnionType(node.clone())
	}
}

#[derive(Debug,Clone)]
pub struct Cast {
	pub expr_type: Option<Type>,
	pub base: Option<Rc<RefCell<Call>>>,
	pub expr: Option<Expr>,
	pub loc: Loc,
}

impl TryFrom<&Expr> for Rc<RefCell<Cast>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Cast(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl From<&Rc<RefCell<Cast>>> for Expr {
	fn from(node:&Rc<RefCell<Cast>>)-> Self{
		Expr::Cast(node.clone())
	}
}

impl TryFrom<&Node> for Rc<RefCell<Cast>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Cast(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl From<&Rc<RefCell<Cast>>> for Node {
	fn from(node:&Rc<RefCell<Cast>>)-> Self{
		Node::Cast(node.clone())
	}
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case",untagged)]
pub enum UnaryOp {
	Not,
	MinusSign,
}

impl TryFrom<&str> for UnaryOp {
	type Error = ();
	fn try_from(s:&str)->Result<Self,()>{
		match s{
			"!" =>Ok(Self::Not),
			"-" =>Ok(Self::MinusSign),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case",untagged)]
pub enum BinaryOp {
	Mul,
	Div,
	Mod,
	LeftArithmeticShift,
	RightArithmeticShift,
	LeftLogicalShift,
	RightLogicalShift,
	BitAnd,
	Add,
	Sub,
	BitOr,
	BitXor,
	Equal,
	NotEqual,
	Less,
	LessOrEq,
	Grater,
	GraterOrEq,
	LogicalAnd,
	LogicalOr,
	CondOp1,
	CondOp2,
	RangeExclusive,
	RangeInclusive,
	Assign,
	DefineAssign,
	ConstAssign,
	AddAssign,
	SubAssign,
	MulAssign,
	DivAssign,
	ModAssign,
	LeftShiftAssign,
	RightShiftAssign,
	BitAndAssign,
	BitOrAssign,
	BitXorAssign,
	Comma,
}

impl TryFrom<&str> for BinaryOp {
	type Error = ();
	fn try_from(s:&str)->Result<Self,()>{
		match s{
			"*" =>Ok(Self::Mul),
			"/" =>Ok(Self::Div),
			"%" =>Ok(Self::Mod),
			"<<<" =>Ok(Self::LeftArithmeticShift),
			">>>" =>Ok(Self::RightArithmeticShift),
			"<<" =>Ok(Self::LeftLogicalShift),
			">>" =>Ok(Self::RightLogicalShift),
			"&" =>Ok(Self::BitAnd),
			"+" =>Ok(Self::Add),
			"-" =>Ok(Self::Sub),
			"|" =>Ok(Self::BitOr),
			"^" =>Ok(Self::BitXor),
			"==" =>Ok(Self::Equal),
			"!=" =>Ok(Self::NotEqual),
			"<" =>Ok(Self::Less),
			"<=" =>Ok(Self::LessOrEq),
			">" =>Ok(Self::Grater),
			">=" =>Ok(Self::GraterOrEq),
			"&&" =>Ok(Self::LogicalAnd),
			"||" =>Ok(Self::LogicalOr),
			"if" =>Ok(Self::CondOp1),
			"else" =>Ok(Self::CondOp2),
			".." =>Ok(Self::RangeExclusive),
			"..=" =>Ok(Self::RangeInclusive),
			"=" =>Ok(Self::Assign),
			":=" =>Ok(Self::DefineAssign),
			"::=" =>Ok(Self::ConstAssign),
			"+=" =>Ok(Self::AddAssign),
			"-=" =>Ok(Self::SubAssign),
			"*=" =>Ok(Self::MulAssign),
			"/=" =>Ok(Self::DivAssign),
			"%=" =>Ok(Self::ModAssign),
			"<<=" =>Ok(Self::LeftShiftAssign),
			">>=" =>Ok(Self::RightShiftAssign),
			"&=" =>Ok(Self::BitAndAssign),
			"|=" =>Ok(Self::BitOrAssign),
			"^=" =>Ok(Self::BitXorAssign),
			"," =>Ok(Self::Comma),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case",untagged)]
pub enum IdentUsage {
	Unknown,
	Reference,
	DefineVariable,
	DefineConst,
	DefineField,
	DefineFormat,
	DefineFn,
	ReferenceType,
}

impl TryFrom<&str> for IdentUsage {
	type Error = ();
	fn try_from(s:&str)->Result<Self,()>{
		match s{
			"unknown" =>Ok(Self::Unknown),
			"reference" =>Ok(Self::Reference),
			"define_variable" =>Ok(Self::DefineVariable),
			"define_const" =>Ok(Self::DefineConst),
			"define_field" =>Ok(Self::DefineField),
			"define_format" =>Ok(Self::DefineFormat),
			"define_fn" =>Ok(Self::DefineFn),
			"reference_type" =>Ok(Self::ReferenceType),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case",untagged)]
pub enum Endian {
	Unspec,
	Big,
	Little,
}

impl TryFrom<&str> for Endian {
	type Error = ();
	fn try_from(s:&str)->Result<Self,()>{
		match s{
			"unspec" =>Ok(Self::Unspec),
			"big" =>Ok(Self::Big),
			"little" =>Ok(Self::Little),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case",untagged)]
pub enum TokenTag {
	Indent,
	Space,
	Line,
	Punct,
	IntLiteral,
	BoolLiteral,
	StrLiteral,
	Keyword,
	Ident,
	Comment,
	Error,
	Unknown,
}

impl TryFrom<&str> for TokenTag {
	type Error = ();
	fn try_from(s:&str)->Result<Self,()>{
		match s{
			"indent" =>Ok(Self::Indent),
			"space" =>Ok(Self::Space),
			"line" =>Ok(Self::Line),
			"punct" =>Ok(Self::Punct),
			"int_literal" =>Ok(Self::IntLiteral),
			"bool_literal" =>Ok(Self::BoolLiteral),
			"str_literal" =>Ok(Self::StrLiteral),
			"keyword" =>Ok(Self::Keyword),
			"ident" =>Ok(Self::Ident),
			"comment" =>Ok(Self::Comment),
			"error" =>Ok(Self::Error),
			"unknown" =>Ok(Self::Unknown),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone)]
pub struct Scope {
	pub prev: Option<Weak<RefCell<Scope>>>,
	pub next: Option<Rc<RefCell<Scope>>>,
	pub branch: Option<Rc<RefCell<Scope>>>,
	pub ident: Vec<Node>,
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
pub struct Loc {
	pub pos: Pos,
	pub file: u64,
	pub line: u64,
	pub col: u64,
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
pub struct Pos {
	pub begin: u64,
	pub end: u64,
}

#[derive(Debug,Clone,Serialize,Deserialize)]
pub struct Token {
	pub tag: TokenTag,
	pub token: String,
	pub loc: Loc,
}

#[derive(Debug,Clone,Serialize,Deserialize)]
pub struct RawNode {
	pub node_type: NodeType,
	pub loc :Loc,
	pub body: HashMap<String,serde_json::Value>,
}

#[derive(Debug,Clone,Serialize,Deserialize)]
pub struct RawScope {
	pub prev :Option<u64>,
	pub next :Option<u64>,
	pub branch :Option<u64>,
	pub ident :Vec<u64>,
}

#[derive(Debug,Clone,Serialize,Deserialize)]
pub struct AST {
	pub node: Vec<RawNode>,
	pub scope: Vec<RawScope>,
}

pub fn parse_ast(ast:AST)->Result<Rc<RefCell<Program>> ,Error>{
	let mut nodes = Vec::new();
	let mut scopes = Vec::new();
	for raw_node in &ast.node{
		let node = match raw_node.node_type {
			NodeType::Program => {
				Node::Program(Rc::new(RefCell::new(Program {
				struct_type: None,
				elements: Vec::new(),
				global_scope: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Binary => {
				Node::Binary(Rc::new(RefCell::new(Binary {
				expr_type: None,
				op: BinaryOp::Mul,
				left: None,
				right: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Unary => {
				Node::Unary(Rc::new(RefCell::new(Unary {
				expr_type: None,
				op: UnaryOp::Not,
				expr: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Cond => {
				Node::Cond(Rc::new(RefCell::new(Cond {
				expr_type: None,
				cond: None,
				then: None,
				els_loc: raw_node.loc.clone(),
				els: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Ident => {
				Node::Ident(Rc::new(RefCell::new(Ident {
				expr_type: None,
				ident: String::new(),
				usage: IdentUsage::Unknown,
				base: None,
				scope: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Call => {
				Node::Call(Rc::new(RefCell::new(Call {
				expr_type: None,
				callee: None,
				raw_arguments: None,
				arguments: Vec::new(),
				end_loc: raw_node.loc.clone(),
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::If => {
				Node::If(Rc::new(RefCell::new(If {
				expr_type: None,
				cond: None,
				then: None,
				els: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::MemberAccess => {
				Node::MemberAccess(Rc::new(RefCell::new(MemberAccess {
				expr_type: None,
				target: None,
				member: String::new(),
				member_loc: raw_node.loc.clone(),
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Paren => {
				Node::Paren(Rc::new(RefCell::new(Paren {
				expr_type: None,
				expr: None,
				end_loc: raw_node.loc.clone(),
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Index => {
				Node::Index(Rc::new(RefCell::new(Index {
				expr_type: None,
				expr: None,
				index: None,
				end_loc: raw_node.loc.clone(),
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Match => {
				Node::Match(Rc::new(RefCell::new(Match {
				expr_type: None,
				cond: None,
				branch: Vec::new(),
				scope: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Range => {
				Node::Range(Rc::new(RefCell::new(Range {
				expr_type: None,
				op: BinaryOp::Mul,
				start: None,
				end: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::TmpVar => {
				Node::TmpVar(Rc::new(RefCell::new(TmpVar {
				expr_type: None,
				tmp_var: 0,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::BlockExpr => {
				Node::BlockExpr(Rc::new(RefCell::new(BlockExpr {
				expr_type: None,
				calls: Vec::new(),
				expr: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Import => {
				Node::Import(Rc::new(RefCell::new(Import {
				expr_type: None,
				path: String::new(),
				base: None,
				import_desc: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::IntLiteral => {
				Node::IntLiteral(Rc::new(RefCell::new(IntLiteral {
				expr_type: None,
				value: String::new(),
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::BoolLiteral => {
				Node::BoolLiteral(Rc::new(RefCell::new(BoolLiteral {
				expr_type: None,
				value: false,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::StrLiteral => {
				Node::StrLiteral(Rc::new(RefCell::new(StrLiteral {
				expr_type: None,
				value: String::new(),
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Input => {
				Node::Input(Rc::new(RefCell::new(Input {
				expr_type: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Output => {
				Node::Output(Rc::new(RefCell::new(Output {
				expr_type: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Config => {
				Node::Config(Rc::new(RefCell::new(Config {
				expr_type: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Loop => {
				Node::Loop(Rc::new(RefCell::new(Loop {
				init: None,
				cond: None,
				step: None,
				body: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::IndentScope => {
				Node::IndentScope(Rc::new(RefCell::new(IndentScope {
				elements: Vec::new(),
				scope: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::MatchBranch => {
				Node::MatchBranch(Rc::new(RefCell::new(MatchBranch {
				cond: None,
				sym_loc: raw_node.loc.clone(),
				then: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Return => {
				Node::Return(Rc::new(RefCell::new(Return {
				expr: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Break => {
				Node::Break(Rc::new(RefCell::new(Break {
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Continue => {
				Node::Continue(Rc::new(RefCell::new(Continue {
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Assert => {
				Node::Assert(Rc::new(RefCell::new(Assert {
				cond: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::ImplicitYield => {
				Node::ImplicitYield(Rc::new(RefCell::new(ImplicitYield {
				expr: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Field => {
				Node::Field(Rc::new(RefCell::new(Field {
				ident: None,
				colon_loc: raw_node.loc.clone(),
				field_type: None,
				raw_arguments: None,
				arguments: Vec::new(),
				belong: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Format => {
				Node::Format(Rc::new(RefCell::new(Format {
				is_enum: false,
				ident: None,
				body: None,
				belong: None,
				struct_type: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Function => {
				Node::Function(Rc::new(RefCell::new(Function {
				ident: None,
				parameters: Vec::new(),
				return_type: None,
				belong: None,
				body: None,
				func_type: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::IntType => {
				Node::IntType(Rc::new(RefCell::new(IntType {
				bit_size: 0,
				endian: Endian::Unspec,
				is_signed: false,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::IdentType => {
				Node::IdentType(Rc::new(RefCell::new(IdentType {
				ident: None,
				base: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::IntLiteralType => {
				Node::IntLiteralType(Rc::new(RefCell::new(IntLiteralType {
				base: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::StrLiteralType => {
				Node::StrLiteralType(Rc::new(RefCell::new(StrLiteralType {
				base: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::VoidType => {
				Node::VoidType(Rc::new(RefCell::new(VoidType {
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::BoolType => {
				Node::BoolType(Rc::new(RefCell::new(BoolType {
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::ArrayType => {
				Node::ArrayType(Rc::new(RefCell::new(ArrayType {
				end_loc: raw_node.loc.clone(),
				base_type: None,
				length: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::FunctionType => {
				Node::FunctionType(Rc::new(RefCell::new(FunctionType {
				return_type: None,
				parameters: Vec::new(),
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::StructType => {
				Node::StructType(Rc::new(RefCell::new(StructType {
				fields: Vec::new(),
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::UnionType => {
				Node::UnionType(Rc::new(RefCell::new(UnionType {
				fields: Vec::new(),
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Cast => {
				Node::Cast(Rc::new(RefCell::new(Cast {
				expr_type: None,
				base: None,
				expr: None,
				loc: raw_node.loc.clone(),
				})))
			},
			_=>return Err(Error::UnknownNodeType(raw_node.node_type)),
		};
		nodes.push(node);
	}
	for _ in &ast.scope{
		let scope = Rc::new(RefCell::new(Scope{
			prev: None,
			next: None,
			branch: None,
			ident: Vec::new(),
		}));
		scopes.push(scope);
	}
	for (i,raw_node) in ast.node.into_iter().enumerate(){
		match raw_node.node_type {
			NodeType::Program => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Program(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let struct_type_body = match raw_node.body.get("struct_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"struct_type")),
				};
				let struct_type_body = match struct_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(struct_type_body.into(),JSONType::Number)),
				};
				let struct_type_body = match nodes.get(struct_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(struct_type_body as usize)),
				};
				let struct_type_body = match struct_type_body {
					Node::StructType(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),struct_type_body.into())),
				};
				node.borrow_mut().struct_type = Some(struct_type_body.clone());
				let elements_body = match raw_node.body.get("elements") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"elements")),
				};
				let elements_body = match elements_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(elements_body.into(),JSONType::Array)),
				};
				for link in elements_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let elements_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					node.borrow_mut().elements.push(elements_body.clone());
				}
				let global_scope_body = match raw_node.body.get("global_scope") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"global_scope")),
				};
				let global_scope_body = match global_scope_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(global_scope_body.into(),JSONType::Number)),
				};
				let global_scope_body = match scopes.get(global_scope_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(global_scope_body as usize)),
				};
				node.borrow_mut().global_scope = Some(global_scope_body.clone());
			},
			NodeType::Binary => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Binary(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				let op_body = match raw_node.body.get("op") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"op")),
				};
				node.borrow_mut().op = match op_body.as_str() {
					Some(v)=>match BinaryOp::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(op_body.into(),JSONType::String)),
				};
				let left_body = match raw_node.body.get("left") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"left")),
				};
				let left_body = match left_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(left_body.into(),JSONType::Number)),
				};
				let left_body = match nodes.get(left_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(left_body as usize)),
				};
				node.borrow_mut().left = Some(left_body.try_into()?);
				let right_body = match raw_node.body.get("right") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"right")),
				};
				let right_body = match right_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(right_body.into(),JSONType::Number)),
				};
				let right_body = match nodes.get(right_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(right_body as usize)),
				};
				node.borrow_mut().right = Some(right_body.try_into()?);
			},
			NodeType::Unary => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Unary(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				let op_body = match raw_node.body.get("op") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"op")),
				};
				node.borrow_mut().op = match op_body.as_str() {
					Some(v)=>match UnaryOp::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(op_body.into(),JSONType::String)),
				};
				let expr_body = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr")),
				};
				let expr_body = match expr_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_body.into(),JSONType::Number)),
				};
				let expr_body = match nodes.get(expr_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_body as usize)),
				};
				node.borrow_mut().expr = Some(expr_body.try_into()?);
			},
			NodeType::Cond => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Cond(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				let cond_body = match raw_node.body.get("cond") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"cond")),
				};
				let cond_body = match cond_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(cond_body.into(),JSONType::Number)),
				};
				let cond_body = match nodes.get(cond_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(cond_body as usize)),
				};
				node.borrow_mut().cond = Some(cond_body.try_into()?);
				let then_body = match raw_node.body.get("then") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"then")),
				};
				let then_body = match then_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(then_body.into(),JSONType::Number)),
				};
				let then_body = match nodes.get(then_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(then_body as usize)),
				};
				node.borrow_mut().then = Some(then_body.try_into()?);
				let els_loc_body = match raw_node.body.get("els_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"els_loc")),
				};
				node.borrow_mut().els_loc = match serde_json::from_value(els_loc_body.clone()) {
					Ok(v)=>v,
					Err(e)=>return Err(Error::JSONError(e)),
				};
				let els_body = match raw_node.body.get("els") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"els")),
				};
				let els_body = match els_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(els_body.into(),JSONType::Number)),
				};
				let els_body = match nodes.get(els_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(els_body as usize)),
				};
				node.borrow_mut().els = Some(els_body.try_into()?);
			},
			NodeType::Ident => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Ident(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				let ident_body = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"ident")),
				};
				node.borrow_mut().ident = match ident_body.as_str() {
					Some(v)=>v.to_string(),
					None=>return Err(Error::MismatchJSONType(ident_body.into(),JSONType::String)),
				};
				let usage_body = match raw_node.body.get("usage") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"usage")),
				};
				node.borrow_mut().usage = match usage_body.as_str() {
					Some(v)=>match IdentUsage::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(usage_body.into(),JSONType::String)),
				};
				let base_body = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"base")),
				};
				let base_body = match base_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(base_body.into(),JSONType::Number)),
				};
				let base_body = match nodes.get(base_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(base_body as usize)),
				};
				node.borrow_mut().base = Some(base_body.clone());
				let scope_body = match raw_node.body.get("scope") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"scope")),
				};
				let scope_body = match scope_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(scope_body.into(),JSONType::Number)),
				};
				let scope_body = match scopes.get(scope_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(scope_body as usize)),
				};
				node.borrow_mut().scope = Some(scope_body.clone());
			},
			NodeType::Call => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Call(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				let callee_body = match raw_node.body.get("callee") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"callee")),
				};
				let callee_body = match callee_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(callee_body.into(),JSONType::Number)),
				};
				let callee_body = match nodes.get(callee_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(callee_body as usize)),
				};
				node.borrow_mut().callee = Some(callee_body.try_into()?);
				let raw_arguments_body = match raw_node.body.get("raw_arguments") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"raw_arguments")),
				};
				let raw_arguments_body = match raw_arguments_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(raw_arguments_body.into(),JSONType::Number)),
				};
				let raw_arguments_body = match nodes.get(raw_arguments_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(raw_arguments_body as usize)),
				};
				node.borrow_mut().raw_arguments = Some(raw_arguments_body.try_into()?);
				let arguments_body = match raw_node.body.get("arguments") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"arguments")),
				};
				let arguments_body = match arguments_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(arguments_body.into(),JSONType::Array)),
				};
				for link in arguments_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let arguments_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					node.borrow_mut().arguments.push(arguments_body.try_into()?);
				}
				let end_loc_body = match raw_node.body.get("end_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"end_loc")),
				};
				node.borrow_mut().end_loc = match serde_json::from_value(end_loc_body.clone()) {
					Ok(v)=>v,
					Err(e)=>return Err(Error::JSONError(e)),
				};
			},
			NodeType::If => {
				let node = nodes[i].clone();
				let node = match node {
					Node::If(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				let cond_body = match raw_node.body.get("cond") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"cond")),
				};
				let cond_body = match cond_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(cond_body.into(),JSONType::Number)),
				};
				let cond_body = match nodes.get(cond_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(cond_body as usize)),
				};
				node.borrow_mut().cond = Some(cond_body.try_into()?);
				let then_body = match raw_node.body.get("then") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"then")),
				};
				let then_body = match then_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(then_body.into(),JSONType::Number)),
				};
				let then_body = match nodes.get(then_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(then_body as usize)),
				};
				let then_body = match then_body {
					Node::IndentScope(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),then_body.into())),
				};
				node.borrow_mut().then = Some(then_body.clone());
				let els_body = match raw_node.body.get("els") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"els")),
				};
				let els_body = match els_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(els_body.into(),JSONType::Number)),
				};
				let els_body = match nodes.get(els_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(els_body as usize)),
				};
				node.borrow_mut().els = Some(els_body.clone());
			},
			NodeType::MemberAccess => {
				let node = nodes[i].clone();
				let node = match node {
					Node::MemberAccess(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				let target_body = match raw_node.body.get("target") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"target")),
				};
				let target_body = match target_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(target_body.into(),JSONType::Number)),
				};
				let target_body = match nodes.get(target_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(target_body as usize)),
				};
				node.borrow_mut().target = Some(target_body.try_into()?);
				let member_body = match raw_node.body.get("member") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"member")),
				};
				node.borrow_mut().member = match member_body.as_str() {
					Some(v)=>v.to_string(),
					None=>return Err(Error::MismatchJSONType(member_body.into(),JSONType::String)),
				};
				let member_loc_body = match raw_node.body.get("member_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"member_loc")),
				};
				node.borrow_mut().member_loc = match serde_json::from_value(member_loc_body.clone()) {
					Ok(v)=>v,
					Err(e)=>return Err(Error::JSONError(e)),
				};
			},
			NodeType::Paren => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Paren(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				let expr_body = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr")),
				};
				let expr_body = match expr_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_body.into(),JSONType::Number)),
				};
				let expr_body = match nodes.get(expr_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_body as usize)),
				};
				node.borrow_mut().expr = Some(expr_body.try_into()?);
				let end_loc_body = match raw_node.body.get("end_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"end_loc")),
				};
				node.borrow_mut().end_loc = match serde_json::from_value(end_loc_body.clone()) {
					Ok(v)=>v,
					Err(e)=>return Err(Error::JSONError(e)),
				};
			},
			NodeType::Index => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Index(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				let expr_body = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr")),
				};
				let expr_body = match expr_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_body.into(),JSONType::Number)),
				};
				let expr_body = match nodes.get(expr_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_body as usize)),
				};
				node.borrow_mut().expr = Some(expr_body.try_into()?);
				let index_body = match raw_node.body.get("index") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"index")),
				};
				let index_body = match index_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(index_body.into(),JSONType::Number)),
				};
				let index_body = match nodes.get(index_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(index_body as usize)),
				};
				node.borrow_mut().index = Some(index_body.try_into()?);
				let end_loc_body = match raw_node.body.get("end_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"end_loc")),
				};
				node.borrow_mut().end_loc = match serde_json::from_value(end_loc_body.clone()) {
					Ok(v)=>v,
					Err(e)=>return Err(Error::JSONError(e)),
				};
			},
			NodeType::Match => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Match(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				let cond_body = match raw_node.body.get("cond") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"cond")),
				};
				let cond_body = match cond_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(cond_body.into(),JSONType::Number)),
				};
				let cond_body = match nodes.get(cond_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(cond_body as usize)),
				};
				node.borrow_mut().cond = Some(cond_body.try_into()?);
				let branch_body = match raw_node.body.get("branch") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"branch")),
				};
				let branch_body = match branch_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(branch_body.into(),JSONType::Array)),
				};
				for link in branch_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let branch_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					let branch_body = match branch_body {
						Node::MatchBranch(body)=>body,
						x =>return Err(Error::MismatchNodeType(x.into(),branch_body.into())),
					};
					node.borrow_mut().branch.push(branch_body.clone());
				}
				let scope_body = match raw_node.body.get("scope") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"scope")),
				};
				let scope_body = match scope_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(scope_body.into(),JSONType::Number)),
				};
				let scope_body = match scopes.get(scope_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(scope_body as usize)),
				};
				node.borrow_mut().scope = Some(scope_body.clone());
			},
			NodeType::Range => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Range(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				let op_body = match raw_node.body.get("op") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"op")),
				};
				node.borrow_mut().op = match op_body.as_str() {
					Some(v)=>match BinaryOp::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(op_body.into(),JSONType::String)),
				};
				let start_body = match raw_node.body.get("start") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"start")),
				};
				let start_body = match start_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(start_body.into(),JSONType::Number)),
				};
				let start_body = match nodes.get(start_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(start_body as usize)),
				};
				node.borrow_mut().start = Some(start_body.try_into()?);
				let end_body = match raw_node.body.get("end") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"end")),
				};
				let end_body = match end_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(end_body.into(),JSONType::Number)),
				};
				let end_body = match nodes.get(end_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(end_body as usize)),
				};
				node.borrow_mut().end = Some(end_body.try_into()?);
			},
			NodeType::TmpVar => {
				let node = nodes[i].clone();
				let node = match node {
					Node::TmpVar(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				let tmp_var_body = match raw_node.body.get("tmp_var") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"tmp_var")),
				};
				node.borrow_mut().tmp_var = match tmp_var_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(tmp_var_body.into(),JSONType::Number)),
				};
			},
			NodeType::BlockExpr => {
				let node = nodes[i].clone();
				let node = match node {
					Node::BlockExpr(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				let calls_body = match raw_node.body.get("calls") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"calls")),
				};
				let calls_body = match calls_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(calls_body.into(),JSONType::Array)),
				};
				for link in calls_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let calls_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					node.borrow_mut().calls.push(calls_body.clone());
				}
				let expr_body = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr")),
				};
				let expr_body = match expr_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_body.into(),JSONType::Number)),
				};
				let expr_body = match nodes.get(expr_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_body as usize)),
				};
				node.borrow_mut().expr = Some(expr_body.try_into()?);
			},
			NodeType::Import => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Import(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				let path_body = match raw_node.body.get("path") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"path")),
				};
				node.borrow_mut().path = match path_body.as_str() {
					Some(v)=>v.to_string(),
					None=>return Err(Error::MismatchJSONType(path_body.into(),JSONType::String)),
				};
				let base_body = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"base")),
				};
				let base_body = match base_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(base_body.into(),JSONType::Number)),
				};
				let base_body = match nodes.get(base_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(base_body as usize)),
				};
				let base_body = match base_body {
					Node::Call(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),base_body.into())),
				};
				node.borrow_mut().base = Some(base_body.clone());
				let import_desc_body = match raw_node.body.get("import_desc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"import_desc")),
				};
				let import_desc_body = match import_desc_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(import_desc_body.into(),JSONType::Number)),
				};
				let import_desc_body = match nodes.get(import_desc_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(import_desc_body as usize)),
				};
				let import_desc_body = match import_desc_body {
					Node::Program(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),import_desc_body.into())),
				};
				node.borrow_mut().import_desc = Some(import_desc_body.clone());
			},
			NodeType::IntLiteral => {
				let node = nodes[i].clone();
				let node = match node {
					Node::IntLiteral(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				let value_body = match raw_node.body.get("value") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"value")),
				};
				node.borrow_mut().value = match value_body.as_str() {
					Some(v)=>v.to_string(),
					None=>return Err(Error::MismatchJSONType(value_body.into(),JSONType::String)),
				};
			},
			NodeType::BoolLiteral => {
				let node = nodes[i].clone();
				let node = match node {
					Node::BoolLiteral(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				let value_body = match raw_node.body.get("value") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"value")),
				};
				node.borrow_mut().value = match value_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(value_body.into(),JSONType::Bool)),
				};
			},
			NodeType::StrLiteral => {
				let node = nodes[i].clone();
				let node = match node {
					Node::StrLiteral(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				let value_body = match raw_node.body.get("value") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"value")),
				};
				node.borrow_mut().value = match value_body.as_str() {
					Some(v)=>v.to_string(),
					None=>return Err(Error::MismatchJSONType(value_body.into(),JSONType::String)),
				};
			},
			NodeType::Input => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Input(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
			},
			NodeType::Output => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Output(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
			},
			NodeType::Config => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Config(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
			},
			NodeType::Loop => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Loop(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let init_body = match raw_node.body.get("init") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"init")),
				};
				let init_body = match init_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(init_body.into(),JSONType::Number)),
				};
				let init_body = match nodes.get(init_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(init_body as usize)),
				};
				node.borrow_mut().init = Some(init_body.try_into()?);
				let cond_body = match raw_node.body.get("cond") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"cond")),
				};
				let cond_body = match cond_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(cond_body.into(),JSONType::Number)),
				};
				let cond_body = match nodes.get(cond_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(cond_body as usize)),
				};
				node.borrow_mut().cond = Some(cond_body.try_into()?);
				let step_body = match raw_node.body.get("step") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"step")),
				};
				let step_body = match step_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(step_body.into(),JSONType::Number)),
				};
				let step_body = match nodes.get(step_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(step_body as usize)),
				};
				node.borrow_mut().step = Some(step_body.try_into()?);
				let body_body = match raw_node.body.get("body") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"body")),
				};
				let body_body = match body_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(body_body.into(),JSONType::Number)),
				};
				let body_body = match nodes.get(body_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(body_body as usize)),
				};
				let body_body = match body_body {
					Node::IndentScope(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),body_body.into())),
				};
				node.borrow_mut().body = Some(body_body.clone());
			},
			NodeType::IndentScope => {
				let node = nodes[i].clone();
				let node = match node {
					Node::IndentScope(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let elements_body = match raw_node.body.get("elements") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"elements")),
				};
				let elements_body = match elements_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(elements_body.into(),JSONType::Array)),
				};
				for link in elements_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let elements_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					node.borrow_mut().elements.push(elements_body.clone());
				}
				let scope_body = match raw_node.body.get("scope") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"scope")),
				};
				let scope_body = match scope_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(scope_body.into(),JSONType::Number)),
				};
				let scope_body = match scopes.get(scope_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(scope_body as usize)),
				};
				node.borrow_mut().scope = Some(scope_body.clone());
			},
			NodeType::MatchBranch => {
				let node = nodes[i].clone();
				let node = match node {
					Node::MatchBranch(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let cond_body = match raw_node.body.get("cond") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"cond")),
				};
				let cond_body = match cond_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(cond_body.into(),JSONType::Number)),
				};
				let cond_body = match nodes.get(cond_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(cond_body as usize)),
				};
				node.borrow_mut().cond = Some(cond_body.try_into()?);
				let sym_loc_body = match raw_node.body.get("sym_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"sym_loc")),
				};
				node.borrow_mut().sym_loc = match serde_json::from_value(sym_loc_body.clone()) {
					Ok(v)=>v,
					Err(e)=>return Err(Error::JSONError(e)),
				};
				let then_body = match raw_node.body.get("then") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"then")),
				};
				let then_body = match then_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(then_body.into(),JSONType::Number)),
				};
				let then_body = match nodes.get(then_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(then_body as usize)),
				};
				node.borrow_mut().then = Some(then_body.clone());
			},
			NodeType::Return => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Return(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_body = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr")),
				};
				let expr_body = match expr_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_body.into(),JSONType::Number)),
				};
				let expr_body = match nodes.get(expr_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_body as usize)),
				};
				node.borrow_mut().expr = Some(expr_body.try_into()?);
			},
			NodeType::Break => {
				let node = nodes[i].clone();
				let _ = match node {
					Node::Break(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
			},
			NodeType::Continue => {
				let node = nodes[i].clone();
				let _ = match node {
					Node::Continue(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
			},
			NodeType::Assert => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Assert(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let cond_body = match raw_node.body.get("cond") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"cond")),
				};
				let cond_body = match cond_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(cond_body.into(),JSONType::Number)),
				};
				let cond_body = match nodes.get(cond_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(cond_body as usize)),
				};
				let cond_body = match cond_body {
					Node::Binary(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),cond_body.into())),
				};
				node.borrow_mut().cond = Some(cond_body.clone());
			},
			NodeType::ImplicitYield => {
				let node = nodes[i].clone();
				let node = match node {
					Node::ImplicitYield(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_body = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr")),
				};
				let expr_body = match expr_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_body.into(),JSONType::Number)),
				};
				let expr_body = match nodes.get(expr_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_body as usize)),
				};
				node.borrow_mut().expr = Some(expr_body.try_into()?);
			},
			NodeType::Field => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Field(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let ident_body = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"ident")),
				};
				let ident_body = match ident_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(ident_body.into(),JSONType::Number)),
				};
				let ident_body = match nodes.get(ident_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(ident_body as usize)),
				};
				let ident_body = match ident_body {
					Node::Ident(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),ident_body.into())),
				};
				node.borrow_mut().ident = Some(ident_body.clone());
				let colon_loc_body = match raw_node.body.get("colon_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"colon_loc")),
				};
				node.borrow_mut().colon_loc = match serde_json::from_value(colon_loc_body.clone()) {
					Ok(v)=>v,
					Err(e)=>return Err(Error::JSONError(e)),
				};
				let field_type_body = match raw_node.body.get("field_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"field_type")),
				};
				let field_type_body = match field_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(field_type_body.into(),JSONType::Number)),
				};
				let field_type_body = match nodes.get(field_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(field_type_body as usize)),
				};
				node.borrow_mut().field_type = Some(field_type_body.try_into()?);
				let raw_arguments_body = match raw_node.body.get("raw_arguments") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"raw_arguments")),
				};
				let raw_arguments_body = match raw_arguments_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(raw_arguments_body.into(),JSONType::Number)),
				};
				let raw_arguments_body = match nodes.get(raw_arguments_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(raw_arguments_body as usize)),
				};
				node.borrow_mut().raw_arguments = Some(raw_arguments_body.try_into()?);
				let arguments_body = match raw_node.body.get("arguments") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"arguments")),
				};
				let arguments_body = match arguments_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(arguments_body.into(),JSONType::Array)),
				};
				for link in arguments_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let arguments_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					node.borrow_mut().arguments.push(arguments_body.try_into()?);
				}
				let belong_body = match raw_node.body.get("belong") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"belong")),
				};
				let belong_body = match belong_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(belong_body.into(),JSONType::Number)),
				};
				let belong_body = match nodes.get(belong_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(belong_body as usize)),
				};
				let belong_body = match belong_body {
					Node::Format(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),belong_body.into())),
				};
				node.borrow_mut().belong = Some(Rc::downgrade(&belong_body));
			},
			NodeType::Format => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Format(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let is_enum_body = match raw_node.body.get("is_enum") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"is_enum")),
				};
				node.borrow_mut().is_enum = match is_enum_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_enum_body.into(),JSONType::Bool)),
				};
				let ident_body = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"ident")),
				};
				let ident_body = match ident_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(ident_body.into(),JSONType::Number)),
				};
				let ident_body = match nodes.get(ident_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(ident_body as usize)),
				};
				let ident_body = match ident_body {
					Node::Ident(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),ident_body.into())),
				};
				node.borrow_mut().ident = Some(ident_body.clone());
				let body_body = match raw_node.body.get("body") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"body")),
				};
				let body_body = match body_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(body_body.into(),JSONType::Number)),
				};
				let body_body = match nodes.get(body_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(body_body as usize)),
				};
				let body_body = match body_body {
					Node::IndentScope(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),body_body.into())),
				};
				node.borrow_mut().body = Some(body_body.clone());
				let belong_body = match raw_node.body.get("belong") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"belong")),
				};
				let belong_body = match belong_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(belong_body.into(),JSONType::Number)),
				};
				let belong_body = match nodes.get(belong_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(belong_body as usize)),
				};
				let belong_body = match belong_body {
					Node::Format(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),belong_body.into())),
				};
				node.borrow_mut().belong = Some(Rc::downgrade(&belong_body));
				let struct_type_body = match raw_node.body.get("struct_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"struct_type")),
				};
				let struct_type_body = match struct_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(struct_type_body.into(),JSONType::Number)),
				};
				let struct_type_body = match nodes.get(struct_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(struct_type_body as usize)),
				};
				let struct_type_body = match struct_type_body {
					Node::StructType(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),struct_type_body.into())),
				};
				node.borrow_mut().struct_type = Some(struct_type_body.clone());
			},
			NodeType::Function => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Function(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let ident_body = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"ident")),
				};
				let ident_body = match ident_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(ident_body.into(),JSONType::Number)),
				};
				let ident_body = match nodes.get(ident_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(ident_body as usize)),
				};
				let ident_body = match ident_body {
					Node::Ident(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),ident_body.into())),
				};
				node.borrow_mut().ident = Some(ident_body.clone());
				let parameters_body = match raw_node.body.get("parameters") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"parameters")),
				};
				let parameters_body = match parameters_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(parameters_body.into(),JSONType::Array)),
				};
				for link in parameters_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let parameters_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					let parameters_body = match parameters_body {
						Node::Field(body)=>body,
						x =>return Err(Error::MismatchNodeType(x.into(),parameters_body.into())),
					};
					node.borrow_mut().parameters.push(parameters_body.clone());
				}
				let return_type_body = match raw_node.body.get("return_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"return_type")),
				};
				let return_type_body = match return_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(return_type_body.into(),JSONType::Number)),
				};
				let return_type_body = match nodes.get(return_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(return_type_body as usize)),
				};
				node.borrow_mut().return_type = Some(return_type_body.try_into()?);
				let belong_body = match raw_node.body.get("belong") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"belong")),
				};
				let belong_body = match belong_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(belong_body.into(),JSONType::Number)),
				};
				let belong_body = match nodes.get(belong_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(belong_body as usize)),
				};
				let belong_body = match belong_body {
					Node::Format(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),belong_body.into())),
				};
				node.borrow_mut().belong = Some(Rc::downgrade(&belong_body));
				let body_body = match raw_node.body.get("body") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"body")),
				};
				let body_body = match body_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(body_body.into(),JSONType::Number)),
				};
				let body_body = match nodes.get(body_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(body_body as usize)),
				};
				let body_body = match body_body {
					Node::IndentScope(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),body_body.into())),
				};
				node.borrow_mut().body = Some(body_body.clone());
				let func_type_body = match raw_node.body.get("func_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"func_type")),
				};
				let func_type_body = match func_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(func_type_body.into(),JSONType::Number)),
				};
				let func_type_body = match nodes.get(func_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(func_type_body as usize)),
				};
				let func_type_body = match func_type_body {
					Node::FunctionType(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),func_type_body.into())),
				};
				node.borrow_mut().func_type = Some(func_type_body.clone());
			},
			NodeType::IntType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::IntType(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let bit_size_body = match raw_node.body.get("bit_size") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"bit_size")),
				};
				node.borrow_mut().bit_size = match bit_size_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(bit_size_body.into(),JSONType::Number)),
				};
				let endian_body = match raw_node.body.get("endian") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"endian")),
				};
				node.borrow_mut().endian = match endian_body.as_str() {
					Some(v)=>match Endian::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(endian_body.into(),JSONType::String)),
				};
				let is_signed_body = match raw_node.body.get("is_signed") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"is_signed")),
				};
				node.borrow_mut().is_signed = match is_signed_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_signed_body.into(),JSONType::Bool)),
				};
			},
			NodeType::IdentType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::IdentType(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let ident_body = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"ident")),
				};
				let ident_body = match ident_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(ident_body.into(),JSONType::Number)),
				};
				let ident_body = match nodes.get(ident_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(ident_body as usize)),
				};
				let ident_body = match ident_body {
					Node::Ident(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),ident_body.into())),
				};
				node.borrow_mut().ident = Some(ident_body.clone());
				let base_body = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"base")),
				};
				let base_body = match base_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(base_body.into(),JSONType::Number)),
				};
				let base_body = match nodes.get(base_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(base_body as usize)),
				};
				let base_body = match base_body {
					Node::Format(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),base_body.into())),
				};
				node.borrow_mut().base = Some(Rc::downgrade(&base_body));
			},
			NodeType::IntLiteralType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::IntLiteralType(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let base_body = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"base")),
				};
				let base_body = match base_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(base_body.into(),JSONType::Number)),
				};
				let base_body = match nodes.get(base_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(base_body as usize)),
				};
				let base_body = match base_body {
					Node::IntLiteral(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),base_body.into())),
				};
				node.borrow_mut().base = Some(Rc::downgrade(&base_body));
			},
			NodeType::StrLiteralType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::StrLiteralType(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let base_body = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"base")),
				};
				let base_body = match base_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(base_body.into(),JSONType::Number)),
				};
				let base_body = match nodes.get(base_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(base_body as usize)),
				};
				let base_body = match base_body {
					Node::StrLiteral(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),base_body.into())),
				};
				node.borrow_mut().base = Some(Rc::downgrade(&base_body));
			},
			NodeType::VoidType => {
				let node = nodes[i].clone();
				let _ = match node {
					Node::VoidType(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
			},
			NodeType::BoolType => {
				let node = nodes[i].clone();
				let _ = match node {
					Node::BoolType(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
			},
			NodeType::ArrayType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::ArrayType(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let end_loc_body = match raw_node.body.get("end_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"end_loc")),
				};
				node.borrow_mut().end_loc = match serde_json::from_value(end_loc_body.clone()) {
					Ok(v)=>v,
					Err(e)=>return Err(Error::JSONError(e)),
				};
				let base_type_body = match raw_node.body.get("base_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"base_type")),
				};
				let base_type_body = match base_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(base_type_body.into(),JSONType::Number)),
				};
				let base_type_body = match nodes.get(base_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(base_type_body as usize)),
				};
				node.borrow_mut().base_type = Some(base_type_body.try_into()?);
				let length_body = match raw_node.body.get("length") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"length")),
				};
				let length_body = match length_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(length_body.into(),JSONType::Number)),
				};
				let length_body = match nodes.get(length_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(length_body as usize)),
				};
				node.borrow_mut().length = Some(length_body.try_into()?);
			},
			NodeType::FunctionType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::FunctionType(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let return_type_body = match raw_node.body.get("return_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"return_type")),
				};
				let return_type_body = match return_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(return_type_body.into(),JSONType::Number)),
				};
				let return_type_body = match nodes.get(return_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(return_type_body as usize)),
				};
				node.borrow_mut().return_type = Some(return_type_body.try_into()?);
				let parameters_body = match raw_node.body.get("parameters") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"parameters")),
				};
				let parameters_body = match parameters_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(parameters_body.into(),JSONType::Array)),
				};
				for link in parameters_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let parameters_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					node.borrow_mut().parameters.push(parameters_body.try_into()?);
				}
			},
			NodeType::StructType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::StructType(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let fields_body = match raw_node.body.get("fields") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"fields")),
				};
				let fields_body = match fields_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(fields_body.into(),JSONType::Array)),
				};
				for link in fields_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let fields_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					node.borrow_mut().fields.push(fields_body.try_into()?);
				}
			},
			NodeType::UnionType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::UnionType(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let fields_body = match raw_node.body.get("fields") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"fields")),
				};
				let fields_body = match fields_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(fields_body.into(),JSONType::Array)),
				};
				for link in fields_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let fields_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					let fields_body = match fields_body {
						Node::StructType(body)=>body,
						x =>return Err(Error::MismatchNodeType(x.into(),fields_body.into())),
					};
					node.borrow_mut().fields.push(fields_body.clone());
				}
			},
			NodeType::Cast => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Cast(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let expr_type_body = match expr_type_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
				};
				let expr_type_body = match nodes.get(expr_type_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
				};
				node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				let base_body = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"base")),
				};
				let base_body = match base_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(base_body.into(),JSONType::Number)),
				};
				let base_body = match nodes.get(base_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(base_body as usize)),
				};
				let base_body = match base_body {
					Node::Call(node)=>node,
					x =>return Err(Error::MismatchNodeType(x.into(),base_body.into())),
				};
				node.borrow_mut().base = Some(base_body.clone());
				let expr_body = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr")),
				};
				let expr_body = match expr_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(expr_body.into(),JSONType::Number)),
				};
				let expr_body = match nodes.get(expr_body as usize) {
					Some(v)=>v,
					None => return Err(Error::IndexOutOfBounds(expr_body as usize)),
				};
				node.borrow_mut().expr = Some(expr_body.try_into()?);
			},
			_=>return Err(Error::UnknownNodeType(raw_node.node_type)),
		};
	}
	for (i,raw_scope) in ast.scope.into_iter().enumerate(){
		let scope = scopes[i].clone();
		if let Some(prev) = raw_scope.prev{
			let prev = match scopes.get(prev as usize) {
				Some(v)=>v,
				None =>return Err(Error::IndexOutOfBounds(prev as usize)),
			};
			scope.borrow_mut().prev = Some(Rc::downgrade(&prev));
		}
		if let Some(next) = raw_scope.next{
			let next = match scopes.get(next as usize) {
				Some(v)=>v,
				None =>return Err(Error::IndexOutOfBounds(next as usize)),
			};
			scope.borrow_mut().next = Some(next.clone());
		}
		if let Some(branch) = raw_scope.branch{
			let branch = match scopes.get(branch as usize) {
				Some(v)=>v,
				None =>return Err(Error::IndexOutOfBounds(branch as usize)),
			};
			scope.borrow_mut().branch = Some(branch.clone());
		}
		for ident in &raw_scope.ident{
			let ident = match nodes.get(*ident as usize) {
				Some(v)=>v,
				None =>return Err(Error::IndexOutOfBounds(*ident as usize)),
			};
			scope.borrow_mut().ident.push(ident.clone());
		}
	}

	match nodes.get(0){
		Some(v)=> match v {
			Node::Program(v)=>Ok(v.clone()),
			_=> Err(Error::MismatchNodeType(NodeType::Program,v.into())),
		},
		None=>Err(Error::IndexOutOfBounds(0)),
	}
}

pub fn walk_node<F:FnMut(&Node)->bool>(node:&Node,f:&mut F){
	if !f(node){
		return;
	}
	match node {
		Node::Program(node)=>{
			if let Some(node) = &node.borrow().struct_type{
				walk_node(&node.into(),f);
			}
			for node in &node.borrow().elements{
				walk_node(node,f);
			}
		},
		Node::Binary(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().left{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().right{
				walk_node(&node.into(),f);
			}
		},
		Node::Unary(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().expr{
				walk_node(&node.into(),f);
			}
		},
		Node::Cond(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().cond{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().then{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().els{
				walk_node(&node.into(),f);
			}
		},
		Node::Ident(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
		},
		Node::Call(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().callee{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().raw_arguments{
				walk_node(&node.into(),f);
			}
			for node in &node.borrow().arguments{
				walk_node(&node.into(),f);
			}
		},
		Node::If(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().cond{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().then{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().els{
				walk_node(node,f);
			}
		},
		Node::MemberAccess(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().target{
				walk_node(&node.into(),f);
			}
		},
		Node::Paren(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().expr{
				walk_node(&node.into(),f);
			}
		},
		Node::Index(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().expr{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().index{
				walk_node(&node.into(),f);
			}
		},
		Node::Match(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().cond{
				walk_node(&node.into(),f);
			}
			for node in &node.borrow().branch{
				walk_node(&node.into(),f);
			}
		},
		Node::Range(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().start{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().end{
				walk_node(&node.into(),f);
			}
		},
		Node::TmpVar(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
		},
		Node::BlockExpr(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
			for node in &node.borrow().calls{
				walk_node(node,f);
			}
			if let Some(node) = &node.borrow().expr{
				walk_node(&node.into(),f);
			}
		},
		Node::Import(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().base{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().import_desc{
				walk_node(&node.into(),f);
			}
		},
		Node::IntLiteral(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
		},
		Node::BoolLiteral(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
		},
		Node::StrLiteral(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
		},
		Node::Input(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
		},
		Node::Output(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
		},
		Node::Config(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
		},
		Node::Loop(node)=>{
			if let Some(node) = &node.borrow().init{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().cond{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().step{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().body{
				walk_node(&node.into(),f);
			}
		},
		Node::IndentScope(node)=>{
			for node in &node.borrow().elements{
				walk_node(node,f);
			}
		},
		Node::MatchBranch(node)=>{
			if let Some(node) = &node.borrow().cond{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().then{
				walk_node(node,f);
			}
		},
		Node::Return(node)=>{
			if let Some(node) = &node.borrow().expr{
				walk_node(&node.into(),f);
			}
		},
		Node::Break(node)=>{
		},
		Node::Continue(node)=>{
		},
		Node::Assert(node)=>{
			if let Some(node) = &node.borrow().cond{
				walk_node(&node.into(),f);
			}
		},
		Node::ImplicitYield(node)=>{
			if let Some(node) = &node.borrow().expr{
				walk_node(&node.into(),f);
			}
		},
		Node::Field(node)=>{
			if let Some(node) = &node.borrow().ident{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().field_type{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().raw_arguments{
				walk_node(&node.into(),f);
			}
			for node in &node.borrow().arguments{
				walk_node(&node.into(),f);
			}
		},
		Node::Format(node)=>{
			if let Some(node) = &node.borrow().ident{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().body{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().struct_type{
				walk_node(&node.into(),f);
			}
		},
		Node::Function(node)=>{
			if let Some(node) = &node.borrow().ident{
				walk_node(&node.into(),f);
			}
			for node in &node.borrow().parameters{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().return_type{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().body{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().func_type{
				walk_node(&node.into(),f);
			}
		},
		Node::IntType(node)=>{
		},
		Node::IdentType(node)=>{
			if let Some(node) = &node.borrow().ident{
				walk_node(&node.into(),f);
			}
		},
		Node::IntLiteralType(node)=>{
		},
		Node::StrLiteralType(node)=>{
		},
		Node::VoidType(node)=>{
		},
		Node::BoolType(node)=>{
		},
		Node::ArrayType(node)=>{
			if let Some(node) = &node.borrow().base_type{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().length{
				walk_node(&node.into(),f);
			}
		},
		Node::FunctionType(node)=>{
			if let Some(node) = &node.borrow().return_type{
				walk_node(&node.into(),f);
			}
			for node in &node.borrow().parameters{
				walk_node(&node.into(),f);
			}
		},
		Node::StructType(node)=>{
			for node in &node.borrow().fields{
				walk_node(&node.into(),f);
			}
		},
		Node::UnionType(node)=>{
			for node in &node.borrow().fields{
				walk_node(&node.into(),f);
			}
		},
		Node::Cast(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().base{
				walk_node(&node.into(),f);
			}
			if let Some(node) = &node.borrow().expr{
				walk_node(&node.into(),f);
			}
		},
	}
}

