// Code generated by ast2rust. DO NOT EDIT.
use std::rc::{Rc,Weak};
use std::cell::RefCell;
use std::convert::TryFrom;
use serde_derive::{Serialize,Deserialize};

use std::collections::HashMap;

#[derive(Debug)]
pub enum JSONType {
	Null,
	Bool,
	Number,
	String,
	Array,
	Object,
}

impl From<&serde_json::Value> for JSONType {
	fn from(v:&serde_json::Value)->Self{
		match v{
			serde_json::Value::Null=>Self::Null,
			serde_json::Value::Bool(_)=>Self::Bool,
			serde_json::Value::Number(_)=>Self::Number,
			serde_json::Value::String(_)=>Self::String,
			serde_json::Value::Array(_)=>Self::Array,
			serde_json::Value::Object(_)=>Self::Object,
		}
	}
}

#[derive(Debug)]
pub enum Error {
	UnknownNodeType(NodeType),
	MismatchNodeType(NodeType,NodeType),
	JSONError(serde_json::Error),
	MissingField(NodeType,&'static str),
	MismatchJSONType(JSONType,JSONType),
	InvalidNodeType(NodeType),
 	InvalidRawNodeType(String),
	IndexOutOfBounds(usize),
	InvalidEnumValue(String),
}

impl From<&Node> for NodeType {
	fn from(node:&Node)-> Self{
		match node {
			Node::Program(_) => Self::Program,
			Node::Comment(_) => Self::Comment,
			Node::CommentGroup(_) => Self::CommentGroup,
			Node::FieldArgument(_) => Self::FieldArgument,
			Node::Binary(_) => Self::Binary,
			Node::Unary(_) => Self::Unary,
			Node::Cond(_) => Self::Cond,
			Node::Ident(_) => Self::Ident,
			Node::Call(_) => Self::Call,
			Node::If(_) => Self::If,
			Node::MemberAccess(_) => Self::MemberAccess,
			Node::Paren(_) => Self::Paren,
			Node::Index(_) => Self::Index,
			Node::Match(_) => Self::Match,
			Node::Range(_) => Self::Range,
			Node::TmpVar(_) => Self::TmpVar,
			Node::Import(_) => Self::Import,
			Node::Cast(_) => Self::Cast,
			Node::Available(_) => Self::Available,
			Node::SpecifyOrder(_) => Self::SpecifyOrder,
			Node::ExplicitError(_) => Self::ExplicitError,
			Node::IoOperation(_) => Self::IoOperation,
			Node::Loop(_) => Self::Loop,
			Node::IndentBlock(_) => Self::IndentBlock,
			Node::ScopedStatement(_) => Self::ScopedStatement,
			Node::MatchBranch(_) => Self::MatchBranch,
			Node::UnionCandidate(_) => Self::UnionCandidate,
			Node::Return(_) => Self::Return,
			Node::Break(_) => Self::Break,
			Node::Continue(_) => Self::Continue,
			Node::Assert(_) => Self::Assert,
			Node::ImplicitYield(_) => Self::ImplicitYield,
			Node::IntType(_) => Self::IntType,
			Node::FloatType(_) => Self::FloatType,
			Node::IdentType(_) => Self::IdentType,
			Node::IntLiteralType(_) => Self::IntLiteralType,
			Node::StrLiteralType(_) => Self::StrLiteralType,
			Node::VoidType(_) => Self::VoidType,
			Node::BoolType(_) => Self::BoolType,
			Node::ArrayType(_) => Self::ArrayType,
			Node::FunctionType(_) => Self::FunctionType,
			Node::StructType(_) => Self::StructType,
			Node::StructUnionType(_) => Self::StructUnionType,
			Node::UnionType(_) => Self::UnionType,
			Node::RangeType(_) => Self::RangeType,
			Node::EnumType(_) => Self::EnumType,
			Node::MetaType(_) => Self::MetaType,
			Node::OptionalType(_) => Self::OptionalType,
			Node::IntLiteral(_) => Self::IntLiteral,
			Node::BoolLiteral(_) => Self::BoolLiteral,
			Node::StrLiteral(_) => Self::StrLiteral,
			Node::TypeLiteral(_) => Self::TypeLiteral,
			Node::SpecialLiteral(_) => Self::SpecialLiteral,
			Node::Field(_) => Self::Field,
			Node::Format(_) => Self::Format,
			Node::State(_) => Self::State,
			Node::Enum(_) => Self::Enum,
			Node::EnumMember(_) => Self::EnumMember,
			Node::Function(_) => Self::Function,
			Node::BuiltinFunction(_) => Self::BuiltinFunction,
			Node::BuiltinField(_) => Self::BuiltinField,
			Node::BuiltinObject(_) => Self::BuiltinObject,
		}
	}
}

impl From<Node> for NodeType {
	fn from(node:Node)-> Self{
		Self::from(&node)
	}
}

impl From<&NodeWeak> for NodeType {
	fn from(node:&NodeWeak)-> Self{
		match node {
			NodeWeak::Program(_) => Self::Program,
			NodeWeak::Comment(_) => Self::Comment,
			NodeWeak::CommentGroup(_) => Self::CommentGroup,
			NodeWeak::FieldArgument(_) => Self::FieldArgument,
			NodeWeak::Binary(_) => Self::Binary,
			NodeWeak::Unary(_) => Self::Unary,
			NodeWeak::Cond(_) => Self::Cond,
			NodeWeak::Ident(_) => Self::Ident,
			NodeWeak::Call(_) => Self::Call,
			NodeWeak::If(_) => Self::If,
			NodeWeak::MemberAccess(_) => Self::MemberAccess,
			NodeWeak::Paren(_) => Self::Paren,
			NodeWeak::Index(_) => Self::Index,
			NodeWeak::Match(_) => Self::Match,
			NodeWeak::Range(_) => Self::Range,
			NodeWeak::TmpVar(_) => Self::TmpVar,
			NodeWeak::Import(_) => Self::Import,
			NodeWeak::Cast(_) => Self::Cast,
			NodeWeak::Available(_) => Self::Available,
			NodeWeak::SpecifyOrder(_) => Self::SpecifyOrder,
			NodeWeak::ExplicitError(_) => Self::ExplicitError,
			NodeWeak::IoOperation(_) => Self::IoOperation,
			NodeWeak::Loop(_) => Self::Loop,
			NodeWeak::IndentBlock(_) => Self::IndentBlock,
			NodeWeak::ScopedStatement(_) => Self::ScopedStatement,
			NodeWeak::MatchBranch(_) => Self::MatchBranch,
			NodeWeak::UnionCandidate(_) => Self::UnionCandidate,
			NodeWeak::Return(_) => Self::Return,
			NodeWeak::Break(_) => Self::Break,
			NodeWeak::Continue(_) => Self::Continue,
			NodeWeak::Assert(_) => Self::Assert,
			NodeWeak::ImplicitYield(_) => Self::ImplicitYield,
			NodeWeak::IntType(_) => Self::IntType,
			NodeWeak::FloatType(_) => Self::FloatType,
			NodeWeak::IdentType(_) => Self::IdentType,
			NodeWeak::IntLiteralType(_) => Self::IntLiteralType,
			NodeWeak::StrLiteralType(_) => Self::StrLiteralType,
			NodeWeak::VoidType(_) => Self::VoidType,
			NodeWeak::BoolType(_) => Self::BoolType,
			NodeWeak::ArrayType(_) => Self::ArrayType,
			NodeWeak::FunctionType(_) => Self::FunctionType,
			NodeWeak::StructType(_) => Self::StructType,
			NodeWeak::StructUnionType(_) => Self::StructUnionType,
			NodeWeak::UnionType(_) => Self::UnionType,
			NodeWeak::RangeType(_) => Self::RangeType,
			NodeWeak::EnumType(_) => Self::EnumType,
			NodeWeak::MetaType(_) => Self::MetaType,
			NodeWeak::OptionalType(_) => Self::OptionalType,
			NodeWeak::IntLiteral(_) => Self::IntLiteral,
			NodeWeak::BoolLiteral(_) => Self::BoolLiteral,
			NodeWeak::StrLiteral(_) => Self::StrLiteral,
			NodeWeak::TypeLiteral(_) => Self::TypeLiteral,
			NodeWeak::SpecialLiteral(_) => Self::SpecialLiteral,
			NodeWeak::Field(_) => Self::Field,
			NodeWeak::Format(_) => Self::Format,
			NodeWeak::State(_) => Self::State,
			NodeWeak::Enum(_) => Self::Enum,
			NodeWeak::EnumMember(_) => Self::EnumMember,
			NodeWeak::Function(_) => Self::Function,
			NodeWeak::BuiltinFunction(_) => Self::BuiltinFunction,
			NodeWeak::BuiltinField(_) => Self::BuiltinField,
			NodeWeak::BuiltinObject(_) => Self::BuiltinObject,
		}
	}
}

impl From<NodeWeak> for NodeType {
	fn from(node:NodeWeak)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case")]pub enum NodeType {
	Program,
	Comment,
	CommentGroup,
	FieldArgument,
	Expr,
	Binary,
	Unary,
	Cond,
	Ident,
	Call,
	If,
	MemberAccess,
	Paren,
	Index,
	Match,
	Range,
	TmpVar,
	Import,
	Cast,
	Available,
	SpecifyOrder,
	ExplicitError,
	IoOperation,
	Stmt,
	Loop,
	IndentBlock,
	ScopedStatement,
	MatchBranch,
	UnionCandidate,
	Return,
	Break,
	Continue,
	Assert,
	ImplicitYield,
	Type,
	IntType,
	FloatType,
	IdentType,
	IntLiteralType,
	StrLiteralType,
	VoidType,
	BoolType,
	ArrayType,
	FunctionType,
	StructType,
	StructUnionType,
	UnionType,
	RangeType,
	EnumType,
	MetaType,
	OptionalType,
	Literal,
	IntLiteral,
	BoolLiteral,
	StrLiteral,
	TypeLiteral,
	SpecialLiteral,
	Member,
	Field,
	Format,
	State,
	Enum,
	EnumMember,
	Function,
	BuiltinMember,
	BuiltinFunction,
	BuiltinField,
	BuiltinObject,
}

impl TryFrom<&str> for NodeType {
	type Error = ();
	fn try_from(s:&str)->Result<Self,()>{
		match s{
			"program" =>Ok(Self::Program),
			"comment" =>Ok(Self::Comment),
			"comment_group" =>Ok(Self::CommentGroup),
			"field_argument" =>Ok(Self::FieldArgument),
			"expr" =>Ok(Self::Expr),
			"binary" =>Ok(Self::Binary),
			"unary" =>Ok(Self::Unary),
			"cond" =>Ok(Self::Cond),
			"ident" =>Ok(Self::Ident),
			"call" =>Ok(Self::Call),
			"if" =>Ok(Self::If),
			"member_access" =>Ok(Self::MemberAccess),
			"paren" =>Ok(Self::Paren),
			"index" =>Ok(Self::Index),
			"match" =>Ok(Self::Match),
			"range" =>Ok(Self::Range),
			"tmp_var" =>Ok(Self::TmpVar),
			"import" =>Ok(Self::Import),
			"cast" =>Ok(Self::Cast),
			"available" =>Ok(Self::Available),
			"specify_order" =>Ok(Self::SpecifyOrder),
			"explicit_error" =>Ok(Self::ExplicitError),
			"io_operation" =>Ok(Self::IoOperation),
			"stmt" =>Ok(Self::Stmt),
			"loop" =>Ok(Self::Loop),
			"indent_block" =>Ok(Self::IndentBlock),
			"scoped_statement" =>Ok(Self::ScopedStatement),
			"match_branch" =>Ok(Self::MatchBranch),
			"union_candidate" =>Ok(Self::UnionCandidate),
			"return" =>Ok(Self::Return),
			"break" =>Ok(Self::Break),
			"continue" =>Ok(Self::Continue),
			"assert" =>Ok(Self::Assert),
			"implicit_yield" =>Ok(Self::ImplicitYield),
			"type" =>Ok(Self::Type),
			"int_type" =>Ok(Self::IntType),
			"float_type" =>Ok(Self::FloatType),
			"ident_type" =>Ok(Self::IdentType),
			"int_literal_type" =>Ok(Self::IntLiteralType),
			"str_literal_type" =>Ok(Self::StrLiteralType),
			"void_type" =>Ok(Self::VoidType),
			"bool_type" =>Ok(Self::BoolType),
			"array_type" =>Ok(Self::ArrayType),
			"function_type" =>Ok(Self::FunctionType),
			"struct_type" =>Ok(Self::StructType),
			"struct_union_type" =>Ok(Self::StructUnionType),
			"union_type" =>Ok(Self::UnionType),
			"range_type" =>Ok(Self::RangeType),
			"enum_type" =>Ok(Self::EnumType),
			"meta_type" =>Ok(Self::MetaType),
			"optional_type" =>Ok(Self::OptionalType),
			"literal" =>Ok(Self::Literal),
			"int_literal" =>Ok(Self::IntLiteral),
			"bool_literal" =>Ok(Self::BoolLiteral),
			"str_literal" =>Ok(Self::StrLiteral),
			"type_literal" =>Ok(Self::TypeLiteral),
			"special_literal" =>Ok(Self::SpecialLiteral),
			"member" =>Ok(Self::Member),
			"field" =>Ok(Self::Field),
			"format" =>Ok(Self::Format),
			"state" =>Ok(Self::State),
			"enum" =>Ok(Self::Enum),
			"enum_member" =>Ok(Self::EnumMember),
			"function" =>Ok(Self::Function),
			"builtin_member" =>Ok(Self::BuiltinMember),
			"builtin_function" =>Ok(Self::BuiltinFunction),
			"builtin_field" =>Ok(Self::BuiltinField),
			"builtin_object" =>Ok(Self::BuiltinObject),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case")]pub enum TokenTag {
	Indent,
	Space,
	Line,
	Punct,
	IntLiteral,
	BoolLiteral,
	StrLiteral,
	Keyword,
	Ident,
	Comment,
	Error,
	Unknown,
}

impl TryFrom<&str> for TokenTag {
	type Error = ();
	fn try_from(s:&str)->Result<Self,()>{
		match s{
			"indent" =>Ok(Self::Indent),
			"space" =>Ok(Self::Space),
			"line" =>Ok(Self::Line),
			"punct" =>Ok(Self::Punct),
			"int_literal" =>Ok(Self::IntLiteral),
			"bool_literal" =>Ok(Self::BoolLiteral),
			"str_literal" =>Ok(Self::StrLiteral),
			"keyword" =>Ok(Self::Keyword),
			"ident" =>Ok(Self::Ident),
			"comment" =>Ok(Self::Comment),
			"error" =>Ok(Self::Error),
			"unknown" =>Ok(Self::Unknown),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case")]pub enum UnaryOp {
	Not,
	MinusSign,
}

impl TryFrom<&str> for UnaryOp {
	type Error = ();
	fn try_from(s:&str)->Result<Self,()>{
		match s{
			"!" =>Ok(Self::Not),
			"-" =>Ok(Self::MinusSign),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case")]pub enum BinaryOp {
	Mul,
	Div,
	Mod,
	LeftArithmeticShift,
	RightArithmeticShift,
	LeftLogicalShift,
	RightLogicalShift,
	BitAnd,
	Add,
	Sub,
	BitOr,
	BitXor,
	Equal,
	NotEqual,
	Less,
	LessOrEq,
	Grater,
	GraterOrEq,
	LogicalAnd,
	LogicalOr,
	CondOp1,
	CondOp2,
	RangeExclusive,
	RangeInclusive,
	Assign,
	DefineAssign,
	ConstAssign,
	AddAssign,
	SubAssign,
	MulAssign,
	DivAssign,
	ModAssign,
	LeftShiftAssign,
	RightShiftAssign,
	BitAndAssign,
	BitOrAssign,
	BitXorAssign,
	Comma,
}

impl TryFrom<&str> for BinaryOp {
	type Error = ();
	fn try_from(s:&str)->Result<Self,()>{
		match s{
			"*" =>Ok(Self::Mul),
			"/" =>Ok(Self::Div),
			"%" =>Ok(Self::Mod),
			"<<<" =>Ok(Self::LeftArithmeticShift),
			">>>" =>Ok(Self::RightArithmeticShift),
			"<<" =>Ok(Self::LeftLogicalShift),
			">>" =>Ok(Self::RightLogicalShift),
			"&" =>Ok(Self::BitAnd),
			"+" =>Ok(Self::Add),
			"-" =>Ok(Self::Sub),
			"|" =>Ok(Self::BitOr),
			"^" =>Ok(Self::BitXor),
			"==" =>Ok(Self::Equal),
			"!=" =>Ok(Self::NotEqual),
			"<" =>Ok(Self::Less),
			"<=" =>Ok(Self::LessOrEq),
			">" =>Ok(Self::Grater),
			">=" =>Ok(Self::GraterOrEq),
			"&&" =>Ok(Self::LogicalAnd),
			"||" =>Ok(Self::LogicalOr),
			"?" =>Ok(Self::CondOp1),
			":" =>Ok(Self::CondOp2),
			".." =>Ok(Self::RangeExclusive),
			"..=" =>Ok(Self::RangeInclusive),
			"=" =>Ok(Self::Assign),
			":=" =>Ok(Self::DefineAssign),
			"::=" =>Ok(Self::ConstAssign),
			"+=" =>Ok(Self::AddAssign),
			"-=" =>Ok(Self::SubAssign),
			"*=" =>Ok(Self::MulAssign),
			"/=" =>Ok(Self::DivAssign),
			"%=" =>Ok(Self::ModAssign),
			"<<=" =>Ok(Self::LeftShiftAssign),
			">>=" =>Ok(Self::RightShiftAssign),
			"&=" =>Ok(Self::BitAndAssign),
			"|=" =>Ok(Self::BitOrAssign),
			"^=" =>Ok(Self::BitXorAssign),
			"," =>Ok(Self::Comma),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case")]pub enum IdentUsage {
	Unknown,
	Reference,
	DefineVariable,
	DefineConst,
	DefineField,
	DefineFormat,
	DefineState,
	DefineEnum,
	DefineEnumMember,
	DefineFn,
	DefineCastFn,
	DefineArg,
	ReferenceType,
	ReferenceMember,
	MaybeType,
	ReferenceBuiltinFn,
}

impl TryFrom<&str> for IdentUsage {
	type Error = ();
	fn try_from(s:&str)->Result<Self,()>{
		match s{
			"unknown" =>Ok(Self::Unknown),
			"reference" =>Ok(Self::Reference),
			"define_variable" =>Ok(Self::DefineVariable),
			"define_const" =>Ok(Self::DefineConst),
			"define_field" =>Ok(Self::DefineField),
			"define_format" =>Ok(Self::DefineFormat),
			"define_state" =>Ok(Self::DefineState),
			"define_enum" =>Ok(Self::DefineEnum),
			"define_enum_member" =>Ok(Self::DefineEnumMember),
			"define_fn" =>Ok(Self::DefineFn),
			"define_cast_fn" =>Ok(Self::DefineCastFn),
			"define_arg" =>Ok(Self::DefineArg),
			"reference_type" =>Ok(Self::ReferenceType),
			"reference_member" =>Ok(Self::ReferenceMember),
			"maybe_type" =>Ok(Self::MaybeType),
			"reference_builtin_fn" =>Ok(Self::ReferenceBuiltinFn),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case")]pub enum Endian {
	Unspec,
	Big,
	Little,
}

impl TryFrom<&str> for Endian {
	type Error = ();
	fn try_from(s:&str)->Result<Self,()>{
		match s{
			"unspec" =>Ok(Self::Unspec),
			"big" =>Ok(Self::Big),
			"little" =>Ok(Self::Little),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case")]pub enum ConstantLevel {
	Unknown,
	Constant,
	ConstVariable,
	Variable,
}

impl TryFrom<&str> for ConstantLevel {
	type Error = ();
	fn try_from(s:&str)->Result<Self,()>{
		match s{
			"unknown" =>Ok(Self::Unknown),
			"constant" =>Ok(Self::Constant),
			"const_variable" =>Ok(Self::ConstVariable),
			"variable" =>Ok(Self::Variable),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case")]pub enum BitAlignment {
	ByteAligned,
	Bit1,
	Bit2,
	Bit3,
	Bit4,
	Bit5,
	Bit6,
	Bit7,
	NotTarget,
	NotDecidable,
}

impl TryFrom<&str> for BitAlignment {
	type Error = ();
	fn try_from(s:&str)->Result<Self,()>{
		match s{
			"byte_aligned" =>Ok(Self::ByteAligned),
			"bit_1" =>Ok(Self::Bit1),
			"bit_2" =>Ok(Self::Bit2),
			"bit_3" =>Ok(Self::Bit3),
			"bit_4" =>Ok(Self::Bit4),
			"bit_5" =>Ok(Self::Bit5),
			"bit_6" =>Ok(Self::Bit6),
			"bit_7" =>Ok(Self::Bit7),
			"not_target" =>Ok(Self::NotTarget),
			"not_decidable" =>Ok(Self::NotDecidable),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case")]pub enum Follow {
	Unknown,
	End,
	Fixed,
	Constant,
	Normal,
}

impl TryFrom<&str> for Follow {
	type Error = ();
	fn try_from(s:&str)->Result<Self,()>{
		match s{
			"unknown" =>Ok(Self::Unknown),
			"end" =>Ok(Self::End),
			"fixed" =>Ok(Self::Fixed),
			"constant" =>Ok(Self::Constant),
			"normal" =>Ok(Self::Normal),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case")]pub enum IoMethod {
	Unspec,
	OutputPut,
	InputPeek,
	InputGet,
	InputBackward,
	InputOffset,
	InputRemain,
	InputSubrange,
	ConfigEndianLittle,
	ConfigEndianBig,
	ConfigEndianNative,
	ConfigBitOrderLsb,
	ConfigBitOrderMsb,
}

impl TryFrom<&str> for IoMethod {
	type Error = ();
	fn try_from(s:&str)->Result<Self,()>{
		match s{
			"unspec" =>Ok(Self::Unspec),
			"output_put" =>Ok(Self::OutputPut),
			"input_peek" =>Ok(Self::InputPeek),
			"input_get" =>Ok(Self::InputGet),
			"input_backward" =>Ok(Self::InputBackward),
			"input_offset" =>Ok(Self::InputOffset),
			"input_remain" =>Ok(Self::InputRemain),
			"input_subrange" =>Ok(Self::InputSubrange),
			"config_endian_little" =>Ok(Self::ConfigEndianLittle),
			"config_endian_big" =>Ok(Self::ConfigEndianBig),
			"config_endian_native" =>Ok(Self::ConfigEndianNative),
			"config_bit_order_lsb" =>Ok(Self::ConfigBitOrderLsb),
			"config_bit_order_msb" =>Ok(Self::ConfigBitOrderMsb),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case")]pub enum SpecialLiteralKind {
	Input,
	Output,
	Config,
}

impl TryFrom<&str> for SpecialLiteralKind {
	type Error = ();
	fn try_from(s:&str)->Result<Self,()>{
		match s{
			"input" =>Ok(Self::Input),
			"output" =>Ok(Self::Output),
			"config" =>Ok(Self::Config),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case")]pub enum OrderType {
	Byte,
	Bit,
}

impl TryFrom<&str> for OrderType {
	type Error = ();
	fn try_from(s:&str)->Result<Self,()>{
		match s{
			"byte" =>Ok(Self::Byte),
			"bit" =>Ok(Self::Bit),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone)]
pub enum Node {
	Program(Rc<RefCell<Program>>),
	Comment(Rc<RefCell<Comment>>),
	CommentGroup(Rc<RefCell<CommentGroup>>),
	FieldArgument(Rc<RefCell<FieldArgument>>),
	Binary(Rc<RefCell<Binary>>),
	Unary(Rc<RefCell<Unary>>),
	Cond(Rc<RefCell<Cond>>),
	Ident(Rc<RefCell<Ident>>),
	Call(Rc<RefCell<Call>>),
	If(Rc<RefCell<If>>),
	MemberAccess(Rc<RefCell<MemberAccess>>),
	Paren(Rc<RefCell<Paren>>),
	Index(Rc<RefCell<Index>>),
	Match(Rc<RefCell<Match>>),
	Range(Rc<RefCell<Range>>),
	TmpVar(Rc<RefCell<TmpVar>>),
	Import(Rc<RefCell<Import>>),
	Cast(Rc<RefCell<Cast>>),
	Available(Rc<RefCell<Available>>),
	SpecifyOrder(Rc<RefCell<SpecifyOrder>>),
	ExplicitError(Rc<RefCell<ExplicitError>>),
	IoOperation(Rc<RefCell<IoOperation>>),
	Loop(Rc<RefCell<Loop>>),
	IndentBlock(Rc<RefCell<IndentBlock>>),
	ScopedStatement(Rc<RefCell<ScopedStatement>>),
	MatchBranch(Rc<RefCell<MatchBranch>>),
	UnionCandidate(Rc<RefCell<UnionCandidate>>),
	Return(Rc<RefCell<Return>>),
	Break(Rc<RefCell<Break>>),
	Continue(Rc<RefCell<Continue>>),
	Assert(Rc<RefCell<Assert>>),
	ImplicitYield(Rc<RefCell<ImplicitYield>>),
	IntType(Rc<RefCell<IntType>>),
	FloatType(Rc<RefCell<FloatType>>),
	IdentType(Rc<RefCell<IdentType>>),
	IntLiteralType(Rc<RefCell<IntLiteralType>>),
	StrLiteralType(Rc<RefCell<StrLiteralType>>),
	VoidType(Rc<RefCell<VoidType>>),
	BoolType(Rc<RefCell<BoolType>>),
	ArrayType(Rc<RefCell<ArrayType>>),
	FunctionType(Rc<RefCell<FunctionType>>),
	StructType(Rc<RefCell<StructType>>),
	StructUnionType(Rc<RefCell<StructUnionType>>),
	UnionType(Rc<RefCell<UnionType>>),
	RangeType(Rc<RefCell<RangeType>>),
	EnumType(Rc<RefCell<EnumType>>),
	MetaType(Rc<RefCell<MetaType>>),
	OptionalType(Rc<RefCell<OptionalType>>),
	IntLiteral(Rc<RefCell<IntLiteral>>),
	BoolLiteral(Rc<RefCell<BoolLiteral>>),
	StrLiteral(Rc<RefCell<StrLiteral>>),
	TypeLiteral(Rc<RefCell<TypeLiteral>>),
	SpecialLiteral(Rc<RefCell<SpecialLiteral>>),
	Field(Rc<RefCell<Field>>),
	Format(Rc<RefCell<Format>>),
	State(Rc<RefCell<State>>),
	Enum(Rc<RefCell<Enum>>),
	EnumMember(Rc<RefCell<EnumMember>>),
	Function(Rc<RefCell<Function>>),
	BuiltinFunction(Rc<RefCell<BuiltinFunction>>),
	BuiltinField(Rc<RefCell<BuiltinField>>),
	BuiltinObject(Rc<RefCell<BuiltinObject>>),
}

#[derive(Debug,Clone)]
pub enum NodeWeak {
	Program(Weak<RefCell<Program>>),
	Comment(Weak<RefCell<Comment>>),
	CommentGroup(Weak<RefCell<CommentGroup>>),
	FieldArgument(Weak<RefCell<FieldArgument>>),
	Binary(Weak<RefCell<Binary>>),
	Unary(Weak<RefCell<Unary>>),
	Cond(Weak<RefCell<Cond>>),
	Ident(Weak<RefCell<Ident>>),
	Call(Weak<RefCell<Call>>),
	If(Weak<RefCell<If>>),
	MemberAccess(Weak<RefCell<MemberAccess>>),
	Paren(Weak<RefCell<Paren>>),
	Index(Weak<RefCell<Index>>),
	Match(Weak<RefCell<Match>>),
	Range(Weak<RefCell<Range>>),
	TmpVar(Weak<RefCell<TmpVar>>),
	Import(Weak<RefCell<Import>>),
	Cast(Weak<RefCell<Cast>>),
	Available(Weak<RefCell<Available>>),
	SpecifyOrder(Weak<RefCell<SpecifyOrder>>),
	ExplicitError(Weak<RefCell<ExplicitError>>),
	IoOperation(Weak<RefCell<IoOperation>>),
	Loop(Weak<RefCell<Loop>>),
	IndentBlock(Weak<RefCell<IndentBlock>>),
	ScopedStatement(Weak<RefCell<ScopedStatement>>),
	MatchBranch(Weak<RefCell<MatchBranch>>),
	UnionCandidate(Weak<RefCell<UnionCandidate>>),
	Return(Weak<RefCell<Return>>),
	Break(Weak<RefCell<Break>>),
	Continue(Weak<RefCell<Continue>>),
	Assert(Weak<RefCell<Assert>>),
	ImplicitYield(Weak<RefCell<ImplicitYield>>),
	IntType(Weak<RefCell<IntType>>),
	FloatType(Weak<RefCell<FloatType>>),
	IdentType(Weak<RefCell<IdentType>>),
	IntLiteralType(Weak<RefCell<IntLiteralType>>),
	StrLiteralType(Weak<RefCell<StrLiteralType>>),
	VoidType(Weak<RefCell<VoidType>>),
	BoolType(Weak<RefCell<BoolType>>),
	ArrayType(Weak<RefCell<ArrayType>>),
	FunctionType(Weak<RefCell<FunctionType>>),
	StructType(Weak<RefCell<StructType>>),
	StructUnionType(Weak<RefCell<StructUnionType>>),
	UnionType(Weak<RefCell<UnionType>>),
	RangeType(Weak<RefCell<RangeType>>),
	EnumType(Weak<RefCell<EnumType>>),
	MetaType(Weak<RefCell<MetaType>>),
	OptionalType(Weak<RefCell<OptionalType>>),
	IntLiteral(Weak<RefCell<IntLiteral>>),
	BoolLiteral(Weak<RefCell<BoolLiteral>>),
	StrLiteral(Weak<RefCell<StrLiteral>>),
	TypeLiteral(Weak<RefCell<TypeLiteral>>),
	SpecialLiteral(Weak<RefCell<SpecialLiteral>>),
	Field(Weak<RefCell<Field>>),
	Format(Weak<RefCell<Format>>),
	State(Weak<RefCell<State>>),
	Enum(Weak<RefCell<Enum>>),
	EnumMember(Weak<RefCell<EnumMember>>),
	Function(Weak<RefCell<Function>>),
	BuiltinFunction(Weak<RefCell<BuiltinFunction>>),
	BuiltinField(Weak<RefCell<BuiltinField>>),
	BuiltinObject(Weak<RefCell<BuiltinObject>>),
}

impl From<&Node> for NodeWeak {
	fn from(node:&Node)-> Self{
		match node {
			Node::Program(node)=>Self::Program(Rc::downgrade(node)),
			Node::Comment(node)=>Self::Comment(Rc::downgrade(node)),
			Node::CommentGroup(node)=>Self::CommentGroup(Rc::downgrade(node)),
			Node::FieldArgument(node)=>Self::FieldArgument(Rc::downgrade(node)),
			Node::Binary(node)=>Self::Binary(Rc::downgrade(node)),
			Node::Unary(node)=>Self::Unary(Rc::downgrade(node)),
			Node::Cond(node)=>Self::Cond(Rc::downgrade(node)),
			Node::Ident(node)=>Self::Ident(Rc::downgrade(node)),
			Node::Call(node)=>Self::Call(Rc::downgrade(node)),
			Node::If(node)=>Self::If(Rc::downgrade(node)),
			Node::MemberAccess(node)=>Self::MemberAccess(Rc::downgrade(node)),
			Node::Paren(node)=>Self::Paren(Rc::downgrade(node)),
			Node::Index(node)=>Self::Index(Rc::downgrade(node)),
			Node::Match(node)=>Self::Match(Rc::downgrade(node)),
			Node::Range(node)=>Self::Range(Rc::downgrade(node)),
			Node::TmpVar(node)=>Self::TmpVar(Rc::downgrade(node)),
			Node::Import(node)=>Self::Import(Rc::downgrade(node)),
			Node::Cast(node)=>Self::Cast(Rc::downgrade(node)),
			Node::Available(node)=>Self::Available(Rc::downgrade(node)),
			Node::SpecifyOrder(node)=>Self::SpecifyOrder(Rc::downgrade(node)),
			Node::ExplicitError(node)=>Self::ExplicitError(Rc::downgrade(node)),
			Node::IoOperation(node)=>Self::IoOperation(Rc::downgrade(node)),
			Node::Loop(node)=>Self::Loop(Rc::downgrade(node)),
			Node::IndentBlock(node)=>Self::IndentBlock(Rc::downgrade(node)),
			Node::ScopedStatement(node)=>Self::ScopedStatement(Rc::downgrade(node)),
			Node::MatchBranch(node)=>Self::MatchBranch(Rc::downgrade(node)),
			Node::UnionCandidate(node)=>Self::UnionCandidate(Rc::downgrade(node)),
			Node::Return(node)=>Self::Return(Rc::downgrade(node)),
			Node::Break(node)=>Self::Break(Rc::downgrade(node)),
			Node::Continue(node)=>Self::Continue(Rc::downgrade(node)),
			Node::Assert(node)=>Self::Assert(Rc::downgrade(node)),
			Node::ImplicitYield(node)=>Self::ImplicitYield(Rc::downgrade(node)),
			Node::IntType(node)=>Self::IntType(Rc::downgrade(node)),
			Node::FloatType(node)=>Self::FloatType(Rc::downgrade(node)),
			Node::IdentType(node)=>Self::IdentType(Rc::downgrade(node)),
			Node::IntLiteralType(node)=>Self::IntLiteralType(Rc::downgrade(node)),
			Node::StrLiteralType(node)=>Self::StrLiteralType(Rc::downgrade(node)),
			Node::VoidType(node)=>Self::VoidType(Rc::downgrade(node)),
			Node::BoolType(node)=>Self::BoolType(Rc::downgrade(node)),
			Node::ArrayType(node)=>Self::ArrayType(Rc::downgrade(node)),
			Node::FunctionType(node)=>Self::FunctionType(Rc::downgrade(node)),
			Node::StructType(node)=>Self::StructType(Rc::downgrade(node)),
			Node::StructUnionType(node)=>Self::StructUnionType(Rc::downgrade(node)),
			Node::UnionType(node)=>Self::UnionType(Rc::downgrade(node)),
			Node::RangeType(node)=>Self::RangeType(Rc::downgrade(node)),
			Node::EnumType(node)=>Self::EnumType(Rc::downgrade(node)),
			Node::MetaType(node)=>Self::MetaType(Rc::downgrade(node)),
			Node::OptionalType(node)=>Self::OptionalType(Rc::downgrade(node)),
			Node::IntLiteral(node)=>Self::IntLiteral(Rc::downgrade(node)),
			Node::BoolLiteral(node)=>Self::BoolLiteral(Rc::downgrade(node)),
			Node::StrLiteral(node)=>Self::StrLiteral(Rc::downgrade(node)),
			Node::TypeLiteral(node)=>Self::TypeLiteral(Rc::downgrade(node)),
			Node::SpecialLiteral(node)=>Self::SpecialLiteral(Rc::downgrade(node)),
			Node::Field(node)=>Self::Field(Rc::downgrade(node)),
			Node::Format(node)=>Self::Format(Rc::downgrade(node)),
			Node::State(node)=>Self::State(Rc::downgrade(node)),
			Node::Enum(node)=>Self::Enum(Rc::downgrade(node)),
			Node::EnumMember(node)=>Self::EnumMember(Rc::downgrade(node)),
			Node::Function(node)=>Self::Function(Rc::downgrade(node)),
			Node::BuiltinFunction(node)=>Self::BuiltinFunction(Rc::downgrade(node)),
			Node::BuiltinField(node)=>Self::BuiltinField(Rc::downgrade(node)),
			Node::BuiltinObject(node)=>Self::BuiltinObject(Rc::downgrade(node)),
		}
	}
}

impl From<Node> for NodeWeak {
	fn from(node:Node)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&NodeWeak> for Node {
	type Error = Error;
	fn try_from(node:&NodeWeak)->Result<Self,Self::Error>{
		match node {
			NodeWeak::Program(node)=>Ok(Self::Program(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Program))?)),
			NodeWeak::Comment(node)=>Ok(Self::Comment(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Comment))?)),
			NodeWeak::CommentGroup(node)=>Ok(Self::CommentGroup(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::CommentGroup))?)),
			NodeWeak::FieldArgument(node)=>Ok(Self::FieldArgument(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::FieldArgument))?)),
			NodeWeak::Binary(node)=>Ok(Self::Binary(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Binary))?)),
			NodeWeak::Unary(node)=>Ok(Self::Unary(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Unary))?)),
			NodeWeak::Cond(node)=>Ok(Self::Cond(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Cond))?)),
			NodeWeak::Ident(node)=>Ok(Self::Ident(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Ident))?)),
			NodeWeak::Call(node)=>Ok(Self::Call(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Call))?)),
			NodeWeak::If(node)=>Ok(Self::If(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::If))?)),
			NodeWeak::MemberAccess(node)=>Ok(Self::MemberAccess(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::MemberAccess))?)),
			NodeWeak::Paren(node)=>Ok(Self::Paren(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Paren))?)),
			NodeWeak::Index(node)=>Ok(Self::Index(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Index))?)),
			NodeWeak::Match(node)=>Ok(Self::Match(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Match))?)),
			NodeWeak::Range(node)=>Ok(Self::Range(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Range))?)),
			NodeWeak::TmpVar(node)=>Ok(Self::TmpVar(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::TmpVar))?)),
			NodeWeak::Import(node)=>Ok(Self::Import(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Import))?)),
			NodeWeak::Cast(node)=>Ok(Self::Cast(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Cast))?)),
			NodeWeak::Available(node)=>Ok(Self::Available(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Available))?)),
			NodeWeak::SpecifyOrder(node)=>Ok(Self::SpecifyOrder(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::SpecifyOrder))?)),
			NodeWeak::ExplicitError(node)=>Ok(Self::ExplicitError(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::ExplicitError))?)),
			NodeWeak::IoOperation(node)=>Ok(Self::IoOperation(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::IoOperation))?)),
			NodeWeak::Loop(node)=>Ok(Self::Loop(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Loop))?)),
			NodeWeak::IndentBlock(node)=>Ok(Self::IndentBlock(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::IndentBlock))?)),
			NodeWeak::ScopedStatement(node)=>Ok(Self::ScopedStatement(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::ScopedStatement))?)),
			NodeWeak::MatchBranch(node)=>Ok(Self::MatchBranch(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::MatchBranch))?)),
			NodeWeak::UnionCandidate(node)=>Ok(Self::UnionCandidate(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::UnionCandidate))?)),
			NodeWeak::Return(node)=>Ok(Self::Return(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Return))?)),
			NodeWeak::Break(node)=>Ok(Self::Break(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Break))?)),
			NodeWeak::Continue(node)=>Ok(Self::Continue(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Continue))?)),
			NodeWeak::Assert(node)=>Ok(Self::Assert(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Assert))?)),
			NodeWeak::ImplicitYield(node)=>Ok(Self::ImplicitYield(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::ImplicitYield))?)),
			NodeWeak::IntType(node)=>Ok(Self::IntType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::IntType))?)),
			NodeWeak::FloatType(node)=>Ok(Self::FloatType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::FloatType))?)),
			NodeWeak::IdentType(node)=>Ok(Self::IdentType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::IdentType))?)),
			NodeWeak::IntLiteralType(node)=>Ok(Self::IntLiteralType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::IntLiteralType))?)),
			NodeWeak::StrLiteralType(node)=>Ok(Self::StrLiteralType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::StrLiteralType))?)),
			NodeWeak::VoidType(node)=>Ok(Self::VoidType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::VoidType))?)),
			NodeWeak::BoolType(node)=>Ok(Self::BoolType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BoolType))?)),
			NodeWeak::ArrayType(node)=>Ok(Self::ArrayType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::ArrayType))?)),
			NodeWeak::FunctionType(node)=>Ok(Self::FunctionType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::FunctionType))?)),
			NodeWeak::StructType(node)=>Ok(Self::StructType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::StructType))?)),
			NodeWeak::StructUnionType(node)=>Ok(Self::StructUnionType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::StructUnionType))?)),
			NodeWeak::UnionType(node)=>Ok(Self::UnionType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::UnionType))?)),
			NodeWeak::RangeType(node)=>Ok(Self::RangeType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::RangeType))?)),
			NodeWeak::EnumType(node)=>Ok(Self::EnumType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::EnumType))?)),
			NodeWeak::MetaType(node)=>Ok(Self::MetaType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::MetaType))?)),
			NodeWeak::OptionalType(node)=>Ok(Self::OptionalType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::OptionalType))?)),
			NodeWeak::IntLiteral(node)=>Ok(Self::IntLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::IntLiteral))?)),
			NodeWeak::BoolLiteral(node)=>Ok(Self::BoolLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BoolLiteral))?)),
			NodeWeak::StrLiteral(node)=>Ok(Self::StrLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::StrLiteral))?)),
			NodeWeak::TypeLiteral(node)=>Ok(Self::TypeLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::TypeLiteral))?)),
			NodeWeak::SpecialLiteral(node)=>Ok(Self::SpecialLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::SpecialLiteral))?)),
			NodeWeak::Field(node)=>Ok(Self::Field(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Field))?)),
			NodeWeak::Format(node)=>Ok(Self::Format(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Format))?)),
			NodeWeak::State(node)=>Ok(Self::State(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::State))?)),
			NodeWeak::Enum(node)=>Ok(Self::Enum(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Enum))?)),
			NodeWeak::EnumMember(node)=>Ok(Self::EnumMember(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::EnumMember))?)),
			NodeWeak::Function(node)=>Ok(Self::Function(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Function))?)),
			NodeWeak::BuiltinFunction(node)=>Ok(Self::BuiltinFunction(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinFunction))?)),
			NodeWeak::BuiltinField(node)=>Ok(Self::BuiltinField(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinField))?)),
			NodeWeak::BuiltinObject(node)=>Ok(Self::BuiltinObject(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinObject))?)),
		}
	}
}

impl TryFrom<NodeWeak> for Node {
	type Error = Error;
	fn try_from(node:NodeWeak)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

#[derive(Debug,Clone)]
pub enum Expr {
	Binary(Rc<RefCell<Binary>>),
	Unary(Rc<RefCell<Unary>>),
	Cond(Rc<RefCell<Cond>>),
	Ident(Rc<RefCell<Ident>>),
	Call(Rc<RefCell<Call>>),
	If(Rc<RefCell<If>>),
	MemberAccess(Rc<RefCell<MemberAccess>>),
	Paren(Rc<RefCell<Paren>>),
	Index(Rc<RefCell<Index>>),
	Match(Rc<RefCell<Match>>),
	Range(Rc<RefCell<Range>>),
	TmpVar(Rc<RefCell<TmpVar>>),
	Import(Rc<RefCell<Import>>),
	Cast(Rc<RefCell<Cast>>),
	Available(Rc<RefCell<Available>>),
	SpecifyOrder(Rc<RefCell<SpecifyOrder>>),
	ExplicitError(Rc<RefCell<ExplicitError>>),
	IoOperation(Rc<RefCell<IoOperation>>),
	IntLiteral(Rc<RefCell<IntLiteral>>),
	BoolLiteral(Rc<RefCell<BoolLiteral>>),
	StrLiteral(Rc<RefCell<StrLiteral>>),
	TypeLiteral(Rc<RefCell<TypeLiteral>>),
	SpecialLiteral(Rc<RefCell<SpecialLiteral>>),
}

#[derive(Debug,Clone)]
pub enum ExprWeak {
	Binary(Weak<RefCell<Binary>>),
	Unary(Weak<RefCell<Unary>>),
	Cond(Weak<RefCell<Cond>>),
	Ident(Weak<RefCell<Ident>>),
	Call(Weak<RefCell<Call>>),
	If(Weak<RefCell<If>>),
	MemberAccess(Weak<RefCell<MemberAccess>>),
	Paren(Weak<RefCell<Paren>>),
	Index(Weak<RefCell<Index>>),
	Match(Weak<RefCell<Match>>),
	Range(Weak<RefCell<Range>>),
	TmpVar(Weak<RefCell<TmpVar>>),
	Import(Weak<RefCell<Import>>),
	Cast(Weak<RefCell<Cast>>),
	Available(Weak<RefCell<Available>>),
	SpecifyOrder(Weak<RefCell<SpecifyOrder>>),
	ExplicitError(Weak<RefCell<ExplicitError>>),
	IoOperation(Weak<RefCell<IoOperation>>),
	IntLiteral(Weak<RefCell<IntLiteral>>),
	BoolLiteral(Weak<RefCell<BoolLiteral>>),
	StrLiteral(Weak<RefCell<StrLiteral>>),
	TypeLiteral(Weak<RefCell<TypeLiteral>>),
	SpecialLiteral(Weak<RefCell<SpecialLiteral>>),
}

impl From<&Expr> for ExprWeak {
	fn from(node:&Expr)-> Self{
		match node {
			Expr::Binary(node)=>Self::Binary(Rc::downgrade(node)),
			Expr::Unary(node)=>Self::Unary(Rc::downgrade(node)),
			Expr::Cond(node)=>Self::Cond(Rc::downgrade(node)),
			Expr::Ident(node)=>Self::Ident(Rc::downgrade(node)),
			Expr::Call(node)=>Self::Call(Rc::downgrade(node)),
			Expr::If(node)=>Self::If(Rc::downgrade(node)),
			Expr::MemberAccess(node)=>Self::MemberAccess(Rc::downgrade(node)),
			Expr::Paren(node)=>Self::Paren(Rc::downgrade(node)),
			Expr::Index(node)=>Self::Index(Rc::downgrade(node)),
			Expr::Match(node)=>Self::Match(Rc::downgrade(node)),
			Expr::Range(node)=>Self::Range(Rc::downgrade(node)),
			Expr::TmpVar(node)=>Self::TmpVar(Rc::downgrade(node)),
			Expr::Import(node)=>Self::Import(Rc::downgrade(node)),
			Expr::Cast(node)=>Self::Cast(Rc::downgrade(node)),
			Expr::Available(node)=>Self::Available(Rc::downgrade(node)),
			Expr::SpecifyOrder(node)=>Self::SpecifyOrder(Rc::downgrade(node)),
			Expr::ExplicitError(node)=>Self::ExplicitError(Rc::downgrade(node)),
			Expr::IoOperation(node)=>Self::IoOperation(Rc::downgrade(node)),
			Expr::IntLiteral(node)=>Self::IntLiteral(Rc::downgrade(node)),
			Expr::BoolLiteral(node)=>Self::BoolLiteral(Rc::downgrade(node)),
			Expr::StrLiteral(node)=>Self::StrLiteral(Rc::downgrade(node)),
			Expr::TypeLiteral(node)=>Self::TypeLiteral(Rc::downgrade(node)),
			Expr::SpecialLiteral(node)=>Self::SpecialLiteral(Rc::downgrade(node)),
		}
	}
}

impl From<Expr> for ExprWeak {
	fn from(node:Expr)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&ExprWeak> for Expr {
	type Error = Error;
	fn try_from(node:&ExprWeak)->Result<Self,Self::Error>{
		match node {
			ExprWeak::Binary(node)=>Ok(Self::Binary(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Binary))?)),
			ExprWeak::Unary(node)=>Ok(Self::Unary(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Unary))?)),
			ExprWeak::Cond(node)=>Ok(Self::Cond(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Cond))?)),
			ExprWeak::Ident(node)=>Ok(Self::Ident(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Ident))?)),
			ExprWeak::Call(node)=>Ok(Self::Call(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Call))?)),
			ExprWeak::If(node)=>Ok(Self::If(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::If))?)),
			ExprWeak::MemberAccess(node)=>Ok(Self::MemberAccess(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::MemberAccess))?)),
			ExprWeak::Paren(node)=>Ok(Self::Paren(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Paren))?)),
			ExprWeak::Index(node)=>Ok(Self::Index(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Index))?)),
			ExprWeak::Match(node)=>Ok(Self::Match(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Match))?)),
			ExprWeak::Range(node)=>Ok(Self::Range(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Range))?)),
			ExprWeak::TmpVar(node)=>Ok(Self::TmpVar(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::TmpVar))?)),
			ExprWeak::Import(node)=>Ok(Self::Import(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Import))?)),
			ExprWeak::Cast(node)=>Ok(Self::Cast(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Cast))?)),
			ExprWeak::Available(node)=>Ok(Self::Available(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Available))?)),
			ExprWeak::SpecifyOrder(node)=>Ok(Self::SpecifyOrder(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::SpecifyOrder))?)),
			ExprWeak::ExplicitError(node)=>Ok(Self::ExplicitError(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::ExplicitError))?)),
			ExprWeak::IoOperation(node)=>Ok(Self::IoOperation(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::IoOperation))?)),
			ExprWeak::IntLiteral(node)=>Ok(Self::IntLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::IntLiteral))?)),
			ExprWeak::BoolLiteral(node)=>Ok(Self::BoolLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BoolLiteral))?)),
			ExprWeak::StrLiteral(node)=>Ok(Self::StrLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::StrLiteral))?)),
			ExprWeak::TypeLiteral(node)=>Ok(Self::TypeLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::TypeLiteral))?)),
			ExprWeak::SpecialLiteral(node)=>Ok(Self::SpecialLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::SpecialLiteral))?)),
		}
	}
}

impl TryFrom<ExprWeak> for Expr {
	type Error = Error;
	fn try_from(node:ExprWeak)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl TryFrom<&Node> for Expr {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Binary(node)=>Ok(Self::Binary(node.clone())),
			Node::Unary(node)=>Ok(Self::Unary(node.clone())),
			Node::Cond(node)=>Ok(Self::Cond(node.clone())),
			Node::Ident(node)=>Ok(Self::Ident(node.clone())),
			Node::Call(node)=>Ok(Self::Call(node.clone())),
			Node::If(node)=>Ok(Self::If(node.clone())),
			Node::MemberAccess(node)=>Ok(Self::MemberAccess(node.clone())),
			Node::Paren(node)=>Ok(Self::Paren(node.clone())),
			Node::Index(node)=>Ok(Self::Index(node.clone())),
			Node::Match(node)=>Ok(Self::Match(node.clone())),
			Node::Range(node)=>Ok(Self::Range(node.clone())),
			Node::TmpVar(node)=>Ok(Self::TmpVar(node.clone())),
			Node::Import(node)=>Ok(Self::Import(node.clone())),
			Node::Cast(node)=>Ok(Self::Cast(node.clone())),
			Node::Available(node)=>Ok(Self::Available(node.clone())),
			Node::SpecifyOrder(node)=>Ok(Self::SpecifyOrder(node.clone())),
			Node::ExplicitError(node)=>Ok(Self::ExplicitError(node.clone())),
			Node::IoOperation(node)=>Ok(Self::IoOperation(node.clone())),
			Node::IntLiteral(node)=>Ok(Self::IntLiteral(node.clone())),
			Node::BoolLiteral(node)=>Ok(Self::BoolLiteral(node.clone())),
			Node::StrLiteral(node)=>Ok(Self::StrLiteral(node.clone())),
			Node::TypeLiteral(node)=>Ok(Self::TypeLiteral(node.clone())),
			Node::SpecialLiteral(node)=>Ok(Self::SpecialLiteral(node.clone())),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Expr {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Expr> for Node {
	fn from(node:&Expr)-> Self{
		match node {
			Expr::Binary(node)=>Self::Binary(node.clone()),
			Expr::Unary(node)=>Self::Unary(node.clone()),
			Expr::Cond(node)=>Self::Cond(node.clone()),
			Expr::Ident(node)=>Self::Ident(node.clone()),
			Expr::Call(node)=>Self::Call(node.clone()),
			Expr::If(node)=>Self::If(node.clone()),
			Expr::MemberAccess(node)=>Self::MemberAccess(node.clone()),
			Expr::Paren(node)=>Self::Paren(node.clone()),
			Expr::Index(node)=>Self::Index(node.clone()),
			Expr::Match(node)=>Self::Match(node.clone()),
			Expr::Range(node)=>Self::Range(node.clone()),
			Expr::TmpVar(node)=>Self::TmpVar(node.clone()),
			Expr::Import(node)=>Self::Import(node.clone()),
			Expr::Cast(node)=>Self::Cast(node.clone()),
			Expr::Available(node)=>Self::Available(node.clone()),
			Expr::SpecifyOrder(node)=>Self::SpecifyOrder(node.clone()),
			Expr::ExplicitError(node)=>Self::ExplicitError(node.clone()),
			Expr::IoOperation(node)=>Self::IoOperation(node.clone()),
			Expr::IntLiteral(node)=>Self::IntLiteral(node.clone()),
			Expr::BoolLiteral(node)=>Self::BoolLiteral(node.clone()),
			Expr::StrLiteral(node)=>Self::StrLiteral(node.clone()),
			Expr::TypeLiteral(node)=>Self::TypeLiteral(node.clone()),
			Expr::SpecialLiteral(node)=>Self::SpecialLiteral(node.clone()),
		}
	}
}

impl From<Expr> for Node {
	fn from(node:Expr)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&ExprWeak> for Node {
	type Error = Error;
	fn try_from(node:&ExprWeak)->Result<Self,Self::Error>{
		match node {
			ExprWeak::Binary(node)=>Ok(Self::Binary(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Binary))?)),
			ExprWeak::Unary(node)=>Ok(Self::Unary(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Unary))?)),
			ExprWeak::Cond(node)=>Ok(Self::Cond(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Cond))?)),
			ExprWeak::Ident(node)=>Ok(Self::Ident(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Ident))?)),
			ExprWeak::Call(node)=>Ok(Self::Call(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Call))?)),
			ExprWeak::If(node)=>Ok(Self::If(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::If))?)),
			ExprWeak::MemberAccess(node)=>Ok(Self::MemberAccess(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::MemberAccess))?)),
			ExprWeak::Paren(node)=>Ok(Self::Paren(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Paren))?)),
			ExprWeak::Index(node)=>Ok(Self::Index(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Index))?)),
			ExprWeak::Match(node)=>Ok(Self::Match(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Match))?)),
			ExprWeak::Range(node)=>Ok(Self::Range(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Range))?)),
			ExprWeak::TmpVar(node)=>Ok(Self::TmpVar(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::TmpVar))?)),
			ExprWeak::Import(node)=>Ok(Self::Import(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Import))?)),
			ExprWeak::Cast(node)=>Ok(Self::Cast(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Cast))?)),
			ExprWeak::Available(node)=>Ok(Self::Available(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Available))?)),
			ExprWeak::SpecifyOrder(node)=>Ok(Self::SpecifyOrder(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::SpecifyOrder))?)),
			ExprWeak::ExplicitError(node)=>Ok(Self::ExplicitError(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::ExplicitError))?)),
			ExprWeak::IoOperation(node)=>Ok(Self::IoOperation(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::IoOperation))?)),
			ExprWeak::IntLiteral(node)=>Ok(Self::IntLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::IntLiteral))?)),
			ExprWeak::BoolLiteral(node)=>Ok(Self::BoolLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BoolLiteral))?)),
			ExprWeak::StrLiteral(node)=>Ok(Self::StrLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::StrLiteral))?)),
			ExprWeak::TypeLiteral(node)=>Ok(Self::TypeLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::TypeLiteral))?)),
			ExprWeak::SpecialLiteral(node)=>Ok(Self::SpecialLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::SpecialLiteral))?)),
		}
	}
}

impl TryFrom<ExprWeak> for Node {
	type Error = Error;
	fn try_from(node:ExprWeak)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&ExprWeak> for NodeWeak {
	fn from(node:&ExprWeak)-> Self{
		match node {
			ExprWeak::Binary(node)=>Self::Binary(node.clone()),
			ExprWeak::Unary(node)=>Self::Unary(node.clone()),
			ExprWeak::Cond(node)=>Self::Cond(node.clone()),
			ExprWeak::Ident(node)=>Self::Ident(node.clone()),
			ExprWeak::Call(node)=>Self::Call(node.clone()),
			ExprWeak::If(node)=>Self::If(node.clone()),
			ExprWeak::MemberAccess(node)=>Self::MemberAccess(node.clone()),
			ExprWeak::Paren(node)=>Self::Paren(node.clone()),
			ExprWeak::Index(node)=>Self::Index(node.clone()),
			ExprWeak::Match(node)=>Self::Match(node.clone()),
			ExprWeak::Range(node)=>Self::Range(node.clone()),
			ExprWeak::TmpVar(node)=>Self::TmpVar(node.clone()),
			ExprWeak::Import(node)=>Self::Import(node.clone()),
			ExprWeak::Cast(node)=>Self::Cast(node.clone()),
			ExprWeak::Available(node)=>Self::Available(node.clone()),
			ExprWeak::SpecifyOrder(node)=>Self::SpecifyOrder(node.clone()),
			ExprWeak::ExplicitError(node)=>Self::ExplicitError(node.clone()),
			ExprWeak::IoOperation(node)=>Self::IoOperation(node.clone()),
			ExprWeak::IntLiteral(node)=>Self::IntLiteral(node.clone()),
			ExprWeak::BoolLiteral(node)=>Self::BoolLiteral(node.clone()),
			ExprWeak::StrLiteral(node)=>Self::StrLiteral(node.clone()),
			ExprWeak::TypeLiteral(node)=>Self::TypeLiteral(node.clone()),
			ExprWeak::SpecialLiteral(node)=>Self::SpecialLiteral(node.clone()),
		}
	}
}

impl From<ExprWeak> for NodeWeak {
	fn from(node:ExprWeak)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&NodeWeak> for ExprWeak {
	type Error = Error;
	fn try_from(node:&NodeWeak)->Result<Self,Self::Error>{
		match node {
			NodeWeak::Binary(node)=>Ok(Self::Binary(node.clone())),
			NodeWeak::Unary(node)=>Ok(Self::Unary(node.clone())),
			NodeWeak::Cond(node)=>Ok(Self::Cond(node.clone())),
			NodeWeak::Ident(node)=>Ok(Self::Ident(node.clone())),
			NodeWeak::Call(node)=>Ok(Self::Call(node.clone())),
			NodeWeak::If(node)=>Ok(Self::If(node.clone())),
			NodeWeak::MemberAccess(node)=>Ok(Self::MemberAccess(node.clone())),
			NodeWeak::Paren(node)=>Ok(Self::Paren(node.clone())),
			NodeWeak::Index(node)=>Ok(Self::Index(node.clone())),
			NodeWeak::Match(node)=>Ok(Self::Match(node.clone())),
			NodeWeak::Range(node)=>Ok(Self::Range(node.clone())),
			NodeWeak::TmpVar(node)=>Ok(Self::TmpVar(node.clone())),
			NodeWeak::Import(node)=>Ok(Self::Import(node.clone())),
			NodeWeak::Cast(node)=>Ok(Self::Cast(node.clone())),
			NodeWeak::Available(node)=>Ok(Self::Available(node.clone())),
			NodeWeak::SpecifyOrder(node)=>Ok(Self::SpecifyOrder(node.clone())),
			NodeWeak::ExplicitError(node)=>Ok(Self::ExplicitError(node.clone())),
			NodeWeak::IoOperation(node)=>Ok(Self::IoOperation(node.clone())),
			NodeWeak::IntLiteral(node)=>Ok(Self::IntLiteral(node.clone())),
			NodeWeak::BoolLiteral(node)=>Ok(Self::BoolLiteral(node.clone())),
			NodeWeak::StrLiteral(node)=>Ok(Self::StrLiteral(node.clone())),
			NodeWeak::TypeLiteral(node)=>Ok(Self::TypeLiteral(node.clone())),
			NodeWeak::SpecialLiteral(node)=>Ok(Self::SpecialLiteral(node.clone())),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<NodeWeak> for ExprWeak {
	type Error = Error;
	fn try_from(node:NodeWeak)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl TryFrom<&Node> for ExprWeak {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Binary(node)=>Ok(Self::Binary(Rc::downgrade(node))),
			Node::Unary(node)=>Ok(Self::Unary(Rc::downgrade(node))),
			Node::Cond(node)=>Ok(Self::Cond(Rc::downgrade(node))),
			Node::Ident(node)=>Ok(Self::Ident(Rc::downgrade(node))),
			Node::Call(node)=>Ok(Self::Call(Rc::downgrade(node))),
			Node::If(node)=>Ok(Self::If(Rc::downgrade(node))),
			Node::MemberAccess(node)=>Ok(Self::MemberAccess(Rc::downgrade(node))),
			Node::Paren(node)=>Ok(Self::Paren(Rc::downgrade(node))),
			Node::Index(node)=>Ok(Self::Index(Rc::downgrade(node))),
			Node::Match(node)=>Ok(Self::Match(Rc::downgrade(node))),
			Node::Range(node)=>Ok(Self::Range(Rc::downgrade(node))),
			Node::TmpVar(node)=>Ok(Self::TmpVar(Rc::downgrade(node))),
			Node::Import(node)=>Ok(Self::Import(Rc::downgrade(node))),
			Node::Cast(node)=>Ok(Self::Cast(Rc::downgrade(node))),
			Node::Available(node)=>Ok(Self::Available(Rc::downgrade(node))),
			Node::SpecifyOrder(node)=>Ok(Self::SpecifyOrder(Rc::downgrade(node))),
			Node::ExplicitError(node)=>Ok(Self::ExplicitError(Rc::downgrade(node))),
			Node::IoOperation(node)=>Ok(Self::IoOperation(Rc::downgrade(node))),
			Node::IntLiteral(node)=>Ok(Self::IntLiteral(Rc::downgrade(node))),
			Node::BoolLiteral(node)=>Ok(Self::BoolLiteral(Rc::downgrade(node))),
			Node::StrLiteral(node)=>Ok(Self::StrLiteral(Rc::downgrade(node))),
			Node::TypeLiteral(node)=>Ok(Self::TypeLiteral(Rc::downgrade(node))),
			Node::SpecialLiteral(node)=>Ok(Self::SpecialLiteral(Rc::downgrade(node))),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for ExprWeak {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

#[derive(Debug,Clone)]
pub enum Stmt {
	Loop(Rc<RefCell<Loop>>),
	IndentBlock(Rc<RefCell<IndentBlock>>),
	ScopedStatement(Rc<RefCell<ScopedStatement>>),
	MatchBranch(Rc<RefCell<MatchBranch>>),
	UnionCandidate(Rc<RefCell<UnionCandidate>>),
	Return(Rc<RefCell<Return>>),
	Break(Rc<RefCell<Break>>),
	Continue(Rc<RefCell<Continue>>),
	Assert(Rc<RefCell<Assert>>),
	ImplicitYield(Rc<RefCell<ImplicitYield>>),
	Field(Rc<RefCell<Field>>),
	Format(Rc<RefCell<Format>>),
	State(Rc<RefCell<State>>),
	Enum(Rc<RefCell<Enum>>),
	EnumMember(Rc<RefCell<EnumMember>>),
	Function(Rc<RefCell<Function>>),
	BuiltinFunction(Rc<RefCell<BuiltinFunction>>),
	BuiltinField(Rc<RefCell<BuiltinField>>),
	BuiltinObject(Rc<RefCell<BuiltinObject>>),
}

#[derive(Debug,Clone)]
pub enum StmtWeak {
	Loop(Weak<RefCell<Loop>>),
	IndentBlock(Weak<RefCell<IndentBlock>>),
	ScopedStatement(Weak<RefCell<ScopedStatement>>),
	MatchBranch(Weak<RefCell<MatchBranch>>),
	UnionCandidate(Weak<RefCell<UnionCandidate>>),
	Return(Weak<RefCell<Return>>),
	Break(Weak<RefCell<Break>>),
	Continue(Weak<RefCell<Continue>>),
	Assert(Weak<RefCell<Assert>>),
	ImplicitYield(Weak<RefCell<ImplicitYield>>),
	Field(Weak<RefCell<Field>>),
	Format(Weak<RefCell<Format>>),
	State(Weak<RefCell<State>>),
	Enum(Weak<RefCell<Enum>>),
	EnumMember(Weak<RefCell<EnumMember>>),
	Function(Weak<RefCell<Function>>),
	BuiltinFunction(Weak<RefCell<BuiltinFunction>>),
	BuiltinField(Weak<RefCell<BuiltinField>>),
	BuiltinObject(Weak<RefCell<BuiltinObject>>),
}

impl From<&Stmt> for StmtWeak {
	fn from(node:&Stmt)-> Self{
		match node {
			Stmt::Loop(node)=>Self::Loop(Rc::downgrade(node)),
			Stmt::IndentBlock(node)=>Self::IndentBlock(Rc::downgrade(node)),
			Stmt::ScopedStatement(node)=>Self::ScopedStatement(Rc::downgrade(node)),
			Stmt::MatchBranch(node)=>Self::MatchBranch(Rc::downgrade(node)),
			Stmt::UnionCandidate(node)=>Self::UnionCandidate(Rc::downgrade(node)),
			Stmt::Return(node)=>Self::Return(Rc::downgrade(node)),
			Stmt::Break(node)=>Self::Break(Rc::downgrade(node)),
			Stmt::Continue(node)=>Self::Continue(Rc::downgrade(node)),
			Stmt::Assert(node)=>Self::Assert(Rc::downgrade(node)),
			Stmt::ImplicitYield(node)=>Self::ImplicitYield(Rc::downgrade(node)),
			Stmt::Field(node)=>Self::Field(Rc::downgrade(node)),
			Stmt::Format(node)=>Self::Format(Rc::downgrade(node)),
			Stmt::State(node)=>Self::State(Rc::downgrade(node)),
			Stmt::Enum(node)=>Self::Enum(Rc::downgrade(node)),
			Stmt::EnumMember(node)=>Self::EnumMember(Rc::downgrade(node)),
			Stmt::Function(node)=>Self::Function(Rc::downgrade(node)),
			Stmt::BuiltinFunction(node)=>Self::BuiltinFunction(Rc::downgrade(node)),
			Stmt::BuiltinField(node)=>Self::BuiltinField(Rc::downgrade(node)),
			Stmt::BuiltinObject(node)=>Self::BuiltinObject(Rc::downgrade(node)),
		}
	}
}

impl From<Stmt> for StmtWeak {
	fn from(node:Stmt)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&StmtWeak> for Stmt {
	type Error = Error;
	fn try_from(node:&StmtWeak)->Result<Self,Self::Error>{
		match node {
			StmtWeak::Loop(node)=>Ok(Self::Loop(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Loop))?)),
			StmtWeak::IndentBlock(node)=>Ok(Self::IndentBlock(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::IndentBlock))?)),
			StmtWeak::ScopedStatement(node)=>Ok(Self::ScopedStatement(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::ScopedStatement))?)),
			StmtWeak::MatchBranch(node)=>Ok(Self::MatchBranch(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::MatchBranch))?)),
			StmtWeak::UnionCandidate(node)=>Ok(Self::UnionCandidate(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::UnionCandidate))?)),
			StmtWeak::Return(node)=>Ok(Self::Return(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Return))?)),
			StmtWeak::Break(node)=>Ok(Self::Break(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Break))?)),
			StmtWeak::Continue(node)=>Ok(Self::Continue(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Continue))?)),
			StmtWeak::Assert(node)=>Ok(Self::Assert(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Assert))?)),
			StmtWeak::ImplicitYield(node)=>Ok(Self::ImplicitYield(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::ImplicitYield))?)),
			StmtWeak::Field(node)=>Ok(Self::Field(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Field))?)),
			StmtWeak::Format(node)=>Ok(Self::Format(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Format))?)),
			StmtWeak::State(node)=>Ok(Self::State(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::State))?)),
			StmtWeak::Enum(node)=>Ok(Self::Enum(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Enum))?)),
			StmtWeak::EnumMember(node)=>Ok(Self::EnumMember(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::EnumMember))?)),
			StmtWeak::Function(node)=>Ok(Self::Function(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Function))?)),
			StmtWeak::BuiltinFunction(node)=>Ok(Self::BuiltinFunction(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinFunction))?)),
			StmtWeak::BuiltinField(node)=>Ok(Self::BuiltinField(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinField))?)),
			StmtWeak::BuiltinObject(node)=>Ok(Self::BuiltinObject(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinObject))?)),
		}
	}
}

impl TryFrom<StmtWeak> for Stmt {
	type Error = Error;
	fn try_from(node:StmtWeak)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl TryFrom<&Node> for Stmt {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Loop(node)=>Ok(Self::Loop(node.clone())),
			Node::IndentBlock(node)=>Ok(Self::IndentBlock(node.clone())),
			Node::ScopedStatement(node)=>Ok(Self::ScopedStatement(node.clone())),
			Node::MatchBranch(node)=>Ok(Self::MatchBranch(node.clone())),
			Node::UnionCandidate(node)=>Ok(Self::UnionCandidate(node.clone())),
			Node::Return(node)=>Ok(Self::Return(node.clone())),
			Node::Break(node)=>Ok(Self::Break(node.clone())),
			Node::Continue(node)=>Ok(Self::Continue(node.clone())),
			Node::Assert(node)=>Ok(Self::Assert(node.clone())),
			Node::ImplicitYield(node)=>Ok(Self::ImplicitYield(node.clone())),
			Node::Field(node)=>Ok(Self::Field(node.clone())),
			Node::Format(node)=>Ok(Self::Format(node.clone())),
			Node::State(node)=>Ok(Self::State(node.clone())),
			Node::Enum(node)=>Ok(Self::Enum(node.clone())),
			Node::EnumMember(node)=>Ok(Self::EnumMember(node.clone())),
			Node::Function(node)=>Ok(Self::Function(node.clone())),
			Node::BuiltinFunction(node)=>Ok(Self::BuiltinFunction(node.clone())),
			Node::BuiltinField(node)=>Ok(Self::BuiltinField(node.clone())),
			Node::BuiltinObject(node)=>Ok(Self::BuiltinObject(node.clone())),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Stmt {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Stmt> for Node {
	fn from(node:&Stmt)-> Self{
		match node {
			Stmt::Loop(node)=>Self::Loop(node.clone()),
			Stmt::IndentBlock(node)=>Self::IndentBlock(node.clone()),
			Stmt::ScopedStatement(node)=>Self::ScopedStatement(node.clone()),
			Stmt::MatchBranch(node)=>Self::MatchBranch(node.clone()),
			Stmt::UnionCandidate(node)=>Self::UnionCandidate(node.clone()),
			Stmt::Return(node)=>Self::Return(node.clone()),
			Stmt::Break(node)=>Self::Break(node.clone()),
			Stmt::Continue(node)=>Self::Continue(node.clone()),
			Stmt::Assert(node)=>Self::Assert(node.clone()),
			Stmt::ImplicitYield(node)=>Self::ImplicitYield(node.clone()),
			Stmt::Field(node)=>Self::Field(node.clone()),
			Stmt::Format(node)=>Self::Format(node.clone()),
			Stmt::State(node)=>Self::State(node.clone()),
			Stmt::Enum(node)=>Self::Enum(node.clone()),
			Stmt::EnumMember(node)=>Self::EnumMember(node.clone()),
			Stmt::Function(node)=>Self::Function(node.clone()),
			Stmt::BuiltinFunction(node)=>Self::BuiltinFunction(node.clone()),
			Stmt::BuiltinField(node)=>Self::BuiltinField(node.clone()),
			Stmt::BuiltinObject(node)=>Self::BuiltinObject(node.clone()),
		}
	}
}

impl From<Stmt> for Node {
	fn from(node:Stmt)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&StmtWeak> for Node {
	type Error = Error;
	fn try_from(node:&StmtWeak)->Result<Self,Self::Error>{
		match node {
			StmtWeak::Loop(node)=>Ok(Self::Loop(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Loop))?)),
			StmtWeak::IndentBlock(node)=>Ok(Self::IndentBlock(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::IndentBlock))?)),
			StmtWeak::ScopedStatement(node)=>Ok(Self::ScopedStatement(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::ScopedStatement))?)),
			StmtWeak::MatchBranch(node)=>Ok(Self::MatchBranch(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::MatchBranch))?)),
			StmtWeak::UnionCandidate(node)=>Ok(Self::UnionCandidate(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::UnionCandidate))?)),
			StmtWeak::Return(node)=>Ok(Self::Return(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Return))?)),
			StmtWeak::Break(node)=>Ok(Self::Break(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Break))?)),
			StmtWeak::Continue(node)=>Ok(Self::Continue(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Continue))?)),
			StmtWeak::Assert(node)=>Ok(Self::Assert(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Assert))?)),
			StmtWeak::ImplicitYield(node)=>Ok(Self::ImplicitYield(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::ImplicitYield))?)),
			StmtWeak::Field(node)=>Ok(Self::Field(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Field))?)),
			StmtWeak::Format(node)=>Ok(Self::Format(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Format))?)),
			StmtWeak::State(node)=>Ok(Self::State(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::State))?)),
			StmtWeak::Enum(node)=>Ok(Self::Enum(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Enum))?)),
			StmtWeak::EnumMember(node)=>Ok(Self::EnumMember(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::EnumMember))?)),
			StmtWeak::Function(node)=>Ok(Self::Function(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Function))?)),
			StmtWeak::BuiltinFunction(node)=>Ok(Self::BuiltinFunction(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinFunction))?)),
			StmtWeak::BuiltinField(node)=>Ok(Self::BuiltinField(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinField))?)),
			StmtWeak::BuiltinObject(node)=>Ok(Self::BuiltinObject(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinObject))?)),
		}
	}
}

impl TryFrom<StmtWeak> for Node {
	type Error = Error;
	fn try_from(node:StmtWeak)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&StmtWeak> for NodeWeak {
	fn from(node:&StmtWeak)-> Self{
		match node {
			StmtWeak::Loop(node)=>Self::Loop(node.clone()),
			StmtWeak::IndentBlock(node)=>Self::IndentBlock(node.clone()),
			StmtWeak::ScopedStatement(node)=>Self::ScopedStatement(node.clone()),
			StmtWeak::MatchBranch(node)=>Self::MatchBranch(node.clone()),
			StmtWeak::UnionCandidate(node)=>Self::UnionCandidate(node.clone()),
			StmtWeak::Return(node)=>Self::Return(node.clone()),
			StmtWeak::Break(node)=>Self::Break(node.clone()),
			StmtWeak::Continue(node)=>Self::Continue(node.clone()),
			StmtWeak::Assert(node)=>Self::Assert(node.clone()),
			StmtWeak::ImplicitYield(node)=>Self::ImplicitYield(node.clone()),
			StmtWeak::Field(node)=>Self::Field(node.clone()),
			StmtWeak::Format(node)=>Self::Format(node.clone()),
			StmtWeak::State(node)=>Self::State(node.clone()),
			StmtWeak::Enum(node)=>Self::Enum(node.clone()),
			StmtWeak::EnumMember(node)=>Self::EnumMember(node.clone()),
			StmtWeak::Function(node)=>Self::Function(node.clone()),
			StmtWeak::BuiltinFunction(node)=>Self::BuiltinFunction(node.clone()),
			StmtWeak::BuiltinField(node)=>Self::BuiltinField(node.clone()),
			StmtWeak::BuiltinObject(node)=>Self::BuiltinObject(node.clone()),
		}
	}
}

impl From<StmtWeak> for NodeWeak {
	fn from(node:StmtWeak)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&NodeWeak> for StmtWeak {
	type Error = Error;
	fn try_from(node:&NodeWeak)->Result<Self,Self::Error>{
		match node {
			NodeWeak::Loop(node)=>Ok(Self::Loop(node.clone())),
			NodeWeak::IndentBlock(node)=>Ok(Self::IndentBlock(node.clone())),
			NodeWeak::ScopedStatement(node)=>Ok(Self::ScopedStatement(node.clone())),
			NodeWeak::MatchBranch(node)=>Ok(Self::MatchBranch(node.clone())),
			NodeWeak::UnionCandidate(node)=>Ok(Self::UnionCandidate(node.clone())),
			NodeWeak::Return(node)=>Ok(Self::Return(node.clone())),
			NodeWeak::Break(node)=>Ok(Self::Break(node.clone())),
			NodeWeak::Continue(node)=>Ok(Self::Continue(node.clone())),
			NodeWeak::Assert(node)=>Ok(Self::Assert(node.clone())),
			NodeWeak::ImplicitYield(node)=>Ok(Self::ImplicitYield(node.clone())),
			NodeWeak::Field(node)=>Ok(Self::Field(node.clone())),
			NodeWeak::Format(node)=>Ok(Self::Format(node.clone())),
			NodeWeak::State(node)=>Ok(Self::State(node.clone())),
			NodeWeak::Enum(node)=>Ok(Self::Enum(node.clone())),
			NodeWeak::EnumMember(node)=>Ok(Self::EnumMember(node.clone())),
			NodeWeak::Function(node)=>Ok(Self::Function(node.clone())),
			NodeWeak::BuiltinFunction(node)=>Ok(Self::BuiltinFunction(node.clone())),
			NodeWeak::BuiltinField(node)=>Ok(Self::BuiltinField(node.clone())),
			NodeWeak::BuiltinObject(node)=>Ok(Self::BuiltinObject(node.clone())),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<NodeWeak> for StmtWeak {
	type Error = Error;
	fn try_from(node:NodeWeak)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl TryFrom<&Node> for StmtWeak {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Loop(node)=>Ok(Self::Loop(Rc::downgrade(node))),
			Node::IndentBlock(node)=>Ok(Self::IndentBlock(Rc::downgrade(node))),
			Node::ScopedStatement(node)=>Ok(Self::ScopedStatement(Rc::downgrade(node))),
			Node::MatchBranch(node)=>Ok(Self::MatchBranch(Rc::downgrade(node))),
			Node::UnionCandidate(node)=>Ok(Self::UnionCandidate(Rc::downgrade(node))),
			Node::Return(node)=>Ok(Self::Return(Rc::downgrade(node))),
			Node::Break(node)=>Ok(Self::Break(Rc::downgrade(node))),
			Node::Continue(node)=>Ok(Self::Continue(Rc::downgrade(node))),
			Node::Assert(node)=>Ok(Self::Assert(Rc::downgrade(node))),
			Node::ImplicitYield(node)=>Ok(Self::ImplicitYield(Rc::downgrade(node))),
			Node::Field(node)=>Ok(Self::Field(Rc::downgrade(node))),
			Node::Format(node)=>Ok(Self::Format(Rc::downgrade(node))),
			Node::State(node)=>Ok(Self::State(Rc::downgrade(node))),
			Node::Enum(node)=>Ok(Self::Enum(Rc::downgrade(node))),
			Node::EnumMember(node)=>Ok(Self::EnumMember(Rc::downgrade(node))),
			Node::Function(node)=>Ok(Self::Function(Rc::downgrade(node))),
			Node::BuiltinFunction(node)=>Ok(Self::BuiltinFunction(Rc::downgrade(node))),
			Node::BuiltinField(node)=>Ok(Self::BuiltinField(Rc::downgrade(node))),
			Node::BuiltinObject(node)=>Ok(Self::BuiltinObject(Rc::downgrade(node))),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for StmtWeak {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

#[derive(Debug,Clone)]
pub enum Type {
	IntType(Rc<RefCell<IntType>>),
	FloatType(Rc<RefCell<FloatType>>),
	IdentType(Rc<RefCell<IdentType>>),
	IntLiteralType(Rc<RefCell<IntLiteralType>>),
	StrLiteralType(Rc<RefCell<StrLiteralType>>),
	VoidType(Rc<RefCell<VoidType>>),
	BoolType(Rc<RefCell<BoolType>>),
	ArrayType(Rc<RefCell<ArrayType>>),
	FunctionType(Rc<RefCell<FunctionType>>),
	StructType(Rc<RefCell<StructType>>),
	StructUnionType(Rc<RefCell<StructUnionType>>),
	UnionType(Rc<RefCell<UnionType>>),
	RangeType(Rc<RefCell<RangeType>>),
	EnumType(Rc<RefCell<EnumType>>),
	MetaType(Rc<RefCell<MetaType>>),
	OptionalType(Rc<RefCell<OptionalType>>),
}

#[derive(Debug,Clone)]
pub enum TypeWeak {
	IntType(Weak<RefCell<IntType>>),
	FloatType(Weak<RefCell<FloatType>>),
	IdentType(Weak<RefCell<IdentType>>),
	IntLiteralType(Weak<RefCell<IntLiteralType>>),
	StrLiteralType(Weak<RefCell<StrLiteralType>>),
	VoidType(Weak<RefCell<VoidType>>),
	BoolType(Weak<RefCell<BoolType>>),
	ArrayType(Weak<RefCell<ArrayType>>),
	FunctionType(Weak<RefCell<FunctionType>>),
	StructType(Weak<RefCell<StructType>>),
	StructUnionType(Weak<RefCell<StructUnionType>>),
	UnionType(Weak<RefCell<UnionType>>),
	RangeType(Weak<RefCell<RangeType>>),
	EnumType(Weak<RefCell<EnumType>>),
	MetaType(Weak<RefCell<MetaType>>),
	OptionalType(Weak<RefCell<OptionalType>>),
}

impl From<&Type> for TypeWeak {
	fn from(node:&Type)-> Self{
		match node {
			Type::IntType(node)=>Self::IntType(Rc::downgrade(node)),
			Type::FloatType(node)=>Self::FloatType(Rc::downgrade(node)),
			Type::IdentType(node)=>Self::IdentType(Rc::downgrade(node)),
			Type::IntLiteralType(node)=>Self::IntLiteralType(Rc::downgrade(node)),
			Type::StrLiteralType(node)=>Self::StrLiteralType(Rc::downgrade(node)),
			Type::VoidType(node)=>Self::VoidType(Rc::downgrade(node)),
			Type::BoolType(node)=>Self::BoolType(Rc::downgrade(node)),
			Type::ArrayType(node)=>Self::ArrayType(Rc::downgrade(node)),
			Type::FunctionType(node)=>Self::FunctionType(Rc::downgrade(node)),
			Type::StructType(node)=>Self::StructType(Rc::downgrade(node)),
			Type::StructUnionType(node)=>Self::StructUnionType(Rc::downgrade(node)),
			Type::UnionType(node)=>Self::UnionType(Rc::downgrade(node)),
			Type::RangeType(node)=>Self::RangeType(Rc::downgrade(node)),
			Type::EnumType(node)=>Self::EnumType(Rc::downgrade(node)),
			Type::MetaType(node)=>Self::MetaType(Rc::downgrade(node)),
			Type::OptionalType(node)=>Self::OptionalType(Rc::downgrade(node)),
		}
	}
}

impl From<Type> for TypeWeak {
	fn from(node:Type)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&TypeWeak> for Type {
	type Error = Error;
	fn try_from(node:&TypeWeak)->Result<Self,Self::Error>{
		match node {
			TypeWeak::IntType(node)=>Ok(Self::IntType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::IntType))?)),
			TypeWeak::FloatType(node)=>Ok(Self::FloatType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::FloatType))?)),
			TypeWeak::IdentType(node)=>Ok(Self::IdentType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::IdentType))?)),
			TypeWeak::IntLiteralType(node)=>Ok(Self::IntLiteralType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::IntLiteralType))?)),
			TypeWeak::StrLiteralType(node)=>Ok(Self::StrLiteralType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::StrLiteralType))?)),
			TypeWeak::VoidType(node)=>Ok(Self::VoidType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::VoidType))?)),
			TypeWeak::BoolType(node)=>Ok(Self::BoolType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BoolType))?)),
			TypeWeak::ArrayType(node)=>Ok(Self::ArrayType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::ArrayType))?)),
			TypeWeak::FunctionType(node)=>Ok(Self::FunctionType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::FunctionType))?)),
			TypeWeak::StructType(node)=>Ok(Self::StructType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::StructType))?)),
			TypeWeak::StructUnionType(node)=>Ok(Self::StructUnionType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::StructUnionType))?)),
			TypeWeak::UnionType(node)=>Ok(Self::UnionType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::UnionType))?)),
			TypeWeak::RangeType(node)=>Ok(Self::RangeType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::RangeType))?)),
			TypeWeak::EnumType(node)=>Ok(Self::EnumType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::EnumType))?)),
			TypeWeak::MetaType(node)=>Ok(Self::MetaType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::MetaType))?)),
			TypeWeak::OptionalType(node)=>Ok(Self::OptionalType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::OptionalType))?)),
		}
	}
}

impl TryFrom<TypeWeak> for Type {
	type Error = Error;
	fn try_from(node:TypeWeak)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl TryFrom<&Node> for Type {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::IntType(node)=>Ok(Self::IntType(node.clone())),
			Node::FloatType(node)=>Ok(Self::FloatType(node.clone())),
			Node::IdentType(node)=>Ok(Self::IdentType(node.clone())),
			Node::IntLiteralType(node)=>Ok(Self::IntLiteralType(node.clone())),
			Node::StrLiteralType(node)=>Ok(Self::StrLiteralType(node.clone())),
			Node::VoidType(node)=>Ok(Self::VoidType(node.clone())),
			Node::BoolType(node)=>Ok(Self::BoolType(node.clone())),
			Node::ArrayType(node)=>Ok(Self::ArrayType(node.clone())),
			Node::FunctionType(node)=>Ok(Self::FunctionType(node.clone())),
			Node::StructType(node)=>Ok(Self::StructType(node.clone())),
			Node::StructUnionType(node)=>Ok(Self::StructUnionType(node.clone())),
			Node::UnionType(node)=>Ok(Self::UnionType(node.clone())),
			Node::RangeType(node)=>Ok(Self::RangeType(node.clone())),
			Node::EnumType(node)=>Ok(Self::EnumType(node.clone())),
			Node::MetaType(node)=>Ok(Self::MetaType(node.clone())),
			Node::OptionalType(node)=>Ok(Self::OptionalType(node.clone())),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Type {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Type> for Node {
	fn from(node:&Type)-> Self{
		match node {
			Type::IntType(node)=>Self::IntType(node.clone()),
			Type::FloatType(node)=>Self::FloatType(node.clone()),
			Type::IdentType(node)=>Self::IdentType(node.clone()),
			Type::IntLiteralType(node)=>Self::IntLiteralType(node.clone()),
			Type::StrLiteralType(node)=>Self::StrLiteralType(node.clone()),
			Type::VoidType(node)=>Self::VoidType(node.clone()),
			Type::BoolType(node)=>Self::BoolType(node.clone()),
			Type::ArrayType(node)=>Self::ArrayType(node.clone()),
			Type::FunctionType(node)=>Self::FunctionType(node.clone()),
			Type::StructType(node)=>Self::StructType(node.clone()),
			Type::StructUnionType(node)=>Self::StructUnionType(node.clone()),
			Type::UnionType(node)=>Self::UnionType(node.clone()),
			Type::RangeType(node)=>Self::RangeType(node.clone()),
			Type::EnumType(node)=>Self::EnumType(node.clone()),
			Type::MetaType(node)=>Self::MetaType(node.clone()),
			Type::OptionalType(node)=>Self::OptionalType(node.clone()),
		}
	}
}

impl From<Type> for Node {
	fn from(node:Type)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&TypeWeak> for Node {
	type Error = Error;
	fn try_from(node:&TypeWeak)->Result<Self,Self::Error>{
		match node {
			TypeWeak::IntType(node)=>Ok(Self::IntType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::IntType))?)),
			TypeWeak::FloatType(node)=>Ok(Self::FloatType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::FloatType))?)),
			TypeWeak::IdentType(node)=>Ok(Self::IdentType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::IdentType))?)),
			TypeWeak::IntLiteralType(node)=>Ok(Self::IntLiteralType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::IntLiteralType))?)),
			TypeWeak::StrLiteralType(node)=>Ok(Self::StrLiteralType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::StrLiteralType))?)),
			TypeWeak::VoidType(node)=>Ok(Self::VoidType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::VoidType))?)),
			TypeWeak::BoolType(node)=>Ok(Self::BoolType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BoolType))?)),
			TypeWeak::ArrayType(node)=>Ok(Self::ArrayType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::ArrayType))?)),
			TypeWeak::FunctionType(node)=>Ok(Self::FunctionType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::FunctionType))?)),
			TypeWeak::StructType(node)=>Ok(Self::StructType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::StructType))?)),
			TypeWeak::StructUnionType(node)=>Ok(Self::StructUnionType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::StructUnionType))?)),
			TypeWeak::UnionType(node)=>Ok(Self::UnionType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::UnionType))?)),
			TypeWeak::RangeType(node)=>Ok(Self::RangeType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::RangeType))?)),
			TypeWeak::EnumType(node)=>Ok(Self::EnumType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::EnumType))?)),
			TypeWeak::MetaType(node)=>Ok(Self::MetaType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::MetaType))?)),
			TypeWeak::OptionalType(node)=>Ok(Self::OptionalType(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::OptionalType))?)),
		}
	}
}

impl TryFrom<TypeWeak> for Node {
	type Error = Error;
	fn try_from(node:TypeWeak)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&TypeWeak> for NodeWeak {
	fn from(node:&TypeWeak)-> Self{
		match node {
			TypeWeak::IntType(node)=>Self::IntType(node.clone()),
			TypeWeak::FloatType(node)=>Self::FloatType(node.clone()),
			TypeWeak::IdentType(node)=>Self::IdentType(node.clone()),
			TypeWeak::IntLiteralType(node)=>Self::IntLiteralType(node.clone()),
			TypeWeak::StrLiteralType(node)=>Self::StrLiteralType(node.clone()),
			TypeWeak::VoidType(node)=>Self::VoidType(node.clone()),
			TypeWeak::BoolType(node)=>Self::BoolType(node.clone()),
			TypeWeak::ArrayType(node)=>Self::ArrayType(node.clone()),
			TypeWeak::FunctionType(node)=>Self::FunctionType(node.clone()),
			TypeWeak::StructType(node)=>Self::StructType(node.clone()),
			TypeWeak::StructUnionType(node)=>Self::StructUnionType(node.clone()),
			TypeWeak::UnionType(node)=>Self::UnionType(node.clone()),
			TypeWeak::RangeType(node)=>Self::RangeType(node.clone()),
			TypeWeak::EnumType(node)=>Self::EnumType(node.clone()),
			TypeWeak::MetaType(node)=>Self::MetaType(node.clone()),
			TypeWeak::OptionalType(node)=>Self::OptionalType(node.clone()),
		}
	}
}

impl From<TypeWeak> for NodeWeak {
	fn from(node:TypeWeak)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&NodeWeak> for TypeWeak {
	type Error = Error;
	fn try_from(node:&NodeWeak)->Result<Self,Self::Error>{
		match node {
			NodeWeak::IntType(node)=>Ok(Self::IntType(node.clone())),
			NodeWeak::FloatType(node)=>Ok(Self::FloatType(node.clone())),
			NodeWeak::IdentType(node)=>Ok(Self::IdentType(node.clone())),
			NodeWeak::IntLiteralType(node)=>Ok(Self::IntLiteralType(node.clone())),
			NodeWeak::StrLiteralType(node)=>Ok(Self::StrLiteralType(node.clone())),
			NodeWeak::VoidType(node)=>Ok(Self::VoidType(node.clone())),
			NodeWeak::BoolType(node)=>Ok(Self::BoolType(node.clone())),
			NodeWeak::ArrayType(node)=>Ok(Self::ArrayType(node.clone())),
			NodeWeak::FunctionType(node)=>Ok(Self::FunctionType(node.clone())),
			NodeWeak::StructType(node)=>Ok(Self::StructType(node.clone())),
			NodeWeak::StructUnionType(node)=>Ok(Self::StructUnionType(node.clone())),
			NodeWeak::UnionType(node)=>Ok(Self::UnionType(node.clone())),
			NodeWeak::RangeType(node)=>Ok(Self::RangeType(node.clone())),
			NodeWeak::EnumType(node)=>Ok(Self::EnumType(node.clone())),
			NodeWeak::MetaType(node)=>Ok(Self::MetaType(node.clone())),
			NodeWeak::OptionalType(node)=>Ok(Self::OptionalType(node.clone())),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<NodeWeak> for TypeWeak {
	type Error = Error;
	fn try_from(node:NodeWeak)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl TryFrom<&Node> for TypeWeak {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::IntType(node)=>Ok(Self::IntType(Rc::downgrade(node))),
			Node::FloatType(node)=>Ok(Self::FloatType(Rc::downgrade(node))),
			Node::IdentType(node)=>Ok(Self::IdentType(Rc::downgrade(node))),
			Node::IntLiteralType(node)=>Ok(Self::IntLiteralType(Rc::downgrade(node))),
			Node::StrLiteralType(node)=>Ok(Self::StrLiteralType(Rc::downgrade(node))),
			Node::VoidType(node)=>Ok(Self::VoidType(Rc::downgrade(node))),
			Node::BoolType(node)=>Ok(Self::BoolType(Rc::downgrade(node))),
			Node::ArrayType(node)=>Ok(Self::ArrayType(Rc::downgrade(node))),
			Node::FunctionType(node)=>Ok(Self::FunctionType(Rc::downgrade(node))),
			Node::StructType(node)=>Ok(Self::StructType(Rc::downgrade(node))),
			Node::StructUnionType(node)=>Ok(Self::StructUnionType(Rc::downgrade(node))),
			Node::UnionType(node)=>Ok(Self::UnionType(Rc::downgrade(node))),
			Node::RangeType(node)=>Ok(Self::RangeType(Rc::downgrade(node))),
			Node::EnumType(node)=>Ok(Self::EnumType(Rc::downgrade(node))),
			Node::MetaType(node)=>Ok(Self::MetaType(Rc::downgrade(node))),
			Node::OptionalType(node)=>Ok(Self::OptionalType(Rc::downgrade(node))),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for TypeWeak {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

#[derive(Debug,Clone)]
pub enum Literal {
	IntLiteral(Rc<RefCell<IntLiteral>>),
	BoolLiteral(Rc<RefCell<BoolLiteral>>),
	StrLiteral(Rc<RefCell<StrLiteral>>),
	TypeLiteral(Rc<RefCell<TypeLiteral>>),
	SpecialLiteral(Rc<RefCell<SpecialLiteral>>),
}

#[derive(Debug,Clone)]
pub enum LiteralWeak {
	IntLiteral(Weak<RefCell<IntLiteral>>),
	BoolLiteral(Weak<RefCell<BoolLiteral>>),
	StrLiteral(Weak<RefCell<StrLiteral>>),
	TypeLiteral(Weak<RefCell<TypeLiteral>>),
	SpecialLiteral(Weak<RefCell<SpecialLiteral>>),
}

impl From<&Literal> for LiteralWeak {
	fn from(node:&Literal)-> Self{
		match node {
			Literal::IntLiteral(node)=>Self::IntLiteral(Rc::downgrade(node)),
			Literal::BoolLiteral(node)=>Self::BoolLiteral(Rc::downgrade(node)),
			Literal::StrLiteral(node)=>Self::StrLiteral(Rc::downgrade(node)),
			Literal::TypeLiteral(node)=>Self::TypeLiteral(Rc::downgrade(node)),
			Literal::SpecialLiteral(node)=>Self::SpecialLiteral(Rc::downgrade(node)),
		}
	}
}

impl From<Literal> for LiteralWeak {
	fn from(node:Literal)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&LiteralWeak> for Literal {
	type Error = Error;
	fn try_from(node:&LiteralWeak)->Result<Self,Self::Error>{
		match node {
			LiteralWeak::IntLiteral(node)=>Ok(Self::IntLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::IntLiteral))?)),
			LiteralWeak::BoolLiteral(node)=>Ok(Self::BoolLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BoolLiteral))?)),
			LiteralWeak::StrLiteral(node)=>Ok(Self::StrLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::StrLiteral))?)),
			LiteralWeak::TypeLiteral(node)=>Ok(Self::TypeLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::TypeLiteral))?)),
			LiteralWeak::SpecialLiteral(node)=>Ok(Self::SpecialLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::SpecialLiteral))?)),
		}
	}
}

impl TryFrom<LiteralWeak> for Literal {
	type Error = Error;
	fn try_from(node:LiteralWeak)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl TryFrom<&Node> for Literal {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::IntLiteral(node)=>Ok(Self::IntLiteral(node.clone())),
			Node::BoolLiteral(node)=>Ok(Self::BoolLiteral(node.clone())),
			Node::StrLiteral(node)=>Ok(Self::StrLiteral(node.clone())),
			Node::TypeLiteral(node)=>Ok(Self::TypeLiteral(node.clone())),
			Node::SpecialLiteral(node)=>Ok(Self::SpecialLiteral(node.clone())),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Literal {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Literal> for Node {
	fn from(node:&Literal)-> Self{
		match node {
			Literal::IntLiteral(node)=>Self::IntLiteral(node.clone()),
			Literal::BoolLiteral(node)=>Self::BoolLiteral(node.clone()),
			Literal::StrLiteral(node)=>Self::StrLiteral(node.clone()),
			Literal::TypeLiteral(node)=>Self::TypeLiteral(node.clone()),
			Literal::SpecialLiteral(node)=>Self::SpecialLiteral(node.clone()),
		}
	}
}

impl From<Literal> for Node {
	fn from(node:Literal)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&LiteralWeak> for Node {
	type Error = Error;
	fn try_from(node:&LiteralWeak)->Result<Self,Self::Error>{
		match node {
			LiteralWeak::IntLiteral(node)=>Ok(Self::IntLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::IntLiteral))?)),
			LiteralWeak::BoolLiteral(node)=>Ok(Self::BoolLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BoolLiteral))?)),
			LiteralWeak::StrLiteral(node)=>Ok(Self::StrLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::StrLiteral))?)),
			LiteralWeak::TypeLiteral(node)=>Ok(Self::TypeLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::TypeLiteral))?)),
			LiteralWeak::SpecialLiteral(node)=>Ok(Self::SpecialLiteral(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::SpecialLiteral))?)),
		}
	}
}

impl TryFrom<LiteralWeak> for Node {
	type Error = Error;
	fn try_from(node:LiteralWeak)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&LiteralWeak> for NodeWeak {
	fn from(node:&LiteralWeak)-> Self{
		match node {
			LiteralWeak::IntLiteral(node)=>Self::IntLiteral(node.clone()),
			LiteralWeak::BoolLiteral(node)=>Self::BoolLiteral(node.clone()),
			LiteralWeak::StrLiteral(node)=>Self::StrLiteral(node.clone()),
			LiteralWeak::TypeLiteral(node)=>Self::TypeLiteral(node.clone()),
			LiteralWeak::SpecialLiteral(node)=>Self::SpecialLiteral(node.clone()),
		}
	}
}

impl From<LiteralWeak> for NodeWeak {
	fn from(node:LiteralWeak)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&NodeWeak> for LiteralWeak {
	type Error = Error;
	fn try_from(node:&NodeWeak)->Result<Self,Self::Error>{
		match node {
			NodeWeak::IntLiteral(node)=>Ok(Self::IntLiteral(node.clone())),
			NodeWeak::BoolLiteral(node)=>Ok(Self::BoolLiteral(node.clone())),
			NodeWeak::StrLiteral(node)=>Ok(Self::StrLiteral(node.clone())),
			NodeWeak::TypeLiteral(node)=>Ok(Self::TypeLiteral(node.clone())),
			NodeWeak::SpecialLiteral(node)=>Ok(Self::SpecialLiteral(node.clone())),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<NodeWeak> for LiteralWeak {
	type Error = Error;
	fn try_from(node:NodeWeak)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl TryFrom<&Node> for LiteralWeak {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::IntLiteral(node)=>Ok(Self::IntLiteral(Rc::downgrade(node))),
			Node::BoolLiteral(node)=>Ok(Self::BoolLiteral(Rc::downgrade(node))),
			Node::StrLiteral(node)=>Ok(Self::StrLiteral(Rc::downgrade(node))),
			Node::TypeLiteral(node)=>Ok(Self::TypeLiteral(Rc::downgrade(node))),
			Node::SpecialLiteral(node)=>Ok(Self::SpecialLiteral(Rc::downgrade(node))),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for LiteralWeak {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

#[derive(Debug,Clone)]
pub enum Member {
	Field(Rc<RefCell<Field>>),
	Format(Rc<RefCell<Format>>),
	State(Rc<RefCell<State>>),
	Enum(Rc<RefCell<Enum>>),
	EnumMember(Rc<RefCell<EnumMember>>),
	Function(Rc<RefCell<Function>>),
	BuiltinFunction(Rc<RefCell<BuiltinFunction>>),
	BuiltinField(Rc<RefCell<BuiltinField>>),
	BuiltinObject(Rc<RefCell<BuiltinObject>>),
}

#[derive(Debug,Clone)]
pub enum MemberWeak {
	Field(Weak<RefCell<Field>>),
	Format(Weak<RefCell<Format>>),
	State(Weak<RefCell<State>>),
	Enum(Weak<RefCell<Enum>>),
	EnumMember(Weak<RefCell<EnumMember>>),
	Function(Weak<RefCell<Function>>),
	BuiltinFunction(Weak<RefCell<BuiltinFunction>>),
	BuiltinField(Weak<RefCell<BuiltinField>>),
	BuiltinObject(Weak<RefCell<BuiltinObject>>),
}

impl From<&Member> for MemberWeak {
	fn from(node:&Member)-> Self{
		match node {
			Member::Field(node)=>Self::Field(Rc::downgrade(node)),
			Member::Format(node)=>Self::Format(Rc::downgrade(node)),
			Member::State(node)=>Self::State(Rc::downgrade(node)),
			Member::Enum(node)=>Self::Enum(Rc::downgrade(node)),
			Member::EnumMember(node)=>Self::EnumMember(Rc::downgrade(node)),
			Member::Function(node)=>Self::Function(Rc::downgrade(node)),
			Member::BuiltinFunction(node)=>Self::BuiltinFunction(Rc::downgrade(node)),
			Member::BuiltinField(node)=>Self::BuiltinField(Rc::downgrade(node)),
			Member::BuiltinObject(node)=>Self::BuiltinObject(Rc::downgrade(node)),
		}
	}
}

impl From<Member> for MemberWeak {
	fn from(node:Member)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&MemberWeak> for Member {
	type Error = Error;
	fn try_from(node:&MemberWeak)->Result<Self,Self::Error>{
		match node {
			MemberWeak::Field(node)=>Ok(Self::Field(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Field))?)),
			MemberWeak::Format(node)=>Ok(Self::Format(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Format))?)),
			MemberWeak::State(node)=>Ok(Self::State(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::State))?)),
			MemberWeak::Enum(node)=>Ok(Self::Enum(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Enum))?)),
			MemberWeak::EnumMember(node)=>Ok(Self::EnumMember(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::EnumMember))?)),
			MemberWeak::Function(node)=>Ok(Self::Function(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Function))?)),
			MemberWeak::BuiltinFunction(node)=>Ok(Self::BuiltinFunction(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinFunction))?)),
			MemberWeak::BuiltinField(node)=>Ok(Self::BuiltinField(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinField))?)),
			MemberWeak::BuiltinObject(node)=>Ok(Self::BuiltinObject(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinObject))?)),
		}
	}
}

impl TryFrom<MemberWeak> for Member {
	type Error = Error;
	fn try_from(node:MemberWeak)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl TryFrom<&Node> for Member {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Field(node)=>Ok(Self::Field(node.clone())),
			Node::Format(node)=>Ok(Self::Format(node.clone())),
			Node::State(node)=>Ok(Self::State(node.clone())),
			Node::Enum(node)=>Ok(Self::Enum(node.clone())),
			Node::EnumMember(node)=>Ok(Self::EnumMember(node.clone())),
			Node::Function(node)=>Ok(Self::Function(node.clone())),
			Node::BuiltinFunction(node)=>Ok(Self::BuiltinFunction(node.clone())),
			Node::BuiltinField(node)=>Ok(Self::BuiltinField(node.clone())),
			Node::BuiltinObject(node)=>Ok(Self::BuiltinObject(node.clone())),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Member {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Member> for Node {
	fn from(node:&Member)-> Self{
		match node {
			Member::Field(node)=>Self::Field(node.clone()),
			Member::Format(node)=>Self::Format(node.clone()),
			Member::State(node)=>Self::State(node.clone()),
			Member::Enum(node)=>Self::Enum(node.clone()),
			Member::EnumMember(node)=>Self::EnumMember(node.clone()),
			Member::Function(node)=>Self::Function(node.clone()),
			Member::BuiltinFunction(node)=>Self::BuiltinFunction(node.clone()),
			Member::BuiltinField(node)=>Self::BuiltinField(node.clone()),
			Member::BuiltinObject(node)=>Self::BuiltinObject(node.clone()),
		}
	}
}

impl From<Member> for Node {
	fn from(node:Member)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&MemberWeak> for Node {
	type Error = Error;
	fn try_from(node:&MemberWeak)->Result<Self,Self::Error>{
		match node {
			MemberWeak::Field(node)=>Ok(Self::Field(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Field))?)),
			MemberWeak::Format(node)=>Ok(Self::Format(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Format))?)),
			MemberWeak::State(node)=>Ok(Self::State(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::State))?)),
			MemberWeak::Enum(node)=>Ok(Self::Enum(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Enum))?)),
			MemberWeak::EnumMember(node)=>Ok(Self::EnumMember(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::EnumMember))?)),
			MemberWeak::Function(node)=>Ok(Self::Function(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::Function))?)),
			MemberWeak::BuiltinFunction(node)=>Ok(Self::BuiltinFunction(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinFunction))?)),
			MemberWeak::BuiltinField(node)=>Ok(Self::BuiltinField(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinField))?)),
			MemberWeak::BuiltinObject(node)=>Ok(Self::BuiltinObject(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinObject))?)),
		}
	}
}

impl TryFrom<MemberWeak> for Node {
	type Error = Error;
	fn try_from(node:MemberWeak)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&MemberWeak> for NodeWeak {
	fn from(node:&MemberWeak)-> Self{
		match node {
			MemberWeak::Field(node)=>Self::Field(node.clone()),
			MemberWeak::Format(node)=>Self::Format(node.clone()),
			MemberWeak::State(node)=>Self::State(node.clone()),
			MemberWeak::Enum(node)=>Self::Enum(node.clone()),
			MemberWeak::EnumMember(node)=>Self::EnumMember(node.clone()),
			MemberWeak::Function(node)=>Self::Function(node.clone()),
			MemberWeak::BuiltinFunction(node)=>Self::BuiltinFunction(node.clone()),
			MemberWeak::BuiltinField(node)=>Self::BuiltinField(node.clone()),
			MemberWeak::BuiltinObject(node)=>Self::BuiltinObject(node.clone()),
		}
	}
}

impl From<MemberWeak> for NodeWeak {
	fn from(node:MemberWeak)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&NodeWeak> for MemberWeak {
	type Error = Error;
	fn try_from(node:&NodeWeak)->Result<Self,Self::Error>{
		match node {
			NodeWeak::Field(node)=>Ok(Self::Field(node.clone())),
			NodeWeak::Format(node)=>Ok(Self::Format(node.clone())),
			NodeWeak::State(node)=>Ok(Self::State(node.clone())),
			NodeWeak::Enum(node)=>Ok(Self::Enum(node.clone())),
			NodeWeak::EnumMember(node)=>Ok(Self::EnumMember(node.clone())),
			NodeWeak::Function(node)=>Ok(Self::Function(node.clone())),
			NodeWeak::BuiltinFunction(node)=>Ok(Self::BuiltinFunction(node.clone())),
			NodeWeak::BuiltinField(node)=>Ok(Self::BuiltinField(node.clone())),
			NodeWeak::BuiltinObject(node)=>Ok(Self::BuiltinObject(node.clone())),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<NodeWeak> for MemberWeak {
	type Error = Error;
	fn try_from(node:NodeWeak)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl TryFrom<&Node> for MemberWeak {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Field(node)=>Ok(Self::Field(Rc::downgrade(node))),
			Node::Format(node)=>Ok(Self::Format(Rc::downgrade(node))),
			Node::State(node)=>Ok(Self::State(Rc::downgrade(node))),
			Node::Enum(node)=>Ok(Self::Enum(Rc::downgrade(node))),
			Node::EnumMember(node)=>Ok(Self::EnumMember(Rc::downgrade(node))),
			Node::Function(node)=>Ok(Self::Function(Rc::downgrade(node))),
			Node::BuiltinFunction(node)=>Ok(Self::BuiltinFunction(Rc::downgrade(node))),
			Node::BuiltinField(node)=>Ok(Self::BuiltinField(Rc::downgrade(node))),
			Node::BuiltinObject(node)=>Ok(Self::BuiltinObject(Rc::downgrade(node))),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for MemberWeak {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

#[derive(Debug,Clone)]
pub enum BuiltinMember {
	BuiltinFunction(Rc<RefCell<BuiltinFunction>>),
	BuiltinField(Rc<RefCell<BuiltinField>>),
	BuiltinObject(Rc<RefCell<BuiltinObject>>),
}

#[derive(Debug,Clone)]
pub enum BuiltinMemberWeak {
	BuiltinFunction(Weak<RefCell<BuiltinFunction>>),
	BuiltinField(Weak<RefCell<BuiltinField>>),
	BuiltinObject(Weak<RefCell<BuiltinObject>>),
}

impl From<&BuiltinMember> for BuiltinMemberWeak {
	fn from(node:&BuiltinMember)-> Self{
		match node {
			BuiltinMember::BuiltinFunction(node)=>Self::BuiltinFunction(Rc::downgrade(node)),
			BuiltinMember::BuiltinField(node)=>Self::BuiltinField(Rc::downgrade(node)),
			BuiltinMember::BuiltinObject(node)=>Self::BuiltinObject(Rc::downgrade(node)),
		}
	}
}

impl From<BuiltinMember> for BuiltinMemberWeak {
	fn from(node:BuiltinMember)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&BuiltinMemberWeak> for BuiltinMember {
	type Error = Error;
	fn try_from(node:&BuiltinMemberWeak)->Result<Self,Self::Error>{
		match node {
			BuiltinMemberWeak::BuiltinFunction(node)=>Ok(Self::BuiltinFunction(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinFunction))?)),
			BuiltinMemberWeak::BuiltinField(node)=>Ok(Self::BuiltinField(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinField))?)),
			BuiltinMemberWeak::BuiltinObject(node)=>Ok(Self::BuiltinObject(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinObject))?)),
		}
	}
}

impl TryFrom<BuiltinMemberWeak> for BuiltinMember {
	type Error = Error;
	fn try_from(node:BuiltinMemberWeak)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl TryFrom<&Node> for BuiltinMember {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::BuiltinFunction(node)=>Ok(Self::BuiltinFunction(node.clone())),
			Node::BuiltinField(node)=>Ok(Self::BuiltinField(node.clone())),
			Node::BuiltinObject(node)=>Ok(Self::BuiltinObject(node.clone())),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for BuiltinMember {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&BuiltinMember> for Node {
	fn from(node:&BuiltinMember)-> Self{
		match node {
			BuiltinMember::BuiltinFunction(node)=>Self::BuiltinFunction(node.clone()),
			BuiltinMember::BuiltinField(node)=>Self::BuiltinField(node.clone()),
			BuiltinMember::BuiltinObject(node)=>Self::BuiltinObject(node.clone()),
		}
	}
}

impl From<BuiltinMember> for Node {
	fn from(node:BuiltinMember)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&BuiltinMemberWeak> for Node {
	type Error = Error;
	fn try_from(node:&BuiltinMemberWeak)->Result<Self,Self::Error>{
		match node {
			BuiltinMemberWeak::BuiltinFunction(node)=>Ok(Self::BuiltinFunction(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinFunction))?)),
			BuiltinMemberWeak::BuiltinField(node)=>Ok(Self::BuiltinField(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinField))?)),
			BuiltinMemberWeak::BuiltinObject(node)=>Ok(Self::BuiltinObject(node.upgrade().ok_or(Error::InvalidNodeType(NodeType::BuiltinObject))?)),
		}
	}
}

impl TryFrom<BuiltinMemberWeak> for Node {
	type Error = Error;
	fn try_from(node:BuiltinMemberWeak)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&BuiltinMemberWeak> for NodeWeak {
	fn from(node:&BuiltinMemberWeak)-> Self{
		match node {
			BuiltinMemberWeak::BuiltinFunction(node)=>Self::BuiltinFunction(node.clone()),
			BuiltinMemberWeak::BuiltinField(node)=>Self::BuiltinField(node.clone()),
			BuiltinMemberWeak::BuiltinObject(node)=>Self::BuiltinObject(node.clone()),
		}
	}
}

impl From<BuiltinMemberWeak> for NodeWeak {
	fn from(node:BuiltinMemberWeak)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&NodeWeak> for BuiltinMemberWeak {
	type Error = Error;
	fn try_from(node:&NodeWeak)->Result<Self,Self::Error>{
		match node {
			NodeWeak::BuiltinFunction(node)=>Ok(Self::BuiltinFunction(node.clone())),
			NodeWeak::BuiltinField(node)=>Ok(Self::BuiltinField(node.clone())),
			NodeWeak::BuiltinObject(node)=>Ok(Self::BuiltinObject(node.clone())),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<NodeWeak> for BuiltinMemberWeak {
	type Error = Error;
	fn try_from(node:NodeWeak)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl TryFrom<&Node> for BuiltinMemberWeak {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::BuiltinFunction(node)=>Ok(Self::BuiltinFunction(Rc::downgrade(node))),
			Node::BuiltinField(node)=>Ok(Self::BuiltinField(Rc::downgrade(node))),
			Node::BuiltinObject(node)=>Ok(Self::BuiltinObject(Rc::downgrade(node))),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for BuiltinMemberWeak {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Program {
	pub loc: Loc,
	pub struct_type: Option<Rc<RefCell<StructType>>>,
	pub elements: Vec<Node>,
	pub global_scope: Option<Rc<RefCell<Scope>>>,
}

impl TryFrom<&Node> for Rc<RefCell<Program>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Program(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Program>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Program>>> for Node {
	fn from(node:&Rc<RefCell<Program>>)-> Self{
		Node::Program(node.clone())
	}
}

impl From<Rc<RefCell<Program>>> for Node {
	fn from(node:Rc<RefCell<Program>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Comment {
	pub loc: Loc,
	pub comment: String,
}

impl TryFrom<&Node> for Rc<RefCell<Comment>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Comment(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Comment>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Comment>>> for Node {
	fn from(node:&Rc<RefCell<Comment>>)-> Self{
		Node::Comment(node.clone())
	}
}

impl From<Rc<RefCell<Comment>>> for Node {
	fn from(node:Rc<RefCell<Comment>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct CommentGroup {
	pub loc: Loc,
	pub comments: Vec<Rc<RefCell<Comment>>>,
}

impl TryFrom<&Node> for Rc<RefCell<CommentGroup>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::CommentGroup(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<CommentGroup>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<CommentGroup>>> for Node {
	fn from(node:&Rc<RefCell<CommentGroup>>)-> Self{
		Node::CommentGroup(node.clone())
	}
}

impl From<Rc<RefCell<CommentGroup>>> for Node {
	fn from(node:Rc<RefCell<CommentGroup>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct FieldArgument {
	pub loc: Loc,
	pub raw_arguments: Option<Expr>,
	pub end_loc: Loc,
	pub collected_arguments: Vec<Expr>,
	pub arguments: Vec<Expr>,
	pub alignment: Option<Expr>,
	pub alignment_value: Option<u64>,
	pub sub_byte_length: Option<Expr>,
	pub sub_byte_begin: Option<Expr>,
}

impl TryFrom<&Node> for Rc<RefCell<FieldArgument>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::FieldArgument(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<FieldArgument>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<FieldArgument>>> for Node {
	fn from(node:&Rc<RefCell<FieldArgument>>)-> Self{
		Node::FieldArgument(node.clone())
	}
}

impl From<Rc<RefCell<FieldArgument>>> for Node {
	fn from(node:Rc<RefCell<FieldArgument>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Binary {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub op: BinaryOp,
	pub left: Option<Expr>,
	pub right: Option<Expr>,
}

impl TryFrom<&Expr> for Rc<RefCell<Binary>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Binary(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<Binary>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Binary>>> for Expr {
	fn from(node:&Rc<RefCell<Binary>>)-> Self{
		Expr::Binary(node.clone())
	}
}

impl From<Rc<RefCell<Binary>>> for Expr {
	fn from(node:Rc<RefCell<Binary>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Binary>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Binary(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Binary>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Binary>>> for Node {
	fn from(node:&Rc<RefCell<Binary>>)-> Self{
		Node::Binary(node.clone())
	}
}

impl From<Rc<RefCell<Binary>>> for Node {
	fn from(node:Rc<RefCell<Binary>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Unary {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub op: UnaryOp,
	pub expr: Option<Expr>,
}

impl TryFrom<&Expr> for Rc<RefCell<Unary>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Unary(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<Unary>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Unary>>> for Expr {
	fn from(node:&Rc<RefCell<Unary>>)-> Self{
		Expr::Unary(node.clone())
	}
}

impl From<Rc<RefCell<Unary>>> for Expr {
	fn from(node:Rc<RefCell<Unary>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Unary>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Unary(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Unary>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Unary>>> for Node {
	fn from(node:&Rc<RefCell<Unary>>)-> Self{
		Node::Unary(node.clone())
	}
}

impl From<Rc<RefCell<Unary>>> for Node {
	fn from(node:Rc<RefCell<Unary>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Cond {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub cond: Option<Expr>,
	pub then: Option<Expr>,
	pub els_loc: Loc,
	pub els: Option<Expr>,
}

impl TryFrom<&Expr> for Rc<RefCell<Cond>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Cond(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<Cond>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Cond>>> for Expr {
	fn from(node:&Rc<RefCell<Cond>>)-> Self{
		Expr::Cond(node.clone())
	}
}

impl From<Rc<RefCell<Cond>>> for Expr {
	fn from(node:Rc<RefCell<Cond>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Cond>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Cond(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Cond>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Cond>>> for Node {
	fn from(node:&Rc<RefCell<Cond>>)-> Self{
		Node::Cond(node.clone())
	}
}

impl From<Rc<RefCell<Cond>>> for Node {
	fn from(node:Rc<RefCell<Cond>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Ident {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub ident: String,
	pub usage: IdentUsage,
	pub base: Option<NodeWeak>,
	pub scope: Option<Rc<RefCell<Scope>>>,
}

impl TryFrom<&Expr> for Rc<RefCell<Ident>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Ident(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<Ident>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Ident>>> for Expr {
	fn from(node:&Rc<RefCell<Ident>>)-> Self{
		Expr::Ident(node.clone())
	}
}

impl From<Rc<RefCell<Ident>>> for Expr {
	fn from(node:Rc<RefCell<Ident>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Ident>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Ident(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Ident>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Ident>>> for Node {
	fn from(node:&Rc<RefCell<Ident>>)-> Self{
		Node::Ident(node.clone())
	}
}

impl From<Rc<RefCell<Ident>>> for Node {
	fn from(node:Rc<RefCell<Ident>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Call {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub callee: Option<Expr>,
	pub raw_arguments: Option<Expr>,
	pub arguments: Vec<Expr>,
	pub end_loc: Loc,
}

impl TryFrom<&Expr> for Rc<RefCell<Call>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Call(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<Call>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Call>>> for Expr {
	fn from(node:&Rc<RefCell<Call>>)-> Self{
		Expr::Call(node.clone())
	}
}

impl From<Rc<RefCell<Call>>> for Expr {
	fn from(node:Rc<RefCell<Call>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Call>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Call(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Call>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Call>>> for Node {
	fn from(node:&Rc<RefCell<Call>>)-> Self{
		Node::Call(node.clone())
	}
}

impl From<Rc<RefCell<Call>>> for Node {
	fn from(node:Rc<RefCell<Call>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct If {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub cond_scope: Option<Rc<RefCell<Scope>>>,
	pub cond: Option<Expr>,
	pub then: Option<Rc<RefCell<IndentBlock>>>,
	pub els: Option<Node>,
}

impl TryFrom<&Expr> for Rc<RefCell<If>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::If(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<If>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<If>>> for Expr {
	fn from(node:&Rc<RefCell<If>>)-> Self{
		Expr::If(node.clone())
	}
}

impl From<Rc<RefCell<If>>> for Expr {
	fn from(node:Rc<RefCell<If>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<If>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::If(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<If>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<If>>> for Node {
	fn from(node:&Rc<RefCell<If>>)-> Self{
		Node::If(node.clone())
	}
}

impl From<Rc<RefCell<If>>> for Node {
	fn from(node:Rc<RefCell<If>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct MemberAccess {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub target: Option<Expr>,
	pub member: Option<Rc<RefCell<Ident>>>,
	pub base: Option<Weak<RefCell<Ident>>>,
}

impl TryFrom<&Expr> for Rc<RefCell<MemberAccess>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::MemberAccess(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<MemberAccess>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<MemberAccess>>> for Expr {
	fn from(node:&Rc<RefCell<MemberAccess>>)-> Self{
		Expr::MemberAccess(node.clone())
	}
}

impl From<Rc<RefCell<MemberAccess>>> for Expr {
	fn from(node:Rc<RefCell<MemberAccess>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<MemberAccess>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::MemberAccess(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<MemberAccess>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<MemberAccess>>> for Node {
	fn from(node:&Rc<RefCell<MemberAccess>>)-> Self{
		Node::MemberAccess(node.clone())
	}
}

impl From<Rc<RefCell<MemberAccess>>> for Node {
	fn from(node:Rc<RefCell<MemberAccess>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Paren {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub expr: Option<Expr>,
	pub end_loc: Loc,
}

impl TryFrom<&Expr> for Rc<RefCell<Paren>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Paren(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<Paren>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Paren>>> for Expr {
	fn from(node:&Rc<RefCell<Paren>>)-> Self{
		Expr::Paren(node.clone())
	}
}

impl From<Rc<RefCell<Paren>>> for Expr {
	fn from(node:Rc<RefCell<Paren>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Paren>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Paren(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Paren>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Paren>>> for Node {
	fn from(node:&Rc<RefCell<Paren>>)-> Self{
		Node::Paren(node.clone())
	}
}

impl From<Rc<RefCell<Paren>>> for Node {
	fn from(node:Rc<RefCell<Paren>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Index {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub expr: Option<Expr>,
	pub index: Option<Expr>,
	pub end_loc: Loc,
}

impl TryFrom<&Expr> for Rc<RefCell<Index>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Index(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<Index>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Index>>> for Expr {
	fn from(node:&Rc<RefCell<Index>>)-> Self{
		Expr::Index(node.clone())
	}
}

impl From<Rc<RefCell<Index>>> for Expr {
	fn from(node:Rc<RefCell<Index>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Index>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Index(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Index>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Index>>> for Node {
	fn from(node:&Rc<RefCell<Index>>)-> Self{
		Node::Index(node.clone())
	}
}

impl From<Rc<RefCell<Index>>> for Node {
	fn from(node:Rc<RefCell<Index>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Match {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub cond_scope: Option<Rc<RefCell<Scope>>>,
	pub cond: Option<Expr>,
	pub branch: Vec<Node>,
}

impl TryFrom<&Expr> for Rc<RefCell<Match>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Match(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<Match>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Match>>> for Expr {
	fn from(node:&Rc<RefCell<Match>>)-> Self{
		Expr::Match(node.clone())
	}
}

impl From<Rc<RefCell<Match>>> for Expr {
	fn from(node:Rc<RefCell<Match>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Match>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Match(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Match>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Match>>> for Node {
	fn from(node:&Rc<RefCell<Match>>)-> Self{
		Node::Match(node.clone())
	}
}

impl From<Rc<RefCell<Match>>> for Node {
	fn from(node:Rc<RefCell<Match>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Range {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub op: BinaryOp,
	pub start: Option<Expr>,
	pub end: Option<Expr>,
}

impl TryFrom<&Expr> for Rc<RefCell<Range>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Range(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<Range>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Range>>> for Expr {
	fn from(node:&Rc<RefCell<Range>>)-> Self{
		Expr::Range(node.clone())
	}
}

impl From<Rc<RefCell<Range>>> for Expr {
	fn from(node:Rc<RefCell<Range>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Range>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Range(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Range>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Range>>> for Node {
	fn from(node:&Rc<RefCell<Range>>)-> Self{
		Node::Range(node.clone())
	}
}

impl From<Rc<RefCell<Range>>> for Node {
	fn from(node:Rc<RefCell<Range>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct TmpVar {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub tmp_var: u64,
}

impl TryFrom<&Expr> for Rc<RefCell<TmpVar>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::TmpVar(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<TmpVar>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<TmpVar>>> for Expr {
	fn from(node:&Rc<RefCell<TmpVar>>)-> Self{
		Expr::TmpVar(node.clone())
	}
}

impl From<Rc<RefCell<TmpVar>>> for Expr {
	fn from(node:Rc<RefCell<TmpVar>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<TmpVar>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::TmpVar(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<TmpVar>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<TmpVar>>> for Node {
	fn from(node:&Rc<RefCell<TmpVar>>)-> Self{
		Node::TmpVar(node.clone())
	}
}

impl From<Rc<RefCell<TmpVar>>> for Node {
	fn from(node:Rc<RefCell<TmpVar>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Import {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub path: String,
	pub base: Option<Rc<RefCell<Call>>>,
	pub import_desc: Option<Rc<RefCell<Program>>>,
}

impl TryFrom<&Expr> for Rc<RefCell<Import>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Import(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<Import>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Import>>> for Expr {
	fn from(node:&Rc<RefCell<Import>>)-> Self{
		Expr::Import(node.clone())
	}
}

impl From<Rc<RefCell<Import>>> for Expr {
	fn from(node:Rc<RefCell<Import>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Import>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Import(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Import>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Import>>> for Node {
	fn from(node:&Rc<RefCell<Import>>)-> Self{
		Node::Import(node.clone())
	}
}

impl From<Rc<RefCell<Import>>> for Node {
	fn from(node:Rc<RefCell<Import>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Cast {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub base: Option<Rc<RefCell<Call>>>,
	pub expr: Option<Expr>,
}

impl TryFrom<&Expr> for Rc<RefCell<Cast>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Cast(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<Cast>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Cast>>> for Expr {
	fn from(node:&Rc<RefCell<Cast>>)-> Self{
		Expr::Cast(node.clone())
	}
}

impl From<Rc<RefCell<Cast>>> for Expr {
	fn from(node:Rc<RefCell<Cast>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Cast>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Cast(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Cast>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Cast>>> for Node {
	fn from(node:&Rc<RefCell<Cast>>)-> Self{
		Node::Cast(node.clone())
	}
}

impl From<Rc<RefCell<Cast>>> for Node {
	fn from(node:Rc<RefCell<Cast>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Available {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub base: Option<Rc<RefCell<Call>>>,
	pub target: Option<Expr>,
}

impl TryFrom<&Expr> for Rc<RefCell<Available>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::Available(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<Available>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Available>>> for Expr {
	fn from(node:&Rc<RefCell<Available>>)-> Self{
		Expr::Available(node.clone())
	}
}

impl From<Rc<RefCell<Available>>> for Expr {
	fn from(node:Rc<RefCell<Available>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Available>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Available(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Available>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Available>>> for Node {
	fn from(node:&Rc<RefCell<Available>>)-> Self{
		Node::Available(node.clone())
	}
}

impl From<Rc<RefCell<Available>>> for Node {
	fn from(node:Rc<RefCell<Available>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct SpecifyOrder {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub base: Option<Rc<RefCell<Binary>>>,
	pub order_type: OrderType,
	pub order: Option<Expr>,
	pub order_value: Option<u64>,
}

impl TryFrom<&Expr> for Rc<RefCell<SpecifyOrder>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::SpecifyOrder(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<SpecifyOrder>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<SpecifyOrder>>> for Expr {
	fn from(node:&Rc<RefCell<SpecifyOrder>>)-> Self{
		Expr::SpecifyOrder(node.clone())
	}
}

impl From<Rc<RefCell<SpecifyOrder>>> for Expr {
	fn from(node:Rc<RefCell<SpecifyOrder>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<SpecifyOrder>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::SpecifyOrder(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<SpecifyOrder>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<SpecifyOrder>>> for Node {
	fn from(node:&Rc<RefCell<SpecifyOrder>>)-> Self{
		Node::SpecifyOrder(node.clone())
	}
}

impl From<Rc<RefCell<SpecifyOrder>>> for Node {
	fn from(node:Rc<RefCell<SpecifyOrder>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct ExplicitError {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub base: Option<Rc<RefCell<Call>>>,
	pub message: Option<Rc<RefCell<StrLiteral>>>,
}

impl TryFrom<&Expr> for Rc<RefCell<ExplicitError>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::ExplicitError(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<ExplicitError>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<ExplicitError>>> for Expr {
	fn from(node:&Rc<RefCell<ExplicitError>>)-> Self{
		Expr::ExplicitError(node.clone())
	}
}

impl From<Rc<RefCell<ExplicitError>>> for Expr {
	fn from(node:Rc<RefCell<ExplicitError>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<ExplicitError>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::ExplicitError(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<ExplicitError>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<ExplicitError>>> for Node {
	fn from(node:&Rc<RefCell<ExplicitError>>)-> Self{
		Node::ExplicitError(node.clone())
	}
}

impl From<Rc<RefCell<ExplicitError>>> for Node {
	fn from(node:Rc<RefCell<ExplicitError>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct IoOperation {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub base: Option<Expr>,
	pub method: IoMethod,
	pub arguments: Vec<Expr>,
}

impl TryFrom<&Expr> for Rc<RefCell<IoOperation>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::IoOperation(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<IoOperation>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<IoOperation>>> for Expr {
	fn from(node:&Rc<RefCell<IoOperation>>)-> Self{
		Expr::IoOperation(node.clone())
	}
}

impl From<Rc<RefCell<IoOperation>>> for Expr {
	fn from(node:Rc<RefCell<IoOperation>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<IoOperation>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::IoOperation(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<IoOperation>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<IoOperation>>> for Node {
	fn from(node:&Rc<RefCell<IoOperation>>)-> Self{
		Node::IoOperation(node.clone())
	}
}

impl From<Rc<RefCell<IoOperation>>> for Node {
	fn from(node:Rc<RefCell<IoOperation>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Loop {
	pub loc: Loc,
	pub cond_scope: Option<Rc<RefCell<Scope>>>,
	pub init: Option<Expr>,
	pub cond: Option<Expr>,
	pub step: Option<Expr>,
	pub body: Option<Rc<RefCell<IndentBlock>>>,
}

impl TryFrom<&Stmt> for Rc<RefCell<Loop>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::Loop(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Stmt> for Rc<RefCell<Loop>> {
	type Error = Error;
	fn try_from(node:Stmt)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Loop>>> for Stmt {
	fn from(node:&Rc<RefCell<Loop>>)-> Self{
		Stmt::Loop(node.clone())
	}
}

impl From<Rc<RefCell<Loop>>> for Stmt {
	fn from(node:Rc<RefCell<Loop>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Loop>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Loop(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Loop>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Loop>>> for Node {
	fn from(node:&Rc<RefCell<Loop>>)-> Self{
		Node::Loop(node.clone())
	}
}

impl From<Rc<RefCell<Loop>>> for Node {
	fn from(node:Rc<RefCell<Loop>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct IndentBlock {
	pub loc: Loc,
	pub struct_type: Option<Rc<RefCell<StructType>>>,
	pub elements: Vec<Node>,
	pub scope: Option<Rc<RefCell<Scope>>>,
}

impl TryFrom<&Stmt> for Rc<RefCell<IndentBlock>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::IndentBlock(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Stmt> for Rc<RefCell<IndentBlock>> {
	type Error = Error;
	fn try_from(node:Stmt)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<IndentBlock>>> for Stmt {
	fn from(node:&Rc<RefCell<IndentBlock>>)-> Self{
		Stmt::IndentBlock(node.clone())
	}
}

impl From<Rc<RefCell<IndentBlock>>> for Stmt {
	fn from(node:Rc<RefCell<IndentBlock>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<IndentBlock>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::IndentBlock(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<IndentBlock>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<IndentBlock>>> for Node {
	fn from(node:&Rc<RefCell<IndentBlock>>)-> Self{
		Node::IndentBlock(node.clone())
	}
}

impl From<Rc<RefCell<IndentBlock>>> for Node {
	fn from(node:Rc<RefCell<IndentBlock>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct ScopedStatement {
	pub loc: Loc,
	pub struct_type: Option<Rc<RefCell<StructType>>>,
	pub statement: Option<Node>,
	pub scope: Option<Rc<RefCell<Scope>>>,
}

impl TryFrom<&Stmt> for Rc<RefCell<ScopedStatement>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::ScopedStatement(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Stmt> for Rc<RefCell<ScopedStatement>> {
	type Error = Error;
	fn try_from(node:Stmt)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<ScopedStatement>>> for Stmt {
	fn from(node:&Rc<RefCell<ScopedStatement>>)-> Self{
		Stmt::ScopedStatement(node.clone())
	}
}

impl From<Rc<RefCell<ScopedStatement>>> for Stmt {
	fn from(node:Rc<RefCell<ScopedStatement>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<ScopedStatement>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::ScopedStatement(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<ScopedStatement>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<ScopedStatement>>> for Node {
	fn from(node:&Rc<RefCell<ScopedStatement>>)-> Self{
		Node::ScopedStatement(node.clone())
	}
}

impl From<Rc<RefCell<ScopedStatement>>> for Node {
	fn from(node:Rc<RefCell<ScopedStatement>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct MatchBranch {
	pub loc: Loc,
	pub belong: Option<Weak<RefCell<Match>>>,
	pub cond: Option<Expr>,
	pub sym_loc: Loc,
	pub then: Option<Node>,
}

impl TryFrom<&Stmt> for Rc<RefCell<MatchBranch>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::MatchBranch(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Stmt> for Rc<RefCell<MatchBranch>> {
	type Error = Error;
	fn try_from(node:Stmt)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<MatchBranch>>> for Stmt {
	fn from(node:&Rc<RefCell<MatchBranch>>)-> Self{
		Stmt::MatchBranch(node.clone())
	}
}

impl From<Rc<RefCell<MatchBranch>>> for Stmt {
	fn from(node:Rc<RefCell<MatchBranch>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<MatchBranch>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::MatchBranch(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<MatchBranch>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<MatchBranch>>> for Node {
	fn from(node:&Rc<RefCell<MatchBranch>>)-> Self{
		Node::MatchBranch(node.clone())
	}
}

impl From<Rc<RefCell<MatchBranch>>> for Node {
	fn from(node:Rc<RefCell<MatchBranch>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct UnionCandidate {
	pub loc: Loc,
	pub cond: Option<ExprWeak>,
	pub field: Option<Weak<RefCell<Field>>>,
}

impl TryFrom<&Stmt> for Rc<RefCell<UnionCandidate>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::UnionCandidate(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Stmt> for Rc<RefCell<UnionCandidate>> {
	type Error = Error;
	fn try_from(node:Stmt)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<UnionCandidate>>> for Stmt {
	fn from(node:&Rc<RefCell<UnionCandidate>>)-> Self{
		Stmt::UnionCandidate(node.clone())
	}
}

impl From<Rc<RefCell<UnionCandidate>>> for Stmt {
	fn from(node:Rc<RefCell<UnionCandidate>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<UnionCandidate>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::UnionCandidate(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<UnionCandidate>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<UnionCandidate>>> for Node {
	fn from(node:&Rc<RefCell<UnionCandidate>>)-> Self{
		Node::UnionCandidate(node.clone())
	}
}

impl From<Rc<RefCell<UnionCandidate>>> for Node {
	fn from(node:Rc<RefCell<UnionCandidate>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Return {
	pub loc: Loc,
	pub expr: Option<Expr>,
}

impl TryFrom<&Stmt> for Rc<RefCell<Return>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::Return(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Stmt> for Rc<RefCell<Return>> {
	type Error = Error;
	fn try_from(node:Stmt)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Return>>> for Stmt {
	fn from(node:&Rc<RefCell<Return>>)-> Self{
		Stmt::Return(node.clone())
	}
}

impl From<Rc<RefCell<Return>>> for Stmt {
	fn from(node:Rc<RefCell<Return>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Return>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Return(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Return>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Return>>> for Node {
	fn from(node:&Rc<RefCell<Return>>)-> Self{
		Node::Return(node.clone())
	}
}

impl From<Rc<RefCell<Return>>> for Node {
	fn from(node:Rc<RefCell<Return>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Break {
	pub loc: Loc,
}

impl TryFrom<&Stmt> for Rc<RefCell<Break>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::Break(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Stmt> for Rc<RefCell<Break>> {
	type Error = Error;
	fn try_from(node:Stmt)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Break>>> for Stmt {
	fn from(node:&Rc<RefCell<Break>>)-> Self{
		Stmt::Break(node.clone())
	}
}

impl From<Rc<RefCell<Break>>> for Stmt {
	fn from(node:Rc<RefCell<Break>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Break>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Break(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Break>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Break>>> for Node {
	fn from(node:&Rc<RefCell<Break>>)-> Self{
		Node::Break(node.clone())
	}
}

impl From<Rc<RefCell<Break>>> for Node {
	fn from(node:Rc<RefCell<Break>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Continue {
	pub loc: Loc,
}

impl TryFrom<&Stmt> for Rc<RefCell<Continue>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::Continue(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Stmt> for Rc<RefCell<Continue>> {
	type Error = Error;
	fn try_from(node:Stmt)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Continue>>> for Stmt {
	fn from(node:&Rc<RefCell<Continue>>)-> Self{
		Stmt::Continue(node.clone())
	}
}

impl From<Rc<RefCell<Continue>>> for Stmt {
	fn from(node:Rc<RefCell<Continue>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Continue>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Continue(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Continue>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Continue>>> for Node {
	fn from(node:&Rc<RefCell<Continue>>)-> Self{
		Node::Continue(node.clone())
	}
}

impl From<Rc<RefCell<Continue>>> for Node {
	fn from(node:Rc<RefCell<Continue>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Assert {
	pub loc: Loc,
	pub cond: Option<Rc<RefCell<Binary>>>,
	pub is_io_related: bool,
}

impl TryFrom<&Stmt> for Rc<RefCell<Assert>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::Assert(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Stmt> for Rc<RefCell<Assert>> {
	type Error = Error;
	fn try_from(node:Stmt)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Assert>>> for Stmt {
	fn from(node:&Rc<RefCell<Assert>>)-> Self{
		Stmt::Assert(node.clone())
	}
}

impl From<Rc<RefCell<Assert>>> for Stmt {
	fn from(node:Rc<RefCell<Assert>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Assert>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Assert(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Assert>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Assert>>> for Node {
	fn from(node:&Rc<RefCell<Assert>>)-> Self{
		Node::Assert(node.clone())
	}
}

impl From<Rc<RefCell<Assert>>> for Node {
	fn from(node:Rc<RefCell<Assert>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct ImplicitYield {
	pub loc: Loc,
	pub expr: Option<Expr>,
}

impl TryFrom<&Stmt> for Rc<RefCell<ImplicitYield>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::ImplicitYield(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Stmt> for Rc<RefCell<ImplicitYield>> {
	type Error = Error;
	fn try_from(node:Stmt)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<ImplicitYield>>> for Stmt {
	fn from(node:&Rc<RefCell<ImplicitYield>>)-> Self{
		Stmt::ImplicitYield(node.clone())
	}
}

impl From<Rc<RefCell<ImplicitYield>>> for Stmt {
	fn from(node:Rc<RefCell<ImplicitYield>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<ImplicitYield>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::ImplicitYield(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<ImplicitYield>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<ImplicitYield>>> for Node {
	fn from(node:&Rc<RefCell<ImplicitYield>>)-> Self{
		Node::ImplicitYield(node.clone())
	}
}

impl From<Rc<RefCell<ImplicitYield>>> for Node {
	fn from(node:Rc<RefCell<ImplicitYield>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct IntType {
	pub loc: Loc,
	pub is_explicit: bool,
	pub non_dynamic: bool,
	pub bit_alignment: BitAlignment,
	pub bit_size: Option<u64>,
	pub endian: Endian,
	pub is_signed: bool,
	pub is_common_supported: bool,
}

impl TryFrom<&Type> for Rc<RefCell<IntType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::IntType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Type> for Rc<RefCell<IntType>> {
	type Error = Error;
	fn try_from(node:Type)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<IntType>>> for Type {
	fn from(node:&Rc<RefCell<IntType>>)-> Self{
		Type::IntType(node.clone())
	}
}

impl From<Rc<RefCell<IntType>>> for Type {
	fn from(node:Rc<RefCell<IntType>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<IntType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::IntType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<IntType>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<IntType>>> for Node {
	fn from(node:&Rc<RefCell<IntType>>)-> Self{
		Node::IntType(node.clone())
	}
}

impl From<Rc<RefCell<IntType>>> for Node {
	fn from(node:Rc<RefCell<IntType>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct FloatType {
	pub loc: Loc,
	pub is_explicit: bool,
	pub non_dynamic: bool,
	pub bit_alignment: BitAlignment,
	pub bit_size: Option<u64>,
	pub endian: Endian,
	pub is_common_supported: bool,
}

impl TryFrom<&Type> for Rc<RefCell<FloatType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::FloatType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Type> for Rc<RefCell<FloatType>> {
	type Error = Error;
	fn try_from(node:Type)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<FloatType>>> for Type {
	fn from(node:&Rc<RefCell<FloatType>>)-> Self{
		Type::FloatType(node.clone())
	}
}

impl From<Rc<RefCell<FloatType>>> for Type {
	fn from(node:Rc<RefCell<FloatType>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<FloatType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::FloatType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<FloatType>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<FloatType>>> for Node {
	fn from(node:&Rc<RefCell<FloatType>>)-> Self{
		Node::FloatType(node.clone())
	}
}

impl From<Rc<RefCell<FloatType>>> for Node {
	fn from(node:Rc<RefCell<FloatType>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct IdentType {
	pub loc: Loc,
	pub is_explicit: bool,
	pub non_dynamic: bool,
	pub bit_alignment: BitAlignment,
	pub bit_size: Option<u64>,
	pub ident: Option<Rc<RefCell<Ident>>>,
	pub base: Option<TypeWeak>,
}

impl TryFrom<&Type> for Rc<RefCell<IdentType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::IdentType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Type> for Rc<RefCell<IdentType>> {
	type Error = Error;
	fn try_from(node:Type)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<IdentType>>> for Type {
	fn from(node:&Rc<RefCell<IdentType>>)-> Self{
		Type::IdentType(node.clone())
	}
}

impl From<Rc<RefCell<IdentType>>> for Type {
	fn from(node:Rc<RefCell<IdentType>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<IdentType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::IdentType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<IdentType>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<IdentType>>> for Node {
	fn from(node:&Rc<RefCell<IdentType>>)-> Self{
		Node::IdentType(node.clone())
	}
}

impl From<Rc<RefCell<IdentType>>> for Node {
	fn from(node:Rc<RefCell<IdentType>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct IntLiteralType {
	pub loc: Loc,
	pub is_explicit: bool,
	pub non_dynamic: bool,
	pub bit_alignment: BitAlignment,
	pub bit_size: Option<u64>,
	pub base: Option<Weak<RefCell<IntLiteral>>>,
}

impl TryFrom<&Type> for Rc<RefCell<IntLiteralType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::IntLiteralType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Type> for Rc<RefCell<IntLiteralType>> {
	type Error = Error;
	fn try_from(node:Type)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<IntLiteralType>>> for Type {
	fn from(node:&Rc<RefCell<IntLiteralType>>)-> Self{
		Type::IntLiteralType(node.clone())
	}
}

impl From<Rc<RefCell<IntLiteralType>>> for Type {
	fn from(node:Rc<RefCell<IntLiteralType>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<IntLiteralType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::IntLiteralType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<IntLiteralType>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<IntLiteralType>>> for Node {
	fn from(node:&Rc<RefCell<IntLiteralType>>)-> Self{
		Node::IntLiteralType(node.clone())
	}
}

impl From<Rc<RefCell<IntLiteralType>>> for Node {
	fn from(node:Rc<RefCell<IntLiteralType>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct StrLiteralType {
	pub loc: Loc,
	pub is_explicit: bool,
	pub non_dynamic: bool,
	pub bit_alignment: BitAlignment,
	pub bit_size: Option<u64>,
	pub base: Option<Weak<RefCell<StrLiteral>>>,
	pub strong_ref: Option<Rc<RefCell<StrLiteral>>>,
}

impl TryFrom<&Type> for Rc<RefCell<StrLiteralType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::StrLiteralType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Type> for Rc<RefCell<StrLiteralType>> {
	type Error = Error;
	fn try_from(node:Type)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<StrLiteralType>>> for Type {
	fn from(node:&Rc<RefCell<StrLiteralType>>)-> Self{
		Type::StrLiteralType(node.clone())
	}
}

impl From<Rc<RefCell<StrLiteralType>>> for Type {
	fn from(node:Rc<RefCell<StrLiteralType>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<StrLiteralType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::StrLiteralType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<StrLiteralType>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<StrLiteralType>>> for Node {
	fn from(node:&Rc<RefCell<StrLiteralType>>)-> Self{
		Node::StrLiteralType(node.clone())
	}
}

impl From<Rc<RefCell<StrLiteralType>>> for Node {
	fn from(node:Rc<RefCell<StrLiteralType>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct VoidType {
	pub loc: Loc,
	pub is_explicit: bool,
	pub non_dynamic: bool,
	pub bit_alignment: BitAlignment,
	pub bit_size: Option<u64>,
}

impl TryFrom<&Type> for Rc<RefCell<VoidType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::VoidType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Type> for Rc<RefCell<VoidType>> {
	type Error = Error;
	fn try_from(node:Type)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<VoidType>>> for Type {
	fn from(node:&Rc<RefCell<VoidType>>)-> Self{
		Type::VoidType(node.clone())
	}
}

impl From<Rc<RefCell<VoidType>>> for Type {
	fn from(node:Rc<RefCell<VoidType>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<VoidType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::VoidType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<VoidType>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<VoidType>>> for Node {
	fn from(node:&Rc<RefCell<VoidType>>)-> Self{
		Node::VoidType(node.clone())
	}
}

impl From<Rc<RefCell<VoidType>>> for Node {
	fn from(node:Rc<RefCell<VoidType>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct BoolType {
	pub loc: Loc,
	pub is_explicit: bool,
	pub non_dynamic: bool,
	pub bit_alignment: BitAlignment,
	pub bit_size: Option<u64>,
}

impl TryFrom<&Type> for Rc<RefCell<BoolType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::BoolType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Type> for Rc<RefCell<BoolType>> {
	type Error = Error;
	fn try_from(node:Type)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<BoolType>>> for Type {
	fn from(node:&Rc<RefCell<BoolType>>)-> Self{
		Type::BoolType(node.clone())
	}
}

impl From<Rc<RefCell<BoolType>>> for Type {
	fn from(node:Rc<RefCell<BoolType>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<BoolType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::BoolType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<BoolType>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<BoolType>>> for Node {
	fn from(node:&Rc<RefCell<BoolType>>)-> Self{
		Node::BoolType(node.clone())
	}
}

impl From<Rc<RefCell<BoolType>>> for Node {
	fn from(node:Rc<RefCell<BoolType>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct ArrayType {
	pub loc: Loc,
	pub is_explicit: bool,
	pub non_dynamic: bool,
	pub bit_alignment: BitAlignment,
	pub bit_size: Option<u64>,
	pub end_loc: Loc,
	pub base_type: Option<Type>,
	pub length: Option<Expr>,
	pub length_value: Option<u64>,
}

impl TryFrom<&Type> for Rc<RefCell<ArrayType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::ArrayType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Type> for Rc<RefCell<ArrayType>> {
	type Error = Error;
	fn try_from(node:Type)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<ArrayType>>> for Type {
	fn from(node:&Rc<RefCell<ArrayType>>)-> Self{
		Type::ArrayType(node.clone())
	}
}

impl From<Rc<RefCell<ArrayType>>> for Type {
	fn from(node:Rc<RefCell<ArrayType>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<ArrayType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::ArrayType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<ArrayType>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<ArrayType>>> for Node {
	fn from(node:&Rc<RefCell<ArrayType>>)-> Self{
		Node::ArrayType(node.clone())
	}
}

impl From<Rc<RefCell<ArrayType>>> for Node {
	fn from(node:Rc<RefCell<ArrayType>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct FunctionType {
	pub loc: Loc,
	pub is_explicit: bool,
	pub non_dynamic: bool,
	pub bit_alignment: BitAlignment,
	pub bit_size: Option<u64>,
	pub return_type: Option<Type>,
	pub parameters: Vec<Type>,
}

impl TryFrom<&Type> for Rc<RefCell<FunctionType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::FunctionType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Type> for Rc<RefCell<FunctionType>> {
	type Error = Error;
	fn try_from(node:Type)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<FunctionType>>> for Type {
	fn from(node:&Rc<RefCell<FunctionType>>)-> Self{
		Type::FunctionType(node.clone())
	}
}

impl From<Rc<RefCell<FunctionType>>> for Type {
	fn from(node:Rc<RefCell<FunctionType>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<FunctionType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::FunctionType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<FunctionType>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<FunctionType>>> for Node {
	fn from(node:&Rc<RefCell<FunctionType>>)-> Self{
		Node::FunctionType(node.clone())
	}
}

impl From<Rc<RefCell<FunctionType>>> for Node {
	fn from(node:Rc<RefCell<FunctionType>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct StructType {
	pub loc: Loc,
	pub is_explicit: bool,
	pub non_dynamic: bool,
	pub bit_alignment: BitAlignment,
	pub bit_size: Option<u64>,
	pub fields: Vec<Member>,
	pub base: Option<NodeWeak>,
	pub recursive: bool,
	pub fixed_header_size: u64,
	pub fixed_tail_size: u64,
}

impl TryFrom<&Type> for Rc<RefCell<StructType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::StructType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Type> for Rc<RefCell<StructType>> {
	type Error = Error;
	fn try_from(node:Type)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<StructType>>> for Type {
	fn from(node:&Rc<RefCell<StructType>>)-> Self{
		Type::StructType(node.clone())
	}
}

impl From<Rc<RefCell<StructType>>> for Type {
	fn from(node:Rc<RefCell<StructType>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<StructType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::StructType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<StructType>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<StructType>>> for Node {
	fn from(node:&Rc<RefCell<StructType>>)-> Self{
		Node::StructType(node.clone())
	}
}

impl From<Rc<RefCell<StructType>>> for Node {
	fn from(node:Rc<RefCell<StructType>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct StructUnionType {
	pub loc: Loc,
	pub is_explicit: bool,
	pub non_dynamic: bool,
	pub bit_alignment: BitAlignment,
	pub bit_size: Option<u64>,
	pub structs: Vec<Rc<RefCell<StructType>>>,
	pub base: Option<ExprWeak>,
	pub union_fields: Vec<Weak<RefCell<Field>>>,
}

impl TryFrom<&Type> for Rc<RefCell<StructUnionType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::StructUnionType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Type> for Rc<RefCell<StructUnionType>> {
	type Error = Error;
	fn try_from(node:Type)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<StructUnionType>>> for Type {
	fn from(node:&Rc<RefCell<StructUnionType>>)-> Self{
		Type::StructUnionType(node.clone())
	}
}

impl From<Rc<RefCell<StructUnionType>>> for Type {
	fn from(node:Rc<RefCell<StructUnionType>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<StructUnionType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::StructUnionType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<StructUnionType>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<StructUnionType>>> for Node {
	fn from(node:&Rc<RefCell<StructUnionType>>)-> Self{
		Node::StructUnionType(node.clone())
	}
}

impl From<Rc<RefCell<StructUnionType>>> for Node {
	fn from(node:Rc<RefCell<StructUnionType>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct UnionType {
	pub loc: Loc,
	pub is_explicit: bool,
	pub non_dynamic: bool,
	pub bit_alignment: BitAlignment,
	pub bit_size: Option<u64>,
	pub cond: Option<ExprWeak>,
	pub candidates: Vec<Rc<RefCell<UnionCandidate>>>,
	pub base_type: Option<Weak<RefCell<StructUnionType>>>,
	pub common_type: Option<Type>,
}

impl TryFrom<&Type> for Rc<RefCell<UnionType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::UnionType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Type> for Rc<RefCell<UnionType>> {
	type Error = Error;
	fn try_from(node:Type)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<UnionType>>> for Type {
	fn from(node:&Rc<RefCell<UnionType>>)-> Self{
		Type::UnionType(node.clone())
	}
}

impl From<Rc<RefCell<UnionType>>> for Type {
	fn from(node:Rc<RefCell<UnionType>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<UnionType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::UnionType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<UnionType>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<UnionType>>> for Node {
	fn from(node:&Rc<RefCell<UnionType>>)-> Self{
		Node::UnionType(node.clone())
	}
}

impl From<Rc<RefCell<UnionType>>> for Node {
	fn from(node:Rc<RefCell<UnionType>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct RangeType {
	pub loc: Loc,
	pub is_explicit: bool,
	pub non_dynamic: bool,
	pub bit_alignment: BitAlignment,
	pub bit_size: Option<u64>,
	pub base_type: Option<Type>,
	pub range: Option<Weak<RefCell<Range>>>,
}

impl TryFrom<&Type> for Rc<RefCell<RangeType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::RangeType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Type> for Rc<RefCell<RangeType>> {
	type Error = Error;
	fn try_from(node:Type)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<RangeType>>> for Type {
	fn from(node:&Rc<RefCell<RangeType>>)-> Self{
		Type::RangeType(node.clone())
	}
}

impl From<Rc<RefCell<RangeType>>> for Type {
	fn from(node:Rc<RefCell<RangeType>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<RangeType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::RangeType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<RangeType>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<RangeType>>> for Node {
	fn from(node:&Rc<RefCell<RangeType>>)-> Self{
		Node::RangeType(node.clone())
	}
}

impl From<Rc<RefCell<RangeType>>> for Node {
	fn from(node:Rc<RefCell<RangeType>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct EnumType {
	pub loc: Loc,
	pub is_explicit: bool,
	pub non_dynamic: bool,
	pub bit_alignment: BitAlignment,
	pub bit_size: Option<u64>,
	pub base: Option<Weak<RefCell<Enum>>>,
}

impl TryFrom<&Type> for Rc<RefCell<EnumType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::EnumType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Type> for Rc<RefCell<EnumType>> {
	type Error = Error;
	fn try_from(node:Type)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<EnumType>>> for Type {
	fn from(node:&Rc<RefCell<EnumType>>)-> Self{
		Type::EnumType(node.clone())
	}
}

impl From<Rc<RefCell<EnumType>>> for Type {
	fn from(node:Rc<RefCell<EnumType>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<EnumType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::EnumType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<EnumType>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<EnumType>>> for Node {
	fn from(node:&Rc<RefCell<EnumType>>)-> Self{
		Node::EnumType(node.clone())
	}
}

impl From<Rc<RefCell<EnumType>>> for Node {
	fn from(node:Rc<RefCell<EnumType>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct MetaType {
	pub loc: Loc,
	pub is_explicit: bool,
	pub non_dynamic: bool,
	pub bit_alignment: BitAlignment,
	pub bit_size: Option<u64>,
}

impl TryFrom<&Type> for Rc<RefCell<MetaType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::MetaType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Type> for Rc<RefCell<MetaType>> {
	type Error = Error;
	fn try_from(node:Type)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<MetaType>>> for Type {
	fn from(node:&Rc<RefCell<MetaType>>)-> Self{
		Type::MetaType(node.clone())
	}
}

impl From<Rc<RefCell<MetaType>>> for Type {
	fn from(node:Rc<RefCell<MetaType>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<MetaType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::MetaType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<MetaType>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<MetaType>>> for Node {
	fn from(node:&Rc<RefCell<MetaType>>)-> Self{
		Node::MetaType(node.clone())
	}
}

impl From<Rc<RefCell<MetaType>>> for Node {
	fn from(node:Rc<RefCell<MetaType>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct OptionalType {
	pub loc: Loc,
	pub is_explicit: bool,
	pub non_dynamic: bool,
	pub bit_alignment: BitAlignment,
	pub bit_size: Option<u64>,
	pub base_type: Option<Type>,
}

impl TryFrom<&Type> for Rc<RefCell<OptionalType>> {
	type Error = Error;
	fn try_from(node:&Type)->Result<Self,Self::Error>{
		match node {
			Type::OptionalType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Type> for Rc<RefCell<OptionalType>> {
	type Error = Error;
	fn try_from(node:Type)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<OptionalType>>> for Type {
	fn from(node:&Rc<RefCell<OptionalType>>)-> Self{
		Type::OptionalType(node.clone())
	}
}

impl From<Rc<RefCell<OptionalType>>> for Type {
	fn from(node:Rc<RefCell<OptionalType>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<OptionalType>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::OptionalType(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<OptionalType>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<OptionalType>>> for Node {
	fn from(node:&Rc<RefCell<OptionalType>>)-> Self{
		Node::OptionalType(node.clone())
	}
}

impl From<Rc<RefCell<OptionalType>>> for Node {
	fn from(node:Rc<RefCell<OptionalType>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct IntLiteral {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub value: String,
}

impl TryFrom<&Literal> for Rc<RefCell<IntLiteral>> {
	type Error = Error;
	fn try_from(node:&Literal)->Result<Self,Self::Error>{
		match node {
			Literal::IntLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Literal> for Rc<RefCell<IntLiteral>> {
	type Error = Error;
	fn try_from(node:Literal)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<IntLiteral>>> for Literal {
	fn from(node:&Rc<RefCell<IntLiteral>>)-> Self{
		Literal::IntLiteral(node.clone())
	}
}

impl From<Rc<RefCell<IntLiteral>>> for Literal {
	fn from(node:Rc<RefCell<IntLiteral>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Expr> for Rc<RefCell<IntLiteral>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::IntLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<IntLiteral>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<IntLiteral>>> for Expr {
	fn from(node:&Rc<RefCell<IntLiteral>>)-> Self{
		Expr::IntLiteral(node.clone())
	}
}

impl From<Rc<RefCell<IntLiteral>>> for Expr {
	fn from(node:Rc<RefCell<IntLiteral>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<IntLiteral>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::IntLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<IntLiteral>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<IntLiteral>>> for Node {
	fn from(node:&Rc<RefCell<IntLiteral>>)-> Self{
		Node::IntLiteral(node.clone())
	}
}

impl From<Rc<RefCell<IntLiteral>>> for Node {
	fn from(node:Rc<RefCell<IntLiteral>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct BoolLiteral {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub value: bool,
}

impl TryFrom<&Literal> for Rc<RefCell<BoolLiteral>> {
	type Error = Error;
	fn try_from(node:&Literal)->Result<Self,Self::Error>{
		match node {
			Literal::BoolLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Literal> for Rc<RefCell<BoolLiteral>> {
	type Error = Error;
	fn try_from(node:Literal)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<BoolLiteral>>> for Literal {
	fn from(node:&Rc<RefCell<BoolLiteral>>)-> Self{
		Literal::BoolLiteral(node.clone())
	}
}

impl From<Rc<RefCell<BoolLiteral>>> for Literal {
	fn from(node:Rc<RefCell<BoolLiteral>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Expr> for Rc<RefCell<BoolLiteral>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::BoolLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<BoolLiteral>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<BoolLiteral>>> for Expr {
	fn from(node:&Rc<RefCell<BoolLiteral>>)-> Self{
		Expr::BoolLiteral(node.clone())
	}
}

impl From<Rc<RefCell<BoolLiteral>>> for Expr {
	fn from(node:Rc<RefCell<BoolLiteral>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<BoolLiteral>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::BoolLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<BoolLiteral>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<BoolLiteral>>> for Node {
	fn from(node:&Rc<RefCell<BoolLiteral>>)-> Self{
		Node::BoolLiteral(node.clone())
	}
}

impl From<Rc<RefCell<BoolLiteral>>> for Node {
	fn from(node:Rc<RefCell<BoolLiteral>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct StrLiteral {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub value: String,
	pub length: u64,
}

impl TryFrom<&Literal> for Rc<RefCell<StrLiteral>> {
	type Error = Error;
	fn try_from(node:&Literal)->Result<Self,Self::Error>{
		match node {
			Literal::StrLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Literal> for Rc<RefCell<StrLiteral>> {
	type Error = Error;
	fn try_from(node:Literal)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<StrLiteral>>> for Literal {
	fn from(node:&Rc<RefCell<StrLiteral>>)-> Self{
		Literal::StrLiteral(node.clone())
	}
}

impl From<Rc<RefCell<StrLiteral>>> for Literal {
	fn from(node:Rc<RefCell<StrLiteral>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Expr> for Rc<RefCell<StrLiteral>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::StrLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<StrLiteral>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<StrLiteral>>> for Expr {
	fn from(node:&Rc<RefCell<StrLiteral>>)-> Self{
		Expr::StrLiteral(node.clone())
	}
}

impl From<Rc<RefCell<StrLiteral>>> for Expr {
	fn from(node:Rc<RefCell<StrLiteral>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<StrLiteral>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::StrLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<StrLiteral>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<StrLiteral>>> for Node {
	fn from(node:&Rc<RefCell<StrLiteral>>)-> Self{
		Node::StrLiteral(node.clone())
	}
}

impl From<Rc<RefCell<StrLiteral>>> for Node {
	fn from(node:Rc<RefCell<StrLiteral>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct TypeLiteral {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub type_literal: Option<Type>,
	pub end_loc: Loc,
}

impl TryFrom<&Literal> for Rc<RefCell<TypeLiteral>> {
	type Error = Error;
	fn try_from(node:&Literal)->Result<Self,Self::Error>{
		match node {
			Literal::TypeLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Literal> for Rc<RefCell<TypeLiteral>> {
	type Error = Error;
	fn try_from(node:Literal)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<TypeLiteral>>> for Literal {
	fn from(node:&Rc<RefCell<TypeLiteral>>)-> Self{
		Literal::TypeLiteral(node.clone())
	}
}

impl From<Rc<RefCell<TypeLiteral>>> for Literal {
	fn from(node:Rc<RefCell<TypeLiteral>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Expr> for Rc<RefCell<TypeLiteral>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::TypeLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<TypeLiteral>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<TypeLiteral>>> for Expr {
	fn from(node:&Rc<RefCell<TypeLiteral>>)-> Self{
		Expr::TypeLiteral(node.clone())
	}
}

impl From<Rc<RefCell<TypeLiteral>>> for Expr {
	fn from(node:Rc<RefCell<TypeLiteral>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<TypeLiteral>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::TypeLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<TypeLiteral>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<TypeLiteral>>> for Node {
	fn from(node:&Rc<RefCell<TypeLiteral>>)-> Self{
		Node::TypeLiteral(node.clone())
	}
}

impl From<Rc<RefCell<TypeLiteral>>> for Node {
	fn from(node:Rc<RefCell<TypeLiteral>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct SpecialLiteral {
	pub loc: Loc,
	pub expr_type: Option<Type>,
	pub constant_level: ConstantLevel,
	pub kind: SpecialLiteralKind,
}

impl TryFrom<&Literal> for Rc<RefCell<SpecialLiteral>> {
	type Error = Error;
	fn try_from(node:&Literal)->Result<Self,Self::Error>{
		match node {
			Literal::SpecialLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Literal> for Rc<RefCell<SpecialLiteral>> {
	type Error = Error;
	fn try_from(node:Literal)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<SpecialLiteral>>> for Literal {
	fn from(node:&Rc<RefCell<SpecialLiteral>>)-> Self{
		Literal::SpecialLiteral(node.clone())
	}
}

impl From<Rc<RefCell<SpecialLiteral>>> for Literal {
	fn from(node:Rc<RefCell<SpecialLiteral>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Expr> for Rc<RefCell<SpecialLiteral>> {
	type Error = Error;
	fn try_from(node:&Expr)->Result<Self,Self::Error>{
		match node {
			Expr::SpecialLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Expr> for Rc<RefCell<SpecialLiteral>> {
	type Error = Error;
	fn try_from(node:Expr)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<SpecialLiteral>>> for Expr {
	fn from(node:&Rc<RefCell<SpecialLiteral>>)-> Self{
		Expr::SpecialLiteral(node.clone())
	}
}

impl From<Rc<RefCell<SpecialLiteral>>> for Expr {
	fn from(node:Rc<RefCell<SpecialLiteral>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<SpecialLiteral>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::SpecialLiteral(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<SpecialLiteral>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<SpecialLiteral>>> for Node {
	fn from(node:&Rc<RefCell<SpecialLiteral>>)-> Self{
		Node::SpecialLiteral(node.clone())
	}
}

impl From<Rc<RefCell<SpecialLiteral>>> for Node {
	fn from(node:Rc<RefCell<SpecialLiteral>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Field {
	pub loc: Loc,
	pub belong: Option<MemberWeak>,
	pub belong_struct: Option<Weak<RefCell<StructType>>>,
	pub ident: Option<Rc<RefCell<Ident>>>,
	pub colon_loc: Loc,
	pub field_type: Option<Type>,
	pub arguments: Option<Rc<RefCell<FieldArgument>>>,
	pub offset_bit: Option<u64>,
	pub offset_recent: u64,
	pub tail_offset_bit: Option<u64>,
	pub tail_offset_recent: u64,
	pub bit_alignment: BitAlignment,
	pub follow: Follow,
	pub eventual_follow: Follow,
}

impl TryFrom<&Member> for Rc<RefCell<Field>> {
	type Error = Error;
	fn try_from(node:&Member)->Result<Self,Self::Error>{
		match node {
			Member::Field(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Member> for Rc<RefCell<Field>> {
	type Error = Error;
	fn try_from(node:Member)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Field>>> for Member {
	fn from(node:&Rc<RefCell<Field>>)-> Self{
		Member::Field(node.clone())
	}
}

impl From<Rc<RefCell<Field>>> for Member {
	fn from(node:Rc<RefCell<Field>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Stmt> for Rc<RefCell<Field>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::Field(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Stmt> for Rc<RefCell<Field>> {
	type Error = Error;
	fn try_from(node:Stmt)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Field>>> for Stmt {
	fn from(node:&Rc<RefCell<Field>>)-> Self{
		Stmt::Field(node.clone())
	}
}

impl From<Rc<RefCell<Field>>> for Stmt {
	fn from(node:Rc<RefCell<Field>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Field>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Field(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Field>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Field>>> for Node {
	fn from(node:&Rc<RefCell<Field>>)-> Self{
		Node::Field(node.clone())
	}
}

impl From<Rc<RefCell<Field>>> for Node {
	fn from(node:Rc<RefCell<Field>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Format {
	pub loc: Loc,
	pub belong: Option<MemberWeak>,
	pub belong_struct: Option<Weak<RefCell<StructType>>>,
	pub ident: Option<Rc<RefCell<Ident>>>,
	pub body: Option<Rc<RefCell<IndentBlock>>>,
	pub encode_fn: Option<Weak<RefCell<Function>>>,
	pub decode_fn: Option<Weak<RefCell<Function>>>,
	pub cast_fns: Vec<Weak<RefCell<Function>>>,
	pub depends: Vec<Weak<RefCell<IdentType>>>,
	pub state_variables: Vec<Weak<RefCell<Ident>>>,
}

impl TryFrom<&Member> for Rc<RefCell<Format>> {
	type Error = Error;
	fn try_from(node:&Member)->Result<Self,Self::Error>{
		match node {
			Member::Format(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Member> for Rc<RefCell<Format>> {
	type Error = Error;
	fn try_from(node:Member)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Format>>> for Member {
	fn from(node:&Rc<RefCell<Format>>)-> Self{
		Member::Format(node.clone())
	}
}

impl From<Rc<RefCell<Format>>> for Member {
	fn from(node:Rc<RefCell<Format>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Stmt> for Rc<RefCell<Format>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::Format(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Stmt> for Rc<RefCell<Format>> {
	type Error = Error;
	fn try_from(node:Stmt)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Format>>> for Stmt {
	fn from(node:&Rc<RefCell<Format>>)-> Self{
		Stmt::Format(node.clone())
	}
}

impl From<Rc<RefCell<Format>>> for Stmt {
	fn from(node:Rc<RefCell<Format>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Format>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Format(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Format>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Format>>> for Node {
	fn from(node:&Rc<RefCell<Format>>)-> Self{
		Node::Format(node.clone())
	}
}

impl From<Rc<RefCell<Format>>> for Node {
	fn from(node:Rc<RefCell<Format>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct State {
	pub loc: Loc,
	pub belong: Option<MemberWeak>,
	pub belong_struct: Option<Weak<RefCell<StructType>>>,
	pub ident: Option<Rc<RefCell<Ident>>>,
	pub body: Option<Rc<RefCell<IndentBlock>>>,
}

impl TryFrom<&Member> for Rc<RefCell<State>> {
	type Error = Error;
	fn try_from(node:&Member)->Result<Self,Self::Error>{
		match node {
			Member::State(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Member> for Rc<RefCell<State>> {
	type Error = Error;
	fn try_from(node:Member)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<State>>> for Member {
	fn from(node:&Rc<RefCell<State>>)-> Self{
		Member::State(node.clone())
	}
}

impl From<Rc<RefCell<State>>> for Member {
	fn from(node:Rc<RefCell<State>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Stmt> for Rc<RefCell<State>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::State(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Stmt> for Rc<RefCell<State>> {
	type Error = Error;
	fn try_from(node:Stmt)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<State>>> for Stmt {
	fn from(node:&Rc<RefCell<State>>)-> Self{
		Stmt::State(node.clone())
	}
}

impl From<Rc<RefCell<State>>> for Stmt {
	fn from(node:Rc<RefCell<State>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<State>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::State(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<State>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<State>>> for Node {
	fn from(node:&Rc<RefCell<State>>)-> Self{
		Node::State(node.clone())
	}
}

impl From<Rc<RefCell<State>>> for Node {
	fn from(node:Rc<RefCell<State>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Enum {
	pub loc: Loc,
	pub belong: Option<MemberWeak>,
	pub belong_struct: Option<Weak<RefCell<StructType>>>,
	pub ident: Option<Rc<RefCell<Ident>>>,
	pub scope: Option<Rc<RefCell<Scope>>>,
	pub colon_loc: Loc,
	pub base_type: Option<Type>,
	pub members: Vec<Rc<RefCell<EnumMember>>>,
	pub enum_type: Option<Rc<RefCell<EnumType>>>,
}

impl TryFrom<&Member> for Rc<RefCell<Enum>> {
	type Error = Error;
	fn try_from(node:&Member)->Result<Self,Self::Error>{
		match node {
			Member::Enum(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Member> for Rc<RefCell<Enum>> {
	type Error = Error;
	fn try_from(node:Member)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Enum>>> for Member {
	fn from(node:&Rc<RefCell<Enum>>)-> Self{
		Member::Enum(node.clone())
	}
}

impl From<Rc<RefCell<Enum>>> for Member {
	fn from(node:Rc<RefCell<Enum>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Stmt> for Rc<RefCell<Enum>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::Enum(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Stmt> for Rc<RefCell<Enum>> {
	type Error = Error;
	fn try_from(node:Stmt)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Enum>>> for Stmt {
	fn from(node:&Rc<RefCell<Enum>>)-> Self{
		Stmt::Enum(node.clone())
	}
}

impl From<Rc<RefCell<Enum>>> for Stmt {
	fn from(node:Rc<RefCell<Enum>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Enum>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Enum(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Enum>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Enum>>> for Node {
	fn from(node:&Rc<RefCell<Enum>>)-> Self{
		Node::Enum(node.clone())
	}
}

impl From<Rc<RefCell<Enum>>> for Node {
	fn from(node:Rc<RefCell<Enum>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct EnumMember {
	pub loc: Loc,
	pub belong: Option<MemberWeak>,
	pub belong_struct: Option<Weak<RefCell<StructType>>>,
	pub ident: Option<Rc<RefCell<Ident>>>,
	pub expr: Option<Expr>,
}

impl TryFrom<&Member> for Rc<RefCell<EnumMember>> {
	type Error = Error;
	fn try_from(node:&Member)->Result<Self,Self::Error>{
		match node {
			Member::EnumMember(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Member> for Rc<RefCell<EnumMember>> {
	type Error = Error;
	fn try_from(node:Member)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<EnumMember>>> for Member {
	fn from(node:&Rc<RefCell<EnumMember>>)-> Self{
		Member::EnumMember(node.clone())
	}
}

impl From<Rc<RefCell<EnumMember>>> for Member {
	fn from(node:Rc<RefCell<EnumMember>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Stmt> for Rc<RefCell<EnumMember>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::EnumMember(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Stmt> for Rc<RefCell<EnumMember>> {
	type Error = Error;
	fn try_from(node:Stmt)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<EnumMember>>> for Stmt {
	fn from(node:&Rc<RefCell<EnumMember>>)-> Self{
		Stmt::EnumMember(node.clone())
	}
}

impl From<Rc<RefCell<EnumMember>>> for Stmt {
	fn from(node:Rc<RefCell<EnumMember>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<EnumMember>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::EnumMember(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<EnumMember>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<EnumMember>>> for Node {
	fn from(node:&Rc<RefCell<EnumMember>>)-> Self{
		Node::EnumMember(node.clone())
	}
}

impl From<Rc<RefCell<EnumMember>>> for Node {
	fn from(node:Rc<RefCell<EnumMember>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Function {
	pub loc: Loc,
	pub belong: Option<MemberWeak>,
	pub belong_struct: Option<Weak<RefCell<StructType>>>,
	pub ident: Option<Rc<RefCell<Ident>>>,
	pub parameters: Vec<Rc<RefCell<Field>>>,
	pub return_type: Option<Type>,
	pub body: Option<Rc<RefCell<IndentBlock>>>,
	pub func_type: Option<Rc<RefCell<FunctionType>>>,
	pub is_cast: bool,
	pub cast_loc: Loc,
}

impl TryFrom<&Member> for Rc<RefCell<Function>> {
	type Error = Error;
	fn try_from(node:&Member)->Result<Self,Self::Error>{
		match node {
			Member::Function(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Member> for Rc<RefCell<Function>> {
	type Error = Error;
	fn try_from(node:Member)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Function>>> for Member {
	fn from(node:&Rc<RefCell<Function>>)-> Self{
		Member::Function(node.clone())
	}
}

impl From<Rc<RefCell<Function>>> for Member {
	fn from(node:Rc<RefCell<Function>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Stmt> for Rc<RefCell<Function>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::Function(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Stmt> for Rc<RefCell<Function>> {
	type Error = Error;
	fn try_from(node:Stmt)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Function>>> for Stmt {
	fn from(node:&Rc<RefCell<Function>>)-> Self{
		Stmt::Function(node.clone())
	}
}

impl From<Rc<RefCell<Function>>> for Stmt {
	fn from(node:Rc<RefCell<Function>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<Function>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Function(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<Function>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<Function>>> for Node {
	fn from(node:&Rc<RefCell<Function>>)-> Self{
		Node::Function(node.clone())
	}
}

impl From<Rc<RefCell<Function>>> for Node {
	fn from(node:Rc<RefCell<Function>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct BuiltinFunction {
	pub loc: Loc,
	pub belong: Option<MemberWeak>,
	pub belong_struct: Option<Weak<RefCell<StructType>>>,
	pub ident: Option<Rc<RefCell<Ident>>>,
	pub func_type: Option<Rc<RefCell<FunctionType>>>,
}

impl TryFrom<&Member> for Rc<RefCell<BuiltinFunction>> {
	type Error = Error;
	fn try_from(node:&Member)->Result<Self,Self::Error>{
		match node {
			Member::BuiltinFunction(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Member> for Rc<RefCell<BuiltinFunction>> {
	type Error = Error;
	fn try_from(node:Member)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<BuiltinFunction>>> for Member {
	fn from(node:&Rc<RefCell<BuiltinFunction>>)-> Self{
		Member::BuiltinFunction(node.clone())
	}
}

impl From<Rc<RefCell<BuiltinFunction>>> for Member {
	fn from(node:Rc<RefCell<BuiltinFunction>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&BuiltinMember> for Rc<RefCell<BuiltinFunction>> {
	type Error = Error;
	fn try_from(node:&BuiltinMember)->Result<Self,Self::Error>{
		match node {
			BuiltinMember::BuiltinFunction(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<BuiltinMember> for Rc<RefCell<BuiltinFunction>> {
	type Error = Error;
	fn try_from(node:BuiltinMember)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<BuiltinFunction>>> for BuiltinMember {
	fn from(node:&Rc<RefCell<BuiltinFunction>>)-> Self{
		BuiltinMember::BuiltinFunction(node.clone())
	}
}

impl From<Rc<RefCell<BuiltinFunction>>> for BuiltinMember {
	fn from(node:Rc<RefCell<BuiltinFunction>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Stmt> for Rc<RefCell<BuiltinFunction>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::BuiltinFunction(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Stmt> for Rc<RefCell<BuiltinFunction>> {
	type Error = Error;
	fn try_from(node:Stmt)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<BuiltinFunction>>> for Stmt {
	fn from(node:&Rc<RefCell<BuiltinFunction>>)-> Self{
		Stmt::BuiltinFunction(node.clone())
	}
}

impl From<Rc<RefCell<BuiltinFunction>>> for Stmt {
	fn from(node:Rc<RefCell<BuiltinFunction>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<BuiltinFunction>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::BuiltinFunction(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<BuiltinFunction>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<BuiltinFunction>>> for Node {
	fn from(node:&Rc<RefCell<BuiltinFunction>>)-> Self{
		Node::BuiltinFunction(node.clone())
	}
}

impl From<Rc<RefCell<BuiltinFunction>>> for Node {
	fn from(node:Rc<RefCell<BuiltinFunction>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct BuiltinField {
	pub loc: Loc,
	pub belong: Option<MemberWeak>,
	pub belong_struct: Option<Weak<RefCell<StructType>>>,
	pub ident: Option<Rc<RefCell<Ident>>>,
	pub field_type: Option<Type>,
}

impl TryFrom<&Member> for Rc<RefCell<BuiltinField>> {
	type Error = Error;
	fn try_from(node:&Member)->Result<Self,Self::Error>{
		match node {
			Member::BuiltinField(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Member> for Rc<RefCell<BuiltinField>> {
	type Error = Error;
	fn try_from(node:Member)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<BuiltinField>>> for Member {
	fn from(node:&Rc<RefCell<BuiltinField>>)-> Self{
		Member::BuiltinField(node.clone())
	}
}

impl From<Rc<RefCell<BuiltinField>>> for Member {
	fn from(node:Rc<RefCell<BuiltinField>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&BuiltinMember> for Rc<RefCell<BuiltinField>> {
	type Error = Error;
	fn try_from(node:&BuiltinMember)->Result<Self,Self::Error>{
		match node {
			BuiltinMember::BuiltinField(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<BuiltinMember> for Rc<RefCell<BuiltinField>> {
	type Error = Error;
	fn try_from(node:BuiltinMember)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<BuiltinField>>> for BuiltinMember {
	fn from(node:&Rc<RefCell<BuiltinField>>)-> Self{
		BuiltinMember::BuiltinField(node.clone())
	}
}

impl From<Rc<RefCell<BuiltinField>>> for BuiltinMember {
	fn from(node:Rc<RefCell<BuiltinField>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Stmt> for Rc<RefCell<BuiltinField>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::BuiltinField(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Stmt> for Rc<RefCell<BuiltinField>> {
	type Error = Error;
	fn try_from(node:Stmt)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<BuiltinField>>> for Stmt {
	fn from(node:&Rc<RefCell<BuiltinField>>)-> Self{
		Stmt::BuiltinField(node.clone())
	}
}

impl From<Rc<RefCell<BuiltinField>>> for Stmt {
	fn from(node:Rc<RefCell<BuiltinField>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<BuiltinField>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::BuiltinField(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<BuiltinField>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<BuiltinField>>> for Node {
	fn from(node:&Rc<RefCell<BuiltinField>>)-> Self{
		Node::BuiltinField(node.clone())
	}
}

impl From<Rc<RefCell<BuiltinField>>> for Node {
	fn from(node:Rc<RefCell<BuiltinField>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct BuiltinObject {
	pub loc: Loc,
	pub belong: Option<MemberWeak>,
	pub belong_struct: Option<Weak<RefCell<StructType>>>,
	pub ident: Option<Rc<RefCell<Ident>>>,
	pub members: Vec<BuiltinMember>,
}

impl TryFrom<&Member> for Rc<RefCell<BuiltinObject>> {
	type Error = Error;
	fn try_from(node:&Member)->Result<Self,Self::Error>{
		match node {
			Member::BuiltinObject(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Member> for Rc<RefCell<BuiltinObject>> {
	type Error = Error;
	fn try_from(node:Member)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<BuiltinObject>>> for Member {
	fn from(node:&Rc<RefCell<BuiltinObject>>)-> Self{
		Member::BuiltinObject(node.clone())
	}
}

impl From<Rc<RefCell<BuiltinObject>>> for Member {
	fn from(node:Rc<RefCell<BuiltinObject>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&BuiltinMember> for Rc<RefCell<BuiltinObject>> {
	type Error = Error;
	fn try_from(node:&BuiltinMember)->Result<Self,Self::Error>{
		match node {
			BuiltinMember::BuiltinObject(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<BuiltinMember> for Rc<RefCell<BuiltinObject>> {
	type Error = Error;
	fn try_from(node:BuiltinMember)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<BuiltinObject>>> for BuiltinMember {
	fn from(node:&Rc<RefCell<BuiltinObject>>)-> Self{
		BuiltinMember::BuiltinObject(node.clone())
	}
}

impl From<Rc<RefCell<BuiltinObject>>> for BuiltinMember {
	fn from(node:Rc<RefCell<BuiltinObject>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Stmt> for Rc<RefCell<BuiltinObject>> {
	type Error = Error;
	fn try_from(node:&Stmt)->Result<Self,Self::Error>{
		match node {
			Stmt::BuiltinObject(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(Node::from(node).into())),
		}
	}
}

impl TryFrom<Stmt> for Rc<RefCell<BuiltinObject>> {
	type Error = Error;
	fn try_from(node:Stmt)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<BuiltinObject>>> for Stmt {
	fn from(node:&Rc<RefCell<BuiltinObject>>)-> Self{
		Stmt::BuiltinObject(node.clone())
	}
}

impl From<Rc<RefCell<BuiltinObject>>> for Stmt {
	fn from(node:Rc<RefCell<BuiltinObject>>)-> Self{
		Self::from(&node)
	}
}

impl TryFrom<&Node> for Rc<RefCell<BuiltinObject>> {
	type Error = Error;
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::BuiltinObject(node)=>Ok(node.clone()),
			_=> Err(Error::InvalidNodeType(node.into())),
		}
	}
}

impl TryFrom<Node> for Rc<RefCell<BuiltinObject>> {
	type Error = Error;
	fn try_from(node:Node)->Result<Self,Self::Error>{
		Self::try_from(&node)
	}
}

impl From<&Rc<RefCell<BuiltinObject>>> for Node {
	fn from(node:&Rc<RefCell<BuiltinObject>>)-> Self{
		Node::BuiltinObject(node.clone())
	}
}

impl From<Rc<RefCell<BuiltinObject>>> for Node {
	fn from(node:Rc<RefCell<BuiltinObject>>)-> Self{
		Self::from(&node)
	}
}

#[derive(Debug,Clone)]
pub struct Scope {
	pub prev: Option<Weak<RefCell<Scope>>>,
	pub next: Option<Rc<RefCell<Scope>>>,
	pub branch: Option<Rc<RefCell<Scope>>>,
	pub ident: Vec<Weak<RefCell<Ident>>>,
	pub owner: Option<NodeWeak>,
	pub branch_root: bool,
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
pub struct Pos {
	pub begin: u64,
	pub end: u64,
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
pub struct Loc {
	pub pos: Pos,
	pub file: u64,
	pub line: u64,
	pub col: u64,
}

#[derive(Debug,Clone,Serialize,Deserialize)]
pub struct Token {
	pub tag: TokenTag,
	pub token: String,
	pub loc: Loc,
}

#[derive(Debug,Clone,Serialize,Deserialize)]
pub struct RawScope {
	pub prev: Option<usize>,
	pub next: Option<usize>,
	pub branch: Option<usize>,
	pub ident: Vec<usize>,
	pub owner: Option<usize>,
	pub branch_root: bool,
}

#[derive(Debug,Clone,Serialize,Deserialize)]
pub struct RawNode {
	pub node_type: String,
	pub loc: Loc,
	pub body: HashMap<String,serde_json::Value>,
}

#[derive(Debug,Clone,Serialize,Deserialize)]
pub struct SrcErrorEntry {
	pub msg: String,
	pub file: String,
	pub loc: Loc,
	pub src: String,
	pub warn: bool,
}

#[derive(Debug,Clone,Serialize,Deserialize)]
pub struct SrcError {
	pub errs: Vec<SrcErrorEntry>,
}

#[derive(Debug,Clone,Serialize,Deserialize)]
pub struct JsonAst {
	pub node: Vec<RawNode>,
	pub scope: Vec<RawScope>,
}

#[derive(Debug,Clone,Serialize,Deserialize)]
pub struct AstFile {
	pub files: Vec<String>,
	pub ast: Option<JsonAst>,
	pub error: Option<SrcError>,
}

#[derive(Debug,Clone,Serialize,Deserialize)]
pub struct TokenFile {
	pub files: Vec<String>,
	pub tokens: Option<Vec<Token>>,
	pub error: Option<SrcError>,
}

pub fn parse_ast(ast:JsonAst)->Result<Rc<RefCell<Program>> ,Error>{
	let mut nodes = Vec::new();
	let mut scopes = Vec::new();
	for raw_node in &ast.node{
		let node_type :NodeType = match raw_node.node_type.as_str().try_into() {
			Ok(v)=>v,
			Err(_) =>return Err(Error::InvalidRawNodeType(raw_node.node_type.clone())),
		};
		let node = match node_type {
			NodeType::Program => {
				Node::Program(Rc::new(RefCell::new(Program {
				loc: raw_node.loc.clone(),
				struct_type: None,
				elements: Vec::new(),
				global_scope: None,
				})))
			},
			NodeType::Comment => {
				Node::Comment(Rc::new(RefCell::new(Comment {
				loc: raw_node.loc.clone(),
				comment: String::new(),
				})))
			},
			NodeType::CommentGroup => {
				Node::CommentGroup(Rc::new(RefCell::new(CommentGroup {
				loc: raw_node.loc.clone(),
				comments: Vec::new(),
				})))
			},
			NodeType::FieldArgument => {
				Node::FieldArgument(Rc::new(RefCell::new(FieldArgument {
				loc: raw_node.loc.clone(),
				raw_arguments: None,
				end_loc: raw_node.loc.clone(),
				collected_arguments: Vec::new(),
				arguments: Vec::new(),
				alignment: None,
				alignment_value: None,
				sub_byte_length: None,
				sub_byte_begin: None,
				})))
			},
			NodeType::Binary => {
				Node::Binary(Rc::new(RefCell::new(Binary {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				op: BinaryOp::Mul,
				left: None,
				right: None,
				})))
			},
			NodeType::Unary => {
				Node::Unary(Rc::new(RefCell::new(Unary {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				op: UnaryOp::Not,
				expr: None,
				})))
			},
			NodeType::Cond => {
				Node::Cond(Rc::new(RefCell::new(Cond {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				cond: None,
				then: None,
				els_loc: raw_node.loc.clone(),
				els: None,
				})))
			},
			NodeType::Ident => {
				Node::Ident(Rc::new(RefCell::new(Ident {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				ident: String::new(),
				usage: IdentUsage::Unknown,
				base: None,
				scope: None,
				})))
			},
			NodeType::Call => {
				Node::Call(Rc::new(RefCell::new(Call {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				callee: None,
				raw_arguments: None,
				arguments: Vec::new(),
				end_loc: raw_node.loc.clone(),
				})))
			},
			NodeType::If => {
				Node::If(Rc::new(RefCell::new(If {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				cond_scope: None,
				cond: None,
				then: None,
				els: None,
				})))
			},
			NodeType::MemberAccess => {
				Node::MemberAccess(Rc::new(RefCell::new(MemberAccess {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				target: None,
				member: None,
				base: None,
				})))
			},
			NodeType::Paren => {
				Node::Paren(Rc::new(RefCell::new(Paren {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				expr: None,
				end_loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Index => {
				Node::Index(Rc::new(RefCell::new(Index {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				expr: None,
				index: None,
				end_loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Match => {
				Node::Match(Rc::new(RefCell::new(Match {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				cond_scope: None,
				cond: None,
				branch: Vec::new(),
				})))
			},
			NodeType::Range => {
				Node::Range(Rc::new(RefCell::new(Range {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				op: BinaryOp::Mul,
				start: None,
				end: None,
				})))
			},
			NodeType::TmpVar => {
				Node::TmpVar(Rc::new(RefCell::new(TmpVar {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				tmp_var: 0,
				})))
			},
			NodeType::Import => {
				Node::Import(Rc::new(RefCell::new(Import {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				path: String::new(),
				base: None,
				import_desc: None,
				})))
			},
			NodeType::Cast => {
				Node::Cast(Rc::new(RefCell::new(Cast {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				base: None,
				expr: None,
				})))
			},
			NodeType::Available => {
				Node::Available(Rc::new(RefCell::new(Available {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				base: None,
				target: None,
				})))
			},
			NodeType::SpecifyOrder => {
				Node::SpecifyOrder(Rc::new(RefCell::new(SpecifyOrder {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				base: None,
				order_type: OrderType::Byte,
				order: None,
				order_value: None,
				})))
			},
			NodeType::ExplicitError => {
				Node::ExplicitError(Rc::new(RefCell::new(ExplicitError {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				base: None,
				message: None,
				})))
			},
			NodeType::IoOperation => {
				Node::IoOperation(Rc::new(RefCell::new(IoOperation {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				base: None,
				method: IoMethod::Unspec,
				arguments: Vec::new(),
				})))
			},
			NodeType::Loop => {
				Node::Loop(Rc::new(RefCell::new(Loop {
				loc: raw_node.loc.clone(),
				cond_scope: None,
				init: None,
				cond: None,
				step: None,
				body: None,
				})))
			},
			NodeType::IndentBlock => {
				Node::IndentBlock(Rc::new(RefCell::new(IndentBlock {
				loc: raw_node.loc.clone(),
				struct_type: None,
				elements: Vec::new(),
				scope: None,
				})))
			},
			NodeType::ScopedStatement => {
				Node::ScopedStatement(Rc::new(RefCell::new(ScopedStatement {
				loc: raw_node.loc.clone(),
				struct_type: None,
				statement: None,
				scope: None,
				})))
			},
			NodeType::MatchBranch => {
				Node::MatchBranch(Rc::new(RefCell::new(MatchBranch {
				loc: raw_node.loc.clone(),
				belong: None,
				cond: None,
				sym_loc: raw_node.loc.clone(),
				then: None,
				})))
			},
			NodeType::UnionCandidate => {
				Node::UnionCandidate(Rc::new(RefCell::new(UnionCandidate {
				loc: raw_node.loc.clone(),
				cond: None,
				field: None,
				})))
			},
			NodeType::Return => {
				Node::Return(Rc::new(RefCell::new(Return {
				loc: raw_node.loc.clone(),
				expr: None,
				})))
			},
			NodeType::Break => {
				Node::Break(Rc::new(RefCell::new(Break {
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Continue => {
				Node::Continue(Rc::new(RefCell::new(Continue {
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Assert => {
				Node::Assert(Rc::new(RefCell::new(Assert {
				loc: raw_node.loc.clone(),
				cond: None,
				is_io_related: false,
				})))
			},
			NodeType::ImplicitYield => {
				Node::ImplicitYield(Rc::new(RefCell::new(ImplicitYield {
				loc: raw_node.loc.clone(),
				expr: None,
				})))
			},
			NodeType::IntType => {
				Node::IntType(Rc::new(RefCell::new(IntType {
				loc: raw_node.loc.clone(),
				is_explicit: false,
				non_dynamic: false,
				bit_alignment: BitAlignment::ByteAligned,
				bit_size: None,
				endian: Endian::Unspec,
				is_signed: false,
				is_common_supported: false,
				})))
			},
			NodeType::FloatType => {
				Node::FloatType(Rc::new(RefCell::new(FloatType {
				loc: raw_node.loc.clone(),
				is_explicit: false,
				non_dynamic: false,
				bit_alignment: BitAlignment::ByteAligned,
				bit_size: None,
				endian: Endian::Unspec,
				is_common_supported: false,
				})))
			},
			NodeType::IdentType => {
				Node::IdentType(Rc::new(RefCell::new(IdentType {
				loc: raw_node.loc.clone(),
				is_explicit: false,
				non_dynamic: false,
				bit_alignment: BitAlignment::ByteAligned,
				bit_size: None,
				ident: None,
				base: None,
				})))
			},
			NodeType::IntLiteralType => {
				Node::IntLiteralType(Rc::new(RefCell::new(IntLiteralType {
				loc: raw_node.loc.clone(),
				is_explicit: false,
				non_dynamic: false,
				bit_alignment: BitAlignment::ByteAligned,
				bit_size: None,
				base: None,
				})))
			},
			NodeType::StrLiteralType => {
				Node::StrLiteralType(Rc::new(RefCell::new(StrLiteralType {
				loc: raw_node.loc.clone(),
				is_explicit: false,
				non_dynamic: false,
				bit_alignment: BitAlignment::ByteAligned,
				bit_size: None,
				base: None,
				strong_ref: None,
				})))
			},
			NodeType::VoidType => {
				Node::VoidType(Rc::new(RefCell::new(VoidType {
				loc: raw_node.loc.clone(),
				is_explicit: false,
				non_dynamic: false,
				bit_alignment: BitAlignment::ByteAligned,
				bit_size: None,
				})))
			},
			NodeType::BoolType => {
				Node::BoolType(Rc::new(RefCell::new(BoolType {
				loc: raw_node.loc.clone(),
				is_explicit: false,
				non_dynamic: false,
				bit_alignment: BitAlignment::ByteAligned,
				bit_size: None,
				})))
			},
			NodeType::ArrayType => {
				Node::ArrayType(Rc::new(RefCell::new(ArrayType {
				loc: raw_node.loc.clone(),
				is_explicit: false,
				non_dynamic: false,
				bit_alignment: BitAlignment::ByteAligned,
				bit_size: None,
				end_loc: raw_node.loc.clone(),
				base_type: None,
				length: None,
				length_value: None,
				})))
			},
			NodeType::FunctionType => {
				Node::FunctionType(Rc::new(RefCell::new(FunctionType {
				loc: raw_node.loc.clone(),
				is_explicit: false,
				non_dynamic: false,
				bit_alignment: BitAlignment::ByteAligned,
				bit_size: None,
				return_type: None,
				parameters: Vec::new(),
				})))
			},
			NodeType::StructType => {
				Node::StructType(Rc::new(RefCell::new(StructType {
				loc: raw_node.loc.clone(),
				is_explicit: false,
				non_dynamic: false,
				bit_alignment: BitAlignment::ByteAligned,
				bit_size: None,
				fields: Vec::new(),
				base: None,
				recursive: false,
				fixed_header_size: 0,
				fixed_tail_size: 0,
				})))
			},
			NodeType::StructUnionType => {
				Node::StructUnionType(Rc::new(RefCell::new(StructUnionType {
				loc: raw_node.loc.clone(),
				is_explicit: false,
				non_dynamic: false,
				bit_alignment: BitAlignment::ByteAligned,
				bit_size: None,
				structs: Vec::new(),
				base: None,
				union_fields: Vec::new(),
				})))
			},
			NodeType::UnionType => {
				Node::UnionType(Rc::new(RefCell::new(UnionType {
				loc: raw_node.loc.clone(),
				is_explicit: false,
				non_dynamic: false,
				bit_alignment: BitAlignment::ByteAligned,
				bit_size: None,
				cond: None,
				candidates: Vec::new(),
				base_type: None,
				common_type: None,
				})))
			},
			NodeType::RangeType => {
				Node::RangeType(Rc::new(RefCell::new(RangeType {
				loc: raw_node.loc.clone(),
				is_explicit: false,
				non_dynamic: false,
				bit_alignment: BitAlignment::ByteAligned,
				bit_size: None,
				base_type: None,
				range: None,
				})))
			},
			NodeType::EnumType => {
				Node::EnumType(Rc::new(RefCell::new(EnumType {
				loc: raw_node.loc.clone(),
				is_explicit: false,
				non_dynamic: false,
				bit_alignment: BitAlignment::ByteAligned,
				bit_size: None,
				base: None,
				})))
			},
			NodeType::MetaType => {
				Node::MetaType(Rc::new(RefCell::new(MetaType {
				loc: raw_node.loc.clone(),
				is_explicit: false,
				non_dynamic: false,
				bit_alignment: BitAlignment::ByteAligned,
				bit_size: None,
				})))
			},
			NodeType::OptionalType => {
				Node::OptionalType(Rc::new(RefCell::new(OptionalType {
				loc: raw_node.loc.clone(),
				is_explicit: false,
				non_dynamic: false,
				bit_alignment: BitAlignment::ByteAligned,
				bit_size: None,
				base_type: None,
				})))
			},
			NodeType::IntLiteral => {
				Node::IntLiteral(Rc::new(RefCell::new(IntLiteral {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				value: String::new(),
				})))
			},
			NodeType::BoolLiteral => {
				Node::BoolLiteral(Rc::new(RefCell::new(BoolLiteral {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				value: false,
				})))
			},
			NodeType::StrLiteral => {
				Node::StrLiteral(Rc::new(RefCell::new(StrLiteral {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				value: String::new(),
				length: 0,
				})))
			},
			NodeType::TypeLiteral => {
				Node::TypeLiteral(Rc::new(RefCell::new(TypeLiteral {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				type_literal: None,
				end_loc: raw_node.loc.clone(),
				})))
			},
			NodeType::SpecialLiteral => {
				Node::SpecialLiteral(Rc::new(RefCell::new(SpecialLiteral {
				loc: raw_node.loc.clone(),
				expr_type: None,
				constant_level: ConstantLevel::Unknown,
				kind: SpecialLiteralKind::Input,
				})))
			},
			NodeType::Field => {
				Node::Field(Rc::new(RefCell::new(Field {
				loc: raw_node.loc.clone(),
				belong: None,
				belong_struct: None,
				ident: None,
				colon_loc: raw_node.loc.clone(),
				field_type: None,
				arguments: None,
				offset_bit: None,
				offset_recent: 0,
				tail_offset_bit: None,
				tail_offset_recent: 0,
				bit_alignment: BitAlignment::ByteAligned,
				follow: Follow::Unknown,
				eventual_follow: Follow::Unknown,
				})))
			},
			NodeType::Format => {
				Node::Format(Rc::new(RefCell::new(Format {
				loc: raw_node.loc.clone(),
				belong: None,
				belong_struct: None,
				ident: None,
				body: None,
				encode_fn: None,
				decode_fn: None,
				cast_fns: Vec::new(),
				depends: Vec::new(),
				state_variables: Vec::new(),
				})))
			},
			NodeType::State => {
				Node::State(Rc::new(RefCell::new(State {
				loc: raw_node.loc.clone(),
				belong: None,
				belong_struct: None,
				ident: None,
				body: None,
				})))
			},
			NodeType::Enum => {
				Node::Enum(Rc::new(RefCell::new(Enum {
				loc: raw_node.loc.clone(),
				belong: None,
				belong_struct: None,
				ident: None,
				scope: None,
				colon_loc: raw_node.loc.clone(),
				base_type: None,
				members: Vec::new(),
				enum_type: None,
				})))
			},
			NodeType::EnumMember => {
				Node::EnumMember(Rc::new(RefCell::new(EnumMember {
				loc: raw_node.loc.clone(),
				belong: None,
				belong_struct: None,
				ident: None,
				expr: None,
				})))
			},
			NodeType::Function => {
				Node::Function(Rc::new(RefCell::new(Function {
				loc: raw_node.loc.clone(),
				belong: None,
				belong_struct: None,
				ident: None,
				parameters: Vec::new(),
				return_type: None,
				body: None,
				func_type: None,
				is_cast: false,
				cast_loc: raw_node.loc.clone(),
				})))
			},
			NodeType::BuiltinFunction => {
				Node::BuiltinFunction(Rc::new(RefCell::new(BuiltinFunction {
				loc: raw_node.loc.clone(),
				belong: None,
				belong_struct: None,
				ident: None,
				func_type: None,
				})))
			},
			NodeType::BuiltinField => {
				Node::BuiltinField(Rc::new(RefCell::new(BuiltinField {
				loc: raw_node.loc.clone(),
				belong: None,
				belong_struct: None,
				ident: None,
				field_type: None,
				})))
			},
			NodeType::BuiltinObject => {
				Node::BuiltinObject(Rc::new(RefCell::new(BuiltinObject {
				loc: raw_node.loc.clone(),
				belong: None,
				belong_struct: None,
				ident: None,
				members: Vec::new(),
				})))
			},
			_=>return Err(Error::UnknownNodeType(node_type)),
		};
		nodes.push(node);
	}
	for _ in &ast.scope{
		let scope = Rc::new(RefCell::new(Scope{
			prev: None,
			next: None,
			branch: None,
			ident: Vec::new(),
			owner: None,
			branch_root: false,
		}));
		scopes.push(scope);
	}
	for (i,raw_node) in ast.node.into_iter().enumerate(){
		let node_type :NodeType = match raw_node.node_type.as_str().try_into() {
			Ok(v)=>v,
			Err(_) =>return Err(Error::InvalidRawNodeType(raw_node.node_type.clone())),
		};
		match node_type {
			NodeType::Program => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Program(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let struct_type_body = match raw_node.body.get("struct_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"struct_type")),
				};
 				if !struct_type_body.is_null() {
					let struct_type_body = match struct_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(struct_type_body.into(),JSONType::Number)),
					};
					let struct_type_body = match nodes.get(struct_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(struct_type_body as usize)),
					};
					let struct_type_body = match struct_type_body {
						Node::StructType(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),struct_type_body.into())),
					};
					node.borrow_mut().struct_type = Some(struct_type_body.clone());
				}
				let elements_body = match raw_node.body.get("elements") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"elements")),
				};
				let elements_body = match elements_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(elements_body.into(),JSONType::Array)),
				};
				for link in elements_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let elements_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					node.borrow_mut().elements.push(elements_body.clone());
				}
				let global_scope_body = match raw_node.body.get("global_scope") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"global_scope")),
				};
 				if !global_scope_body.is_null() {
					let global_scope_body = match global_scope_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(global_scope_body.into(),JSONType::Number)),
					};
					let global_scope_body = match scopes.get(global_scope_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(global_scope_body as usize)),
					};
					node.borrow_mut().global_scope = Some(global_scope_body.clone());
				}
			},
			NodeType::Comment => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Comment(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let comment_body = match raw_node.body.get("comment") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"comment")),
				};
				node.borrow_mut().comment = match comment_body.as_str() {
					Some(v)=>v.to_string(),
					None=>return Err(Error::MismatchJSONType(comment_body.into(),JSONType::String)),
				};
			},
			NodeType::CommentGroup => {
				let node = nodes[i].clone();
				let node = match node {
					Node::CommentGroup(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let comments_body = match raw_node.body.get("comments") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"comments")),
				};
				let comments_body = match comments_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(comments_body.into(),JSONType::Array)),
				};
				for link in comments_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let comments_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					let comments_body = match comments_body {
						Node::Comment(body)=>body,
						x =>return Err(Error::MismatchNodeType(x.into(),comments_body.into())),
					};
					node.borrow_mut().comments.push(comments_body.clone());
				}
			},
			NodeType::FieldArgument => {
				let node = nodes[i].clone();
				let node = match node {
					Node::FieldArgument(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let raw_arguments_body = match raw_node.body.get("raw_arguments") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"raw_arguments")),
				};
 				if !raw_arguments_body.is_null() {
					let raw_arguments_body = match raw_arguments_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(raw_arguments_body.into(),JSONType::Number)),
					};
					let raw_arguments_body = match nodes.get(raw_arguments_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(raw_arguments_body as usize)),
					};
					node.borrow_mut().raw_arguments = Some(raw_arguments_body.try_into()?);
				}
				let end_loc_body = match raw_node.body.get("end_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"end_loc")),
				};
				node.borrow_mut().end_loc = match serde_json::from_value(end_loc_body.clone()) {
					Ok(v)=>v,
					Err(e)=>return Err(Error::JSONError(e)),
				};
				let collected_arguments_body = match raw_node.body.get("collected_arguments") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"collected_arguments")),
				};
				let collected_arguments_body = match collected_arguments_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(collected_arguments_body.into(),JSONType::Array)),
				};
				for link in collected_arguments_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let collected_arguments_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					node.borrow_mut().collected_arguments.push(collected_arguments_body.try_into()?);
				}
				let arguments_body = match raw_node.body.get("arguments") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"arguments")),
				};
				let arguments_body = match arguments_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(arguments_body.into(),JSONType::Array)),
				};
				for link in arguments_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let arguments_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					node.borrow_mut().arguments.push(arguments_body.try_into()?);
				}
				let alignment_body = match raw_node.body.get("alignment") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"alignment")),
				};
 				if !alignment_body.is_null() {
					let alignment_body = match alignment_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(alignment_body.into(),JSONType::Number)),
					};
					let alignment_body = match nodes.get(alignment_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(alignment_body as usize)),
					};
					node.borrow_mut().alignment = Some(alignment_body.try_into()?);
				}
				let alignment_value_body = match raw_node.body.get("alignment_value") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"alignment_value")),
				};
				node.borrow_mut().alignment_value = match alignment_value_body.as_u64() {
					Some(v)=>Some(v),
					None=> match alignment_value_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(alignment_value_body.into(),JSONType::Number)),
					},
				};
				let sub_byte_length_body = match raw_node.body.get("sub_byte_length") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"sub_byte_length")),
				};
 				if !sub_byte_length_body.is_null() {
					let sub_byte_length_body = match sub_byte_length_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(sub_byte_length_body.into(),JSONType::Number)),
					};
					let sub_byte_length_body = match nodes.get(sub_byte_length_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(sub_byte_length_body as usize)),
					};
					node.borrow_mut().sub_byte_length = Some(sub_byte_length_body.try_into()?);
				}
				let sub_byte_begin_body = match raw_node.body.get("sub_byte_begin") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"sub_byte_begin")),
				};
 				if !sub_byte_begin_body.is_null() {
					let sub_byte_begin_body = match sub_byte_begin_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(sub_byte_begin_body.into(),JSONType::Number)),
					};
					let sub_byte_begin_body = match nodes.get(sub_byte_begin_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(sub_byte_begin_body as usize)),
					};
					node.borrow_mut().sub_byte_begin = Some(sub_byte_begin_body.try_into()?);
				}
			},
			NodeType::Binary => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Binary(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let op_body = match raw_node.body.get("op") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"op")),
				};
				node.borrow_mut().op = match op_body.as_str() {
					Some(v)=>match BinaryOp::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(op_body.into(),JSONType::String)),
				};
				let left_body = match raw_node.body.get("left") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"left")),
				};
 				if !left_body.is_null() {
					let left_body = match left_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(left_body.into(),JSONType::Number)),
					};
					let left_body = match nodes.get(left_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(left_body as usize)),
					};
					node.borrow_mut().left = Some(left_body.try_into()?);
				}
				let right_body = match raw_node.body.get("right") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"right")),
				};
 				if !right_body.is_null() {
					let right_body = match right_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(right_body.into(),JSONType::Number)),
					};
					let right_body = match nodes.get(right_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(right_body as usize)),
					};
					node.borrow_mut().right = Some(right_body.try_into()?);
				}
			},
			NodeType::Unary => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Unary(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let op_body = match raw_node.body.get("op") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"op")),
				};
				node.borrow_mut().op = match op_body.as_str() {
					Some(v)=>match UnaryOp::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(op_body.into(),JSONType::String)),
				};
				let expr_body = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr")),
				};
 				if !expr_body.is_null() {
					let expr_body = match expr_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_body.into(),JSONType::Number)),
					};
					let expr_body = match nodes.get(expr_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_body as usize)),
					};
					node.borrow_mut().expr = Some(expr_body.try_into()?);
				}
			},
			NodeType::Cond => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Cond(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let cond_body = match raw_node.body.get("cond") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"cond")),
				};
 				if !cond_body.is_null() {
					let cond_body = match cond_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(cond_body.into(),JSONType::Number)),
					};
					let cond_body = match nodes.get(cond_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(cond_body as usize)),
					};
					node.borrow_mut().cond = Some(cond_body.try_into()?);
				}
				let then_body = match raw_node.body.get("then") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"then")),
				};
 				if !then_body.is_null() {
					let then_body = match then_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(then_body.into(),JSONType::Number)),
					};
					let then_body = match nodes.get(then_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(then_body as usize)),
					};
					node.borrow_mut().then = Some(then_body.try_into()?);
				}
				let els_loc_body = match raw_node.body.get("els_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"els_loc")),
				};
				node.borrow_mut().els_loc = match serde_json::from_value(els_loc_body.clone()) {
					Ok(v)=>v,
					Err(e)=>return Err(Error::JSONError(e)),
				};
				let els_body = match raw_node.body.get("els") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"els")),
				};
 				if !els_body.is_null() {
					let els_body = match els_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(els_body.into(),JSONType::Number)),
					};
					let els_body = match nodes.get(els_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(els_body as usize)),
					};
					node.borrow_mut().els = Some(els_body.try_into()?);
				}
			},
			NodeType::Ident => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Ident(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let ident_body = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"ident")),
				};
				node.borrow_mut().ident = match ident_body.as_str() {
					Some(v)=>v.to_string(),
					None=>return Err(Error::MismatchJSONType(ident_body.into(),JSONType::String)),
				};
				let usage_body = match raw_node.body.get("usage") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"usage")),
				};
				node.borrow_mut().usage = match usage_body.as_str() {
					Some(v)=>match IdentUsage::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(usage_body.into(),JSONType::String)),
				};
				let base_body = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"base")),
				};
 				if !base_body.is_null() {
					let base_body = match base_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(base_body.into(),JSONType::Number)),
					};
					let base_body = match nodes.get(base_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(base_body as usize)),
					};
					node.borrow_mut().base = Some(NodeWeak::from(base_body.clone()));
				}
				let scope_body = match raw_node.body.get("scope") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"scope")),
				};
 				if !scope_body.is_null() {
					let scope_body = match scope_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(scope_body.into(),JSONType::Number)),
					};
					let scope_body = match scopes.get(scope_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(scope_body as usize)),
					};
					node.borrow_mut().scope = Some(scope_body.clone());
				}
			},
			NodeType::Call => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Call(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let callee_body = match raw_node.body.get("callee") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"callee")),
				};
 				if !callee_body.is_null() {
					let callee_body = match callee_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(callee_body.into(),JSONType::Number)),
					};
					let callee_body = match nodes.get(callee_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(callee_body as usize)),
					};
					node.borrow_mut().callee = Some(callee_body.try_into()?);
				}
				let raw_arguments_body = match raw_node.body.get("raw_arguments") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"raw_arguments")),
				};
 				if !raw_arguments_body.is_null() {
					let raw_arguments_body = match raw_arguments_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(raw_arguments_body.into(),JSONType::Number)),
					};
					let raw_arguments_body = match nodes.get(raw_arguments_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(raw_arguments_body as usize)),
					};
					node.borrow_mut().raw_arguments = Some(raw_arguments_body.try_into()?);
				}
				let arguments_body = match raw_node.body.get("arguments") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"arguments")),
				};
				let arguments_body = match arguments_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(arguments_body.into(),JSONType::Array)),
				};
				for link in arguments_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let arguments_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					node.borrow_mut().arguments.push(arguments_body.try_into()?);
				}
				let end_loc_body = match raw_node.body.get("end_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"end_loc")),
				};
				node.borrow_mut().end_loc = match serde_json::from_value(end_loc_body.clone()) {
					Ok(v)=>v,
					Err(e)=>return Err(Error::JSONError(e)),
				};
			},
			NodeType::If => {
				let node = nodes[i].clone();
				let node = match node {
					Node::If(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let cond_scope_body = match raw_node.body.get("cond_scope") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"cond_scope")),
				};
 				if !cond_scope_body.is_null() {
					let cond_scope_body = match cond_scope_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(cond_scope_body.into(),JSONType::Number)),
					};
					let cond_scope_body = match scopes.get(cond_scope_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(cond_scope_body as usize)),
					};
					node.borrow_mut().cond_scope = Some(cond_scope_body.clone());
				}
				let cond_body = match raw_node.body.get("cond") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"cond")),
				};
 				if !cond_body.is_null() {
					let cond_body = match cond_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(cond_body.into(),JSONType::Number)),
					};
					let cond_body = match nodes.get(cond_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(cond_body as usize)),
					};
					node.borrow_mut().cond = Some(cond_body.try_into()?);
				}
				let then_body = match raw_node.body.get("then") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"then")),
				};
 				if !then_body.is_null() {
					let then_body = match then_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(then_body.into(),JSONType::Number)),
					};
					let then_body = match nodes.get(then_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(then_body as usize)),
					};
					let then_body = match then_body {
						Node::IndentBlock(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),then_body.into())),
					};
					node.borrow_mut().then = Some(then_body.clone());
				}
				let els_body = match raw_node.body.get("els") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"els")),
				};
 				if !els_body.is_null() {
					let els_body = match els_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(els_body.into(),JSONType::Number)),
					};
					let els_body = match nodes.get(els_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(els_body as usize)),
					};
					node.borrow_mut().els = Some(els_body.clone());
				}
			},
			NodeType::MemberAccess => {
				let node = nodes[i].clone();
				let node = match node {
					Node::MemberAccess(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let target_body = match raw_node.body.get("target") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"target")),
				};
 				if !target_body.is_null() {
					let target_body = match target_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(target_body.into(),JSONType::Number)),
					};
					let target_body = match nodes.get(target_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(target_body as usize)),
					};
					node.borrow_mut().target = Some(target_body.try_into()?);
				}
				let member_body = match raw_node.body.get("member") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"member")),
				};
 				if !member_body.is_null() {
					let member_body = match member_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(member_body.into(),JSONType::Number)),
					};
					let member_body = match nodes.get(member_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(member_body as usize)),
					};
					let member_body = match member_body {
						Node::Ident(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),member_body.into())),
					};
					node.borrow_mut().member = Some(member_body.clone());
				}
				let base_body = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"base")),
				};
 				if !base_body.is_null() {
					let base_body = match base_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(base_body.into(),JSONType::Number)),
					};
					let base_body = match nodes.get(base_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(base_body as usize)),
					};
					let base_body = match base_body {
						Node::Ident(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),base_body.into())),
					};
					node.borrow_mut().base = Some(Rc::downgrade(&base_body));
				}
			},
			NodeType::Paren => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Paren(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let expr_body = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr")),
				};
 				if !expr_body.is_null() {
					let expr_body = match expr_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_body.into(),JSONType::Number)),
					};
					let expr_body = match nodes.get(expr_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_body as usize)),
					};
					node.borrow_mut().expr = Some(expr_body.try_into()?);
				}
				let end_loc_body = match raw_node.body.get("end_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"end_loc")),
				};
				node.borrow_mut().end_loc = match serde_json::from_value(end_loc_body.clone()) {
					Ok(v)=>v,
					Err(e)=>return Err(Error::JSONError(e)),
				};
			},
			NodeType::Index => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Index(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let expr_body = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr")),
				};
 				if !expr_body.is_null() {
					let expr_body = match expr_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_body.into(),JSONType::Number)),
					};
					let expr_body = match nodes.get(expr_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_body as usize)),
					};
					node.borrow_mut().expr = Some(expr_body.try_into()?);
				}
				let index_body = match raw_node.body.get("index") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"index")),
				};
 				if !index_body.is_null() {
					let index_body = match index_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(index_body.into(),JSONType::Number)),
					};
					let index_body = match nodes.get(index_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(index_body as usize)),
					};
					node.borrow_mut().index = Some(index_body.try_into()?);
				}
				let end_loc_body = match raw_node.body.get("end_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"end_loc")),
				};
				node.borrow_mut().end_loc = match serde_json::from_value(end_loc_body.clone()) {
					Ok(v)=>v,
					Err(e)=>return Err(Error::JSONError(e)),
				};
			},
			NodeType::Match => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Match(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let cond_scope_body = match raw_node.body.get("cond_scope") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"cond_scope")),
				};
 				if !cond_scope_body.is_null() {
					let cond_scope_body = match cond_scope_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(cond_scope_body.into(),JSONType::Number)),
					};
					let cond_scope_body = match scopes.get(cond_scope_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(cond_scope_body as usize)),
					};
					node.borrow_mut().cond_scope = Some(cond_scope_body.clone());
				}
				let cond_body = match raw_node.body.get("cond") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"cond")),
				};
 				if !cond_body.is_null() {
					let cond_body = match cond_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(cond_body.into(),JSONType::Number)),
					};
					let cond_body = match nodes.get(cond_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(cond_body as usize)),
					};
					node.borrow_mut().cond = Some(cond_body.try_into()?);
				}
				let branch_body = match raw_node.body.get("branch") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"branch")),
				};
				let branch_body = match branch_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(branch_body.into(),JSONType::Array)),
				};
				for link in branch_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let branch_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					node.borrow_mut().branch.push(branch_body.clone());
				}
			},
			NodeType::Range => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Range(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let op_body = match raw_node.body.get("op") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"op")),
				};
				node.borrow_mut().op = match op_body.as_str() {
					Some(v)=>match BinaryOp::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(op_body.into(),JSONType::String)),
				};
				let start_body = match raw_node.body.get("start") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"start")),
				};
 				if !start_body.is_null() {
					let start_body = match start_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(start_body.into(),JSONType::Number)),
					};
					let start_body = match nodes.get(start_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(start_body as usize)),
					};
					node.borrow_mut().start = Some(start_body.try_into()?);
				}
				let end_body = match raw_node.body.get("end") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"end")),
				};
 				if !end_body.is_null() {
					let end_body = match end_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(end_body.into(),JSONType::Number)),
					};
					let end_body = match nodes.get(end_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(end_body as usize)),
					};
					node.borrow_mut().end = Some(end_body.try_into()?);
				}
			},
			NodeType::TmpVar => {
				let node = nodes[i].clone();
				let node = match node {
					Node::TmpVar(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let tmp_var_body = match raw_node.body.get("tmp_var") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"tmp_var")),
				};
				node.borrow_mut().tmp_var = match tmp_var_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(tmp_var_body.into(),JSONType::Number)),
				};
			},
			NodeType::Import => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Import(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let path_body = match raw_node.body.get("path") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"path")),
				};
				node.borrow_mut().path = match path_body.as_str() {
					Some(v)=>v.to_string(),
					None=>return Err(Error::MismatchJSONType(path_body.into(),JSONType::String)),
				};
				let base_body = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"base")),
				};
 				if !base_body.is_null() {
					let base_body = match base_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(base_body.into(),JSONType::Number)),
					};
					let base_body = match nodes.get(base_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(base_body as usize)),
					};
					let base_body = match base_body {
						Node::Call(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),base_body.into())),
					};
					node.borrow_mut().base = Some(base_body.clone());
				}
				let import_desc_body = match raw_node.body.get("import_desc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"import_desc")),
				};
 				if !import_desc_body.is_null() {
					let import_desc_body = match import_desc_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(import_desc_body.into(),JSONType::Number)),
					};
					let import_desc_body = match nodes.get(import_desc_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(import_desc_body as usize)),
					};
					let import_desc_body = match import_desc_body {
						Node::Program(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),import_desc_body.into())),
					};
					node.borrow_mut().import_desc = Some(import_desc_body.clone());
				}
			},
			NodeType::Cast => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Cast(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let base_body = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"base")),
				};
 				if !base_body.is_null() {
					let base_body = match base_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(base_body.into(),JSONType::Number)),
					};
					let base_body = match nodes.get(base_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(base_body as usize)),
					};
					let base_body = match base_body {
						Node::Call(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),base_body.into())),
					};
					node.borrow_mut().base = Some(base_body.clone());
				}
				let expr_body = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr")),
				};
 				if !expr_body.is_null() {
					let expr_body = match expr_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_body.into(),JSONType::Number)),
					};
					let expr_body = match nodes.get(expr_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_body as usize)),
					};
					node.borrow_mut().expr = Some(expr_body.try_into()?);
				}
			},
			NodeType::Available => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Available(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let base_body = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"base")),
				};
 				if !base_body.is_null() {
					let base_body = match base_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(base_body.into(),JSONType::Number)),
					};
					let base_body = match nodes.get(base_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(base_body as usize)),
					};
					let base_body = match base_body {
						Node::Call(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),base_body.into())),
					};
					node.borrow_mut().base = Some(base_body.clone());
				}
				let target_body = match raw_node.body.get("target") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"target")),
				};
 				if !target_body.is_null() {
					let target_body = match target_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(target_body.into(),JSONType::Number)),
					};
					let target_body = match nodes.get(target_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(target_body as usize)),
					};
					node.borrow_mut().target = Some(target_body.try_into()?);
				}
			},
			NodeType::SpecifyOrder => {
				let node = nodes[i].clone();
				let node = match node {
					Node::SpecifyOrder(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let base_body = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"base")),
				};
 				if !base_body.is_null() {
					let base_body = match base_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(base_body.into(),JSONType::Number)),
					};
					let base_body = match nodes.get(base_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(base_body as usize)),
					};
					let base_body = match base_body {
						Node::Binary(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),base_body.into())),
					};
					node.borrow_mut().base = Some(base_body.clone());
				}
				let order_type_body = match raw_node.body.get("order_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"order_type")),
				};
				node.borrow_mut().order_type = match order_type_body.as_str() {
					Some(v)=>match OrderType::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(order_type_body.into(),JSONType::String)),
				};
				let order_body = match raw_node.body.get("order") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"order")),
				};
 				if !order_body.is_null() {
					let order_body = match order_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(order_body.into(),JSONType::Number)),
					};
					let order_body = match nodes.get(order_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(order_body as usize)),
					};
					node.borrow_mut().order = Some(order_body.try_into()?);
				}
				let order_value_body = match raw_node.body.get("order_value") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"order_value")),
				};
				node.borrow_mut().order_value = match order_value_body.as_u64() {
					Some(v)=>Some(v),
					None=> match order_value_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(order_value_body.into(),JSONType::Number)),
					},
				};
			},
			NodeType::ExplicitError => {
				let node = nodes[i].clone();
				let node = match node {
					Node::ExplicitError(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let base_body = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"base")),
				};
 				if !base_body.is_null() {
					let base_body = match base_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(base_body.into(),JSONType::Number)),
					};
					let base_body = match nodes.get(base_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(base_body as usize)),
					};
					let base_body = match base_body {
						Node::Call(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),base_body.into())),
					};
					node.borrow_mut().base = Some(base_body.clone());
				}
				let message_body = match raw_node.body.get("message") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"message")),
				};
 				if !message_body.is_null() {
					let message_body = match message_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(message_body.into(),JSONType::Number)),
					};
					let message_body = match nodes.get(message_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(message_body as usize)),
					};
					let message_body = match message_body {
						Node::StrLiteral(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),message_body.into())),
					};
					node.borrow_mut().message = Some(message_body.clone());
				}
			},
			NodeType::IoOperation => {
				let node = nodes[i].clone();
				let node = match node {
					Node::IoOperation(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let base_body = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"base")),
				};
 				if !base_body.is_null() {
					let base_body = match base_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(base_body.into(),JSONType::Number)),
					};
					let base_body = match nodes.get(base_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(base_body as usize)),
					};
					node.borrow_mut().base = Some(base_body.try_into()?);
				}
				let method_body = match raw_node.body.get("method") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"method")),
				};
				node.borrow_mut().method = match method_body.as_str() {
					Some(v)=>match IoMethod::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(method_body.into(),JSONType::String)),
				};
				let arguments_body = match raw_node.body.get("arguments") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"arguments")),
				};
				let arguments_body = match arguments_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(arguments_body.into(),JSONType::Array)),
				};
				for link in arguments_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let arguments_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					node.borrow_mut().arguments.push(arguments_body.try_into()?);
				}
			},
			NodeType::Loop => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Loop(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let cond_scope_body = match raw_node.body.get("cond_scope") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"cond_scope")),
				};
 				if !cond_scope_body.is_null() {
					let cond_scope_body = match cond_scope_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(cond_scope_body.into(),JSONType::Number)),
					};
					let cond_scope_body = match scopes.get(cond_scope_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(cond_scope_body as usize)),
					};
					node.borrow_mut().cond_scope = Some(cond_scope_body.clone());
				}
				let init_body = match raw_node.body.get("init") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"init")),
				};
 				if !init_body.is_null() {
					let init_body = match init_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(init_body.into(),JSONType::Number)),
					};
					let init_body = match nodes.get(init_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(init_body as usize)),
					};
					node.borrow_mut().init = Some(init_body.try_into()?);
				}
				let cond_body = match raw_node.body.get("cond") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"cond")),
				};
 				if !cond_body.is_null() {
					let cond_body = match cond_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(cond_body.into(),JSONType::Number)),
					};
					let cond_body = match nodes.get(cond_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(cond_body as usize)),
					};
					node.borrow_mut().cond = Some(cond_body.try_into()?);
				}
				let step_body = match raw_node.body.get("step") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"step")),
				};
 				if !step_body.is_null() {
					let step_body = match step_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(step_body.into(),JSONType::Number)),
					};
					let step_body = match nodes.get(step_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(step_body as usize)),
					};
					node.borrow_mut().step = Some(step_body.try_into()?);
				}
				let body_body = match raw_node.body.get("body") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"body")),
				};
 				if !body_body.is_null() {
					let body_body = match body_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(body_body.into(),JSONType::Number)),
					};
					let body_body = match nodes.get(body_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(body_body as usize)),
					};
					let body_body = match body_body {
						Node::IndentBlock(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),body_body.into())),
					};
					node.borrow_mut().body = Some(body_body.clone());
				}
			},
			NodeType::IndentBlock => {
				let node = nodes[i].clone();
				let node = match node {
					Node::IndentBlock(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let struct_type_body = match raw_node.body.get("struct_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"struct_type")),
				};
 				if !struct_type_body.is_null() {
					let struct_type_body = match struct_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(struct_type_body.into(),JSONType::Number)),
					};
					let struct_type_body = match nodes.get(struct_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(struct_type_body as usize)),
					};
					let struct_type_body = match struct_type_body {
						Node::StructType(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),struct_type_body.into())),
					};
					node.borrow_mut().struct_type = Some(struct_type_body.clone());
				}
				let elements_body = match raw_node.body.get("elements") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"elements")),
				};
				let elements_body = match elements_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(elements_body.into(),JSONType::Array)),
				};
				for link in elements_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let elements_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					node.borrow_mut().elements.push(elements_body.clone());
				}
				let scope_body = match raw_node.body.get("scope") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"scope")),
				};
 				if !scope_body.is_null() {
					let scope_body = match scope_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(scope_body.into(),JSONType::Number)),
					};
					let scope_body = match scopes.get(scope_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(scope_body as usize)),
					};
					node.borrow_mut().scope = Some(scope_body.clone());
				}
			},
			NodeType::ScopedStatement => {
				let node = nodes[i].clone();
				let node = match node {
					Node::ScopedStatement(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let struct_type_body = match raw_node.body.get("struct_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"struct_type")),
				};
 				if !struct_type_body.is_null() {
					let struct_type_body = match struct_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(struct_type_body.into(),JSONType::Number)),
					};
					let struct_type_body = match nodes.get(struct_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(struct_type_body as usize)),
					};
					let struct_type_body = match struct_type_body {
						Node::StructType(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),struct_type_body.into())),
					};
					node.borrow_mut().struct_type = Some(struct_type_body.clone());
				}
				let statement_body = match raw_node.body.get("statement") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"statement")),
				};
 				if !statement_body.is_null() {
					let statement_body = match statement_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(statement_body.into(),JSONType::Number)),
					};
					let statement_body = match nodes.get(statement_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(statement_body as usize)),
					};
					node.borrow_mut().statement = Some(statement_body.clone());
				}
				let scope_body = match raw_node.body.get("scope") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"scope")),
				};
 				if !scope_body.is_null() {
					let scope_body = match scope_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(scope_body.into(),JSONType::Number)),
					};
					let scope_body = match scopes.get(scope_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(scope_body as usize)),
					};
					node.borrow_mut().scope = Some(scope_body.clone());
				}
			},
			NodeType::MatchBranch => {
				let node = nodes[i].clone();
				let node = match node {
					Node::MatchBranch(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let belong_body = match raw_node.body.get("belong") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"belong")),
				};
 				if !belong_body.is_null() {
					let belong_body = match belong_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(belong_body.into(),JSONType::Number)),
					};
					let belong_body = match nodes.get(belong_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(belong_body as usize)),
					};
					let belong_body = match belong_body {
						Node::Match(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),belong_body.into())),
					};
					node.borrow_mut().belong = Some(Rc::downgrade(&belong_body));
				}
				let cond_body = match raw_node.body.get("cond") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"cond")),
				};
 				if !cond_body.is_null() {
					let cond_body = match cond_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(cond_body.into(),JSONType::Number)),
					};
					let cond_body = match nodes.get(cond_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(cond_body as usize)),
					};
					node.borrow_mut().cond = Some(cond_body.try_into()?);
				}
				let sym_loc_body = match raw_node.body.get("sym_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"sym_loc")),
				};
				node.borrow_mut().sym_loc = match serde_json::from_value(sym_loc_body.clone()) {
					Ok(v)=>v,
					Err(e)=>return Err(Error::JSONError(e)),
				};
				let then_body = match raw_node.body.get("then") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"then")),
				};
 				if !then_body.is_null() {
					let then_body = match then_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(then_body.into(),JSONType::Number)),
					};
					let then_body = match nodes.get(then_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(then_body as usize)),
					};
					node.borrow_mut().then = Some(then_body.clone());
				}
			},
			NodeType::UnionCandidate => {
				let node = nodes[i].clone();
				let node = match node {
					Node::UnionCandidate(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let cond_body = match raw_node.body.get("cond") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"cond")),
				};
 				if !cond_body.is_null() {
					let cond_body = match cond_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(cond_body.into(),JSONType::Number)),
					};
					let cond_body = match nodes.get(cond_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(cond_body as usize)),
					};
					node.borrow_mut().cond = Some(cond_body.try_into()?);
				}
				let field_body = match raw_node.body.get("field") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"field")),
				};
 				if !field_body.is_null() {
					let field_body = match field_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(field_body.into(),JSONType::Number)),
					};
					let field_body = match nodes.get(field_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(field_body as usize)),
					};
					let field_body = match field_body {
						Node::Field(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),field_body.into())),
					};
					node.borrow_mut().field = Some(Rc::downgrade(&field_body));
				}
			},
			NodeType::Return => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Return(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_body = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr")),
				};
 				if !expr_body.is_null() {
					let expr_body = match expr_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_body.into(),JSONType::Number)),
					};
					let expr_body = match nodes.get(expr_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_body as usize)),
					};
					node.borrow_mut().expr = Some(expr_body.try_into()?);
				}
			},
			NodeType::Break => {
				let node = nodes[i].clone();
				let _ = match node {
					Node::Break(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
			},
			NodeType::Continue => {
				let node = nodes[i].clone();
				let _ = match node {
					Node::Continue(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
			},
			NodeType::Assert => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Assert(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let cond_body = match raw_node.body.get("cond") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"cond")),
				};
 				if !cond_body.is_null() {
					let cond_body = match cond_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(cond_body.into(),JSONType::Number)),
					};
					let cond_body = match nodes.get(cond_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(cond_body as usize)),
					};
					let cond_body = match cond_body {
						Node::Binary(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),cond_body.into())),
					};
					node.borrow_mut().cond = Some(cond_body.clone());
				}
				let is_io_related_body = match raw_node.body.get("is_io_related") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_io_related")),
				};
				node.borrow_mut().is_io_related = match is_io_related_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_io_related_body.into(),JSONType::Bool)),
				};
			},
			NodeType::ImplicitYield => {
				let node = nodes[i].clone();
				let node = match node {
					Node::ImplicitYield(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_body = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr")),
				};
 				if !expr_body.is_null() {
					let expr_body = match expr_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_body.into(),JSONType::Number)),
					};
					let expr_body = match nodes.get(expr_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_body as usize)),
					};
					node.borrow_mut().expr = Some(expr_body.try_into()?);
				}
			},
			NodeType::IntType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::IntType(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let is_explicit_body = match raw_node.body.get("is_explicit") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_explicit")),
				};
				node.borrow_mut().is_explicit = match is_explicit_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_explicit_body.into(),JSONType::Bool)),
				};
				let non_dynamic_body = match raw_node.body.get("non_dynamic") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"non_dynamic")),
				};
				node.borrow_mut().non_dynamic = match non_dynamic_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(non_dynamic_body.into(),JSONType::Bool)),
				};
				let bit_alignment_body = match raw_node.body.get("bit_alignment") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_alignment")),
				};
				node.borrow_mut().bit_alignment = match bit_alignment_body.as_str() {
					Some(v)=>match BitAlignment::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(bit_alignment_body.into(),JSONType::String)),
				};
				let bit_size_body = match raw_node.body.get("bit_size") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_size")),
				};
				node.borrow_mut().bit_size = match bit_size_body.as_u64() {
					Some(v)=>Some(v),
					None=> match bit_size_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(bit_size_body.into(),JSONType::Number)),
					},
				};
				let endian_body = match raw_node.body.get("endian") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"endian")),
				};
				node.borrow_mut().endian = match endian_body.as_str() {
					Some(v)=>match Endian::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(endian_body.into(),JSONType::String)),
				};
				let is_signed_body = match raw_node.body.get("is_signed") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_signed")),
				};
				node.borrow_mut().is_signed = match is_signed_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_signed_body.into(),JSONType::Bool)),
				};
				let is_common_supported_body = match raw_node.body.get("is_common_supported") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_common_supported")),
				};
				node.borrow_mut().is_common_supported = match is_common_supported_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_common_supported_body.into(),JSONType::Bool)),
				};
			},
			NodeType::FloatType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::FloatType(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let is_explicit_body = match raw_node.body.get("is_explicit") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_explicit")),
				};
				node.borrow_mut().is_explicit = match is_explicit_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_explicit_body.into(),JSONType::Bool)),
				};
				let non_dynamic_body = match raw_node.body.get("non_dynamic") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"non_dynamic")),
				};
				node.borrow_mut().non_dynamic = match non_dynamic_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(non_dynamic_body.into(),JSONType::Bool)),
				};
				let bit_alignment_body = match raw_node.body.get("bit_alignment") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_alignment")),
				};
				node.borrow_mut().bit_alignment = match bit_alignment_body.as_str() {
					Some(v)=>match BitAlignment::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(bit_alignment_body.into(),JSONType::String)),
				};
				let bit_size_body = match raw_node.body.get("bit_size") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_size")),
				};
				node.borrow_mut().bit_size = match bit_size_body.as_u64() {
					Some(v)=>Some(v),
					None=> match bit_size_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(bit_size_body.into(),JSONType::Number)),
					},
				};
				let endian_body = match raw_node.body.get("endian") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"endian")),
				};
				node.borrow_mut().endian = match endian_body.as_str() {
					Some(v)=>match Endian::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(endian_body.into(),JSONType::String)),
				};
				let is_common_supported_body = match raw_node.body.get("is_common_supported") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_common_supported")),
				};
				node.borrow_mut().is_common_supported = match is_common_supported_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_common_supported_body.into(),JSONType::Bool)),
				};
			},
			NodeType::IdentType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::IdentType(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let is_explicit_body = match raw_node.body.get("is_explicit") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_explicit")),
				};
				node.borrow_mut().is_explicit = match is_explicit_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_explicit_body.into(),JSONType::Bool)),
				};
				let non_dynamic_body = match raw_node.body.get("non_dynamic") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"non_dynamic")),
				};
				node.borrow_mut().non_dynamic = match non_dynamic_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(non_dynamic_body.into(),JSONType::Bool)),
				};
				let bit_alignment_body = match raw_node.body.get("bit_alignment") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_alignment")),
				};
				node.borrow_mut().bit_alignment = match bit_alignment_body.as_str() {
					Some(v)=>match BitAlignment::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(bit_alignment_body.into(),JSONType::String)),
				};
				let bit_size_body = match raw_node.body.get("bit_size") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_size")),
				};
				node.borrow_mut().bit_size = match bit_size_body.as_u64() {
					Some(v)=>Some(v),
					None=> match bit_size_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(bit_size_body.into(),JSONType::Number)),
					},
				};
				let ident_body = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"ident")),
				};
 				if !ident_body.is_null() {
					let ident_body = match ident_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(ident_body.into(),JSONType::Number)),
					};
					let ident_body = match nodes.get(ident_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(ident_body as usize)),
					};
					let ident_body = match ident_body {
						Node::Ident(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),ident_body.into())),
					};
					node.borrow_mut().ident = Some(ident_body.clone());
				}
				let base_body = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"base")),
				};
 				if !base_body.is_null() {
					let base_body = match base_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(base_body.into(),JSONType::Number)),
					};
					let base_body = match nodes.get(base_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(base_body as usize)),
					};
					node.borrow_mut().base = Some(base_body.try_into()?);
				}
			},
			NodeType::IntLiteralType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::IntLiteralType(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let is_explicit_body = match raw_node.body.get("is_explicit") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_explicit")),
				};
				node.borrow_mut().is_explicit = match is_explicit_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_explicit_body.into(),JSONType::Bool)),
				};
				let non_dynamic_body = match raw_node.body.get("non_dynamic") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"non_dynamic")),
				};
				node.borrow_mut().non_dynamic = match non_dynamic_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(non_dynamic_body.into(),JSONType::Bool)),
				};
				let bit_alignment_body = match raw_node.body.get("bit_alignment") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_alignment")),
				};
				node.borrow_mut().bit_alignment = match bit_alignment_body.as_str() {
					Some(v)=>match BitAlignment::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(bit_alignment_body.into(),JSONType::String)),
				};
				let bit_size_body = match raw_node.body.get("bit_size") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_size")),
				};
				node.borrow_mut().bit_size = match bit_size_body.as_u64() {
					Some(v)=>Some(v),
					None=> match bit_size_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(bit_size_body.into(),JSONType::Number)),
					},
				};
				let base_body = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"base")),
				};
 				if !base_body.is_null() {
					let base_body = match base_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(base_body.into(),JSONType::Number)),
					};
					let base_body = match nodes.get(base_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(base_body as usize)),
					};
					let base_body = match base_body {
						Node::IntLiteral(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),base_body.into())),
					};
					node.borrow_mut().base = Some(Rc::downgrade(&base_body));
				}
			},
			NodeType::StrLiteralType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::StrLiteralType(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let is_explicit_body = match raw_node.body.get("is_explicit") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_explicit")),
				};
				node.borrow_mut().is_explicit = match is_explicit_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_explicit_body.into(),JSONType::Bool)),
				};
				let non_dynamic_body = match raw_node.body.get("non_dynamic") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"non_dynamic")),
				};
				node.borrow_mut().non_dynamic = match non_dynamic_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(non_dynamic_body.into(),JSONType::Bool)),
				};
				let bit_alignment_body = match raw_node.body.get("bit_alignment") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_alignment")),
				};
				node.borrow_mut().bit_alignment = match bit_alignment_body.as_str() {
					Some(v)=>match BitAlignment::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(bit_alignment_body.into(),JSONType::String)),
				};
				let bit_size_body = match raw_node.body.get("bit_size") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_size")),
				};
				node.borrow_mut().bit_size = match bit_size_body.as_u64() {
					Some(v)=>Some(v),
					None=> match bit_size_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(bit_size_body.into(),JSONType::Number)),
					},
				};
				let base_body = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"base")),
				};
 				if !base_body.is_null() {
					let base_body = match base_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(base_body.into(),JSONType::Number)),
					};
					let base_body = match nodes.get(base_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(base_body as usize)),
					};
					let base_body = match base_body {
						Node::StrLiteral(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),base_body.into())),
					};
					node.borrow_mut().base = Some(Rc::downgrade(&base_body));
				}
				let strong_ref_body = match raw_node.body.get("strong_ref") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"strong_ref")),
				};
 				if !strong_ref_body.is_null() {
					let strong_ref_body = match strong_ref_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(strong_ref_body.into(),JSONType::Number)),
					};
					let strong_ref_body = match nodes.get(strong_ref_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(strong_ref_body as usize)),
					};
					let strong_ref_body = match strong_ref_body {
						Node::StrLiteral(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),strong_ref_body.into())),
					};
					node.borrow_mut().strong_ref = Some(strong_ref_body.clone());
				}
			},
			NodeType::VoidType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::VoidType(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let is_explicit_body = match raw_node.body.get("is_explicit") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_explicit")),
				};
				node.borrow_mut().is_explicit = match is_explicit_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_explicit_body.into(),JSONType::Bool)),
				};
				let non_dynamic_body = match raw_node.body.get("non_dynamic") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"non_dynamic")),
				};
				node.borrow_mut().non_dynamic = match non_dynamic_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(non_dynamic_body.into(),JSONType::Bool)),
				};
				let bit_alignment_body = match raw_node.body.get("bit_alignment") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_alignment")),
				};
				node.borrow_mut().bit_alignment = match bit_alignment_body.as_str() {
					Some(v)=>match BitAlignment::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(bit_alignment_body.into(),JSONType::String)),
				};
				let bit_size_body = match raw_node.body.get("bit_size") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_size")),
				};
				node.borrow_mut().bit_size = match bit_size_body.as_u64() {
					Some(v)=>Some(v),
					None=> match bit_size_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(bit_size_body.into(),JSONType::Number)),
					},
				};
			},
			NodeType::BoolType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::BoolType(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let is_explicit_body = match raw_node.body.get("is_explicit") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_explicit")),
				};
				node.borrow_mut().is_explicit = match is_explicit_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_explicit_body.into(),JSONType::Bool)),
				};
				let non_dynamic_body = match raw_node.body.get("non_dynamic") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"non_dynamic")),
				};
				node.borrow_mut().non_dynamic = match non_dynamic_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(non_dynamic_body.into(),JSONType::Bool)),
				};
				let bit_alignment_body = match raw_node.body.get("bit_alignment") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_alignment")),
				};
				node.borrow_mut().bit_alignment = match bit_alignment_body.as_str() {
					Some(v)=>match BitAlignment::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(bit_alignment_body.into(),JSONType::String)),
				};
				let bit_size_body = match raw_node.body.get("bit_size") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_size")),
				};
				node.borrow_mut().bit_size = match bit_size_body.as_u64() {
					Some(v)=>Some(v),
					None=> match bit_size_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(bit_size_body.into(),JSONType::Number)),
					},
				};
			},
			NodeType::ArrayType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::ArrayType(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let is_explicit_body = match raw_node.body.get("is_explicit") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_explicit")),
				};
				node.borrow_mut().is_explicit = match is_explicit_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_explicit_body.into(),JSONType::Bool)),
				};
				let non_dynamic_body = match raw_node.body.get("non_dynamic") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"non_dynamic")),
				};
				node.borrow_mut().non_dynamic = match non_dynamic_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(non_dynamic_body.into(),JSONType::Bool)),
				};
				let bit_alignment_body = match raw_node.body.get("bit_alignment") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_alignment")),
				};
				node.borrow_mut().bit_alignment = match bit_alignment_body.as_str() {
					Some(v)=>match BitAlignment::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(bit_alignment_body.into(),JSONType::String)),
				};
				let bit_size_body = match raw_node.body.get("bit_size") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_size")),
				};
				node.borrow_mut().bit_size = match bit_size_body.as_u64() {
					Some(v)=>Some(v),
					None=> match bit_size_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(bit_size_body.into(),JSONType::Number)),
					},
				};
				let end_loc_body = match raw_node.body.get("end_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"end_loc")),
				};
				node.borrow_mut().end_loc = match serde_json::from_value(end_loc_body.clone()) {
					Ok(v)=>v,
					Err(e)=>return Err(Error::JSONError(e)),
				};
				let base_type_body = match raw_node.body.get("base_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"base_type")),
				};
 				if !base_type_body.is_null() {
					let base_type_body = match base_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(base_type_body.into(),JSONType::Number)),
					};
					let base_type_body = match nodes.get(base_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(base_type_body as usize)),
					};
					node.borrow_mut().base_type = Some(base_type_body.try_into()?);
				}
				let length_body = match raw_node.body.get("length") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"length")),
				};
 				if !length_body.is_null() {
					let length_body = match length_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(length_body.into(),JSONType::Number)),
					};
					let length_body = match nodes.get(length_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(length_body as usize)),
					};
					node.borrow_mut().length = Some(length_body.try_into()?);
				}
				let length_value_body = match raw_node.body.get("length_value") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"length_value")),
				};
				node.borrow_mut().length_value = match length_value_body.as_u64() {
					Some(v)=>Some(v),
					None=> match length_value_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(length_value_body.into(),JSONType::Number)),
					},
				};
			},
			NodeType::FunctionType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::FunctionType(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let is_explicit_body = match raw_node.body.get("is_explicit") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_explicit")),
				};
				node.borrow_mut().is_explicit = match is_explicit_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_explicit_body.into(),JSONType::Bool)),
				};
				let non_dynamic_body = match raw_node.body.get("non_dynamic") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"non_dynamic")),
				};
				node.borrow_mut().non_dynamic = match non_dynamic_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(non_dynamic_body.into(),JSONType::Bool)),
				};
				let bit_alignment_body = match raw_node.body.get("bit_alignment") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_alignment")),
				};
				node.borrow_mut().bit_alignment = match bit_alignment_body.as_str() {
					Some(v)=>match BitAlignment::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(bit_alignment_body.into(),JSONType::String)),
				};
				let bit_size_body = match raw_node.body.get("bit_size") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_size")),
				};
				node.borrow_mut().bit_size = match bit_size_body.as_u64() {
					Some(v)=>Some(v),
					None=> match bit_size_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(bit_size_body.into(),JSONType::Number)),
					},
				};
				let return_type_body = match raw_node.body.get("return_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"return_type")),
				};
 				if !return_type_body.is_null() {
					let return_type_body = match return_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(return_type_body.into(),JSONType::Number)),
					};
					let return_type_body = match nodes.get(return_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(return_type_body as usize)),
					};
					node.borrow_mut().return_type = Some(return_type_body.try_into()?);
				}
				let parameters_body = match raw_node.body.get("parameters") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"parameters")),
				};
				let parameters_body = match parameters_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(parameters_body.into(),JSONType::Array)),
				};
				for link in parameters_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let parameters_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					node.borrow_mut().parameters.push(parameters_body.try_into()?);
				}
			},
			NodeType::StructType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::StructType(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let is_explicit_body = match raw_node.body.get("is_explicit") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_explicit")),
				};
				node.borrow_mut().is_explicit = match is_explicit_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_explicit_body.into(),JSONType::Bool)),
				};
				let non_dynamic_body = match raw_node.body.get("non_dynamic") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"non_dynamic")),
				};
				node.borrow_mut().non_dynamic = match non_dynamic_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(non_dynamic_body.into(),JSONType::Bool)),
				};
				let bit_alignment_body = match raw_node.body.get("bit_alignment") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_alignment")),
				};
				node.borrow_mut().bit_alignment = match bit_alignment_body.as_str() {
					Some(v)=>match BitAlignment::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(bit_alignment_body.into(),JSONType::String)),
				};
				let bit_size_body = match raw_node.body.get("bit_size") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_size")),
				};
				node.borrow_mut().bit_size = match bit_size_body.as_u64() {
					Some(v)=>Some(v),
					None=> match bit_size_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(bit_size_body.into(),JSONType::Number)),
					},
				};
				let fields_body = match raw_node.body.get("fields") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"fields")),
				};
				let fields_body = match fields_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(fields_body.into(),JSONType::Array)),
				};
				for link in fields_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let fields_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					node.borrow_mut().fields.push(fields_body.try_into()?);
				}
				let base_body = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"base")),
				};
 				if !base_body.is_null() {
					let base_body = match base_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(base_body.into(),JSONType::Number)),
					};
					let base_body = match nodes.get(base_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(base_body as usize)),
					};
					node.borrow_mut().base = Some(NodeWeak::from(base_body.clone()));
				}
				let recursive_body = match raw_node.body.get("recursive") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"recursive")),
				};
				node.borrow_mut().recursive = match recursive_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(recursive_body.into(),JSONType::Bool)),
				};
				let fixed_header_size_body = match raw_node.body.get("fixed_header_size") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"fixed_header_size")),
				};
				node.borrow_mut().fixed_header_size = match fixed_header_size_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(fixed_header_size_body.into(),JSONType::Number)),
				};
				let fixed_tail_size_body = match raw_node.body.get("fixed_tail_size") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"fixed_tail_size")),
				};
				node.borrow_mut().fixed_tail_size = match fixed_tail_size_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(fixed_tail_size_body.into(),JSONType::Number)),
				};
			},
			NodeType::StructUnionType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::StructUnionType(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let is_explicit_body = match raw_node.body.get("is_explicit") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_explicit")),
				};
				node.borrow_mut().is_explicit = match is_explicit_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_explicit_body.into(),JSONType::Bool)),
				};
				let non_dynamic_body = match raw_node.body.get("non_dynamic") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"non_dynamic")),
				};
				node.borrow_mut().non_dynamic = match non_dynamic_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(non_dynamic_body.into(),JSONType::Bool)),
				};
				let bit_alignment_body = match raw_node.body.get("bit_alignment") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_alignment")),
				};
				node.borrow_mut().bit_alignment = match bit_alignment_body.as_str() {
					Some(v)=>match BitAlignment::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(bit_alignment_body.into(),JSONType::String)),
				};
				let bit_size_body = match raw_node.body.get("bit_size") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_size")),
				};
				node.borrow_mut().bit_size = match bit_size_body.as_u64() {
					Some(v)=>Some(v),
					None=> match bit_size_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(bit_size_body.into(),JSONType::Number)),
					},
				};
				let structs_body = match raw_node.body.get("structs") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"structs")),
				};
				let structs_body = match structs_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(structs_body.into(),JSONType::Array)),
				};
				for link in structs_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let structs_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					let structs_body = match structs_body {
						Node::StructType(body)=>body,
						x =>return Err(Error::MismatchNodeType(x.into(),structs_body.into())),
					};
					node.borrow_mut().structs.push(structs_body.clone());
				}
				let base_body = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"base")),
				};
 				if !base_body.is_null() {
					let base_body = match base_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(base_body.into(),JSONType::Number)),
					};
					let base_body = match nodes.get(base_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(base_body as usize)),
					};
					node.borrow_mut().base = Some(base_body.try_into()?);
				}
				let union_fields_body = match raw_node.body.get("union_fields") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"union_fields")),
				};
				let union_fields_body = match union_fields_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(union_fields_body.into(),JSONType::Array)),
				};
				for link in union_fields_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let union_fields_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					let union_fields_body = match union_fields_body {
						Node::Field(body)=>body,
						x =>return Err(Error::MismatchNodeType(x.into(),union_fields_body.into())),
					};
					node.borrow_mut().union_fields.push(Rc::downgrade(&union_fields_body));
				}
			},
			NodeType::UnionType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::UnionType(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let is_explicit_body = match raw_node.body.get("is_explicit") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_explicit")),
				};
				node.borrow_mut().is_explicit = match is_explicit_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_explicit_body.into(),JSONType::Bool)),
				};
				let non_dynamic_body = match raw_node.body.get("non_dynamic") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"non_dynamic")),
				};
				node.borrow_mut().non_dynamic = match non_dynamic_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(non_dynamic_body.into(),JSONType::Bool)),
				};
				let bit_alignment_body = match raw_node.body.get("bit_alignment") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_alignment")),
				};
				node.borrow_mut().bit_alignment = match bit_alignment_body.as_str() {
					Some(v)=>match BitAlignment::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(bit_alignment_body.into(),JSONType::String)),
				};
				let bit_size_body = match raw_node.body.get("bit_size") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_size")),
				};
				node.borrow_mut().bit_size = match bit_size_body.as_u64() {
					Some(v)=>Some(v),
					None=> match bit_size_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(bit_size_body.into(),JSONType::Number)),
					},
				};
				let cond_body = match raw_node.body.get("cond") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"cond")),
				};
 				if !cond_body.is_null() {
					let cond_body = match cond_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(cond_body.into(),JSONType::Number)),
					};
					let cond_body = match nodes.get(cond_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(cond_body as usize)),
					};
					node.borrow_mut().cond = Some(cond_body.try_into()?);
				}
				let candidates_body = match raw_node.body.get("candidates") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"candidates")),
				};
				let candidates_body = match candidates_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(candidates_body.into(),JSONType::Array)),
				};
				for link in candidates_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let candidates_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					let candidates_body = match candidates_body {
						Node::UnionCandidate(body)=>body,
						x =>return Err(Error::MismatchNodeType(x.into(),candidates_body.into())),
					};
					node.borrow_mut().candidates.push(candidates_body.clone());
				}
				let base_type_body = match raw_node.body.get("base_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"base_type")),
				};
 				if !base_type_body.is_null() {
					let base_type_body = match base_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(base_type_body.into(),JSONType::Number)),
					};
					let base_type_body = match nodes.get(base_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(base_type_body as usize)),
					};
					let base_type_body = match base_type_body {
						Node::StructUnionType(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),base_type_body.into())),
					};
					node.borrow_mut().base_type = Some(Rc::downgrade(&base_type_body));
				}
				let common_type_body = match raw_node.body.get("common_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"common_type")),
				};
 				if !common_type_body.is_null() {
					let common_type_body = match common_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(common_type_body.into(),JSONType::Number)),
					};
					let common_type_body = match nodes.get(common_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(common_type_body as usize)),
					};
					node.borrow_mut().common_type = Some(common_type_body.try_into()?);
				}
			},
			NodeType::RangeType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::RangeType(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let is_explicit_body = match raw_node.body.get("is_explicit") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_explicit")),
				};
				node.borrow_mut().is_explicit = match is_explicit_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_explicit_body.into(),JSONType::Bool)),
				};
				let non_dynamic_body = match raw_node.body.get("non_dynamic") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"non_dynamic")),
				};
				node.borrow_mut().non_dynamic = match non_dynamic_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(non_dynamic_body.into(),JSONType::Bool)),
				};
				let bit_alignment_body = match raw_node.body.get("bit_alignment") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_alignment")),
				};
				node.borrow_mut().bit_alignment = match bit_alignment_body.as_str() {
					Some(v)=>match BitAlignment::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(bit_alignment_body.into(),JSONType::String)),
				};
				let bit_size_body = match raw_node.body.get("bit_size") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_size")),
				};
				node.borrow_mut().bit_size = match bit_size_body.as_u64() {
					Some(v)=>Some(v),
					None=> match bit_size_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(bit_size_body.into(),JSONType::Number)),
					},
				};
				let base_type_body = match raw_node.body.get("base_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"base_type")),
				};
 				if !base_type_body.is_null() {
					let base_type_body = match base_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(base_type_body.into(),JSONType::Number)),
					};
					let base_type_body = match nodes.get(base_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(base_type_body as usize)),
					};
					node.borrow_mut().base_type = Some(base_type_body.try_into()?);
				}
				let range_body = match raw_node.body.get("range") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"range")),
				};
 				if !range_body.is_null() {
					let range_body = match range_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(range_body.into(),JSONType::Number)),
					};
					let range_body = match nodes.get(range_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(range_body as usize)),
					};
					let range_body = match range_body {
						Node::Range(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),range_body.into())),
					};
					node.borrow_mut().range = Some(Rc::downgrade(&range_body));
				}
			},
			NodeType::EnumType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::EnumType(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let is_explicit_body = match raw_node.body.get("is_explicit") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_explicit")),
				};
				node.borrow_mut().is_explicit = match is_explicit_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_explicit_body.into(),JSONType::Bool)),
				};
				let non_dynamic_body = match raw_node.body.get("non_dynamic") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"non_dynamic")),
				};
				node.borrow_mut().non_dynamic = match non_dynamic_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(non_dynamic_body.into(),JSONType::Bool)),
				};
				let bit_alignment_body = match raw_node.body.get("bit_alignment") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_alignment")),
				};
				node.borrow_mut().bit_alignment = match bit_alignment_body.as_str() {
					Some(v)=>match BitAlignment::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(bit_alignment_body.into(),JSONType::String)),
				};
				let bit_size_body = match raw_node.body.get("bit_size") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_size")),
				};
				node.borrow_mut().bit_size = match bit_size_body.as_u64() {
					Some(v)=>Some(v),
					None=> match bit_size_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(bit_size_body.into(),JSONType::Number)),
					},
				};
				let base_body = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"base")),
				};
 				if !base_body.is_null() {
					let base_body = match base_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(base_body.into(),JSONType::Number)),
					};
					let base_body = match nodes.get(base_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(base_body as usize)),
					};
					let base_body = match base_body {
						Node::Enum(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),base_body.into())),
					};
					node.borrow_mut().base = Some(Rc::downgrade(&base_body));
				}
			},
			NodeType::MetaType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::MetaType(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let is_explicit_body = match raw_node.body.get("is_explicit") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_explicit")),
				};
				node.borrow_mut().is_explicit = match is_explicit_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_explicit_body.into(),JSONType::Bool)),
				};
				let non_dynamic_body = match raw_node.body.get("non_dynamic") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"non_dynamic")),
				};
				node.borrow_mut().non_dynamic = match non_dynamic_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(non_dynamic_body.into(),JSONType::Bool)),
				};
				let bit_alignment_body = match raw_node.body.get("bit_alignment") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_alignment")),
				};
				node.borrow_mut().bit_alignment = match bit_alignment_body.as_str() {
					Some(v)=>match BitAlignment::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(bit_alignment_body.into(),JSONType::String)),
				};
				let bit_size_body = match raw_node.body.get("bit_size") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_size")),
				};
				node.borrow_mut().bit_size = match bit_size_body.as_u64() {
					Some(v)=>Some(v),
					None=> match bit_size_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(bit_size_body.into(),JSONType::Number)),
					},
				};
			},
			NodeType::OptionalType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::OptionalType(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let is_explicit_body = match raw_node.body.get("is_explicit") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_explicit")),
				};
				node.borrow_mut().is_explicit = match is_explicit_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_explicit_body.into(),JSONType::Bool)),
				};
				let non_dynamic_body = match raw_node.body.get("non_dynamic") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"non_dynamic")),
				};
				node.borrow_mut().non_dynamic = match non_dynamic_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(non_dynamic_body.into(),JSONType::Bool)),
				};
				let bit_alignment_body = match raw_node.body.get("bit_alignment") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_alignment")),
				};
				node.borrow_mut().bit_alignment = match bit_alignment_body.as_str() {
					Some(v)=>match BitAlignment::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(bit_alignment_body.into(),JSONType::String)),
				};
				let bit_size_body = match raw_node.body.get("bit_size") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_size")),
				};
				node.borrow_mut().bit_size = match bit_size_body.as_u64() {
					Some(v)=>Some(v),
					None=> match bit_size_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(bit_size_body.into(),JSONType::Number)),
					},
				};
				let base_type_body = match raw_node.body.get("base_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"base_type")),
				};
 				if !base_type_body.is_null() {
					let base_type_body = match base_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(base_type_body.into(),JSONType::Number)),
					};
					let base_type_body = match nodes.get(base_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(base_type_body as usize)),
					};
					node.borrow_mut().base_type = Some(base_type_body.try_into()?);
				}
			},
			NodeType::IntLiteral => {
				let node = nodes[i].clone();
				let node = match node {
					Node::IntLiteral(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let value_body = match raw_node.body.get("value") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"value")),
				};
				node.borrow_mut().value = match value_body.as_str() {
					Some(v)=>v.to_string(),
					None=>return Err(Error::MismatchJSONType(value_body.into(),JSONType::String)),
				};
			},
			NodeType::BoolLiteral => {
				let node = nodes[i].clone();
				let node = match node {
					Node::BoolLiteral(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let value_body = match raw_node.body.get("value") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"value")),
				};
				node.borrow_mut().value = match value_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(value_body.into(),JSONType::Bool)),
				};
			},
			NodeType::StrLiteral => {
				let node = nodes[i].clone();
				let node = match node {
					Node::StrLiteral(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let value_body = match raw_node.body.get("value") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"value")),
				};
				node.borrow_mut().value = match value_body.as_str() {
					Some(v)=>v.to_string(),
					None=>return Err(Error::MismatchJSONType(value_body.into(),JSONType::String)),
				};
				let length_body = match raw_node.body.get("length") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"length")),
				};
				node.borrow_mut().length = match length_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(length_body.into(),JSONType::Number)),
				};
			},
			NodeType::TypeLiteral => {
				let node = nodes[i].clone();
				let node = match node {
					Node::TypeLiteral(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let type_literal_body = match raw_node.body.get("type_literal") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"type_literal")),
				};
 				if !type_literal_body.is_null() {
					let type_literal_body = match type_literal_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(type_literal_body.into(),JSONType::Number)),
					};
					let type_literal_body = match nodes.get(type_literal_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(type_literal_body as usize)),
					};
					node.borrow_mut().type_literal = Some(type_literal_body.try_into()?);
				}
				let end_loc_body = match raw_node.body.get("end_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"end_loc")),
				};
				node.borrow_mut().end_loc = match serde_json::from_value(end_loc_body.clone()) {
					Ok(v)=>v,
					Err(e)=>return Err(Error::JSONError(e)),
				};
			},
			NodeType::SpecialLiteral => {
				let node = nodes[i].clone();
				let node = match node {
					Node::SpecialLiteral(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let expr_type_body = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr_type")),
				};
 				if !expr_type_body.is_null() {
					let expr_type_body = match expr_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_type_body.into(),JSONType::Number)),
					};
					let expr_type_body = match nodes.get(expr_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_type_body as usize)),
					};
					node.borrow_mut().expr_type = Some(expr_type_body.try_into()?);
				}
				let constant_level_body = match raw_node.body.get("constant_level") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"constant_level")),
				};
				node.borrow_mut().constant_level = match constant_level_body.as_str() {
					Some(v)=>match ConstantLevel::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(constant_level_body.into(),JSONType::String)),
				};
				let kind_body = match raw_node.body.get("kind") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"kind")),
				};
				node.borrow_mut().kind = match kind_body.as_str() {
					Some(v)=>match SpecialLiteralKind::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(kind_body.into(),JSONType::String)),
				};
			},
			NodeType::Field => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Field(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let belong_body = match raw_node.body.get("belong") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"belong")),
				};
 				if !belong_body.is_null() {
					let belong_body = match belong_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(belong_body.into(),JSONType::Number)),
					};
					let belong_body = match nodes.get(belong_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(belong_body as usize)),
					};
					node.borrow_mut().belong = Some(belong_body.try_into()?);
				}
				let belong_struct_body = match raw_node.body.get("belong_struct") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"belong_struct")),
				};
 				if !belong_struct_body.is_null() {
					let belong_struct_body = match belong_struct_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(belong_struct_body.into(),JSONType::Number)),
					};
					let belong_struct_body = match nodes.get(belong_struct_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(belong_struct_body as usize)),
					};
					let belong_struct_body = match belong_struct_body {
						Node::StructType(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),belong_struct_body.into())),
					};
					node.borrow_mut().belong_struct = Some(Rc::downgrade(&belong_struct_body));
				}
				let ident_body = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"ident")),
				};
 				if !ident_body.is_null() {
					let ident_body = match ident_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(ident_body.into(),JSONType::Number)),
					};
					let ident_body = match nodes.get(ident_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(ident_body as usize)),
					};
					let ident_body = match ident_body {
						Node::Ident(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),ident_body.into())),
					};
					node.borrow_mut().ident = Some(ident_body.clone());
				}
				let colon_loc_body = match raw_node.body.get("colon_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"colon_loc")),
				};
				node.borrow_mut().colon_loc = match serde_json::from_value(colon_loc_body.clone()) {
					Ok(v)=>v,
					Err(e)=>return Err(Error::JSONError(e)),
				};
				let field_type_body = match raw_node.body.get("field_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"field_type")),
				};
 				if !field_type_body.is_null() {
					let field_type_body = match field_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(field_type_body.into(),JSONType::Number)),
					};
					let field_type_body = match nodes.get(field_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(field_type_body as usize)),
					};
					node.borrow_mut().field_type = Some(field_type_body.try_into()?);
				}
				let arguments_body = match raw_node.body.get("arguments") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"arguments")),
				};
 				if !arguments_body.is_null() {
					let arguments_body = match arguments_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(arguments_body.into(),JSONType::Number)),
					};
					let arguments_body = match nodes.get(arguments_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(arguments_body as usize)),
					};
					let arguments_body = match arguments_body {
						Node::FieldArgument(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),arguments_body.into())),
					};
					node.borrow_mut().arguments = Some(arguments_body.clone());
				}
				let offset_bit_body = match raw_node.body.get("offset_bit") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"offset_bit")),
				};
				node.borrow_mut().offset_bit = match offset_bit_body.as_u64() {
					Some(v)=>Some(v),
					None=> match offset_bit_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(offset_bit_body.into(),JSONType::Number)),
					},
				};
				let offset_recent_body = match raw_node.body.get("offset_recent") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"offset_recent")),
				};
				node.borrow_mut().offset_recent = match offset_recent_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(offset_recent_body.into(),JSONType::Number)),
				};
				let tail_offset_bit_body = match raw_node.body.get("tail_offset_bit") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"tail_offset_bit")),
				};
				node.borrow_mut().tail_offset_bit = match tail_offset_bit_body.as_u64() {
					Some(v)=>Some(v),
					None=> match tail_offset_bit_body.is_null() {
						true=>None,
						false=>return Err(Error::MismatchJSONType(tail_offset_bit_body.into(),JSONType::Number)),
					},
				};
				let tail_offset_recent_body = match raw_node.body.get("tail_offset_recent") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"tail_offset_recent")),
				};
				node.borrow_mut().tail_offset_recent = match tail_offset_recent_body.as_u64() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(tail_offset_recent_body.into(),JSONType::Number)),
				};
				let bit_alignment_body = match raw_node.body.get("bit_alignment") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"bit_alignment")),
				};
				node.borrow_mut().bit_alignment = match bit_alignment_body.as_str() {
					Some(v)=>match BitAlignment::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(bit_alignment_body.into(),JSONType::String)),
				};
				let follow_body = match raw_node.body.get("follow") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"follow")),
				};
				node.borrow_mut().follow = match follow_body.as_str() {
					Some(v)=>match Follow::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(follow_body.into(),JSONType::String)),
				};
				let eventual_follow_body = match raw_node.body.get("eventual_follow") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"eventual_follow")),
				};
				node.borrow_mut().eventual_follow = match eventual_follow_body.as_str() {
					Some(v)=>match Follow::try_from(v) {
						Ok(v)=>v,
						Err(_) => return Err(Error::InvalidEnumValue(v.to_string())),
					},
					None=>return Err(Error::MismatchJSONType(eventual_follow_body.into(),JSONType::String)),
				};
			},
			NodeType::Format => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Format(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let belong_body = match raw_node.body.get("belong") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"belong")),
				};
 				if !belong_body.is_null() {
					let belong_body = match belong_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(belong_body.into(),JSONType::Number)),
					};
					let belong_body = match nodes.get(belong_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(belong_body as usize)),
					};
					node.borrow_mut().belong = Some(belong_body.try_into()?);
				}
				let belong_struct_body = match raw_node.body.get("belong_struct") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"belong_struct")),
				};
 				if !belong_struct_body.is_null() {
					let belong_struct_body = match belong_struct_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(belong_struct_body.into(),JSONType::Number)),
					};
					let belong_struct_body = match nodes.get(belong_struct_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(belong_struct_body as usize)),
					};
					let belong_struct_body = match belong_struct_body {
						Node::StructType(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),belong_struct_body.into())),
					};
					node.borrow_mut().belong_struct = Some(Rc::downgrade(&belong_struct_body));
				}
				let ident_body = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"ident")),
				};
 				if !ident_body.is_null() {
					let ident_body = match ident_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(ident_body.into(),JSONType::Number)),
					};
					let ident_body = match nodes.get(ident_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(ident_body as usize)),
					};
					let ident_body = match ident_body {
						Node::Ident(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),ident_body.into())),
					};
					node.borrow_mut().ident = Some(ident_body.clone());
				}
				let body_body = match raw_node.body.get("body") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"body")),
				};
 				if !body_body.is_null() {
					let body_body = match body_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(body_body.into(),JSONType::Number)),
					};
					let body_body = match nodes.get(body_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(body_body as usize)),
					};
					let body_body = match body_body {
						Node::IndentBlock(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),body_body.into())),
					};
					node.borrow_mut().body = Some(body_body.clone());
				}
				let encode_fn_body = match raw_node.body.get("encode_fn") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"encode_fn")),
				};
 				if !encode_fn_body.is_null() {
					let encode_fn_body = match encode_fn_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(encode_fn_body.into(),JSONType::Number)),
					};
					let encode_fn_body = match nodes.get(encode_fn_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(encode_fn_body as usize)),
					};
					let encode_fn_body = match encode_fn_body {
						Node::Function(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),encode_fn_body.into())),
					};
					node.borrow_mut().encode_fn = Some(Rc::downgrade(&encode_fn_body));
				}
				let decode_fn_body = match raw_node.body.get("decode_fn") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"decode_fn")),
				};
 				if !decode_fn_body.is_null() {
					let decode_fn_body = match decode_fn_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(decode_fn_body.into(),JSONType::Number)),
					};
					let decode_fn_body = match nodes.get(decode_fn_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(decode_fn_body as usize)),
					};
					let decode_fn_body = match decode_fn_body {
						Node::Function(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),decode_fn_body.into())),
					};
					node.borrow_mut().decode_fn = Some(Rc::downgrade(&decode_fn_body));
				}
				let cast_fns_body = match raw_node.body.get("cast_fns") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"cast_fns")),
				};
				let cast_fns_body = match cast_fns_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(cast_fns_body.into(),JSONType::Array)),
				};
				for link in cast_fns_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let cast_fns_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					let cast_fns_body = match cast_fns_body {
						Node::Function(body)=>body,
						x =>return Err(Error::MismatchNodeType(x.into(),cast_fns_body.into())),
					};
					node.borrow_mut().cast_fns.push(Rc::downgrade(&cast_fns_body));
				}
				let depends_body = match raw_node.body.get("depends") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"depends")),
				};
				let depends_body = match depends_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(depends_body.into(),JSONType::Array)),
				};
				for link in depends_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let depends_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					let depends_body = match depends_body {
						Node::IdentType(body)=>body,
						x =>return Err(Error::MismatchNodeType(x.into(),depends_body.into())),
					};
					node.borrow_mut().depends.push(Rc::downgrade(&depends_body));
				}
				let state_variables_body = match raw_node.body.get("state_variables") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"state_variables")),
				};
				let state_variables_body = match state_variables_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(state_variables_body.into(),JSONType::Array)),
				};
				for link in state_variables_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let state_variables_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					let state_variables_body = match state_variables_body {
						Node::Ident(body)=>body,
						x =>return Err(Error::MismatchNodeType(x.into(),state_variables_body.into())),
					};
					node.borrow_mut().state_variables.push(Rc::downgrade(&state_variables_body));
				}
			},
			NodeType::State => {
				let node = nodes[i].clone();
				let node = match node {
					Node::State(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let belong_body = match raw_node.body.get("belong") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"belong")),
				};
 				if !belong_body.is_null() {
					let belong_body = match belong_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(belong_body.into(),JSONType::Number)),
					};
					let belong_body = match nodes.get(belong_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(belong_body as usize)),
					};
					node.borrow_mut().belong = Some(belong_body.try_into()?);
				}
				let belong_struct_body = match raw_node.body.get("belong_struct") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"belong_struct")),
				};
 				if !belong_struct_body.is_null() {
					let belong_struct_body = match belong_struct_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(belong_struct_body.into(),JSONType::Number)),
					};
					let belong_struct_body = match nodes.get(belong_struct_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(belong_struct_body as usize)),
					};
					let belong_struct_body = match belong_struct_body {
						Node::StructType(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),belong_struct_body.into())),
					};
					node.borrow_mut().belong_struct = Some(Rc::downgrade(&belong_struct_body));
				}
				let ident_body = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"ident")),
				};
 				if !ident_body.is_null() {
					let ident_body = match ident_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(ident_body.into(),JSONType::Number)),
					};
					let ident_body = match nodes.get(ident_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(ident_body as usize)),
					};
					let ident_body = match ident_body {
						Node::Ident(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),ident_body.into())),
					};
					node.borrow_mut().ident = Some(ident_body.clone());
				}
				let body_body = match raw_node.body.get("body") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"body")),
				};
 				if !body_body.is_null() {
					let body_body = match body_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(body_body.into(),JSONType::Number)),
					};
					let body_body = match nodes.get(body_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(body_body as usize)),
					};
					let body_body = match body_body {
						Node::IndentBlock(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),body_body.into())),
					};
					node.borrow_mut().body = Some(body_body.clone());
				}
			},
			NodeType::Enum => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Enum(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let belong_body = match raw_node.body.get("belong") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"belong")),
				};
 				if !belong_body.is_null() {
					let belong_body = match belong_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(belong_body.into(),JSONType::Number)),
					};
					let belong_body = match nodes.get(belong_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(belong_body as usize)),
					};
					node.borrow_mut().belong = Some(belong_body.try_into()?);
				}
				let belong_struct_body = match raw_node.body.get("belong_struct") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"belong_struct")),
				};
 				if !belong_struct_body.is_null() {
					let belong_struct_body = match belong_struct_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(belong_struct_body.into(),JSONType::Number)),
					};
					let belong_struct_body = match nodes.get(belong_struct_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(belong_struct_body as usize)),
					};
					let belong_struct_body = match belong_struct_body {
						Node::StructType(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),belong_struct_body.into())),
					};
					node.borrow_mut().belong_struct = Some(Rc::downgrade(&belong_struct_body));
				}
				let ident_body = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"ident")),
				};
 				if !ident_body.is_null() {
					let ident_body = match ident_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(ident_body.into(),JSONType::Number)),
					};
					let ident_body = match nodes.get(ident_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(ident_body as usize)),
					};
					let ident_body = match ident_body {
						Node::Ident(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),ident_body.into())),
					};
					node.borrow_mut().ident = Some(ident_body.clone());
				}
				let scope_body = match raw_node.body.get("scope") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"scope")),
				};
 				if !scope_body.is_null() {
					let scope_body = match scope_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(scope_body.into(),JSONType::Number)),
					};
					let scope_body = match scopes.get(scope_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(scope_body as usize)),
					};
					node.borrow_mut().scope = Some(scope_body.clone());
				}
				let colon_loc_body = match raw_node.body.get("colon_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"colon_loc")),
				};
				node.borrow_mut().colon_loc = match serde_json::from_value(colon_loc_body.clone()) {
					Ok(v)=>v,
					Err(e)=>return Err(Error::JSONError(e)),
				};
				let base_type_body = match raw_node.body.get("base_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"base_type")),
				};
 				if !base_type_body.is_null() {
					let base_type_body = match base_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(base_type_body.into(),JSONType::Number)),
					};
					let base_type_body = match nodes.get(base_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(base_type_body as usize)),
					};
					node.borrow_mut().base_type = Some(base_type_body.try_into()?);
				}
				let members_body = match raw_node.body.get("members") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"members")),
				};
				let members_body = match members_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(members_body.into(),JSONType::Array)),
				};
				for link in members_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let members_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					let members_body = match members_body {
						Node::EnumMember(body)=>body,
						x =>return Err(Error::MismatchNodeType(x.into(),members_body.into())),
					};
					node.borrow_mut().members.push(members_body.clone());
				}
				let enum_type_body = match raw_node.body.get("enum_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"enum_type")),
				};
 				if !enum_type_body.is_null() {
					let enum_type_body = match enum_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(enum_type_body.into(),JSONType::Number)),
					};
					let enum_type_body = match nodes.get(enum_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(enum_type_body as usize)),
					};
					let enum_type_body = match enum_type_body {
						Node::EnumType(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),enum_type_body.into())),
					};
					node.borrow_mut().enum_type = Some(enum_type_body.clone());
				}
			},
			NodeType::EnumMember => {
				let node = nodes[i].clone();
				let node = match node {
					Node::EnumMember(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let belong_body = match raw_node.body.get("belong") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"belong")),
				};
 				if !belong_body.is_null() {
					let belong_body = match belong_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(belong_body.into(),JSONType::Number)),
					};
					let belong_body = match nodes.get(belong_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(belong_body as usize)),
					};
					node.borrow_mut().belong = Some(belong_body.try_into()?);
				}
				let belong_struct_body = match raw_node.body.get("belong_struct") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"belong_struct")),
				};
 				if !belong_struct_body.is_null() {
					let belong_struct_body = match belong_struct_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(belong_struct_body.into(),JSONType::Number)),
					};
					let belong_struct_body = match nodes.get(belong_struct_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(belong_struct_body as usize)),
					};
					let belong_struct_body = match belong_struct_body {
						Node::StructType(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),belong_struct_body.into())),
					};
					node.borrow_mut().belong_struct = Some(Rc::downgrade(&belong_struct_body));
				}
				let ident_body = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"ident")),
				};
 				if !ident_body.is_null() {
					let ident_body = match ident_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(ident_body.into(),JSONType::Number)),
					};
					let ident_body = match nodes.get(ident_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(ident_body as usize)),
					};
					let ident_body = match ident_body {
						Node::Ident(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),ident_body.into())),
					};
					node.borrow_mut().ident = Some(ident_body.clone());
				}
				let expr_body = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"expr")),
				};
 				if !expr_body.is_null() {
					let expr_body = match expr_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(expr_body.into(),JSONType::Number)),
					};
					let expr_body = match nodes.get(expr_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(expr_body as usize)),
					};
					node.borrow_mut().expr = Some(expr_body.try_into()?);
				}
			},
			NodeType::Function => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Function(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let belong_body = match raw_node.body.get("belong") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"belong")),
				};
 				if !belong_body.is_null() {
					let belong_body = match belong_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(belong_body.into(),JSONType::Number)),
					};
					let belong_body = match nodes.get(belong_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(belong_body as usize)),
					};
					node.borrow_mut().belong = Some(belong_body.try_into()?);
				}
				let belong_struct_body = match raw_node.body.get("belong_struct") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"belong_struct")),
				};
 				if !belong_struct_body.is_null() {
					let belong_struct_body = match belong_struct_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(belong_struct_body.into(),JSONType::Number)),
					};
					let belong_struct_body = match nodes.get(belong_struct_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(belong_struct_body as usize)),
					};
					let belong_struct_body = match belong_struct_body {
						Node::StructType(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),belong_struct_body.into())),
					};
					node.borrow_mut().belong_struct = Some(Rc::downgrade(&belong_struct_body));
				}
				let ident_body = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"ident")),
				};
 				if !ident_body.is_null() {
					let ident_body = match ident_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(ident_body.into(),JSONType::Number)),
					};
					let ident_body = match nodes.get(ident_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(ident_body as usize)),
					};
					let ident_body = match ident_body {
						Node::Ident(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),ident_body.into())),
					};
					node.borrow_mut().ident = Some(ident_body.clone());
				}
				let parameters_body = match raw_node.body.get("parameters") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"parameters")),
				};
				let parameters_body = match parameters_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(parameters_body.into(),JSONType::Array)),
				};
				for link in parameters_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let parameters_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					let parameters_body = match parameters_body {
						Node::Field(body)=>body,
						x =>return Err(Error::MismatchNodeType(x.into(),parameters_body.into())),
					};
					node.borrow_mut().parameters.push(parameters_body.clone());
				}
				let return_type_body = match raw_node.body.get("return_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"return_type")),
				};
 				if !return_type_body.is_null() {
					let return_type_body = match return_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(return_type_body.into(),JSONType::Number)),
					};
					let return_type_body = match nodes.get(return_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(return_type_body as usize)),
					};
					node.borrow_mut().return_type = Some(return_type_body.try_into()?);
				}
				let body_body = match raw_node.body.get("body") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"body")),
				};
 				if !body_body.is_null() {
					let body_body = match body_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(body_body.into(),JSONType::Number)),
					};
					let body_body = match nodes.get(body_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(body_body as usize)),
					};
					let body_body = match body_body {
						Node::IndentBlock(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),body_body.into())),
					};
					node.borrow_mut().body = Some(body_body.clone());
				}
				let func_type_body = match raw_node.body.get("func_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"func_type")),
				};
 				if !func_type_body.is_null() {
					let func_type_body = match func_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(func_type_body.into(),JSONType::Number)),
					};
					let func_type_body = match nodes.get(func_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(func_type_body as usize)),
					};
					let func_type_body = match func_type_body {
						Node::FunctionType(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),func_type_body.into())),
					};
					node.borrow_mut().func_type = Some(func_type_body.clone());
				}
				let is_cast_body = match raw_node.body.get("is_cast") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"is_cast")),
				};
				node.borrow_mut().is_cast = match is_cast_body.as_bool() {
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(is_cast_body.into(),JSONType::Bool)),
				};
				let cast_loc_body = match raw_node.body.get("cast_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"cast_loc")),
				};
				node.borrow_mut().cast_loc = match serde_json::from_value(cast_loc_body.clone()) {
					Ok(v)=>v,
					Err(e)=>return Err(Error::JSONError(e)),
				};
			},
			NodeType::BuiltinFunction => {
				let node = nodes[i].clone();
				let node = match node {
					Node::BuiltinFunction(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let belong_body = match raw_node.body.get("belong") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"belong")),
				};
 				if !belong_body.is_null() {
					let belong_body = match belong_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(belong_body.into(),JSONType::Number)),
					};
					let belong_body = match nodes.get(belong_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(belong_body as usize)),
					};
					node.borrow_mut().belong = Some(belong_body.try_into()?);
				}
				let belong_struct_body = match raw_node.body.get("belong_struct") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"belong_struct")),
				};
 				if !belong_struct_body.is_null() {
					let belong_struct_body = match belong_struct_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(belong_struct_body.into(),JSONType::Number)),
					};
					let belong_struct_body = match nodes.get(belong_struct_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(belong_struct_body as usize)),
					};
					let belong_struct_body = match belong_struct_body {
						Node::StructType(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),belong_struct_body.into())),
					};
					node.borrow_mut().belong_struct = Some(Rc::downgrade(&belong_struct_body));
				}
				let ident_body = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"ident")),
				};
 				if !ident_body.is_null() {
					let ident_body = match ident_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(ident_body.into(),JSONType::Number)),
					};
					let ident_body = match nodes.get(ident_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(ident_body as usize)),
					};
					let ident_body = match ident_body {
						Node::Ident(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),ident_body.into())),
					};
					node.borrow_mut().ident = Some(ident_body.clone());
				}
				let func_type_body = match raw_node.body.get("func_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"func_type")),
				};
 				if !func_type_body.is_null() {
					let func_type_body = match func_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(func_type_body.into(),JSONType::Number)),
					};
					let func_type_body = match nodes.get(func_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(func_type_body as usize)),
					};
					let func_type_body = match func_type_body {
						Node::FunctionType(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),func_type_body.into())),
					};
					node.borrow_mut().func_type = Some(func_type_body.clone());
				}
			},
			NodeType::BuiltinField => {
				let node = nodes[i].clone();
				let node = match node {
					Node::BuiltinField(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let belong_body = match raw_node.body.get("belong") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"belong")),
				};
 				if !belong_body.is_null() {
					let belong_body = match belong_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(belong_body.into(),JSONType::Number)),
					};
					let belong_body = match nodes.get(belong_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(belong_body as usize)),
					};
					node.borrow_mut().belong = Some(belong_body.try_into()?);
				}
				let belong_struct_body = match raw_node.body.get("belong_struct") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"belong_struct")),
				};
 				if !belong_struct_body.is_null() {
					let belong_struct_body = match belong_struct_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(belong_struct_body.into(),JSONType::Number)),
					};
					let belong_struct_body = match nodes.get(belong_struct_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(belong_struct_body as usize)),
					};
					let belong_struct_body = match belong_struct_body {
						Node::StructType(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),belong_struct_body.into())),
					};
					node.borrow_mut().belong_struct = Some(Rc::downgrade(&belong_struct_body));
				}
				let ident_body = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"ident")),
				};
 				if !ident_body.is_null() {
					let ident_body = match ident_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(ident_body.into(),JSONType::Number)),
					};
					let ident_body = match nodes.get(ident_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(ident_body as usize)),
					};
					let ident_body = match ident_body {
						Node::Ident(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),ident_body.into())),
					};
					node.borrow_mut().ident = Some(ident_body.clone());
				}
				let field_type_body = match raw_node.body.get("field_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"field_type")),
				};
 				if !field_type_body.is_null() {
					let field_type_body = match field_type_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(field_type_body.into(),JSONType::Number)),
					};
					let field_type_body = match nodes.get(field_type_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(field_type_body as usize)),
					};
					node.borrow_mut().field_type = Some(field_type_body.try_into()?);
				}
			},
			NodeType::BuiltinObject => {
				let node = nodes[i].clone();
				let node = match node {
					Node::BuiltinObject(node)=>node,
					_=>return Err(Error::MismatchNodeType(node_type,node.into())),
				};
				let belong_body = match raw_node.body.get("belong") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"belong")),
				};
 				if !belong_body.is_null() {
					let belong_body = match belong_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(belong_body.into(),JSONType::Number)),
					};
					let belong_body = match nodes.get(belong_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(belong_body as usize)),
					};
					node.borrow_mut().belong = Some(belong_body.try_into()?);
				}
				let belong_struct_body = match raw_node.body.get("belong_struct") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"belong_struct")),
				};
 				if !belong_struct_body.is_null() {
					let belong_struct_body = match belong_struct_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(belong_struct_body.into(),JSONType::Number)),
					};
					let belong_struct_body = match nodes.get(belong_struct_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(belong_struct_body as usize)),
					};
					let belong_struct_body = match belong_struct_body {
						Node::StructType(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),belong_struct_body.into())),
					};
					node.borrow_mut().belong_struct = Some(Rc::downgrade(&belong_struct_body));
				}
				let ident_body = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"ident")),
				};
 				if !ident_body.is_null() {
					let ident_body = match ident_body.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(ident_body.into(),JSONType::Number)),
					};
					let ident_body = match nodes.get(ident_body as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(ident_body as usize)),
					};
					let ident_body = match ident_body {
						Node::Ident(node)=>node,
						x =>return Err(Error::MismatchNodeType(x.into(),ident_body.into())),
					};
					node.borrow_mut().ident = Some(ident_body.clone());
				}
				let members_body = match raw_node.body.get("members") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(node_type,"members")),
				};
				let members_body = match members_body.as_array(){
					Some(v)=>v,
					None=>return Err(Error::MismatchJSONType(members_body.into(),JSONType::Array)),
				};
				for link in members_body {
					let link = match link.as_u64() {
						Some(v)=>v,
						None=>return Err(Error::MismatchJSONType(link.into(),JSONType::Number)),
					};
					let members_body = match nodes.get(link as usize) {
						Some(v)=>v,
						None => return Err(Error::IndexOutOfBounds(link as usize)),
					};
					node.borrow_mut().members.push(members_body.try_into()?);
				}
			},
			_=>return Err(Error::UnknownNodeType(node_type)),
		};
	}
	for (i,raw_scope) in ast.scope.into_iter().enumerate(){
		let scope = scopes[i].clone();
		if let Some(owner) = raw_scope.owner {
			let owner = match nodes.get(owner as usize) {
				Some(v)=>v,
				None =>return Err(Error::IndexOutOfBounds(owner as usize)),
			};
			scope.borrow_mut().owner = Some(NodeWeak::from(owner));
		}
		if let Some(prev) = raw_scope.prev{
			let prev = match scopes.get(prev as usize) {
				Some(v)=>v,
				None =>return Err(Error::IndexOutOfBounds(prev as usize)),
			};
			scope.borrow_mut().prev = Some(Rc::downgrade(&prev));
		}
		if let Some(next) = raw_scope.next{
			let next = match scopes.get(next as usize) {
				Some(v)=>v,
				None =>return Err(Error::IndexOutOfBounds(next as usize)),
			};
			scope.borrow_mut().next = Some(next.clone());
		}
		if let Some(branch) = raw_scope.branch{
			let branch = match scopes.get(branch as usize) {
				Some(v)=>v,
				None =>return Err(Error::IndexOutOfBounds(branch as usize)),
			};
			scope.borrow_mut().branch = Some(branch.clone());
		}
		for ident in &raw_scope.ident{
			let ident = match nodes.get(*ident as usize) {
				Some(v)=>v,
				None =>return Err(Error::IndexOutOfBounds(*ident as usize)),
			};
 			let ident = match ident {
				Node::Ident(v)=> v,
				_=>return Err(Error::MismatchNodeType(NodeType::Ident,ident.into())),
			};
			scope.borrow_mut().ident.push(Rc::downgrade(ident));
		}
	}

	match nodes.get(0){
		Some(v)=> match v {
			Node::Program(v)=>Ok(v.clone()),
			_=> Err(Error::MismatchNodeType(NodeType::Program,v.into())),
		},
		None=>Err(Error::IndexOutOfBounds(0)),
	}
}

pub trait Visitor {
	fn visit(&self,node:&Node)->bool;
}

impl<F :Fn(&dyn Visitor,&Node)->bool> Visitor for F {
	fn visit(&self,node:&Node)->bool{
		self(self,node)
	}
}

pub fn walk_node<'a,F>(node:&Node,f:&'a F)
where
	F: Visitor+?Sized+'a
{
	match node {
		Node::Program(node)=>{
			if let Some(node) = &node.borrow().struct_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			for node in &node.borrow().elements{
				if !f.visit(node) {
					return;
				}
			}
		},
		Node::Comment(_)=>{},
		Node::CommentGroup(node)=>{
			for node in &node.borrow().comments{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::FieldArgument(node)=>{
			if let Some(node) = &node.borrow().raw_arguments{
				if !f.visit(&node.into()){
					return;
				}
			}
			for node in &node.borrow().arguments{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().alignment{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().sub_byte_length{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().sub_byte_begin{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::Binary(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().left{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().right{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::Unary(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().expr{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::Cond(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().cond{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().then{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().els{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::Ident(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::Call(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().callee{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().raw_arguments{
				if !f.visit(&node.into()){
					return;
				}
			}
			for node in &node.borrow().arguments{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::If(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().cond{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().then{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().els{
				if !f.visit(node) {
					return;
				}
			}
		},
		Node::MemberAccess(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().target{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().member{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::Paren(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().expr{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::Index(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().expr{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().index{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::Match(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().cond{
				if !f.visit(&node.into()){
					return;
				}
			}
			for node in &node.borrow().branch{
				if !f.visit(node) {
					return;
				}
			}
		},
		Node::Range(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().start{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().end{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::TmpVar(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::Import(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().base{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().import_desc{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::Cast(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().base{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().expr{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::Available(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().base{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().target{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::SpecifyOrder(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().base{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().order{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::ExplicitError(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().base{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().message{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::IoOperation(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().base{
				if !f.visit(&node.into()){
					return;
				}
			}
			for node in &node.borrow().arguments{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::Loop(node)=>{
			if let Some(node) = &node.borrow().init{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().cond{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().step{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().body{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::IndentBlock(node)=>{
			if let Some(node) = &node.borrow().struct_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			for node in &node.borrow().elements{
				if !f.visit(node) {
					return;
				}
			}
		},
		Node::ScopedStatement(node)=>{
			if let Some(node) = &node.borrow().struct_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().statement{
				if !f.visit(node) {
					return;
				}
			}
		},
		Node::MatchBranch(node)=>{
			if let Some(node) = &node.borrow().cond{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().then{
				if !f.visit(node) {
					return;
				}
			}
		},
		Node::UnionCandidate(_)=>{},
		Node::Return(node)=>{
			if let Some(node) = &node.borrow().expr{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::Break(_)=>{},
		Node::Continue(_)=>{},
		Node::Assert(node)=>{
			if let Some(node) = &node.borrow().cond{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::ImplicitYield(node)=>{
			if let Some(node) = &node.borrow().expr{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::IntType(_)=>{},
		Node::FloatType(_)=>{},
		Node::IdentType(node)=>{
			if let Some(node) = &node.borrow().ident{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::IntLiteralType(_)=>{},
		Node::StrLiteralType(node)=>{
			if let Some(node) = &node.borrow().strong_ref{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::VoidType(_)=>{},
		Node::BoolType(_)=>{},
		Node::ArrayType(node)=>{
			if let Some(node) = &node.borrow().base_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().length{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::FunctionType(node)=>{
			if let Some(node) = &node.borrow().return_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			for node in &node.borrow().parameters{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::StructType(node)=>{
			for node in &node.borrow().fields{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::StructUnionType(node)=>{
			for node in &node.borrow().structs{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::UnionType(node)=>{
			for node in &node.borrow().candidates{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().common_type{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::RangeType(node)=>{
			if let Some(node) = &node.borrow().base_type{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::EnumType(_)=>{},
		Node::MetaType(_)=>{},
		Node::OptionalType(node)=>{
			if let Some(node) = &node.borrow().base_type{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::IntLiteral(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::BoolLiteral(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::StrLiteral(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::TypeLiteral(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().type_literal{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::SpecialLiteral(node)=>{
			if let Some(node) = &node.borrow().expr_type{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::Field(node)=>{
			if let Some(node) = &node.borrow().ident{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().field_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().arguments{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::Format(node)=>{
			if let Some(node) = &node.borrow().ident{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().body{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::State(node)=>{
			if let Some(node) = &node.borrow().ident{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().body{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::Enum(node)=>{
			if let Some(node) = &node.borrow().ident{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().base_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			for node in &node.borrow().members{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().enum_type{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::EnumMember(node)=>{
			if let Some(node) = &node.borrow().ident{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().expr{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::Function(node)=>{
			if let Some(node) = &node.borrow().ident{
				if !f.visit(&node.into()){
					return;
				}
			}
			for node in &node.borrow().parameters{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().return_type{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().body{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().func_type{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::BuiltinFunction(node)=>{
			if let Some(node) = &node.borrow().ident{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().func_type{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::BuiltinField(node)=>{
			if let Some(node) = &node.borrow().ident{
				if !f.visit(&node.into()){
					return;
				}
			}
			if let Some(node) = &node.borrow().field_type{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
		Node::BuiltinObject(node)=>{
			if let Some(node) = &node.borrow().ident{
				if !f.visit(&node.into()){
					return;
				}
			}
			for node in &node.borrow().members{
				if !f.visit(&node.into()){
					return;
				}
			}
		},
	}
}

