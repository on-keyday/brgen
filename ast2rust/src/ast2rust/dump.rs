// Code generated by ast2rust. DO NOT EDIT.
use std::rc::{Rc,Weak};
use std::cell::RefCell;
use std::convert::TryFrom;
use serde_derive::{Serialize,Deserialize};

use std::collections::HashMap;

pub enum Error {
	UnknownNodeType(NodeType),
	MismatchNodeType(NodeType,NodeType),
	JSONError(serde_json::Error),
	MissingField(NodeType,&'static str),
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case",untagged)]
pub enum NodeType {
	Node,
	Program,
	Expr,
	Binary,
	Unary,
	Cond,
	Ident,
	Call,
	If,
	MemberAccess,
	Paren,
	Index,
	Match,
	Range,
	TmpVar,
	BlockExpr,
	Import,
	Literal,
	IntLiteral,
	BoolLiteral,
	StrLiteral,
	Input,
	Output,
	Config,
	Stmt,
	Loop,
	IndentScope,
	MatchBranch,
	Return,
	Break,
	Continue,
	Assert,
	ImplicitYield,
	Member,
	Field,
	Format,
	Function,
	Type,
	IntType,
	IdentType,
	IntLiteralType,
	StrLiteralType,
	VoidType,
	BoolType,
	ArrayType,
	FunctionType,
	StructType,
	UnionType,
	Cast,
}

impl TryFrom<&str> for NodeType {
	type Error = ();
	fn try_from(s:&str)->Result<Self,Self::Error>{
		match s{
			"node" =>Ok(Self::Node),
			"program" =>Ok(Self::Program),
			"expr" =>Ok(Self::Expr),
			"binary" =>Ok(Self::Binary),
			"unary" =>Ok(Self::Unary),
			"cond" =>Ok(Self::Cond),
			"ident" =>Ok(Self::Ident),
			"call" =>Ok(Self::Call),
			"if" =>Ok(Self::If),
			"member_access" =>Ok(Self::MemberAccess),
			"paren" =>Ok(Self::Paren),
			"index" =>Ok(Self::Index),
			"match" =>Ok(Self::Match),
			"range" =>Ok(Self::Range),
			"tmp_var" =>Ok(Self::TmpVar),
			"block_expr" =>Ok(Self::BlockExpr),
			"import" =>Ok(Self::Import),
			"literal" =>Ok(Self::Literal),
			"int_literal" =>Ok(Self::IntLiteral),
			"bool_literal" =>Ok(Self::BoolLiteral),
			"str_literal" =>Ok(Self::StrLiteral),
			"input" =>Ok(Self::Input),
			"output" =>Ok(Self::Output),
			"config" =>Ok(Self::Config),
			"stmt" =>Ok(Self::Stmt),
			"loop" =>Ok(Self::Loop),
			"indent_scope" =>Ok(Self::IndentScope),
			"match_branch" =>Ok(Self::MatchBranch),
			"return" =>Ok(Self::Return),
			"break" =>Ok(Self::Break),
			"continue" =>Ok(Self::Continue),
			"assert" =>Ok(Self::Assert),
			"implicit_yield" =>Ok(Self::ImplicitYield),
			"member" =>Ok(Self::Member),
			"field" =>Ok(Self::Field),
			"format" =>Ok(Self::Format),
			"function" =>Ok(Self::Function),
			"type" =>Ok(Self::Type),
			"int_type" =>Ok(Self::IntType),
			"ident_type" =>Ok(Self::IdentType),
			"int_literal_type" =>Ok(Self::IntLiteralType),
			"str_literal_type" =>Ok(Self::StrLiteralType),
			"void_type" =>Ok(Self::VoidType),
			"bool_type" =>Ok(Self::BoolType),
			"array_type" =>Ok(Self::ArrayType),
			"function_type" =>Ok(Self::FunctionType),
			"struct_type" =>Ok(Self::StructType),
			"union_type" =>Ok(Self::UnionType),
			"cast" =>Ok(Self::Cast),
			_=> Err(()),
		}
	}
}

impl TryFrom<&Node> for NodeType {
	type Error = ();
	fn try_from(node:&Node)->Result<Self,Self::Error>{
		match node {
			Node::Node(_) =>Ok(Self::Node),
			Node::Program(_) =>Ok(Self::Program),
			Node::Expr(_) =>Ok(Self::Expr),
			Node::Binary(_) =>Ok(Self::Binary),
			Node::Unary(_) =>Ok(Self::Unary),
			Node::Cond(_) =>Ok(Self::Cond),
			Node::Ident(_) =>Ok(Self::Ident),
			Node::Call(_) =>Ok(Self::Call),
			Node::If(_) =>Ok(Self::If),
			Node::MemberAccess(_) =>Ok(Self::MemberAccess),
			Node::Paren(_) =>Ok(Self::Paren),
			Node::Index(_) =>Ok(Self::Index),
			Node::Match(_) =>Ok(Self::Match),
			Node::Range(_) =>Ok(Self::Range),
			Node::TmpVar(_) =>Ok(Self::TmpVar),
			Node::BlockExpr(_) =>Ok(Self::BlockExpr),
			Node::Import(_) =>Ok(Self::Import),
			Node::Literal(_) =>Ok(Self::Literal),
			Node::IntLiteral(_) =>Ok(Self::IntLiteral),
			Node::BoolLiteral(_) =>Ok(Self::BoolLiteral),
			Node::StrLiteral(_) =>Ok(Self::StrLiteral),
			Node::Input(_) =>Ok(Self::Input),
			Node::Output(_) =>Ok(Self::Output),
			Node::Config(_) =>Ok(Self::Config),
			Node::Stmt(_) =>Ok(Self::Stmt),
			Node::Loop(_) =>Ok(Self::Loop),
			Node::IndentScope(_) =>Ok(Self::IndentScope),
			Node::MatchBranch(_) =>Ok(Self::MatchBranch),
			Node::Return(_) =>Ok(Self::Return),
			Node::Break(_) =>Ok(Self::Break),
			Node::Continue(_) =>Ok(Self::Continue),
			Node::Assert(_) =>Ok(Self::Assert),
			Node::ImplicitYield(_) =>Ok(Self::ImplicitYield),
			Node::Member(_) =>Ok(Self::Member),
			Node::Field(_) =>Ok(Self::Field),
			Node::Format(_) =>Ok(Self::Format),
			Node::Function(_) =>Ok(Self::Function),
			Node::Type(_) =>Ok(Self::Type),
			Node::IntType(_) =>Ok(Self::IntType),
			Node::IdentType(_) =>Ok(Self::IdentType),
			Node::IntLiteralType(_) =>Ok(Self::IntLiteralType),
			Node::StrLiteralType(_) =>Ok(Self::StrLiteralType),
			Node::VoidType(_) =>Ok(Self::VoidType),
			Node::BoolType(_) =>Ok(Self::BoolType),
			Node::ArrayType(_) =>Ok(Self::ArrayType),
			Node::FunctionType(_) =>Ok(Self::FunctionType),
			Node::StructType(_) =>Ok(Self::StructType),
			Node::UnionType(_) =>Ok(Self::UnionType),
			Node::Cast(_) =>Ok(Self::Cast),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone)]
pub enum Node {
	Program(Rc<RefCell<Program>>),
	Binary(Rc<RefCell<Binary>>),
	Unary(Rc<RefCell<Unary>>),
	Cond(Rc<RefCell<Cond>>),
	Ident(Rc<RefCell<Ident>>),
	Call(Rc<RefCell<Call>>),
	If(Rc<RefCell<If>>),
	MemberAccess(Rc<RefCell<MemberAccess>>),
	Paren(Rc<RefCell<Paren>>),
	Index(Rc<RefCell<Index>>),
	Match(Rc<RefCell<Match>>),
	Range(Rc<RefCell<Range>>),
	TmpVar(Rc<RefCell<TmpVar>>),
	BlockExpr(Rc<RefCell<BlockExpr>>),
	Import(Rc<RefCell<Import>>),
	IntLiteral(Rc<RefCell<IntLiteral>>),
	BoolLiteral(Rc<RefCell<BoolLiteral>>),
	StrLiteral(Rc<RefCell<StrLiteral>>),
	Input(Rc<RefCell<Input>>),
	Output(Rc<RefCell<Output>>),
	Config(Rc<RefCell<Config>>),
	Loop(Rc<RefCell<Loop>>),
	IndentScope(Rc<RefCell<IndentScope>>),
	MatchBranch(Rc<RefCell<MatchBranch>>),
	Return(Rc<RefCell<Return>>),
	Break(Rc<RefCell<Break>>),
	Continue(Rc<RefCell<Continue>>),
	Assert(Rc<RefCell<Assert>>),
	ImplicitYield(Rc<RefCell<ImplicitYield>>),
	Field(Rc<RefCell<Field>>),
	Format(Rc<RefCell<Format>>),
	Function(Rc<RefCell<Function>>),
	IntType(Rc<RefCell<IntType>>),
	IdentType(Rc<RefCell<IdentType>>),
	IntLiteralType(Rc<RefCell<IntLiteralType>>),
	StrLiteralType(Rc<RefCell<StrLiteralType>>),
	VoidType(Rc<RefCell<VoidType>>),
	BoolType(Rc<RefCell<BoolType>>),
	ArrayType(Rc<RefCell<ArrayType>>),
	FunctionType(Rc<RefCell<FunctionType>>),
	StructType(Rc<RefCell<StructType>>),
	UnionType(Rc<RefCell<UnionType>>),
	Cast(Rc<RefCell<Cast>>),
}

#[derive(Debug,Clone)]
pub enum Expr {
	Binary(Rc<RefCell<Binary>>),
	Unary(Rc<RefCell<Unary>>),
	Cond(Rc<RefCell<Cond>>),
	Ident(Rc<RefCell<Ident>>),
	Call(Rc<RefCell<Call>>),
	If(Rc<RefCell<If>>),
	MemberAccess(Rc<RefCell<MemberAccess>>),
	Paren(Rc<RefCell<Paren>>),
	Index(Rc<RefCell<Index>>),
	Match(Rc<RefCell<Match>>),
	Range(Rc<RefCell<Range>>),
	TmpVar(Rc<RefCell<TmpVar>>),
	BlockExpr(Rc<RefCell<BlockExpr>>),
	Import(Rc<RefCell<Import>>),
	IntLiteral(Rc<RefCell<IntLiteral>>),
	BoolLiteral(Rc<RefCell<BoolLiteral>>),
	StrLiteral(Rc<RefCell<StrLiteral>>),
	Input(Rc<RefCell<Input>>),
	Output(Rc<RefCell<Output>>),
	Config(Rc<RefCell<Config>>),
	Cast(Rc<RefCell<Cast>>),
}

#[derive(Debug,Clone)]
pub enum Literal {
	IntLiteral(Rc<RefCell<IntLiteral>>),
	BoolLiteral(Rc<RefCell<BoolLiteral>>),
	StrLiteral(Rc<RefCell<StrLiteral>>),
	Input(Rc<RefCell<Input>>),
	Output(Rc<RefCell<Output>>),
	Config(Rc<RefCell<Config>>),
}

#[derive(Debug,Clone)]
pub enum Stmt {
	Loop(Rc<RefCell<Loop>>),
	IndentScope(Rc<RefCell<IndentScope>>),
	MatchBranch(Rc<RefCell<MatchBranch>>),
	Return(Rc<RefCell<Return>>),
	Break(Rc<RefCell<Break>>),
	Continue(Rc<RefCell<Continue>>),
	Assert(Rc<RefCell<Assert>>),
	ImplicitYield(Rc<RefCell<ImplicitYield>>),
	Field(Rc<RefCell<Field>>),
	Format(Rc<RefCell<Format>>),
	Function(Rc<RefCell<Function>>),
}

#[derive(Debug,Clone)]
pub enum Member {
	Field(Rc<RefCell<Field>>),
	Format(Rc<RefCell<Format>>),
	Function(Rc<RefCell<Function>>),
}

#[derive(Debug,Clone)]
pub enum Type {
	IntType(Rc<RefCell<IntType>>),
	IdentType(Rc<RefCell<IdentType>>),
	IntLiteralType(Rc<RefCell<IntLiteralType>>),
	StrLiteralType(Rc<RefCell<StrLiteralType>>),
	VoidType(Rc<RefCell<VoidType>>),
	BoolType(Rc<RefCell<BoolType>>),
	ArrayType(Rc<RefCell<ArrayType>>),
	FunctionType(Rc<RefCell<FunctionType>>),
	StructType(Rc<RefCell<StructType>>),
	UnionType(Rc<RefCell<UnionType>>),
}

#[derive(Debug,Clone)]
pub struct Program {
	pub struct_type: Option<Rc<RefCell<StructType>>>,
	pub elements: Vec<Option<Node>>,
	pub global_scope: Option<Rc<RefCell<Scope>>>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Binary {
	pub expr_type: Option<Type>,
	pub op: BinaryOp,
	pub left: Option<Expr>,
	pub right: Option<Expr>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Unary {
	pub expr_type: Option<Type>,
	pub op: UnaryOp,
	pub expr: Option<Expr>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Cond {
	pub expr_type: Option<Type>,
	pub cond: Option<Expr>,
	pub then: Option<Expr>,
	pub els_loc: Loc,
	pub els: Option<Expr>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Ident {
	pub expr_type: Option<Type>,
	pub ident: String,
	pub usage: IdentUsage,
	pub base: Option<Node>,
	pub scope: Option<Rc<RefCell<Scope>>>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Call {
	pub expr_type: Option<Type>,
	pub callee: Option<Expr>,
	pub raw_arguments: Option<Expr>,
	pub arguments: Vec<Option<Expr>>,
	pub end_loc: Loc,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct If {
	pub expr_type: Option<Type>,
	pub cond: Option<Expr>,
	pub then: Option<Rc<RefCell<IndentScope>>>,
	pub els: Option<Node>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct MemberAccess {
	pub expr_type: Option<Type>,
	pub target: Option<Expr>,
	pub member: String,
	pub member_loc: Loc,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Paren {
	pub expr_type: Option<Type>,
	pub expr: Option<Expr>,
	pub end_loc: Loc,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Index {
	pub expr_type: Option<Type>,
	pub expr: Option<Expr>,
	pub index: Option<Expr>,
	pub end_loc: Loc,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Match {
	pub expr_type: Option<Type>,
	pub cond: Option<Expr>,
	pub branch: Vec<Option<Rc<RefCell<MatchBranch>>>>,
	pub scope: Option<Rc<RefCell<Scope>>>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Range {
	pub expr_type: Option<Type>,
	pub op: BinaryOp,
	pub start: Option<Expr>,
	pub end: Option<Expr>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct TmpVar {
	pub expr_type: Option<Type>,
	pub tmp_var: u64,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct BlockExpr {
	pub expr_type: Option<Type>,
	pub calls: Vec<Option<Node>>,
	pub expr: Option<Expr>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Import {
	pub expr_type: Option<Type>,
	pub path: String,
	pub base: Option<Rc<RefCell<Call>>>,
	pub import_desc: Option<Rc<RefCell<Program>>>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct IntLiteral {
	pub expr_type: Option<Type>,
	pub value: String,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct BoolLiteral {
	pub expr_type: Option<Type>,
	pub value: bool,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct StrLiteral {
	pub expr_type: Option<Type>,
	pub value: String,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Input {
	pub expr_type: Option<Type>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Output {
	pub expr_type: Option<Type>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Config {
	pub expr_type: Option<Type>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Loop {
	pub init: Option<Expr>,
	pub cond: Option<Expr>,
	pub step: Option<Expr>,
	pub body: Option<Rc<RefCell<IndentScope>>>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct IndentScope {
	pub elements: Vec<Option<Node>>,
	pub scope: Option<Rc<RefCell<Scope>>>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct MatchBranch {
	pub cond: Option<Expr>,
	pub sym_loc: Loc,
	pub then: Option<Node>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Return {
	pub expr: Option<Expr>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Break {
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Continue {
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Assert {
	pub cond: Option<Rc<RefCell<Binary>>>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct ImplicitYield {
	pub expr: Option<Expr>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Field {
	pub ident: Option<Rc<RefCell<Ident>>>,
	pub colon_loc: Loc,
	pub field_type: Option<Type>,
	pub raw_arguments: Option<Expr>,
	pub arguments: Vec<Option<Expr>>,
	pub belong: Option<Weak<RefCell<Format>>>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Format {
	pub is_enum: bool,
	pub ident: Option<Rc<RefCell<Ident>>>,
	pub body: Option<Rc<RefCell<IndentScope>>>,
	pub belong: Option<Weak<RefCell<Format>>>,
	pub struct_type: Option<Rc<RefCell<StructType>>>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Function {
	pub ident: Option<Rc<RefCell<Ident>>>,
	pub parameters: Vec<Option<Rc<RefCell<Field>>>>,
	pub return_type: Option<Type>,
	pub belong: Option<Weak<RefCell<Format>>>,
	pub body: Option<Rc<RefCell<IndentScope>>>,
	pub func_type: Option<Rc<RefCell<FunctionType>>>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct IntType {
	pub bit_size: u64,
	pub endian: Endian,
	pub is_signed: bool,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct IdentType {
	pub ident: Option<Rc<RefCell<Ident>>>,
	pub base: Option<Weak<RefCell<Format>>>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct IntLiteralType {
	pub base: Option<Weak<RefCell<IntLiteral>>>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct StrLiteralType {
	pub base: Option<Weak<RefCell<StrLiteral>>>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct VoidType {
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct BoolType {
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct ArrayType {
	pub end_loc: Loc,
	pub base_type: Option<Type>,
	pub length: Option<Expr>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct FunctionType {
	pub return_type: Option<Type>,
	pub parameters: Vec<Option<Type>>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct StructType {
	pub fields: Vec<Option<Member>>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct UnionType {
	pub fields: Vec<Option<Rc<RefCell<StructType>>>>,
	pub loc: Loc,
}

#[derive(Debug,Clone)]
pub struct Cast {
	pub expr_type: Option<Type>,
	pub base: Option<Rc<RefCell<Call>>>,
	pub expr: Option<Expr>,
	pub loc: Loc,
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case",untagged)]
pub enum UnaryOp {
	Not,
	MinusSign,
}

impl TryFrom<&str> for UnaryOp {
	type Error = ();
	fn try_from(s:&str)->Result<Self,Self::Error>{
		match s{
			"!" =>Ok(Self::Not),
			"-" =>Ok(Self::MinusSign),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case",untagged)]
pub enum BinaryOp {
	Mul,
	Div,
	Mod,
	LeftArithmeticShift,
	RightArithmeticShift,
	LeftLogicalShift,
	RightLogicalShift,
	BitAnd,
	Add,
	Sub,
	BitOr,
	BitXor,
	Equal,
	NotEqual,
	Less,
	LessOrEq,
	Grater,
	GraterOrEq,
	LogicalAnd,
	LogicalOr,
	CondOp1,
	CondOp2,
	RangeExclusive,
	RangeInclusive,
	Assign,
	DefineAssign,
	ConstAssign,
	AddAssign,
	SubAssign,
	MulAssign,
	DivAssign,
	ModAssign,
	LeftShiftAssign,
	RightShiftAssign,
	BitAndAssign,
	BitOrAssign,
	BitXorAssign,
	Comma,
}

impl TryFrom<&str> for BinaryOp {
	type Error = ();
	fn try_from(s:&str)->Result<Self,Self::Error>{
		match s{
			"*" =>Ok(Self::Mul),
			"/" =>Ok(Self::Div),
			"%" =>Ok(Self::Mod),
			"<<<" =>Ok(Self::LeftArithmeticShift),
			">>>" =>Ok(Self::RightArithmeticShift),
			"<<" =>Ok(Self::LeftLogicalShift),
			">>" =>Ok(Self::RightLogicalShift),
			"&" =>Ok(Self::BitAnd),
			"+" =>Ok(Self::Add),
			"-" =>Ok(Self::Sub),
			"|" =>Ok(Self::BitOr),
			"^" =>Ok(Self::BitXor),
			"==" =>Ok(Self::Equal),
			"!=" =>Ok(Self::NotEqual),
			"<" =>Ok(Self::Less),
			"<=" =>Ok(Self::LessOrEq),
			">" =>Ok(Self::Grater),
			">=" =>Ok(Self::GraterOrEq),
			"&&" =>Ok(Self::LogicalAnd),
			"||" =>Ok(Self::LogicalOr),
			"if" =>Ok(Self::CondOp1),
			"else" =>Ok(Self::CondOp2),
			".." =>Ok(Self::RangeExclusive),
			"..=" =>Ok(Self::RangeInclusive),
			"=" =>Ok(Self::Assign),
			":=" =>Ok(Self::DefineAssign),
			"::=" =>Ok(Self::ConstAssign),
			"+=" =>Ok(Self::AddAssign),
			"-=" =>Ok(Self::SubAssign),
			"*=" =>Ok(Self::MulAssign),
			"/=" =>Ok(Self::DivAssign),
			"%=" =>Ok(Self::ModAssign),
			"<<=" =>Ok(Self::LeftShiftAssign),
			">>=" =>Ok(Self::RightShiftAssign),
			"&=" =>Ok(Self::BitAndAssign),
			"|=" =>Ok(Self::BitOrAssign),
			"^=" =>Ok(Self::BitXorAssign),
			"," =>Ok(Self::Comma),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case",untagged)]
pub enum IdentUsage {
	Unknown,
	Reference,
	DefineVariable,
	DefineConst,
	DefineField,
	DefineFormat,
	DefineFn,
	ReferenceType,
}

impl TryFrom<&str> for IdentUsage {
	type Error = ();
	fn try_from(s:&str)->Result<Self,Self::Error>{
		match s{
			"unknown" =>Ok(Self::Unknown),
			"reference" =>Ok(Self::Reference),
			"define_variable" =>Ok(Self::DefineVariable),
			"define_const" =>Ok(Self::DefineConst),
			"define_field" =>Ok(Self::DefineField),
			"define_format" =>Ok(Self::DefineFormat),
			"define_fn" =>Ok(Self::DefineFn),
			"reference_type" =>Ok(Self::ReferenceType),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
#[serde(rename_all = "snake_case",untagged)]
pub enum Endian {
	Unspec,
	Big,
	Little,
}

impl TryFrom<&str> for Endian {
	type Error = ();
	fn try_from(s:&str)->Result<Self,Self::Error>{
		match s{
			"unspec" =>Ok(Self::Unspec),
			"big" =>Ok(Self::Big),
			"little" =>Ok(Self::Little),
			_=> Err(()),
		}
	}
}

#[derive(Debug,Clone)]
pub struct Scope {
	pub prev: Option<Weak<RefCell<Scope>>>,
	pub next: Option<Rc<RefCell<Scope>>>,
	pub branch: Option<Rc<RefCell<Scope>>>,
	pub ident: Vec<Option<Node>>,
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
pub struct Loc {
	pub pos: Pos,
	pub file: u64,
	pub line: u64,
	pub col: u64,
}

#[derive(Debug,Clone,Copy,Serialize,Deserialize)]
pub struct Pos {
	pub begin: u64,
	pub end: u64,
}

#[derive(Debug,Clone,Serialize,Deserialize)]
pub struct RawNode {
	pub node_type: NodeType,
	pub loc :Loc,
	pub body: HashMap<String,serde_json::Value>,
}

#[derive(Debug,Clone,Serialize,Deserialize)]
pub struct RawScope {
	pub prev :Option<u64>,
	pub next :Option<u64>,
	pub branch :Option<u64>,
	pub ident :Vec<u64>,
}

#[derive(Debug,Clone,Serialize,Deserialize)]
pub struct AST {
	pub node: Vec<RawNode>,
	pub scope: Vec<RawScope>,
}

pub fn parse_ast(ast:AST)->Result<Rc<RefCell<Program>> ,Error>{
	let mut nodes = Vec::new();
	let mut scopes = Vec::new();
	for raw_node in &ast.node{
		let node = match raw_node.node_type {
			NodeType::Program => {
				Node::Program(Rc::new(RefCell::new(Program {
				struct_type: None,
				elements: Vec::new(),
				global_scope: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Binary => {
				Node::Binary(Rc::new(RefCell::new(Binary {
				expr_type: None,
				op: BinaryOp::Mul,
				left: None,
				right: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Unary => {
				Node::Unary(Rc::new(RefCell::new(Unary {
				expr_type: None,
				op: UnaryOp::Not,
				expr: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Cond => {
				Node::Cond(Rc::new(RefCell::new(Cond {
				expr_type: None,
				cond: None,
				then: None,
				els_loc: raw_node.loc.clone(),
				els: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Ident => {
				Node::Ident(Rc::new(RefCell::new(Ident {
				expr_type: None,
				ident: String::new(),
				usage: IdentUsage::Unknown,
				base: None,
				scope: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Call => {
				Node::Call(Rc::new(RefCell::new(Call {
				expr_type: None,
				callee: None,
				raw_arguments: None,
				arguments: Vec::new(),
				end_loc: raw_node.loc.clone(),
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::If => {
				Node::If(Rc::new(RefCell::new(If {
				expr_type: None,
				cond: None,
				then: None,
				els: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::MemberAccess => {
				Node::MemberAccess(Rc::new(RefCell::new(MemberAccess {
				expr_type: None,
				target: None,
				member: String::new(),
				member_loc: raw_node.loc.clone(),
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Paren => {
				Node::Paren(Rc::new(RefCell::new(Paren {
				expr_type: None,
				expr: None,
				end_loc: raw_node.loc.clone(),
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Index => {
				Node::Index(Rc::new(RefCell::new(Index {
				expr_type: None,
				expr: None,
				index: None,
				end_loc: raw_node.loc.clone(),
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Match => {
				Node::Match(Rc::new(RefCell::new(Match {
				expr_type: None,
				cond: None,
				branch: Vec::new(),
				scope: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Range => {
				Node::Range(Rc::new(RefCell::new(Range {
				expr_type: None,
				op: BinaryOp::Mul,
				start: None,
				end: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::TmpVar => {
				Node::TmpVar(Rc::new(RefCell::new(TmpVar {
				expr_type: None,
				tmp_var: 0,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::BlockExpr => {
				Node::BlockExpr(Rc::new(RefCell::new(BlockExpr {
				expr_type: None,
				calls: Vec::new(),
				expr: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Import => {
				Node::Import(Rc::new(RefCell::new(Import {
				expr_type: None,
				path: String::new(),
				base: None,
				import_desc: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::IntLiteral => {
				Node::IntLiteral(Rc::new(RefCell::new(IntLiteral {
				expr_type: None,
				value: String::new(),
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::BoolLiteral => {
				Node::BoolLiteral(Rc::new(RefCell::new(BoolLiteral {
				expr_type: None,
				value: false,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::StrLiteral => {
				Node::StrLiteral(Rc::new(RefCell::new(StrLiteral {
				expr_type: None,
				value: String::new(),
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Input => {
				Node::Input(Rc::new(RefCell::new(Input {
				expr_type: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Output => {
				Node::Output(Rc::new(RefCell::new(Output {
				expr_type: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Config => {
				Node::Config(Rc::new(RefCell::new(Config {
				expr_type: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Loop => {
				Node::Loop(Rc::new(RefCell::new(Loop {
				init: None,
				cond: None,
				step: None,
				body: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::IndentScope => {
				Node::IndentScope(Rc::new(RefCell::new(IndentScope {
				elements: Vec::new(),
				scope: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::MatchBranch => {
				Node::MatchBranch(Rc::new(RefCell::new(MatchBranch {
				cond: None,
				sym_loc: raw_node.loc.clone(),
				then: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Return => {
				Node::Return(Rc::new(RefCell::new(Return {
				expr: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Break => {
				Node::Break(Rc::new(RefCell::new(Break {
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Continue => {
				Node::Continue(Rc::new(RefCell::new(Continue {
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Assert => {
				Node::Assert(Rc::new(RefCell::new(Assert {
				cond: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::ImplicitYield => {
				Node::ImplicitYield(Rc::new(RefCell::new(ImplicitYield {
				expr: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Field => {
				Node::Field(Rc::new(RefCell::new(Field {
				ident: None,
				colon_loc: raw_node.loc.clone(),
				field_type: None,
				raw_arguments: None,
				arguments: Vec::new(),
				belong: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Format => {
				Node::Format(Rc::new(RefCell::new(Format {
				is_enum: false,
				ident: None,
				body: None,
				belong: None,
				struct_type: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Function => {
				Node::Function(Rc::new(RefCell::new(Function {
				ident: None,
				parameters: Vec::new(),
				return_type: None,
				belong: None,
				body: None,
				func_type: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::IntType => {
				Node::IntType(Rc::new(RefCell::new(IntType {
				bit_size: 0,
				endian: Endian::Unspec,
				is_signed: false,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::IdentType => {
				Node::IdentType(Rc::new(RefCell::new(IdentType {
				ident: None,
				base: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::IntLiteralType => {
				Node::IntLiteralType(Rc::new(RefCell::new(IntLiteralType {
				base: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::StrLiteralType => {
				Node::StrLiteralType(Rc::new(RefCell::new(StrLiteralType {
				base: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::VoidType => {
				Node::VoidType(Rc::new(RefCell::new(VoidType {
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::BoolType => {
				Node::BoolType(Rc::new(RefCell::new(BoolType {
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::ArrayType => {
				Node::ArrayType(Rc::new(RefCell::new(ArrayType {
				end_loc: raw_node.loc.clone(),
				base_type: None,
				length: None,
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::FunctionType => {
				Node::FunctionType(Rc::new(RefCell::new(FunctionType {
				return_type: None,
				parameters: Vec::new(),
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::StructType => {
				Node::StructType(Rc::new(RefCell::new(StructType {
				fields: Vec::new(),
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::UnionType => {
				Node::UnionType(Rc::new(RefCell::new(UnionType {
				fields: Vec::new(),
				loc: raw_node.loc.clone(),
				})))
			},
			NodeType::Cast => {
				Node::Cast(Rc::new(RefCell::new(Cast {
				expr_type: None,
				base: None,
				expr: None,
				loc: raw_node.loc.clone(),
				})))
			},
			_=>return Err(Error::UnknownNodeType(raw_node.node_type)),
		};
		nodes.push(node);
	}
	for raw_scope in &ast.scope{
		let scope = Scope{
			prev: None,
			next: None,
			branch: None,
			ident: Vec::new(),
		};
		scopes.push(scope);
	}
	for (i,raw_node) in ast.node.into_iter().enumerate(){
		match raw_node.node_type {
			NodeType::Program => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Program(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let struct_typebody = match raw_node.body.get("struct_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"struct_type")),
				};
				let elementsbody = match raw_node.body.get("elements") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"elements")),
				};
				let global_scopebody = match raw_node.body.get("global_scope") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"global_scope")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Binary => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Binary(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let opbody = match raw_node.body.get("op") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"op")),
				};
				let leftbody = match raw_node.body.get("left") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"left")),
				};
				let rightbody = match raw_node.body.get("right") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"right")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Unary => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Unary(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let opbody = match raw_node.body.get("op") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"op")),
				};
				let exprbody = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Cond => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Cond(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let condbody = match raw_node.body.get("cond") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"cond")),
				};
				let thenbody = match raw_node.body.get("then") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"then")),
				};
				let els_locbody = match raw_node.body.get("els_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"els_loc")),
				};
				let elsbody = match raw_node.body.get("els") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"els")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Ident => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Ident(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let identbody = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"ident")),
				};
				let usagebody = match raw_node.body.get("usage") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"usage")),
				};
				let basebody = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"base")),
				};
				let scopebody = match raw_node.body.get("scope") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"scope")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Call => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Call(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let calleebody = match raw_node.body.get("callee") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"callee")),
				};
				let raw_argumentsbody = match raw_node.body.get("raw_arguments") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"raw_arguments")),
				};
				let argumentsbody = match raw_node.body.get("arguments") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"arguments")),
				};
				let end_locbody = match raw_node.body.get("end_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"end_loc")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::If => {
				let node = nodes[i].clone();
				let node = match node {
					Node::If(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let condbody = match raw_node.body.get("cond") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"cond")),
				};
				let thenbody = match raw_node.body.get("then") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"then")),
				};
				let elsbody = match raw_node.body.get("els") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"els")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::MemberAccess => {
				let node = nodes[i].clone();
				let node = match node {
					Node::MemberAccess(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let targetbody = match raw_node.body.get("target") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"target")),
				};
				let memberbody = match raw_node.body.get("member") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"member")),
				};
				let member_locbody = match raw_node.body.get("member_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"member_loc")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Paren => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Paren(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let exprbody = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr")),
				};
				let end_locbody = match raw_node.body.get("end_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"end_loc")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Index => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Index(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let exprbody = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr")),
				};
				let indexbody = match raw_node.body.get("index") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"index")),
				};
				let end_locbody = match raw_node.body.get("end_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"end_loc")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Match => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Match(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let condbody = match raw_node.body.get("cond") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"cond")),
				};
				let branchbody = match raw_node.body.get("branch") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"branch")),
				};
				let scopebody = match raw_node.body.get("scope") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"scope")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Range => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Range(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let opbody = match raw_node.body.get("op") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"op")),
				};
				let startbody = match raw_node.body.get("start") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"start")),
				};
				let endbody = match raw_node.body.get("end") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"end")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::TmpVar => {
				let node = nodes[i].clone();
				let node = match node {
					Node::TmpVar(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let tmp_varbody = match raw_node.body.get("tmp_var") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"tmp_var")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::BlockExpr => {
				let node = nodes[i].clone();
				let node = match node {
					Node::BlockExpr(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let callsbody = match raw_node.body.get("calls") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"calls")),
				};
				let exprbody = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Import => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Import(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let pathbody = match raw_node.body.get("path") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"path")),
				};
				let basebody = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"base")),
				};
				let import_descbody = match raw_node.body.get("import_desc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"import_desc")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::IntLiteral => {
				let node = nodes[i].clone();
				let node = match node {
					Node::IntLiteral(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let valuebody = match raw_node.body.get("value") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"value")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::BoolLiteral => {
				let node = nodes[i].clone();
				let node = match node {
					Node::BoolLiteral(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let valuebody = match raw_node.body.get("value") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"value")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::StrLiteral => {
				let node = nodes[i].clone();
				let node = match node {
					Node::StrLiteral(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let valuebody = match raw_node.body.get("value") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"value")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Input => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Input(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Output => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Output(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Config => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Config(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Loop => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Loop(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let initbody = match raw_node.body.get("init") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"init")),
				};
				let condbody = match raw_node.body.get("cond") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"cond")),
				};
				let stepbody = match raw_node.body.get("step") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"step")),
				};
				let bodybody = match raw_node.body.get("body") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"body")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::IndentScope => {
				let node = nodes[i].clone();
				let node = match node {
					Node::IndentScope(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let elementsbody = match raw_node.body.get("elements") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"elements")),
				};
				let scopebody = match raw_node.body.get("scope") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"scope")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::MatchBranch => {
				let node = nodes[i].clone();
				let node = match node {
					Node::MatchBranch(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let condbody = match raw_node.body.get("cond") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"cond")),
				};
				let sym_locbody = match raw_node.body.get("sym_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"sym_loc")),
				};
				let thenbody = match raw_node.body.get("then") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"then")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Return => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Return(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let exprbody = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Break => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Break(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Continue => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Continue(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Assert => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Assert(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let condbody = match raw_node.body.get("cond") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"cond")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::ImplicitYield => {
				let node = nodes[i].clone();
				let node = match node {
					Node::ImplicitYield(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let exprbody = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Field => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Field(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let identbody = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"ident")),
				};
				let colon_locbody = match raw_node.body.get("colon_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"colon_loc")),
				};
				let field_typebody = match raw_node.body.get("field_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"field_type")),
				};
				let raw_argumentsbody = match raw_node.body.get("raw_arguments") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"raw_arguments")),
				};
				let argumentsbody = match raw_node.body.get("arguments") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"arguments")),
				};
				let belongbody = match raw_node.body.get("belong") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"belong")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Format => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Format(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let is_enumbody = match raw_node.body.get("is_enum") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"is_enum")),
				};
				let identbody = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"ident")),
				};
				let bodybody = match raw_node.body.get("body") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"body")),
				};
				let belongbody = match raw_node.body.get("belong") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"belong")),
				};
				let struct_typebody = match raw_node.body.get("struct_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"struct_type")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Function => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Function(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let identbody = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"ident")),
				};
				let parametersbody = match raw_node.body.get("parameters") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"parameters")),
				};
				let return_typebody = match raw_node.body.get("return_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"return_type")),
				};
				let belongbody = match raw_node.body.get("belong") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"belong")),
				};
				let bodybody = match raw_node.body.get("body") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"body")),
				};
				let func_typebody = match raw_node.body.get("func_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"func_type")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::IntType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::IntType(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let bit_sizebody = match raw_node.body.get("bit_size") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"bit_size")),
				};
				let endianbody = match raw_node.body.get("endian") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"endian")),
				};
				let is_signedbody = match raw_node.body.get("is_signed") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"is_signed")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::IdentType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::IdentType(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let identbody = match raw_node.body.get("ident") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"ident")),
				};
				let basebody = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"base")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::IntLiteralType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::IntLiteralType(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let basebody = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"base")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::StrLiteralType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::StrLiteralType(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let basebody = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"base")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::VoidType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::VoidType(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::BoolType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::BoolType(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::ArrayType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::ArrayType(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let end_locbody = match raw_node.body.get("end_loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"end_loc")),
				};
				let base_typebody = match raw_node.body.get("base_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"base_type")),
				};
				let lengthbody = match raw_node.body.get("length") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"length")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::FunctionType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::FunctionType(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let return_typebody = match raw_node.body.get("return_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"return_type")),
				};
				let parametersbody = match raw_node.body.get("parameters") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"parameters")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::StructType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::StructType(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let fieldsbody = match raw_node.body.get("fields") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"fields")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::UnionType => {
				let node = nodes[i].clone();
				let node = match node {
					Node::UnionType(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let fieldsbody = match raw_node.body.get("fields") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"fields")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			NodeType::Cast => {
				let node = nodes[i].clone();
				let node = match node {
					Node::Cast(node)=>node,
					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),
				};
				let expr_typebody = match raw_node.body.get("expr_type") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr_type")),
				};
				let basebody = match raw_node.body.get("base") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"base")),
				};
				let exprbody = match raw_node.body.get("expr") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"expr")),
				};
				let locbody = match raw_node.body.get("loc") {
					Some(v)=>v,
					None=>return Err(Error::MissingField(raw_node.node_type,"loc")),
				};
			},
			_=>return Err(Error::UnknownNodeType(raw_node.node_type)),
		};
	}
}

