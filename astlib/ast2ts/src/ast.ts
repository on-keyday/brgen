// Code generated by gen_ast2ts; DO NOT EDIT.

export namespace ast2ts {

export type NodeType = "program" | "comment" | "comment_group" | "field_argument" | "expr" | "binary" | "unary" | "cond" | "ident" | "call" | "if" | "member_access" | "paren" | "index" | "match" | "range" | "identity" | "tmp_var" | "import" | "cast" | "available" | "specify_order" | "explicit_error" | "io_operation" | "or_cond" | "bad_expr" | "stmt" | "loop" | "indent_block" | "scoped_statement" | "match_branch" | "union_candidate" | "return" | "break" | "continue" | "assert" | "implicit_yield" | "metadata" | "type" | "int_type" | "float_type" | "ident_type" | "int_literal_type" | "str_literal_type" | "regex_literal_type" | "void_type" | "bool_type" | "array_type" | "function_type" | "struct_type" | "struct_union_type" | "union_type" | "range_type" | "enum_type" | "meta_type" | "optional_type" | "generic_type" | "literal" | "int_literal" | "bool_literal" | "str_literal" | "regex_literal" | "char_literal" | "type_literal" | "special_literal" | "member" | "field" | "format" | "state" | "enum" | "enum_member" | "function";

export function isNodeType(obj: any): obj is NodeType {
	return obj && typeof obj === 'string' && (obj === "program" || obj === "comment" || obj === "comment_group" || obj === "field_argument" || obj === "expr" || obj === "binary" || obj === "unary" || obj === "cond" || obj === "ident" || obj === "call" || obj === "if" || obj === "member_access" || obj === "paren" || obj === "index" || obj === "match" || obj === "range" || obj === "identity" || obj === "tmp_var" || obj === "import" || obj === "cast" || obj === "available" || obj === "specify_order" || obj === "explicit_error" || obj === "io_operation" || obj === "or_cond" || obj === "bad_expr" || obj === "stmt" || obj === "loop" || obj === "indent_block" || obj === "scoped_statement" || obj === "match_branch" || obj === "union_candidate" || obj === "return" || obj === "break" || obj === "continue" || obj === "assert" || obj === "implicit_yield" || obj === "metadata" || obj === "type" || obj === "int_type" || obj === "float_type" || obj === "ident_type" || obj === "int_literal_type" || obj === "str_literal_type" || obj === "regex_literal_type" || obj === "void_type" || obj === "bool_type" || obj === "array_type" || obj === "function_type" || obj === "struct_type" || obj === "struct_union_type" || obj === "union_type" || obj === "range_type" || obj === "enum_type" || obj === "meta_type" || obj === "optional_type" || obj === "generic_type" || obj === "literal" || obj === "int_literal" || obj === "bool_literal" || obj === "str_literal" || obj === "regex_literal" || obj === "char_literal" || obj === "type_literal" || obj === "special_literal" || obj === "member" || obj === "field" || obj === "format" || obj === "state" || obj === "enum" || obj === "enum_member" || obj === "function")
}

export const enum TokenTag {
	indent = "indent",
	space = "space",
	line = "line",
	punct = "punct",
	int_literal = "int_literal",
	bool_literal = "bool_literal",
	str_literal = "str_literal",
	regex_literal = "regex_literal",
	char_literal = "char_literal",
	keyword = "keyword",
	ident = "ident",
	comment = "comment",
	error = "error",
	unknown = "unknown",
};

export function isTokenTag(obj: any): obj is TokenTag {
	return obj && typeof obj === 'string' && (obj === "indent" || obj === "space" || obj === "line" || obj === "punct" || obj === "int_literal" || obj === "bool_literal" || obj === "str_literal" || obj === "regex_literal" || obj === "char_literal" || obj === "keyword" || obj === "ident" || obj === "comment" || obj === "error" || obj === "unknown")
}

export const enum UnaryOp {
	not = "!",
	minus_sign = "-",
};

export function isUnaryOp(obj: any): obj is UnaryOp {
	return obj && typeof obj === 'string' && (obj === "!" || obj === "-")
}

export const enum BinaryOp {
	mul = "*",
	div = "/",
	mod = "%",
	left_arithmetic_shift = "<<<",
	right_arithmetic_shift = ">>>",
	left_logical_shift = "<<",
	right_logical_shift = ">>",
	bit_and = "&",
	add = "+",
	sub = "-",
	bit_or = "|",
	bit_xor = "^",
	equal = "==",
	not_equal = "!=",
	less = "<",
	less_or_eq = "<=",
	grater = ">",
	grater_or_eq = ">=",
	logical_and = "&&",
	logical_or = "||",
	cond_op_1 = "?",
	cond_op_2 = ":",
	range_exclusive = "..",
	range_inclusive = "..=",
	assign = "=",
	define_assign = ":=",
	const_assign = "::=",
	add_assign = "+=",
	sub_assign = "-=",
	mul_assign = "*=",
	div_assign = "/=",
	mod_assign = "%=",
	left_logical_shift_assign = "<<=",
	right_logical_shift_assign = ">>=",
	left_arithmetic_shift_assign = "<<<=",
	right_arithmetic_shift_assign = ">>>=",
	bit_and_assign = "&=",
	bit_or_assign = "|=",
	bit_xor_assign = "^=",
	comma = ",",
	in_assign = "in",
	append_assign = "append",
};

export function isBinaryOp(obj: any): obj is BinaryOp {
	return obj && typeof obj === 'string' && (obj === "*" || obj === "/" || obj === "%" || obj === "<<<" || obj === ">>>" || obj === "<<" || obj === ">>" || obj === "&" || obj === "+" || obj === "-" || obj === "|" || obj === "^" || obj === "==" || obj === "!=" || obj === "<" || obj === "<=" || obj === ">" || obj === ">=" || obj === "&&" || obj === "||" || obj === "?" || obj === ":" || obj === ".." || obj === "..=" || obj === "=" || obj === ":=" || obj === "::=" || obj === "+=" || obj === "-=" || obj === "*=" || obj === "/=" || obj === "%=" || obj === "<<=" || obj === ">>=" || obj === "<<<=" || obj === ">>>=" || obj === "&=" || obj === "|=" || obj === "^=" || obj === "," || obj === "in" || obj === "append")
}

export const enum IdentUsage {
	unknown = "unknown",
	bad_ident = "bad_ident",
	reference = "reference",
	define_variable = "define_variable",
	define_const = "define_const",
	define_field = "define_field",
	define_format = "define_format",
	define_state = "define_state",
	define_enum = "define_enum",
	define_enum_member = "define_enum_member",
	define_fn = "define_fn",
	define_cast_fn = "define_cast_fn",
	define_arg = "define_arg",
	reference_type = "reference_type",
	reference_member = "reference_member",
	reference_member_type = "reference_member_type",
	maybe_type = "maybe_type",
	reference_builtin_fn = "reference_builtin_fn",
};

export function isIdentUsage(obj: any): obj is IdentUsage {
	return obj && typeof obj === 'string' && (obj === "unknown" || obj === "bad_ident" || obj === "reference" || obj === "define_variable" || obj === "define_const" || obj === "define_field" || obj === "define_format" || obj === "define_state" || obj === "define_enum" || obj === "define_enum_member" || obj === "define_fn" || obj === "define_cast_fn" || obj === "define_arg" || obj === "reference_type" || obj === "reference_member" || obj === "reference_member_type" || obj === "maybe_type" || obj === "reference_builtin_fn")
}

export const enum Endian {
	unspec = "unspec",
	big = "big",
	little = "little",
};

export function isEndian(obj: any): obj is Endian {
	return obj && typeof obj === 'string' && (obj === "unspec" || obj === "big" || obj === "little")
}

export const enum ConstantLevel {
	unknown = "unknown",
	constant = "constant",
	immutable_variable = "immutable_variable",
	variable = "variable",
};

export function isConstantLevel(obj: any): obj is ConstantLevel {
	return obj && typeof obj === 'string' && (obj === "unknown" || obj === "constant" || obj === "immutable_variable" || obj === "variable")
}

export const enum BitAlignment {
	byte_aligned = "byte_aligned",
	bit_1 = "bit_1",
	bit_2 = "bit_2",
	bit_3 = "bit_3",
	bit_4 = "bit_4",
	bit_5 = "bit_5",
	bit_6 = "bit_6",
	bit_7 = "bit_7",
	not_target = "not_target",
	not_decidable = "not_decidable",
};

export function isBitAlignment(obj: any): obj is BitAlignment {
	return obj && typeof obj === 'string' && (obj === "byte_aligned" || obj === "bit_1" || obj === "bit_2" || obj === "bit_3" || obj === "bit_4" || obj === "bit_5" || obj === "bit_6" || obj === "bit_7" || obj === "not_target" || obj === "not_decidable")
}

export const enum Follow {
	unknown = "unknown",
	end = "end",
	fixed = "fixed",
	constant = "constant",
	normal = "normal",
};

export function isFollow(obj: any): obj is Follow {
	return obj && typeof obj === 'string' && (obj === "unknown" || obj === "end" || obj === "fixed" || obj === "constant" || obj === "normal")
}

export const enum IoMethod {
	unspec = "unspec",
	output_put = "output_put",
	input_peek = "input_peek",
	input_get = "input_get",
	input_backward = "input_backward",
	input_offset = "input_offset",
	input_bit_offset = "input_bit_offset",
	input_remain = "input_remain",
	input_subrange = "input_subrange",
	config_endian_little = "config_endian_little",
	config_endian_big = "config_endian_big",
	config_endian_native = "config_endian_native",
	config_bit_order_lsb = "config_bit_order_lsb",
	config_bit_order_msb = "config_bit_order_msb",
};

export function isIoMethod(obj: any): obj is IoMethod {
	return obj && typeof obj === 'string' && (obj === "unspec" || obj === "output_put" || obj === "input_peek" || obj === "input_get" || obj === "input_backward" || obj === "input_offset" || obj === "input_bit_offset" || obj === "input_remain" || obj === "input_subrange" || obj === "config_endian_little" || obj === "config_endian_big" || obj === "config_endian_native" || obj === "config_bit_order_lsb" || obj === "config_bit_order_msb")
}

export const enum SpecialLiteralKind {
	input = "input",
	output = "output",
	config = "config",
};

export function isSpecialLiteralKind(obj: any): obj is SpecialLiteralKind {
	return obj && typeof obj === 'string' && (obj === "input" || obj === "output" || obj === "config")
}

export const enum OrderType {
	byte = "byte",
	bit_stream = "bit_stream",
	bit_mapping = "bit_mapping",
	bit_both = "bit_both",
};

export function isOrderType(obj: any): obj is OrderType {
	return obj && typeof obj === 'string' && (obj === "byte" || obj === "bit_stream" || obj === "bit_mapping" || obj === "bit_both")
}

export const enum BlockTrait {
	none = 0,
	fixed_primitive = 1,
	fixed_float = 2,
	fixed_array = 4,
	variable_array = 8,
	struct = 16,
	conditional = 32,
	static_peek = 64,
	bit_field = 128,
	read_state = 256,
	write_state = 512,
	terminal_pattern = 1024,
	bit_stream = 2048,
	dynamic_order = 4096,
	full_input = 8192,
	backward_input = 16384,
	magic_value = 32768,
	assertion = 65536,
	explicit_error = 131072,
	procedural = 262144,
	for_loop = 524288,
	local_variable = 1048576,
	description_only = 2097152,
	uncommon_size = 4194304,
	control_flow_change = 8388608,
};

export function isBlockTrait(obj: any): obj is BlockTrait {
	return typeof obj === 'number' && Number.isInteger(obj) // easy check
}

export function BlockTraitToString(v: BlockTrait): string {
  const result = [];
  if ((v & 1) === 1) result.push("fixed_primitive");
  if ((v & 2) === 2) result.push("fixed_float");
  if ((v & 4) === 4) result.push("fixed_array");
  if ((v & 8) === 8) result.push("variable_array");
  if ((v & 16) === 16) result.push("struct");
  if ((v & 32) === 32) result.push("conditional");
  if ((v & 64) === 64) result.push("static_peek");
  if ((v & 128) === 128) result.push("bit_field");
  if ((v & 256) === 256) result.push("read_state");
  if ((v & 512) === 512) result.push("write_state");
  if ((v & 1024) === 1024) result.push("terminal_pattern");
  if ((v & 2048) === 2048) result.push("bit_stream");
  if ((v & 4096) === 4096) result.push("dynamic_order");
  if ((v & 8192) === 8192) result.push("full_input");
  if ((v & 16384) === 16384) result.push("backward_input");
  if ((v & 32768) === 32768) result.push("magic_value");
  if ((v & 65536) === 65536) result.push("assertion");
  if ((v & 131072) === 131072) result.push("explicit_error");
  if ((v & 262144) === 262144) result.push("procedural");
  if ((v & 524288) === 524288) result.push("for_loop");
  if ((v & 1048576) === 1048576) result.push("local_variable");
  if ((v & 2097152) === 2097152) result.push("description_only");
  if ((v & 4194304) === 4194304) result.push("uncommon_size");
  if ((v & 8388608) === 8388608) result.push("control_flow_change");
  if (result.length === 0) {
    return "none";
  }
  return result.join(' | ');
}

export interface Node {
	readonly node_type: NodeType;
	loc: Loc;
}

export function isNode(obj: any): obj is Node {
	if (isProgram(obj)) return true;
	if (isComment(obj)) return true;
	if (isCommentGroup(obj)) return true;
	if (isFieldArgument(obj)) return true;
	if (isBinary(obj)) return true;
	if (isUnary(obj)) return true;
	if (isCond(obj)) return true;
	if (isIdent(obj)) return true;
	if (isCall(obj)) return true;
	if (isIf(obj)) return true;
	if (isMemberAccess(obj)) return true;
	if (isParen(obj)) return true;
	if (isIndex(obj)) return true;
	if (isMatch(obj)) return true;
	if (isRange(obj)) return true;
	if (isIdentity(obj)) return true;
	if (isTmpVar(obj)) return true;
	if (isImport(obj)) return true;
	if (isCast(obj)) return true;
	if (isAvailable(obj)) return true;
	if (isSpecifyOrder(obj)) return true;
	if (isExplicitError(obj)) return true;
	if (isIoOperation(obj)) return true;
	if (isOrCond(obj)) return true;
	if (isBadExpr(obj)) return true;
	if (isLoop(obj)) return true;
	if (isIndentBlock(obj)) return true;
	if (isScopedStatement(obj)) return true;
	if (isMatchBranch(obj)) return true;
	if (isUnionCandidate(obj)) return true;
	if (isReturn(obj)) return true;
	if (isBreak(obj)) return true;
	if (isContinue(obj)) return true;
	if (isAssert(obj)) return true;
	if (isImplicitYield(obj)) return true;
	if (isMetadata(obj)) return true;
	if (isIntType(obj)) return true;
	if (isFloatType(obj)) return true;
	if (isIdentType(obj)) return true;
	if (isIntLiteralType(obj)) return true;
	if (isStrLiteralType(obj)) return true;
	if (isRegexLiteralType(obj)) return true;
	if (isVoidType(obj)) return true;
	if (isBoolType(obj)) return true;
	if (isArrayType(obj)) return true;
	if (isFunctionType(obj)) return true;
	if (isStructType(obj)) return true;
	if (isStructUnionType(obj)) return true;
	if (isUnionType(obj)) return true;
	if (isRangeType(obj)) return true;
	if (isEnumType(obj)) return true;
	if (isMetaType(obj)) return true;
	if (isOptionalType(obj)) return true;
	if (isGenericType(obj)) return true;
	if (isIntLiteral(obj)) return true;
	if (isBoolLiteral(obj)) return true;
	if (isStrLiteral(obj)) return true;
	if (isRegexLiteral(obj)) return true;
	if (isCharLiteral(obj)) return true;
	if (isTypeLiteral(obj)) return true;
	if (isSpecialLiteral(obj)) return true;
	if (isField(obj)) return true;
	if (isFormat(obj)) return true;
	if (isState(obj)) return true;
	if (isEnum(obj)) return true;
	if (isEnumMember(obj)) return true;
	if (isFunction(obj)) return true;
	return false;
}

export interface Expr extends Node {
	expr_type: Type|null;
	constant_level: ConstantLevel;
}

export function isExpr(obj: any): obj is Expr {
	if (isBinary(obj)) return true;
	if (isUnary(obj)) return true;
	if (isCond(obj)) return true;
	if (isIdent(obj)) return true;
	if (isCall(obj)) return true;
	if (isIf(obj)) return true;
	if (isMemberAccess(obj)) return true;
	if (isParen(obj)) return true;
	if (isIndex(obj)) return true;
	if (isMatch(obj)) return true;
	if (isRange(obj)) return true;
	if (isIdentity(obj)) return true;
	if (isTmpVar(obj)) return true;
	if (isImport(obj)) return true;
	if (isCast(obj)) return true;
	if (isAvailable(obj)) return true;
	if (isSpecifyOrder(obj)) return true;
	if (isExplicitError(obj)) return true;
	if (isIoOperation(obj)) return true;
	if (isOrCond(obj)) return true;
	if (isBadExpr(obj)) return true;
	if (isIntLiteral(obj)) return true;
	if (isBoolLiteral(obj)) return true;
	if (isStrLiteral(obj)) return true;
	if (isRegexLiteral(obj)) return true;
	if (isCharLiteral(obj)) return true;
	if (isTypeLiteral(obj)) return true;
	if (isSpecialLiteral(obj)) return true;
	return false;
}

export interface Stmt extends Node {
}

export function isStmt(obj: any): obj is Stmt {
	if (isLoop(obj)) return true;
	if (isIndentBlock(obj)) return true;
	if (isScopedStatement(obj)) return true;
	if (isMatchBranch(obj)) return true;
	if (isUnionCandidate(obj)) return true;
	if (isReturn(obj)) return true;
	if (isBreak(obj)) return true;
	if (isContinue(obj)) return true;
	if (isAssert(obj)) return true;
	if (isImplicitYield(obj)) return true;
	if (isMetadata(obj)) return true;
	if (isField(obj)) return true;
	if (isFormat(obj)) return true;
	if (isState(obj)) return true;
	if (isEnum(obj)) return true;
	if (isEnumMember(obj)) return true;
	if (isFunction(obj)) return true;
	return false;
}

export interface Type extends Node {
	is_explicit: boolean;
	non_dynamic_allocation: boolean;
	bit_alignment: BitAlignment;
	bit_size: number|null;
}

export function isType(obj: any): obj is Type {
	if (isIntType(obj)) return true;
	if (isFloatType(obj)) return true;
	if (isIdentType(obj)) return true;
	if (isIntLiteralType(obj)) return true;
	if (isStrLiteralType(obj)) return true;
	if (isRegexLiteralType(obj)) return true;
	if (isVoidType(obj)) return true;
	if (isBoolType(obj)) return true;
	if (isArrayType(obj)) return true;
	if (isFunctionType(obj)) return true;
	if (isStructType(obj)) return true;
	if (isStructUnionType(obj)) return true;
	if (isUnionType(obj)) return true;
	if (isRangeType(obj)) return true;
	if (isEnumType(obj)) return true;
	if (isMetaType(obj)) return true;
	if (isOptionalType(obj)) return true;
	if (isGenericType(obj)) return true;
	return false;
}

export interface Literal extends Expr {
}

export function isLiteral(obj: any): obj is Literal {
	if (isIntLiteral(obj)) return true;
	if (isBoolLiteral(obj)) return true;
	if (isStrLiteral(obj)) return true;
	if (isRegexLiteral(obj)) return true;
	if (isCharLiteral(obj)) return true;
	if (isTypeLiteral(obj)) return true;
	if (isSpecialLiteral(obj)) return true;
	return false;
}

export interface Member extends Stmt {
	belong: Member|null;
	belong_struct: StructType|null;
	ident: Ident|null;
}

export function isMember(obj: any): obj is Member {
	if (isField(obj)) return true;
	if (isFormat(obj)) return true;
	if (isState(obj)) return true;
	if (isEnum(obj)) return true;
	if (isEnumMember(obj)) return true;
	if (isFunction(obj)) return true;
	return false;
}

export interface Program extends Node {
	struct_type: StructType|null;
	elements: Node[];
	global_scope: Scope|null;
	metadata: Metadata[];
	endian: SpecifyOrder|null;
}

export function isProgram(obj: any): obj is Program {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "program"
}

export interface Comment extends Node {
	comment: string;
}

export function isComment(obj: any): obj is Comment {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "comment"
}

export interface CommentGroup extends Node {
	comments: Comment[];
}

export function isCommentGroup(obj: any): obj is CommentGroup {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "comment_group"
}

export interface FieldArgument extends Node {
	raw_arguments: Expr|null;
	end_loc: Loc;
	collected_arguments: Expr[];
	arguments: Expr[];
	assigns: Binary[];
	alignment: Expr|null;
	alignment_value: number|null;
	sub_byte_length: Expr|null;
	sub_byte_begin: Expr|null;
	peek: Expr|null;
	peek_value: number|null;
	type_map: TypeLiteral|null;
	metadata: Metadata[];
}

export function isFieldArgument(obj: any): obj is FieldArgument {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "field_argument"
}

export interface Binary extends Expr {
	op: BinaryOp;
	left: Expr|null;
	right: Expr|null;
}

export function isBinary(obj: any): obj is Binary {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "binary"
}

export interface Unary extends Expr {
	op: UnaryOp;
	expr: Expr|null;
}

export function isUnary(obj: any): obj is Unary {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "unary"
}

export interface Cond extends Expr {
	cond: Expr|null;
	then: Expr|null;
	els_loc: Loc;
	els: Expr|null;
}

export function isCond(obj: any): obj is Cond {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "cond"
}

export interface Ident extends Expr {
	ident: string;
	usage: IdentUsage;
	base: Node|null;
	scope: Scope|null;
}

export function isIdent(obj: any): obj is Ident {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "ident"
}

export interface Call extends Expr {
	callee: Expr|null;
	raw_arguments: Expr|null;
	arguments: Expr[];
	end_loc: Loc;
}

export function isCall(obj: any): obj is Call {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "call"
}

export interface If extends Expr {
	struct_union_type: StructUnionType|null;
	cond_scope: Scope|null;
	cond: Identity|null;
	then: IndentBlock|null;
	els: Node|null;
}

export function isIf(obj: any): obj is If {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "if"
}

export interface MemberAccess extends Expr {
	target: Expr|null;
	member: Ident|null;
	base: Ident|null;
}

export function isMemberAccess(obj: any): obj is MemberAccess {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "member_access"
}

export interface Paren extends Expr {
	expr: Expr|null;
	end_loc: Loc;
}

export function isParen(obj: any): obj is Paren {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "paren"
}

export interface Index extends Expr {
	expr: Expr|null;
	index: Expr|null;
	end_loc: Loc;
}

export function isIndex(obj: any): obj is Index {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "index"
}

export interface Match extends Expr {
	struct_union_type: StructUnionType|null;
	cond_scope: Scope|null;
	cond: Identity|null;
	branch: MatchBranch[];
	trial_match: boolean;
}

export function isMatch(obj: any): obj is Match {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "match"
}

export interface Range extends Expr {
	op: BinaryOp;
	start: Expr|null;
	end: Expr|null;
}

export function isRange(obj: any): obj is Range {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "range"
}

export interface Identity extends Expr {
	expr: Expr|null;
}

export function isIdentity(obj: any): obj is Identity {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "identity"
}

export interface TmpVar extends Expr {
	tmp_var: number;
}

export function isTmpVar(obj: any): obj is TmpVar {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "tmp_var"
}

export interface Import extends Expr {
	path: string;
	base: Call|null;
	import_desc: Program|null;
}

export function isImport(obj: any): obj is Import {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "import"
}

export interface Cast extends Expr {
	base: Call|null;
	arguments: Expr[];
}

export function isCast(obj: any): obj is Cast {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "cast"
}

export interface Available extends Expr {
	base: Call|null;
	target: Expr|null;
}

export function isAvailable(obj: any): obj is Available {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "available"
}

export interface SpecifyOrder extends Expr {
	base: Binary|null;
	order_type: OrderType;
	order: Expr|null;
	order_value: number|null;
}

export function isSpecifyOrder(obj: any): obj is SpecifyOrder {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "specify_order"
}

export interface ExplicitError extends Expr {
	base: Call|null;
	message: StrLiteral|null;
}

export function isExplicitError(obj: any): obj is ExplicitError {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "explicit_error"
}

export interface IoOperation extends Expr {
	base: Expr|null;
	method: IoMethod;
	arguments: Expr[];
}

export function isIoOperation(obj: any): obj is IoOperation {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "io_operation"
}

export interface OrCond extends Expr {
	base: Binary|null;
	conds: Expr[];
}

export function isOrCond(obj: any): obj is OrCond {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "or_cond"
}

export interface BadExpr extends Expr {
	content: string;
	bad_expr: Expr|null;
}

export function isBadExpr(obj: any): obj is BadExpr {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "bad_expr"
}

export interface Loop extends Stmt {
	cond_scope: Scope|null;
	init: Expr|null;
	cond: Expr|null;
	step: Expr|null;
	body: IndentBlock|null;
}

export function isLoop(obj: any): obj is Loop {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "loop"
}

export interface IndentBlock extends Stmt {
	struct_type: StructType|null;
	elements: Node[];
	scope: Scope|null;
	metadata: Metadata[];
	block_traits: BlockTrait;
}

export function isIndentBlock(obj: any): obj is IndentBlock {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "indent_block"
}

export interface ScopedStatement extends Stmt {
	struct_type: StructType|null;
	statement: Node|null;
	scope: Scope|null;
}

export function isScopedStatement(obj: any): obj is ScopedStatement {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "scoped_statement"
}

export interface MatchBranch extends Stmt {
	belong: Match|null;
	cond: Identity|null;
	sym_loc: Loc;
	then: Node|null;
}

export function isMatchBranch(obj: any): obj is MatchBranch {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "match_branch"
}

export interface UnionCandidate extends Stmt {
	cond: Expr|null;
	field: Field|null;
}

export function isUnionCandidate(obj: any): obj is UnionCandidate {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "union_candidate"
}

export interface Return extends Stmt {
	expr: Expr|null;
	related_function: Function|null;
}

export function isReturn(obj: any): obj is Return {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "return"
}

export interface Break extends Stmt {
	related_loop: Loop|null;
}

export function isBreak(obj: any): obj is Break {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "break"
}

export interface Continue extends Stmt {
	related_loop: Loop|null;
}

export function isContinue(obj: any): obj is Continue {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "continue"
}

export interface Assert extends Stmt {
	cond: Binary|null;
	is_io_related: boolean;
}

export function isAssert(obj: any): obj is Assert {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "assert"
}

export interface ImplicitYield extends Stmt {
	expr: Expr|null;
}

export function isImplicitYield(obj: any): obj is ImplicitYield {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "implicit_yield"
}

export interface Metadata extends Stmt {
	base: Expr|null;
	name: string;
	values: Expr[];
}

export function isMetadata(obj: any): obj is Metadata {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "metadata"
}

export interface IntType extends Type {
	endian: Endian;
	is_signed: boolean;
	is_common_supported: boolean;
}

export function isIntType(obj: any): obj is IntType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "int_type"
}

export interface FloatType extends Type {
	endian: Endian;
	is_common_supported: boolean;
}

export function isFloatType(obj: any): obj is FloatType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "float_type"
}

export interface IdentType extends Type {
	import_ref: MemberAccess|null;
	ident: Ident|null;
	base: Type|null;
}

export function isIdentType(obj: any): obj is IdentType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "ident_type"
}

export interface IntLiteralType extends Type {
	base: IntLiteral|null;
}

export function isIntLiteralType(obj: any): obj is IntLiteralType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "int_literal_type"
}

export interface StrLiteralType extends Type {
	base: StrLiteral|null;
	strong_ref: StrLiteral|null;
}

export function isStrLiteralType(obj: any): obj is StrLiteralType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "str_literal_type"
}

export interface RegexLiteralType extends Type {
	base: RegexLiteral|null;
	strong_ref: RegexLiteral|null;
}

export function isRegexLiteralType(obj: any): obj is RegexLiteralType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "regex_literal_type"
}

export interface VoidType extends Type {
}

export function isVoidType(obj: any): obj is VoidType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "void_type"
}

export interface BoolType extends Type {
}

export function isBoolType(obj: any): obj is BoolType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "bool_type"
}

export interface ArrayType extends Type {
	end_loc: Loc;
	element_type: Type|null;
	length: Expr|null;
	length_value: number|null;
	is_bytes: boolean;
}

export function isArrayType(obj: any): obj is ArrayType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "array_type"
}

export interface FunctionType extends Type {
	return_type: Type|null;
	parameters: Type[];
}

export function isFunctionType(obj: any): obj is FunctionType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "function_type"
}

export interface StructType extends Type {
	fields: Member[];
	base: Node|null;
	recursive: boolean;
	fixed_header_size: number;
	fixed_tail_size: number;
	type_map: TypeLiteral|null;
}

export function isStructType(obj: any): obj is StructType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "struct_type"
}

export interface StructUnionType extends Type {
	cond: Identity|null;
	conds: Expr[];
	structs: StructType[];
	base: Expr|null;
	union_fields: Field[];
	exhaustive: boolean;
}

export function isStructUnionType(obj: any): obj is StructUnionType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "struct_union_type"
}

export interface UnionType extends Type {
	cond: Expr|null;
	candidates: UnionCandidate[];
	base_type: StructUnionType|null;
	common_type: Type|null;
	member_candidates: Field[];
}

export function isUnionType(obj: any): obj is UnionType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "union_type"
}

export interface RangeType extends Type {
	base_type: Type|null;
	range: Range|null;
}

export function isRangeType(obj: any): obj is RangeType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "range_type"
}

export interface EnumType extends Type {
	base: Enum|null;
}

export function isEnumType(obj: any): obj is EnumType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "enum_type"
}

export interface MetaType extends Type {
}

export function isMetaType(obj: any): obj is MetaType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "meta_type"
}

export interface OptionalType extends Type {
	base_type: Type|null;
}

export function isOptionalType(obj: any): obj is OptionalType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "optional_type"
}

export interface GenericType extends Type {
	belong: Member|null;
}

export function isGenericType(obj: any): obj is GenericType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "generic_type"
}

export interface IntLiteral extends Literal {
	value: string;
}

export function isIntLiteral(obj: any): obj is IntLiteral {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "int_literal"
}

export interface BoolLiteral extends Literal {
	value: boolean;
}

export function isBoolLiteral(obj: any): obj is BoolLiteral {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "bool_literal"
}

export interface StrLiteral extends Literal {
	value: string;
	length: number;
}

export function isStrLiteral(obj: any): obj is StrLiteral {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "str_literal"
}

export interface RegexLiteral extends Literal {
	value: string;
}

export function isRegexLiteral(obj: any): obj is RegexLiteral {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "regex_literal"
}

export interface CharLiteral extends Literal {
	value: string;
	code: number;
}

export function isCharLiteral(obj: any): obj is CharLiteral {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "char_literal"
}

export interface TypeLiteral extends Literal {
	type_literal: Type|null;
	end_loc: Loc;
}

export function isTypeLiteral(obj: any): obj is TypeLiteral {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "type_literal"
}

export interface SpecialLiteral extends Literal {
	kind: SpecialLiteralKind;
}

export function isSpecialLiteral(obj: any): obj is SpecialLiteral {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "special_literal"
}

export interface Field extends Member {
	colon_loc: Loc;
	is_state_variable: boolean;
	field_type: Type|null;
	arguments: FieldArgument|null;
	offset_bit: number|null;
	offset_recent: number;
	tail_offset_bit: number|null;
	tail_offset_recent: number;
	bit_alignment: BitAlignment;
	eventual_bit_alignment: BitAlignment;
	follow: Follow;
	eventual_follow: Follow;
	next: Field|null;
}

export function isField(obj: any): obj is Field {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "field"
}

export interface Format extends Member {
	body: IndentBlock|null;
	encode_fn: Function|null;
	decode_fn: Function|null;
	cast_fns: Function[];
	depends: IdentType[];
	state_variables: Field[];
}

export function isFormat(obj: any): obj is Format {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "format"
}

export interface State extends Member {
	body: IndentBlock|null;
}

export function isState(obj: any): obj is State {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "state"
}

export interface Enum extends Member {
	scope: Scope|null;
	colon_loc: Loc;
	base_type: Type|null;
	members: EnumMember[];
	enum_type: EnumType|null;
}

export function isEnum(obj: any): obj is Enum {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "enum"
}

export interface EnumMember extends Member {
	raw_expr: Expr|null;
	value: Expr|null;
	str_literal: StrLiteral|null;
}

export function isEnumMember(obj: any): obj is EnumMember {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "enum_member"
}

export interface Function extends Member {
	parameters: Field[];
	return_type: Type|null;
	body: IndentBlock|null;
	func_type: FunctionType|null;
	is_cast: boolean;
}

export function isFunction(obj: any): obj is Function {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "function"
}

export interface Scope {
	prev: Scope|null;
	next: Scope|null;
	branch: Scope|null;
	ident: Ident[];
	owner: Node|null;
	branch_root: boolean;
}

export function isScope(obj: any): obj is Scope {
	return obj && typeof obj === 'object' && typeof obj?.prev === 'object' && typeof obj?.next === 'object' && typeof obj?.branch === 'object' && Array.isArray(obj?.ident) && (obj?.owner === null || isNode(obj?.owner)) && typeof obj?.branch_root === "boolean"
}

export interface Pos {
	begin: number;
	end: number;
}

export function isPos(obj: any): obj is Pos {
	return obj && typeof obj === 'object' && typeof obj?.begin === "number" && typeof obj?.end === "number"
}

export interface Loc {
	pos: Pos;
	file: number;
	line: number;
	col: number;
}

export function isLoc(obj: any): obj is Loc {
	return obj && typeof obj === 'object' && isPos(obj?.pos) && typeof obj?.file === "number" && typeof obj?.line === "number" && typeof obj?.col === "number"
}

export interface Token {
	tag: TokenTag;
	token: string;
	loc: Loc;
}

export function isToken(obj: any): obj is Token {
	return obj && typeof obj === 'object' && isTokenTag(obj?.tag) && typeof obj?.token === "string" && isLoc(obj?.loc)
}

export interface RawScope {
	prev: number|null;
	next: number|null;
	branch: number|null;
	ident: number[];
	owner: number|null;
	branch_root: boolean;
}

export function isRawScope(obj: any): obj is RawScope {
	return obj && typeof obj === 'object' && (obj?.prev === null || typeof obj?.prev === "number") && (obj?.next === null || typeof obj?.next === "number") && (obj?.branch === null || typeof obj?.branch === "number") && Array.isArray(obj?.ident) && (obj?.owner === null || typeof obj?.owner === "number") && typeof obj?.branch_root === "boolean"
}

export interface RawNode {
	node_type: NodeType;
	loc: Loc;
	body: any;
}

export function isRawNode(obj: any): obj is RawNode {
	return obj && typeof obj === 'object' && isNodeType(obj?.node_type) && isLoc(obj?.loc) && obj?.body !== undefined
}

export interface SrcErrorEntry {
	msg: string;
	file: string;
	loc: Loc;
	src: string;
	warn: boolean;
}

export function isSrcErrorEntry(obj: any): obj is SrcErrorEntry {
	return obj && typeof obj === 'object' && typeof obj?.msg === "string" && typeof obj?.file === "string" && isLoc(obj?.loc) && typeof obj?.src === "string" && typeof obj?.warn === "boolean"
}

export interface SrcError {
	errs: SrcErrorEntry[];
}

export function isSrcError(obj: any): obj is SrcError {
	return obj && typeof obj === 'object' && Array.isArray(obj?.errs)
}

export interface JsonAst {
	node: RawNode[];
	scope: RawScope[];
}

export function isJsonAst(obj: any): obj is JsonAst {
	return obj && typeof obj === 'object' && Array.isArray(obj?.node) && Array.isArray(obj?.scope)
}

export interface AstFile {
	success: boolean;
	files: string[];
	ast: JsonAst|null;
	error: SrcError|null;
}

export function isAstFile(obj: any): obj is AstFile {
	return obj && typeof obj === 'object' && typeof obj?.success === "boolean" && Array.isArray(obj?.files) && (obj?.ast === null || isJsonAst(obj?.ast)) && (obj?.error === null || isSrcError(obj?.error))
}

export interface TokenFile {
	success: boolean;
	files: string[];
	tokens: Token[]|null;
	error: SrcError|null;
}

export function isTokenFile(obj: any): obj is TokenFile {
	return obj && typeof obj === 'object' && typeof obj?.success === "boolean" && Array.isArray(obj?.files) && (obj?.tokens === null || Array.isArray(obj?.tokens)) && (obj?.error === null || isSrcError(obj?.error))
}

export interface GenerateMapFile {
	structs: string[];
	line_map: LineMap[];
}

export function isGenerateMapFile(obj: any): obj is GenerateMapFile {
	return obj && typeof obj === 'object' && Array.isArray(obj?.structs) && Array.isArray(obj?.line_map)
}

export interface LineMap {
	line: number;
	loc: Loc;
}

export function isLineMap(obj: any): obj is LineMap {
	return obj && typeof obj === 'object' && typeof obj?.line === "number" && isLoc(obj?.loc)
}

interface astConstructor {
	node : Node[];
	scope : Scope[];
}

export function parseAST(obj: JsonAst): Program {
	const o :JsonAst = {
		node: obj.node.map((n: any) => {
			if (!isRawNode(n)) {
				throw new Error('invalid node');
			}
			return n;
		}),
		scope: obj.scope.map((s: any) => {
			if (!isRawScope(s)) {
				throw new Error('invalid scope');
			}
			return s;
		})
	}
	const c :astConstructor = {
		node: [],
		scope: []
	}
	for (const on of o.node) {
		switch (on.node_type) {
		case "program": {
			const n :Program = {
				node_type: "program",
				loc: on.loc,
				struct_type: null,
				elements: [],
				global_scope: null,
				metadata: [],
				endian: null,
			}
			c.node.push(n);
			break;
		}
		case "comment": {
			const n :Comment = {
				node_type: "comment",
				loc: on.loc,
				comment: '',
			}
			c.node.push(n);
			break;
		}
		case "comment_group": {
			const n :CommentGroup = {
				node_type: "comment_group",
				loc: on.loc,
				comments: [],
			}
			c.node.push(n);
			break;
		}
		case "field_argument": {
			const n :FieldArgument = {
				node_type: "field_argument",
				loc: on.loc,
				raw_arguments: null,
				end_loc: on.loc,
				collected_arguments: [],
				arguments: [],
				assigns: [],
				alignment: null,
				alignment_value: null,
				sub_byte_length: null,
				sub_byte_begin: null,
				peek: null,
				peek_value: null,
				type_map: null,
				metadata: [],
			}
			c.node.push(n);
			break;
		}
		case "binary": {
			const n :Binary = {
				node_type: "binary",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				op: BinaryOp.mul,
				left: null,
				right: null,
			}
			c.node.push(n);
			break;
		}
		case "unary": {
			const n :Unary = {
				node_type: "unary",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				op: UnaryOp.not,
				expr: null,
			}
			c.node.push(n);
			break;
		}
		case "cond": {
			const n :Cond = {
				node_type: "cond",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				cond: null,
				then: null,
				els_loc: on.loc,
				els: null,
			}
			c.node.push(n);
			break;
		}
		case "ident": {
			const n :Ident = {
				node_type: "ident",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				ident: '',
				usage: IdentUsage.unknown,
				base: null,
				scope: null,
			}
			c.node.push(n);
			break;
		}
		case "call": {
			const n :Call = {
				node_type: "call",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				callee: null,
				raw_arguments: null,
				arguments: [],
				end_loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "if": {
			const n :If = {
				node_type: "if",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				struct_union_type: null,
				cond_scope: null,
				cond: null,
				then: null,
				els: null,
			}
			c.node.push(n);
			break;
		}
		case "member_access": {
			const n :MemberAccess = {
				node_type: "member_access",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				target: null,
				member: null,
				base: null,
			}
			c.node.push(n);
			break;
		}
		case "paren": {
			const n :Paren = {
				node_type: "paren",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				expr: null,
				end_loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "index": {
			const n :Index = {
				node_type: "index",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				expr: null,
				index: null,
				end_loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "match": {
			const n :Match = {
				node_type: "match",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				struct_union_type: null,
				cond_scope: null,
				cond: null,
				branch: [],
				trial_match: false,
			}
			c.node.push(n);
			break;
		}
		case "range": {
			const n :Range = {
				node_type: "range",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				op: BinaryOp.mul,
				start: null,
				end: null,
			}
			c.node.push(n);
			break;
		}
		case "identity": {
			const n :Identity = {
				node_type: "identity",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				expr: null,
			}
			c.node.push(n);
			break;
		}
		case "tmp_var": {
			const n :TmpVar = {
				node_type: "tmp_var",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				tmp_var: 0,
			}
			c.node.push(n);
			break;
		}
		case "import": {
			const n :Import = {
				node_type: "import",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				path: '',
				base: null,
				import_desc: null,
			}
			c.node.push(n);
			break;
		}
		case "cast": {
			const n :Cast = {
				node_type: "cast",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				base: null,
				arguments: [],
			}
			c.node.push(n);
			break;
		}
		case "available": {
			const n :Available = {
				node_type: "available",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				base: null,
				target: null,
			}
			c.node.push(n);
			break;
		}
		case "specify_order": {
			const n :SpecifyOrder = {
				node_type: "specify_order",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				base: null,
				order_type: OrderType.byte,
				order: null,
				order_value: null,
			}
			c.node.push(n);
			break;
		}
		case "explicit_error": {
			const n :ExplicitError = {
				node_type: "explicit_error",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				base: null,
				message: null,
			}
			c.node.push(n);
			break;
		}
		case "io_operation": {
			const n :IoOperation = {
				node_type: "io_operation",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				base: null,
				method: IoMethod.unspec,
				arguments: [],
			}
			c.node.push(n);
			break;
		}
		case "or_cond": {
			const n :OrCond = {
				node_type: "or_cond",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				base: null,
				conds: [],
			}
			c.node.push(n);
			break;
		}
		case "bad_expr": {
			const n :BadExpr = {
				node_type: "bad_expr",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				content: '',
				bad_expr: null,
			}
			c.node.push(n);
			break;
		}
		case "loop": {
			const n :Loop = {
				node_type: "loop",
				loc: on.loc,
				cond_scope: null,
				init: null,
				cond: null,
				step: null,
				body: null,
			}
			c.node.push(n);
			break;
		}
		case "indent_block": {
			const n :IndentBlock = {
				node_type: "indent_block",
				loc: on.loc,
				struct_type: null,
				elements: [],
				scope: null,
				metadata: [],
				block_traits: BlockTrait.none,
			}
			c.node.push(n);
			break;
		}
		case "scoped_statement": {
			const n :ScopedStatement = {
				node_type: "scoped_statement",
				loc: on.loc,
				struct_type: null,
				statement: null,
				scope: null,
			}
			c.node.push(n);
			break;
		}
		case "match_branch": {
			const n :MatchBranch = {
				node_type: "match_branch",
				loc: on.loc,
				belong: null,
				cond: null,
				sym_loc: on.loc,
				then: null,
			}
			c.node.push(n);
			break;
		}
		case "union_candidate": {
			const n :UnionCandidate = {
				node_type: "union_candidate",
				loc: on.loc,
				cond: null,
				field: null,
			}
			c.node.push(n);
			break;
		}
		case "return": {
			const n :Return = {
				node_type: "return",
				loc: on.loc,
				expr: null,
				related_function: null,
			}
			c.node.push(n);
			break;
		}
		case "break": {
			const n :Break = {
				node_type: "break",
				loc: on.loc,
				related_loop: null,
			}
			c.node.push(n);
			break;
		}
		case "continue": {
			const n :Continue = {
				node_type: "continue",
				loc: on.loc,
				related_loop: null,
			}
			c.node.push(n);
			break;
		}
		case "assert": {
			const n :Assert = {
				node_type: "assert",
				loc: on.loc,
				cond: null,
				is_io_related: false,
			}
			c.node.push(n);
			break;
		}
		case "implicit_yield": {
			const n :ImplicitYield = {
				node_type: "implicit_yield",
				loc: on.loc,
				expr: null,
			}
			c.node.push(n);
			break;
		}
		case "metadata": {
			const n :Metadata = {
				node_type: "metadata",
				loc: on.loc,
				base: null,
				name: '',
				values: [],
			}
			c.node.push(n);
			break;
		}
		case "int_type": {
			const n :IntType = {
				node_type: "int_type",
				loc: on.loc,
				is_explicit: false,
				non_dynamic_allocation: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: null,
				endian: Endian.unspec,
				is_signed: false,
				is_common_supported: false,
			}
			c.node.push(n);
			break;
		}
		case "float_type": {
			const n :FloatType = {
				node_type: "float_type",
				loc: on.loc,
				is_explicit: false,
				non_dynamic_allocation: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: null,
				endian: Endian.unspec,
				is_common_supported: false,
			}
			c.node.push(n);
			break;
		}
		case "ident_type": {
			const n :IdentType = {
				node_type: "ident_type",
				loc: on.loc,
				is_explicit: false,
				non_dynamic_allocation: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: null,
				import_ref: null,
				ident: null,
				base: null,
			}
			c.node.push(n);
			break;
		}
		case "int_literal_type": {
			const n :IntLiteralType = {
				node_type: "int_literal_type",
				loc: on.loc,
				is_explicit: false,
				non_dynamic_allocation: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: null,
				base: null,
			}
			c.node.push(n);
			break;
		}
		case "str_literal_type": {
			const n :StrLiteralType = {
				node_type: "str_literal_type",
				loc: on.loc,
				is_explicit: false,
				non_dynamic_allocation: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: null,
				base: null,
				strong_ref: null,
			}
			c.node.push(n);
			break;
		}
		case "regex_literal_type": {
			const n :RegexLiteralType = {
				node_type: "regex_literal_type",
				loc: on.loc,
				is_explicit: false,
				non_dynamic_allocation: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: null,
				base: null,
				strong_ref: null,
			}
			c.node.push(n);
			break;
		}
		case "void_type": {
			const n :VoidType = {
				node_type: "void_type",
				loc: on.loc,
				is_explicit: false,
				non_dynamic_allocation: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: null,
			}
			c.node.push(n);
			break;
		}
		case "bool_type": {
			const n :BoolType = {
				node_type: "bool_type",
				loc: on.loc,
				is_explicit: false,
				non_dynamic_allocation: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: null,
			}
			c.node.push(n);
			break;
		}
		case "array_type": {
			const n :ArrayType = {
				node_type: "array_type",
				loc: on.loc,
				is_explicit: false,
				non_dynamic_allocation: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: null,
				end_loc: on.loc,
				element_type: null,
				length: null,
				length_value: null,
				is_bytes: false,
			}
			c.node.push(n);
			break;
		}
		case "function_type": {
			const n :FunctionType = {
				node_type: "function_type",
				loc: on.loc,
				is_explicit: false,
				non_dynamic_allocation: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: null,
				return_type: null,
				parameters: [],
			}
			c.node.push(n);
			break;
		}
		case "struct_type": {
			const n :StructType = {
				node_type: "struct_type",
				loc: on.loc,
				is_explicit: false,
				non_dynamic_allocation: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: null,
				fields: [],
				base: null,
				recursive: false,
				fixed_header_size: 0,
				fixed_tail_size: 0,
				type_map: null,
			}
			c.node.push(n);
			break;
		}
		case "struct_union_type": {
			const n :StructUnionType = {
				node_type: "struct_union_type",
				loc: on.loc,
				is_explicit: false,
				non_dynamic_allocation: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: null,
				cond: null,
				conds: [],
				structs: [],
				base: null,
				union_fields: [],
				exhaustive: false,
			}
			c.node.push(n);
			break;
		}
		case "union_type": {
			const n :UnionType = {
				node_type: "union_type",
				loc: on.loc,
				is_explicit: false,
				non_dynamic_allocation: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: null,
				cond: null,
				candidates: [],
				base_type: null,
				common_type: null,
				member_candidates: [],
			}
			c.node.push(n);
			break;
		}
		case "range_type": {
			const n :RangeType = {
				node_type: "range_type",
				loc: on.loc,
				is_explicit: false,
				non_dynamic_allocation: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: null,
				base_type: null,
				range: null,
			}
			c.node.push(n);
			break;
		}
		case "enum_type": {
			const n :EnumType = {
				node_type: "enum_type",
				loc: on.loc,
				is_explicit: false,
				non_dynamic_allocation: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: null,
				base: null,
			}
			c.node.push(n);
			break;
		}
		case "meta_type": {
			const n :MetaType = {
				node_type: "meta_type",
				loc: on.loc,
				is_explicit: false,
				non_dynamic_allocation: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: null,
			}
			c.node.push(n);
			break;
		}
		case "optional_type": {
			const n :OptionalType = {
				node_type: "optional_type",
				loc: on.loc,
				is_explicit: false,
				non_dynamic_allocation: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: null,
				base_type: null,
			}
			c.node.push(n);
			break;
		}
		case "generic_type": {
			const n :GenericType = {
				node_type: "generic_type",
				loc: on.loc,
				is_explicit: false,
				non_dynamic_allocation: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: null,
				belong: null,
			}
			c.node.push(n);
			break;
		}
		case "int_literal": {
			const n :IntLiteral = {
				node_type: "int_literal",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				value: '',
			}
			c.node.push(n);
			break;
		}
		case "bool_literal": {
			const n :BoolLiteral = {
				node_type: "bool_literal",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				value: false,
			}
			c.node.push(n);
			break;
		}
		case "str_literal": {
			const n :StrLiteral = {
				node_type: "str_literal",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				value: '',
				length: 0,
			}
			c.node.push(n);
			break;
		}
		case "regex_literal": {
			const n :RegexLiteral = {
				node_type: "regex_literal",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				value: '',
			}
			c.node.push(n);
			break;
		}
		case "char_literal": {
			const n :CharLiteral = {
				node_type: "char_literal",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				value: '',
				code: 0,
			}
			c.node.push(n);
			break;
		}
		case "type_literal": {
			const n :TypeLiteral = {
				node_type: "type_literal",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				type_literal: null,
				end_loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "special_literal": {
			const n :SpecialLiteral = {
				node_type: "special_literal",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				kind: SpecialLiteralKind.input,
			}
			c.node.push(n);
			break;
		}
		case "field": {
			const n :Field = {
				node_type: "field",
				loc: on.loc,
				belong: null,
				belong_struct: null,
				ident: null,
				colon_loc: on.loc,
				is_state_variable: false,
				field_type: null,
				arguments: null,
				offset_bit: null,
				offset_recent: 0,
				tail_offset_bit: null,
				tail_offset_recent: 0,
				bit_alignment: BitAlignment.byte_aligned,
				eventual_bit_alignment: BitAlignment.byte_aligned,
				follow: Follow.unknown,
				eventual_follow: Follow.unknown,
				next: null,
			}
			c.node.push(n);
			break;
		}
		case "format": {
			const n :Format = {
				node_type: "format",
				loc: on.loc,
				belong: null,
				belong_struct: null,
				ident: null,
				body: null,
				encode_fn: null,
				decode_fn: null,
				cast_fns: [],
				depends: [],
				state_variables: [],
			}
			c.node.push(n);
			break;
		}
		case "state": {
			const n :State = {
				node_type: "state",
				loc: on.loc,
				belong: null,
				belong_struct: null,
				ident: null,
				body: null,
			}
			c.node.push(n);
			break;
		}
		case "enum": {
			const n :Enum = {
				node_type: "enum",
				loc: on.loc,
				belong: null,
				belong_struct: null,
				ident: null,
				scope: null,
				colon_loc: on.loc,
				base_type: null,
				members: [],
				enum_type: null,
			}
			c.node.push(n);
			break;
		}
		case "enum_member": {
			const n :EnumMember = {
				node_type: "enum_member",
				loc: on.loc,
				belong: null,
				belong_struct: null,
				ident: null,
				raw_expr: null,
				value: null,
				str_literal: null,
			}
			c.node.push(n);
			break;
		}
		case "function": {
			const n :Function = {
				node_type: "function",
				loc: on.loc,
				belong: null,
				belong_struct: null,
				ident: null,
				parameters: [],
				return_type: null,
				body: null,
				func_type: null,
				is_cast: false,
			}
			c.node.push(n);
			break;
		}
		default:
			throw new Error('invalid node type');
		}
	}
	for (const _ of o.scope) {
		const n :Scope = {
			prev: null,
			next: null,
			branch: null,
			ident: [],
			owner: null,
			branch_root: false,
		}
		c.scope.push(n);
	}
	for (let i = 0; i < o.node.length; i++) {
		const on = o.node[i];
		const cnode = c.node[i];
		switch (cnode.node_type) {
		case "program": {
			const n :Program = cnode as Program;
			if (on.body?.struct_type !== null && typeof on.body?.struct_type !== 'number') {
				throw new Error('invalid node list at Program::struct_type');
			}
			const tmpstruct_type = on.body.struct_type === null ? null : c.node[on.body.struct_type];
			if (!(tmpstruct_type === null || isStructType(tmpstruct_type))) {
				throw new Error('invalid node list at Program::struct_type');
			}
			n.struct_type = tmpstruct_type;
			for (const o of on.body.elements) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at Program::elements');
				}
				const tmpelements = c.node[o];
				n.elements.push(tmpelements);
			}
			if (on.body?.global_scope !== null && typeof on.body?.global_scope !== 'number') {
				throw new Error('invalid node list at Program::global_scope');
			}
			const tmpglobal_scope = on.body.global_scope === null ? null : c.scope[on.body.global_scope];
			if (tmpglobal_scope !== null && !isScope(tmpglobal_scope)) {
				throw new Error('invalid node list at Program::global_scope');
			}
			n.global_scope = tmpglobal_scope;
			for (const o of on.body.metadata) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at Program::metadata');
				}
				const tmpmetadata = c.node[o];
				if (!isMetadata(tmpmetadata)) {
					throw new Error('invalid node list at Program::metadata');
				}
				n.metadata.push(tmpmetadata);
			}
			if (on.body?.endian !== null && typeof on.body?.endian !== 'number') {
				throw new Error('invalid node list at Program::endian');
			}
			const tmpendian = on.body.endian === null ? null : c.node[on.body.endian];
			if (!(tmpendian === null || isSpecifyOrder(tmpendian))) {
				throw new Error('invalid node list at Program::endian');
			}
			n.endian = tmpendian;
			break;
		}
		case "comment": {
			const n :Comment = cnode as Comment;
			const tmpcomment = on.body?.comment;
			if (typeof tmpcomment !== "string") {
				throw new Error('invalid node list at Comment::comment');
			}
			n.comment = on.body.comment;
			break;
		}
		case "comment_group": {
			const n :CommentGroup = cnode as CommentGroup;
			for (const o of on.body.comments) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at CommentGroup::comments');
				}
				const tmpcomments = c.node[o];
				if (!isComment(tmpcomments)) {
					throw new Error('invalid node list at CommentGroup::comments');
				}
				n.comments.push(tmpcomments);
			}
			break;
		}
		case "field_argument": {
			const n :FieldArgument = cnode as FieldArgument;
			if (on.body?.raw_arguments !== null && typeof on.body?.raw_arguments !== 'number') {
				throw new Error('invalid node list at FieldArgument::raw_arguments');
			}
			const tmpraw_arguments = on.body.raw_arguments === null ? null : c.node[on.body.raw_arguments];
			if (!(tmpraw_arguments === null || isExpr(tmpraw_arguments))) {
				throw new Error('invalid node list at FieldArgument::raw_arguments');
			}
			n.raw_arguments = tmpraw_arguments;
			const tmpend_loc = on.body?.end_loc;
			if (!isLoc(tmpend_loc)) {
				throw new Error('invalid node list at FieldArgument::end_loc');
			}
			n.end_loc = tmpend_loc;
			for (const o of on.body.collected_arguments) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at FieldArgument::collected_arguments');
				}
				const tmpcollected_arguments = c.node[o];
				if (!isExpr(tmpcollected_arguments)) {
					throw new Error('invalid node list at FieldArgument::collected_arguments');
				}
				n.collected_arguments.push(tmpcollected_arguments);
			}
			for (const o of on.body.arguments) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at FieldArgument::arguments');
				}
				const tmparguments = c.node[o];
				if (!isExpr(tmparguments)) {
					throw new Error('invalid node list at FieldArgument::arguments');
				}
				n.arguments.push(tmparguments);
			}
			for (const o of on.body.assigns) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at FieldArgument::assigns');
				}
				const tmpassigns = c.node[o];
				if (!isBinary(tmpassigns)) {
					throw new Error('invalid node list at FieldArgument::assigns');
				}
				n.assigns.push(tmpassigns);
			}
			if (on.body?.alignment !== null && typeof on.body?.alignment !== 'number') {
				throw new Error('invalid node list at FieldArgument::alignment');
			}
			const tmpalignment = on.body.alignment === null ? null : c.node[on.body.alignment];
			if (!(tmpalignment === null || isExpr(tmpalignment))) {
				throw new Error('invalid node list at FieldArgument::alignment');
			}
			n.alignment = tmpalignment;
			const tmpalignment_value = on.body?.alignment_value;
			if (tmpalignment_value !== null && typeof tmpalignment_value !== "number") {
				throw new Error('invalid node list at FieldArgument::alignment_value');
			}
			n.alignment_value = on.body.alignment_value;
			if (on.body?.sub_byte_length !== null && typeof on.body?.sub_byte_length !== 'number') {
				throw new Error('invalid node list at FieldArgument::sub_byte_length');
			}
			const tmpsub_byte_length = on.body.sub_byte_length === null ? null : c.node[on.body.sub_byte_length];
			if (!(tmpsub_byte_length === null || isExpr(tmpsub_byte_length))) {
				throw new Error('invalid node list at FieldArgument::sub_byte_length');
			}
			n.sub_byte_length = tmpsub_byte_length;
			if (on.body?.sub_byte_begin !== null && typeof on.body?.sub_byte_begin !== 'number') {
				throw new Error('invalid node list at FieldArgument::sub_byte_begin');
			}
			const tmpsub_byte_begin = on.body.sub_byte_begin === null ? null : c.node[on.body.sub_byte_begin];
			if (!(tmpsub_byte_begin === null || isExpr(tmpsub_byte_begin))) {
				throw new Error('invalid node list at FieldArgument::sub_byte_begin');
			}
			n.sub_byte_begin = tmpsub_byte_begin;
			if (on.body?.peek !== null && typeof on.body?.peek !== 'number') {
				throw new Error('invalid node list at FieldArgument::peek');
			}
			const tmppeek = on.body.peek === null ? null : c.node[on.body.peek];
			if (!(tmppeek === null || isExpr(tmppeek))) {
				throw new Error('invalid node list at FieldArgument::peek');
			}
			n.peek = tmppeek;
			const tmppeek_value = on.body?.peek_value;
			if (tmppeek_value !== null && typeof tmppeek_value !== "number") {
				throw new Error('invalid node list at FieldArgument::peek_value');
			}
			n.peek_value = on.body.peek_value;
			if (on.body?.type_map !== null && typeof on.body?.type_map !== 'number') {
				throw new Error('invalid node list at FieldArgument::type_map');
			}
			const tmptype_map = on.body.type_map === null ? null : c.node[on.body.type_map];
			if (!(tmptype_map === null || isTypeLiteral(tmptype_map))) {
				throw new Error('invalid node list at FieldArgument::type_map');
			}
			n.type_map = tmptype_map;
			for (const o of on.body.metadata) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at FieldArgument::metadata');
				}
				const tmpmetadata = c.node[o];
				if (!isMetadata(tmpmetadata)) {
					throw new Error('invalid node list at FieldArgument::metadata');
				}
				n.metadata.push(tmpmetadata);
			}
			break;
		}
		case "binary": {
			const n :Binary = cnode as Binary;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Binary::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Binary::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Binary::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmpop = on.body?.op;
			if (!isBinaryOp(tmpop)) {
				throw new Error('invalid node list at Binary::op');
			}
			n.op = tmpop;
			if (on.body?.left !== null && typeof on.body?.left !== 'number') {
				throw new Error('invalid node list at Binary::left');
			}
			const tmpleft = on.body.left === null ? null : c.node[on.body.left];
			if (!(tmpleft === null || isExpr(tmpleft))) {
				throw new Error('invalid node list at Binary::left');
			}
			n.left = tmpleft;
			if (on.body?.right !== null && typeof on.body?.right !== 'number') {
				throw new Error('invalid node list at Binary::right');
			}
			const tmpright = on.body.right === null ? null : c.node[on.body.right];
			if (!(tmpright === null || isExpr(tmpright))) {
				throw new Error('invalid node list at Binary::right');
			}
			n.right = tmpright;
			break;
		}
		case "unary": {
			const n :Unary = cnode as Unary;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Unary::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Unary::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Unary::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmpop = on.body?.op;
			if (!isUnaryOp(tmpop)) {
				throw new Error('invalid node list at Unary::op');
			}
			n.op = tmpop;
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list at Unary::expr');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list at Unary::expr');
			}
			n.expr = tmpexpr;
			break;
		}
		case "cond": {
			const n :Cond = cnode as Cond;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Cond::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Cond::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Cond::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list at Cond::cond');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isExpr(tmpcond))) {
				throw new Error('invalid node list at Cond::cond');
			}
			n.cond = tmpcond;
			if (on.body?.then !== null && typeof on.body?.then !== 'number') {
				throw new Error('invalid node list at Cond::then');
			}
			const tmpthen = on.body.then === null ? null : c.node[on.body.then];
			if (!(tmpthen === null || isExpr(tmpthen))) {
				throw new Error('invalid node list at Cond::then');
			}
			n.then = tmpthen;
			const tmpels_loc = on.body?.els_loc;
			if (!isLoc(tmpels_loc)) {
				throw new Error('invalid node list at Cond::els_loc');
			}
			n.els_loc = tmpels_loc;
			if (on.body?.els !== null && typeof on.body?.els !== 'number') {
				throw new Error('invalid node list at Cond::els');
			}
			const tmpels = on.body.els === null ? null : c.node[on.body.els];
			if (!(tmpels === null || isExpr(tmpels))) {
				throw new Error('invalid node list at Cond::els');
			}
			n.els = tmpels;
			break;
		}
		case "ident": {
			const n :Ident = cnode as Ident;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Ident::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Ident::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Ident::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmpident = on.body?.ident;
			if (typeof tmpident !== "string") {
				throw new Error('invalid node list at Ident::ident');
			}
			n.ident = on.body.ident;
			const tmpusage = on.body?.usage;
			if (!isIdentUsage(tmpusage)) {
				throw new Error('invalid node list at Ident::usage');
			}
			n.usage = tmpusage;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at Ident::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isNode(tmpbase))) {
				throw new Error('invalid node list at Ident::base');
			}
			n.base = tmpbase;
			if (on.body?.scope !== null && typeof on.body?.scope !== 'number') {
				throw new Error('invalid node list at Ident::scope');
			}
			const tmpscope = on.body.scope === null ? null : c.scope[on.body.scope];
			if (tmpscope !== null && !isScope(tmpscope)) {
				throw new Error('invalid node list at Ident::scope');
			}
			n.scope = tmpscope;
			break;
		}
		case "call": {
			const n :Call = cnode as Call;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Call::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Call::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Call::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.callee !== null && typeof on.body?.callee !== 'number') {
				throw new Error('invalid node list at Call::callee');
			}
			const tmpcallee = on.body.callee === null ? null : c.node[on.body.callee];
			if (!(tmpcallee === null || isExpr(tmpcallee))) {
				throw new Error('invalid node list at Call::callee');
			}
			n.callee = tmpcallee;
			if (on.body?.raw_arguments !== null && typeof on.body?.raw_arguments !== 'number') {
				throw new Error('invalid node list at Call::raw_arguments');
			}
			const tmpraw_arguments = on.body.raw_arguments === null ? null : c.node[on.body.raw_arguments];
			if (!(tmpraw_arguments === null || isExpr(tmpraw_arguments))) {
				throw new Error('invalid node list at Call::raw_arguments');
			}
			n.raw_arguments = tmpraw_arguments;
			for (const o of on.body.arguments) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at Call::arguments');
				}
				const tmparguments = c.node[o];
				if (!isExpr(tmparguments)) {
					throw new Error('invalid node list at Call::arguments');
				}
				n.arguments.push(tmparguments);
			}
			const tmpend_loc = on.body?.end_loc;
			if (!isLoc(tmpend_loc)) {
				throw new Error('invalid node list at Call::end_loc');
			}
			n.end_loc = tmpend_loc;
			break;
		}
		case "if": {
			const n :If = cnode as If;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at If::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at If::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at If::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.struct_union_type !== null && typeof on.body?.struct_union_type !== 'number') {
				throw new Error('invalid node list at If::struct_union_type');
			}
			const tmpstruct_union_type = on.body.struct_union_type === null ? null : c.node[on.body.struct_union_type];
			if (!(tmpstruct_union_type === null || isStructUnionType(tmpstruct_union_type))) {
				throw new Error('invalid node list at If::struct_union_type');
			}
			n.struct_union_type = tmpstruct_union_type;
			if (on.body?.cond_scope !== null && typeof on.body?.cond_scope !== 'number') {
				throw new Error('invalid node list at If::cond_scope');
			}
			const tmpcond_scope = on.body.cond_scope === null ? null : c.scope[on.body.cond_scope];
			if (tmpcond_scope !== null && !isScope(tmpcond_scope)) {
				throw new Error('invalid node list at If::cond_scope');
			}
			n.cond_scope = tmpcond_scope;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list at If::cond');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isIdentity(tmpcond))) {
				throw new Error('invalid node list at If::cond');
			}
			n.cond = tmpcond;
			if (on.body?.then !== null && typeof on.body?.then !== 'number') {
				throw new Error('invalid node list at If::then');
			}
			const tmpthen = on.body.then === null ? null : c.node[on.body.then];
			if (!(tmpthen === null || isIndentBlock(tmpthen))) {
				throw new Error('invalid node list at If::then');
			}
			n.then = tmpthen;
			if (on.body?.els !== null && typeof on.body?.els !== 'number') {
				throw new Error('invalid node list at If::els');
			}
			const tmpels = on.body.els === null ? null : c.node[on.body.els];
			if (!(tmpels === null || isNode(tmpels))) {
				throw new Error('invalid node list at If::els');
			}
			n.els = tmpels;
			break;
		}
		case "member_access": {
			const n :MemberAccess = cnode as MemberAccess;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at MemberAccess::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at MemberAccess::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at MemberAccess::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.target !== null && typeof on.body?.target !== 'number') {
				throw new Error('invalid node list at MemberAccess::target');
			}
			const tmptarget = on.body.target === null ? null : c.node[on.body.target];
			if (!(tmptarget === null || isExpr(tmptarget))) {
				throw new Error('invalid node list at MemberAccess::target');
			}
			n.target = tmptarget;
			if (on.body?.member !== null && typeof on.body?.member !== 'number') {
				throw new Error('invalid node list at MemberAccess::member');
			}
			const tmpmember = on.body.member === null ? null : c.node[on.body.member];
			if (!(tmpmember === null || isIdent(tmpmember))) {
				throw new Error('invalid node list at MemberAccess::member');
			}
			n.member = tmpmember;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at MemberAccess::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isIdent(tmpbase))) {
				throw new Error('invalid node list at MemberAccess::base');
			}
			n.base = tmpbase;
			break;
		}
		case "paren": {
			const n :Paren = cnode as Paren;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Paren::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Paren::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Paren::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list at Paren::expr');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list at Paren::expr');
			}
			n.expr = tmpexpr;
			const tmpend_loc = on.body?.end_loc;
			if (!isLoc(tmpend_loc)) {
				throw new Error('invalid node list at Paren::end_loc');
			}
			n.end_loc = tmpend_loc;
			break;
		}
		case "index": {
			const n :Index = cnode as Index;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Index::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Index::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Index::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list at Index::expr');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list at Index::expr');
			}
			n.expr = tmpexpr;
			if (on.body?.index !== null && typeof on.body?.index !== 'number') {
				throw new Error('invalid node list at Index::index');
			}
			const tmpindex = on.body.index === null ? null : c.node[on.body.index];
			if (!(tmpindex === null || isExpr(tmpindex))) {
				throw new Error('invalid node list at Index::index');
			}
			n.index = tmpindex;
			const tmpend_loc = on.body?.end_loc;
			if (!isLoc(tmpend_loc)) {
				throw new Error('invalid node list at Index::end_loc');
			}
			n.end_loc = tmpend_loc;
			break;
		}
		case "match": {
			const n :Match = cnode as Match;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Match::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Match::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Match::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.struct_union_type !== null && typeof on.body?.struct_union_type !== 'number') {
				throw new Error('invalid node list at Match::struct_union_type');
			}
			const tmpstruct_union_type = on.body.struct_union_type === null ? null : c.node[on.body.struct_union_type];
			if (!(tmpstruct_union_type === null || isStructUnionType(tmpstruct_union_type))) {
				throw new Error('invalid node list at Match::struct_union_type');
			}
			n.struct_union_type = tmpstruct_union_type;
			if (on.body?.cond_scope !== null && typeof on.body?.cond_scope !== 'number') {
				throw new Error('invalid node list at Match::cond_scope');
			}
			const tmpcond_scope = on.body.cond_scope === null ? null : c.scope[on.body.cond_scope];
			if (tmpcond_scope !== null && !isScope(tmpcond_scope)) {
				throw new Error('invalid node list at Match::cond_scope');
			}
			n.cond_scope = tmpcond_scope;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list at Match::cond');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isIdentity(tmpcond))) {
				throw new Error('invalid node list at Match::cond');
			}
			n.cond = tmpcond;
			for (const o of on.body.branch) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at Match::branch');
				}
				const tmpbranch = c.node[o];
				if (!isMatchBranch(tmpbranch)) {
					throw new Error('invalid node list at Match::branch');
				}
				n.branch.push(tmpbranch);
			}
			const tmptrial_match = on.body?.trial_match;
			if (typeof tmptrial_match !== "boolean") {
				throw new Error('invalid node list at Match::trial_match');
			}
			n.trial_match = on.body.trial_match;
			break;
		}
		case "range": {
			const n :Range = cnode as Range;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Range::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Range::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Range::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmpop = on.body?.op;
			if (!isBinaryOp(tmpop)) {
				throw new Error('invalid node list at Range::op');
			}
			n.op = tmpop;
			if (on.body?.start !== null && typeof on.body?.start !== 'number') {
				throw new Error('invalid node list at Range::start');
			}
			const tmpstart = on.body.start === null ? null : c.node[on.body.start];
			if (!(tmpstart === null || isExpr(tmpstart))) {
				throw new Error('invalid node list at Range::start');
			}
			n.start = tmpstart;
			if (on.body?.end !== null && typeof on.body?.end !== 'number') {
				throw new Error('invalid node list at Range::end');
			}
			const tmpend = on.body.end === null ? null : c.node[on.body.end];
			if (!(tmpend === null || isExpr(tmpend))) {
				throw new Error('invalid node list at Range::end');
			}
			n.end = tmpend;
			break;
		}
		case "identity": {
			const n :Identity = cnode as Identity;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Identity::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Identity::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Identity::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list at Identity::expr');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list at Identity::expr');
			}
			n.expr = tmpexpr;
			break;
		}
		case "tmp_var": {
			const n :TmpVar = cnode as TmpVar;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at TmpVar::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at TmpVar::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at TmpVar::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmptmp_var = on.body?.tmp_var;
			if (typeof tmptmp_var !== "number") {
				throw new Error('invalid node list at TmpVar::tmp_var');
			}
			n.tmp_var = on.body.tmp_var;
			break;
		}
		case "import": {
			const n :Import = cnode as Import;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Import::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Import::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Import::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmppath = on.body?.path;
			if (typeof tmppath !== "string") {
				throw new Error('invalid node list at Import::path');
			}
			n.path = on.body.path;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at Import::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isCall(tmpbase))) {
				throw new Error('invalid node list at Import::base');
			}
			n.base = tmpbase;
			if (on.body?.import_desc !== null && typeof on.body?.import_desc !== 'number') {
				throw new Error('invalid node list at Import::import_desc');
			}
			const tmpimport_desc = on.body.import_desc === null ? null : c.node[on.body.import_desc];
			if (!(tmpimport_desc === null || isProgram(tmpimport_desc))) {
				throw new Error('invalid node list at Import::import_desc');
			}
			n.import_desc = tmpimport_desc;
			break;
		}
		case "cast": {
			const n :Cast = cnode as Cast;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Cast::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Cast::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Cast::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at Cast::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isCall(tmpbase))) {
				throw new Error('invalid node list at Cast::base');
			}
			n.base = tmpbase;
			for (const o of on.body.arguments) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at Cast::arguments');
				}
				const tmparguments = c.node[o];
				if (!isExpr(tmparguments)) {
					throw new Error('invalid node list at Cast::arguments');
				}
				n.arguments.push(tmparguments);
			}
			break;
		}
		case "available": {
			const n :Available = cnode as Available;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Available::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Available::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Available::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at Available::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isCall(tmpbase))) {
				throw new Error('invalid node list at Available::base');
			}
			n.base = tmpbase;
			if (on.body?.target !== null && typeof on.body?.target !== 'number') {
				throw new Error('invalid node list at Available::target');
			}
			const tmptarget = on.body.target === null ? null : c.node[on.body.target];
			if (!(tmptarget === null || isExpr(tmptarget))) {
				throw new Error('invalid node list at Available::target');
			}
			n.target = tmptarget;
			break;
		}
		case "specify_order": {
			const n :SpecifyOrder = cnode as SpecifyOrder;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at SpecifyOrder::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at SpecifyOrder::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at SpecifyOrder::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at SpecifyOrder::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isBinary(tmpbase))) {
				throw new Error('invalid node list at SpecifyOrder::base');
			}
			n.base = tmpbase;
			const tmporder_type = on.body?.order_type;
			if (!isOrderType(tmporder_type)) {
				throw new Error('invalid node list at SpecifyOrder::order_type');
			}
			n.order_type = tmporder_type;
			if (on.body?.order !== null && typeof on.body?.order !== 'number') {
				throw new Error('invalid node list at SpecifyOrder::order');
			}
			const tmporder = on.body.order === null ? null : c.node[on.body.order];
			if (!(tmporder === null || isExpr(tmporder))) {
				throw new Error('invalid node list at SpecifyOrder::order');
			}
			n.order = tmporder;
			const tmporder_value = on.body?.order_value;
			if (tmporder_value !== null && typeof tmporder_value !== "number") {
				throw new Error('invalid node list at SpecifyOrder::order_value');
			}
			n.order_value = on.body.order_value;
			break;
		}
		case "explicit_error": {
			const n :ExplicitError = cnode as ExplicitError;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at ExplicitError::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at ExplicitError::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at ExplicitError::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at ExplicitError::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isCall(tmpbase))) {
				throw new Error('invalid node list at ExplicitError::base');
			}
			n.base = tmpbase;
			if (on.body?.message !== null && typeof on.body?.message !== 'number') {
				throw new Error('invalid node list at ExplicitError::message');
			}
			const tmpmessage = on.body.message === null ? null : c.node[on.body.message];
			if (!(tmpmessage === null || isStrLiteral(tmpmessage))) {
				throw new Error('invalid node list at ExplicitError::message');
			}
			n.message = tmpmessage;
			break;
		}
		case "io_operation": {
			const n :IoOperation = cnode as IoOperation;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at IoOperation::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at IoOperation::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at IoOperation::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at IoOperation::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isExpr(tmpbase))) {
				throw new Error('invalid node list at IoOperation::base');
			}
			n.base = tmpbase;
			const tmpmethod = on.body?.method;
			if (!isIoMethod(tmpmethod)) {
				throw new Error('invalid node list at IoOperation::method');
			}
			n.method = tmpmethod;
			for (const o of on.body.arguments) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at IoOperation::arguments');
				}
				const tmparguments = c.node[o];
				if (!isExpr(tmparguments)) {
					throw new Error('invalid node list at IoOperation::arguments');
				}
				n.arguments.push(tmparguments);
			}
			break;
		}
		case "or_cond": {
			const n :OrCond = cnode as OrCond;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at OrCond::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at OrCond::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at OrCond::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at OrCond::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isBinary(tmpbase))) {
				throw new Error('invalid node list at OrCond::base');
			}
			n.base = tmpbase;
			for (const o of on.body.conds) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at OrCond::conds');
				}
				const tmpconds = c.node[o];
				if (!isExpr(tmpconds)) {
					throw new Error('invalid node list at OrCond::conds');
				}
				n.conds.push(tmpconds);
			}
			break;
		}
		case "bad_expr": {
			const n :BadExpr = cnode as BadExpr;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at BadExpr::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at BadExpr::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at BadExpr::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmpcontent = on.body?.content;
			if (typeof tmpcontent !== "string") {
				throw new Error('invalid node list at BadExpr::content');
			}
			n.content = on.body.content;
			if (on.body?.bad_expr !== null && typeof on.body?.bad_expr !== 'number') {
				throw new Error('invalid node list at BadExpr::bad_expr');
			}
			const tmpbad_expr = on.body.bad_expr === null ? null : c.node[on.body.bad_expr];
			if (!(tmpbad_expr === null || isExpr(tmpbad_expr))) {
				throw new Error('invalid node list at BadExpr::bad_expr');
			}
			n.bad_expr = tmpbad_expr;
			break;
		}
		case "loop": {
			const n :Loop = cnode as Loop;
			if (on.body?.cond_scope !== null && typeof on.body?.cond_scope !== 'number') {
				throw new Error('invalid node list at Loop::cond_scope');
			}
			const tmpcond_scope = on.body.cond_scope === null ? null : c.scope[on.body.cond_scope];
			if (tmpcond_scope !== null && !isScope(tmpcond_scope)) {
				throw new Error('invalid node list at Loop::cond_scope');
			}
			n.cond_scope = tmpcond_scope;
			if (on.body?.init !== null && typeof on.body?.init !== 'number') {
				throw new Error('invalid node list at Loop::init');
			}
			const tmpinit = on.body.init === null ? null : c.node[on.body.init];
			if (!(tmpinit === null || isExpr(tmpinit))) {
				throw new Error('invalid node list at Loop::init');
			}
			n.init = tmpinit;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list at Loop::cond');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isExpr(tmpcond))) {
				throw new Error('invalid node list at Loop::cond');
			}
			n.cond = tmpcond;
			if (on.body?.step !== null && typeof on.body?.step !== 'number') {
				throw new Error('invalid node list at Loop::step');
			}
			const tmpstep = on.body.step === null ? null : c.node[on.body.step];
			if (!(tmpstep === null || isExpr(tmpstep))) {
				throw new Error('invalid node list at Loop::step');
			}
			n.step = tmpstep;
			if (on.body?.body !== null && typeof on.body?.body !== 'number') {
				throw new Error('invalid node list at Loop::body');
			}
			const tmpbody = on.body.body === null ? null : c.node[on.body.body];
			if (!(tmpbody === null || isIndentBlock(tmpbody))) {
				throw new Error('invalid node list at Loop::body');
			}
			n.body = tmpbody;
			break;
		}
		case "indent_block": {
			const n :IndentBlock = cnode as IndentBlock;
			if (on.body?.struct_type !== null && typeof on.body?.struct_type !== 'number') {
				throw new Error('invalid node list at IndentBlock::struct_type');
			}
			const tmpstruct_type = on.body.struct_type === null ? null : c.node[on.body.struct_type];
			if (!(tmpstruct_type === null || isStructType(tmpstruct_type))) {
				throw new Error('invalid node list at IndentBlock::struct_type');
			}
			n.struct_type = tmpstruct_type;
			for (const o of on.body.elements) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at IndentBlock::elements');
				}
				const tmpelements = c.node[o];
				n.elements.push(tmpelements);
			}
			if (on.body?.scope !== null && typeof on.body?.scope !== 'number') {
				throw new Error('invalid node list at IndentBlock::scope');
			}
			const tmpscope = on.body.scope === null ? null : c.scope[on.body.scope];
			if (tmpscope !== null && !isScope(tmpscope)) {
				throw new Error('invalid node list at IndentBlock::scope');
			}
			n.scope = tmpscope;
			for (const o of on.body.metadata) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at IndentBlock::metadata');
				}
				const tmpmetadata = c.node[o];
				if (!isMetadata(tmpmetadata)) {
					throw new Error('invalid node list at IndentBlock::metadata');
				}
				n.metadata.push(tmpmetadata);
			}
			const tmpblock_traits = on.body?.block_traits;
			if (!isBlockTrait(tmpblock_traits)) {
				throw new Error('invalid node list at IndentBlock::block_traits');
			}
			n.block_traits = tmpblock_traits;
			break;
		}
		case "scoped_statement": {
			const n :ScopedStatement = cnode as ScopedStatement;
			if (on.body?.struct_type !== null && typeof on.body?.struct_type !== 'number') {
				throw new Error('invalid node list at ScopedStatement::struct_type');
			}
			const tmpstruct_type = on.body.struct_type === null ? null : c.node[on.body.struct_type];
			if (!(tmpstruct_type === null || isStructType(tmpstruct_type))) {
				throw new Error('invalid node list at ScopedStatement::struct_type');
			}
			n.struct_type = tmpstruct_type;
			if (on.body?.statement !== null && typeof on.body?.statement !== 'number') {
				throw new Error('invalid node list at ScopedStatement::statement');
			}
			const tmpstatement = on.body.statement === null ? null : c.node[on.body.statement];
			if (!(tmpstatement === null || isNode(tmpstatement))) {
				throw new Error('invalid node list at ScopedStatement::statement');
			}
			n.statement = tmpstatement;
			if (on.body?.scope !== null && typeof on.body?.scope !== 'number') {
				throw new Error('invalid node list at ScopedStatement::scope');
			}
			const tmpscope = on.body.scope === null ? null : c.scope[on.body.scope];
			if (tmpscope !== null && !isScope(tmpscope)) {
				throw new Error('invalid node list at ScopedStatement::scope');
			}
			n.scope = tmpscope;
			break;
		}
		case "match_branch": {
			const n :MatchBranch = cnode as MatchBranch;
			if (on.body?.belong !== null && typeof on.body?.belong !== 'number') {
				throw new Error('invalid node list at MatchBranch::belong');
			}
			const tmpbelong = on.body.belong === null ? null : c.node[on.body.belong];
			if (!(tmpbelong === null || isMatch(tmpbelong))) {
				throw new Error('invalid node list at MatchBranch::belong');
			}
			n.belong = tmpbelong;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list at MatchBranch::cond');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isIdentity(tmpcond))) {
				throw new Error('invalid node list at MatchBranch::cond');
			}
			n.cond = tmpcond;
			const tmpsym_loc = on.body?.sym_loc;
			if (!isLoc(tmpsym_loc)) {
				throw new Error('invalid node list at MatchBranch::sym_loc');
			}
			n.sym_loc = tmpsym_loc;
			if (on.body?.then !== null && typeof on.body?.then !== 'number') {
				throw new Error('invalid node list at MatchBranch::then');
			}
			const tmpthen = on.body.then === null ? null : c.node[on.body.then];
			if (!(tmpthen === null || isNode(tmpthen))) {
				throw new Error('invalid node list at MatchBranch::then');
			}
			n.then = tmpthen;
			break;
		}
		case "union_candidate": {
			const n :UnionCandidate = cnode as UnionCandidate;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list at UnionCandidate::cond');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isExpr(tmpcond))) {
				throw new Error('invalid node list at UnionCandidate::cond');
			}
			n.cond = tmpcond;
			if (on.body?.field !== null && typeof on.body?.field !== 'number') {
				throw new Error('invalid node list at UnionCandidate::field');
			}
			const tmpfield = on.body.field === null ? null : c.node[on.body.field];
			if (!(tmpfield === null || isField(tmpfield))) {
				throw new Error('invalid node list at UnionCandidate::field');
			}
			n.field = tmpfield;
			break;
		}
		case "return": {
			const n :Return = cnode as Return;
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list at Return::expr');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list at Return::expr');
			}
			n.expr = tmpexpr;
			if (on.body?.related_function !== null && typeof on.body?.related_function !== 'number') {
				throw new Error('invalid node list at Return::related_function');
			}
			const tmprelated_function = on.body.related_function === null ? null : c.node[on.body.related_function];
			if (!(tmprelated_function === null || isFunction(tmprelated_function))) {
				throw new Error('invalid node list at Return::related_function');
			}
			n.related_function = tmprelated_function;
			break;
		}
		case "break": {
			const n :Break = cnode as Break;
			if (on.body?.related_loop !== null && typeof on.body?.related_loop !== 'number') {
				throw new Error('invalid node list at Break::related_loop');
			}
			const tmprelated_loop = on.body.related_loop === null ? null : c.node[on.body.related_loop];
			if (!(tmprelated_loop === null || isLoop(tmprelated_loop))) {
				throw new Error('invalid node list at Break::related_loop');
			}
			n.related_loop = tmprelated_loop;
			break;
		}
		case "continue": {
			const n :Continue = cnode as Continue;
			if (on.body?.related_loop !== null && typeof on.body?.related_loop !== 'number') {
				throw new Error('invalid node list at Continue::related_loop');
			}
			const tmprelated_loop = on.body.related_loop === null ? null : c.node[on.body.related_loop];
			if (!(tmprelated_loop === null || isLoop(tmprelated_loop))) {
				throw new Error('invalid node list at Continue::related_loop');
			}
			n.related_loop = tmprelated_loop;
			break;
		}
		case "assert": {
			const n :Assert = cnode as Assert;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list at Assert::cond');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isBinary(tmpcond))) {
				throw new Error('invalid node list at Assert::cond');
			}
			n.cond = tmpcond;
			const tmpis_io_related = on.body?.is_io_related;
			if (typeof tmpis_io_related !== "boolean") {
				throw new Error('invalid node list at Assert::is_io_related');
			}
			n.is_io_related = on.body.is_io_related;
			break;
		}
		case "implicit_yield": {
			const n :ImplicitYield = cnode as ImplicitYield;
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list at ImplicitYield::expr');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list at ImplicitYield::expr');
			}
			n.expr = tmpexpr;
			break;
		}
		case "metadata": {
			const n :Metadata = cnode as Metadata;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at Metadata::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isExpr(tmpbase))) {
				throw new Error('invalid node list at Metadata::base');
			}
			n.base = tmpbase;
			const tmpname = on.body?.name;
			if (typeof tmpname !== "string") {
				throw new Error('invalid node list at Metadata::name');
			}
			n.name = on.body.name;
			for (const o of on.body.values) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at Metadata::values');
				}
				const tmpvalues = c.node[o];
				if (!isExpr(tmpvalues)) {
					throw new Error('invalid node list at Metadata::values');
				}
				n.values.push(tmpvalues);
			}
			break;
		}
		case "int_type": {
			const n :IntType = cnode as IntType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof tmpis_explicit !== "boolean") {
				throw new Error('invalid node list at IntType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpnon_dynamic_allocation = on.body?.non_dynamic_allocation;
			if (typeof tmpnon_dynamic_allocation !== "boolean") {
				throw new Error('invalid node list at IntType::non_dynamic_allocation');
			}
			n.non_dynamic_allocation = on.body.non_dynamic_allocation;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at IntType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (tmpbit_size !== null && typeof tmpbit_size !== "number") {
				throw new Error('invalid node list at IntType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			const tmpendian = on.body?.endian;
			if (!isEndian(tmpendian)) {
				throw new Error('invalid node list at IntType::endian');
			}
			n.endian = tmpendian;
			const tmpis_signed = on.body?.is_signed;
			if (typeof tmpis_signed !== "boolean") {
				throw new Error('invalid node list at IntType::is_signed');
			}
			n.is_signed = on.body.is_signed;
			const tmpis_common_supported = on.body?.is_common_supported;
			if (typeof tmpis_common_supported !== "boolean") {
				throw new Error('invalid node list at IntType::is_common_supported');
			}
			n.is_common_supported = on.body.is_common_supported;
			break;
		}
		case "float_type": {
			const n :FloatType = cnode as FloatType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof tmpis_explicit !== "boolean") {
				throw new Error('invalid node list at FloatType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpnon_dynamic_allocation = on.body?.non_dynamic_allocation;
			if (typeof tmpnon_dynamic_allocation !== "boolean") {
				throw new Error('invalid node list at FloatType::non_dynamic_allocation');
			}
			n.non_dynamic_allocation = on.body.non_dynamic_allocation;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at FloatType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (tmpbit_size !== null && typeof tmpbit_size !== "number") {
				throw new Error('invalid node list at FloatType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			const tmpendian = on.body?.endian;
			if (!isEndian(tmpendian)) {
				throw new Error('invalid node list at FloatType::endian');
			}
			n.endian = tmpendian;
			const tmpis_common_supported = on.body?.is_common_supported;
			if (typeof tmpis_common_supported !== "boolean") {
				throw new Error('invalid node list at FloatType::is_common_supported');
			}
			n.is_common_supported = on.body.is_common_supported;
			break;
		}
		case "ident_type": {
			const n :IdentType = cnode as IdentType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof tmpis_explicit !== "boolean") {
				throw new Error('invalid node list at IdentType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpnon_dynamic_allocation = on.body?.non_dynamic_allocation;
			if (typeof tmpnon_dynamic_allocation !== "boolean") {
				throw new Error('invalid node list at IdentType::non_dynamic_allocation');
			}
			n.non_dynamic_allocation = on.body.non_dynamic_allocation;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at IdentType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (tmpbit_size !== null && typeof tmpbit_size !== "number") {
				throw new Error('invalid node list at IdentType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			if (on.body?.import_ref !== null && typeof on.body?.import_ref !== 'number') {
				throw new Error('invalid node list at IdentType::import_ref');
			}
			const tmpimport_ref = on.body.import_ref === null ? null : c.node[on.body.import_ref];
			if (!(tmpimport_ref === null || isMemberAccess(tmpimport_ref))) {
				throw new Error('invalid node list at IdentType::import_ref');
			}
			n.import_ref = tmpimport_ref;
			if (on.body?.ident !== null && typeof on.body?.ident !== 'number') {
				throw new Error('invalid node list at IdentType::ident');
			}
			const tmpident = on.body.ident === null ? null : c.node[on.body.ident];
			if (!(tmpident === null || isIdent(tmpident))) {
				throw new Error('invalid node list at IdentType::ident');
			}
			n.ident = tmpident;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at IdentType::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isType(tmpbase))) {
				throw new Error('invalid node list at IdentType::base');
			}
			n.base = tmpbase;
			break;
		}
		case "int_literal_type": {
			const n :IntLiteralType = cnode as IntLiteralType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof tmpis_explicit !== "boolean") {
				throw new Error('invalid node list at IntLiteralType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpnon_dynamic_allocation = on.body?.non_dynamic_allocation;
			if (typeof tmpnon_dynamic_allocation !== "boolean") {
				throw new Error('invalid node list at IntLiteralType::non_dynamic_allocation');
			}
			n.non_dynamic_allocation = on.body.non_dynamic_allocation;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at IntLiteralType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (tmpbit_size !== null && typeof tmpbit_size !== "number") {
				throw new Error('invalid node list at IntLiteralType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at IntLiteralType::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isIntLiteral(tmpbase))) {
				throw new Error('invalid node list at IntLiteralType::base');
			}
			n.base = tmpbase;
			break;
		}
		case "str_literal_type": {
			const n :StrLiteralType = cnode as StrLiteralType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof tmpis_explicit !== "boolean") {
				throw new Error('invalid node list at StrLiteralType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpnon_dynamic_allocation = on.body?.non_dynamic_allocation;
			if (typeof tmpnon_dynamic_allocation !== "boolean") {
				throw new Error('invalid node list at StrLiteralType::non_dynamic_allocation');
			}
			n.non_dynamic_allocation = on.body.non_dynamic_allocation;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at StrLiteralType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (tmpbit_size !== null && typeof tmpbit_size !== "number") {
				throw new Error('invalid node list at StrLiteralType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at StrLiteralType::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isStrLiteral(tmpbase))) {
				throw new Error('invalid node list at StrLiteralType::base');
			}
			n.base = tmpbase;
			if (on.body?.strong_ref !== null && typeof on.body?.strong_ref !== 'number') {
				throw new Error('invalid node list at StrLiteralType::strong_ref');
			}
			const tmpstrong_ref = on.body.strong_ref === null ? null : c.node[on.body.strong_ref];
			if (!(tmpstrong_ref === null || isStrLiteral(tmpstrong_ref))) {
				throw new Error('invalid node list at StrLiteralType::strong_ref');
			}
			n.strong_ref = tmpstrong_ref;
			break;
		}
		case "regex_literal_type": {
			const n :RegexLiteralType = cnode as RegexLiteralType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof tmpis_explicit !== "boolean") {
				throw new Error('invalid node list at RegexLiteralType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpnon_dynamic_allocation = on.body?.non_dynamic_allocation;
			if (typeof tmpnon_dynamic_allocation !== "boolean") {
				throw new Error('invalid node list at RegexLiteralType::non_dynamic_allocation');
			}
			n.non_dynamic_allocation = on.body.non_dynamic_allocation;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at RegexLiteralType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (tmpbit_size !== null && typeof tmpbit_size !== "number") {
				throw new Error('invalid node list at RegexLiteralType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at RegexLiteralType::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isRegexLiteral(tmpbase))) {
				throw new Error('invalid node list at RegexLiteralType::base');
			}
			n.base = tmpbase;
			if (on.body?.strong_ref !== null && typeof on.body?.strong_ref !== 'number') {
				throw new Error('invalid node list at RegexLiteralType::strong_ref');
			}
			const tmpstrong_ref = on.body.strong_ref === null ? null : c.node[on.body.strong_ref];
			if (!(tmpstrong_ref === null || isRegexLiteral(tmpstrong_ref))) {
				throw new Error('invalid node list at RegexLiteralType::strong_ref');
			}
			n.strong_ref = tmpstrong_ref;
			break;
		}
		case "void_type": {
			const n :VoidType = cnode as VoidType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof tmpis_explicit !== "boolean") {
				throw new Error('invalid node list at VoidType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpnon_dynamic_allocation = on.body?.non_dynamic_allocation;
			if (typeof tmpnon_dynamic_allocation !== "boolean") {
				throw new Error('invalid node list at VoidType::non_dynamic_allocation');
			}
			n.non_dynamic_allocation = on.body.non_dynamic_allocation;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at VoidType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (tmpbit_size !== null && typeof tmpbit_size !== "number") {
				throw new Error('invalid node list at VoidType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			break;
		}
		case "bool_type": {
			const n :BoolType = cnode as BoolType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof tmpis_explicit !== "boolean") {
				throw new Error('invalid node list at BoolType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpnon_dynamic_allocation = on.body?.non_dynamic_allocation;
			if (typeof tmpnon_dynamic_allocation !== "boolean") {
				throw new Error('invalid node list at BoolType::non_dynamic_allocation');
			}
			n.non_dynamic_allocation = on.body.non_dynamic_allocation;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at BoolType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (tmpbit_size !== null && typeof tmpbit_size !== "number") {
				throw new Error('invalid node list at BoolType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			break;
		}
		case "array_type": {
			const n :ArrayType = cnode as ArrayType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof tmpis_explicit !== "boolean") {
				throw new Error('invalid node list at ArrayType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpnon_dynamic_allocation = on.body?.non_dynamic_allocation;
			if (typeof tmpnon_dynamic_allocation !== "boolean") {
				throw new Error('invalid node list at ArrayType::non_dynamic_allocation');
			}
			n.non_dynamic_allocation = on.body.non_dynamic_allocation;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at ArrayType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (tmpbit_size !== null && typeof tmpbit_size !== "number") {
				throw new Error('invalid node list at ArrayType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			const tmpend_loc = on.body?.end_loc;
			if (!isLoc(tmpend_loc)) {
				throw new Error('invalid node list at ArrayType::end_loc');
			}
			n.end_loc = tmpend_loc;
			if (on.body?.element_type !== null && typeof on.body?.element_type !== 'number') {
				throw new Error('invalid node list at ArrayType::element_type');
			}
			const tmpelement_type = on.body.element_type === null ? null : c.node[on.body.element_type];
			if (!(tmpelement_type === null || isType(tmpelement_type))) {
				throw new Error('invalid node list at ArrayType::element_type');
			}
			n.element_type = tmpelement_type;
			if (on.body?.length !== null && typeof on.body?.length !== 'number') {
				throw new Error('invalid node list at ArrayType::length');
			}
			const tmplength = on.body.length === null ? null : c.node[on.body.length];
			if (!(tmplength === null || isExpr(tmplength))) {
				throw new Error('invalid node list at ArrayType::length');
			}
			n.length = tmplength;
			const tmplength_value = on.body?.length_value;
			if (tmplength_value !== null && typeof tmplength_value !== "number") {
				throw new Error('invalid node list at ArrayType::length_value');
			}
			n.length_value = on.body.length_value;
			const tmpis_bytes = on.body?.is_bytes;
			if (typeof tmpis_bytes !== "boolean") {
				throw new Error('invalid node list at ArrayType::is_bytes');
			}
			n.is_bytes = on.body.is_bytes;
			break;
		}
		case "function_type": {
			const n :FunctionType = cnode as FunctionType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof tmpis_explicit !== "boolean") {
				throw new Error('invalid node list at FunctionType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpnon_dynamic_allocation = on.body?.non_dynamic_allocation;
			if (typeof tmpnon_dynamic_allocation !== "boolean") {
				throw new Error('invalid node list at FunctionType::non_dynamic_allocation');
			}
			n.non_dynamic_allocation = on.body.non_dynamic_allocation;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at FunctionType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (tmpbit_size !== null && typeof tmpbit_size !== "number") {
				throw new Error('invalid node list at FunctionType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			if (on.body?.return_type !== null && typeof on.body?.return_type !== 'number') {
				throw new Error('invalid node list at FunctionType::return_type');
			}
			const tmpreturn_type = on.body.return_type === null ? null : c.node[on.body.return_type];
			if (!(tmpreturn_type === null || isType(tmpreturn_type))) {
				throw new Error('invalid node list at FunctionType::return_type');
			}
			n.return_type = tmpreturn_type;
			for (const o of on.body.parameters) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at FunctionType::parameters');
				}
				const tmpparameters = c.node[o];
				if (!isType(tmpparameters)) {
					throw new Error('invalid node list at FunctionType::parameters');
				}
				n.parameters.push(tmpparameters);
			}
			break;
		}
		case "struct_type": {
			const n :StructType = cnode as StructType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof tmpis_explicit !== "boolean") {
				throw new Error('invalid node list at StructType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpnon_dynamic_allocation = on.body?.non_dynamic_allocation;
			if (typeof tmpnon_dynamic_allocation !== "boolean") {
				throw new Error('invalid node list at StructType::non_dynamic_allocation');
			}
			n.non_dynamic_allocation = on.body.non_dynamic_allocation;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at StructType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (tmpbit_size !== null && typeof tmpbit_size !== "number") {
				throw new Error('invalid node list at StructType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			for (const o of on.body.fields) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at StructType::fields');
				}
				const tmpfields = c.node[o];
				if (!isMember(tmpfields)) {
					throw new Error('invalid node list at StructType::fields');
				}
				n.fields.push(tmpfields);
			}
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at StructType::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isNode(tmpbase))) {
				throw new Error('invalid node list at StructType::base');
			}
			n.base = tmpbase;
			const tmprecursive = on.body?.recursive;
			if (typeof tmprecursive !== "boolean") {
				throw new Error('invalid node list at StructType::recursive');
			}
			n.recursive = on.body.recursive;
			const tmpfixed_header_size = on.body?.fixed_header_size;
			if (typeof tmpfixed_header_size !== "number") {
				throw new Error('invalid node list at StructType::fixed_header_size');
			}
			n.fixed_header_size = on.body.fixed_header_size;
			const tmpfixed_tail_size = on.body?.fixed_tail_size;
			if (typeof tmpfixed_tail_size !== "number") {
				throw new Error('invalid node list at StructType::fixed_tail_size');
			}
			n.fixed_tail_size = on.body.fixed_tail_size;
			if (on.body?.type_map !== null && typeof on.body?.type_map !== 'number') {
				throw new Error('invalid node list at StructType::type_map');
			}
			const tmptype_map = on.body.type_map === null ? null : c.node[on.body.type_map];
			if (!(tmptype_map === null || isTypeLiteral(tmptype_map))) {
				throw new Error('invalid node list at StructType::type_map');
			}
			n.type_map = tmptype_map;
			break;
		}
		case "struct_union_type": {
			const n :StructUnionType = cnode as StructUnionType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof tmpis_explicit !== "boolean") {
				throw new Error('invalid node list at StructUnionType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpnon_dynamic_allocation = on.body?.non_dynamic_allocation;
			if (typeof tmpnon_dynamic_allocation !== "boolean") {
				throw new Error('invalid node list at StructUnionType::non_dynamic_allocation');
			}
			n.non_dynamic_allocation = on.body.non_dynamic_allocation;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at StructUnionType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (tmpbit_size !== null && typeof tmpbit_size !== "number") {
				throw new Error('invalid node list at StructUnionType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list at StructUnionType::cond');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isIdentity(tmpcond))) {
				throw new Error('invalid node list at StructUnionType::cond');
			}
			n.cond = tmpcond;
			for (const o of on.body.conds) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at StructUnionType::conds');
				}
				const tmpconds = c.node[o];
				if (!isExpr(tmpconds)) {
					throw new Error('invalid node list at StructUnionType::conds');
				}
				n.conds.push(tmpconds);
			}
			for (const o of on.body.structs) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at StructUnionType::structs');
				}
				const tmpstructs = c.node[o];
				if (!isStructType(tmpstructs)) {
					throw new Error('invalid node list at StructUnionType::structs');
				}
				n.structs.push(tmpstructs);
			}
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at StructUnionType::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isExpr(tmpbase))) {
				throw new Error('invalid node list at StructUnionType::base');
			}
			n.base = tmpbase;
			for (const o of on.body.union_fields) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at StructUnionType::union_fields');
				}
				const tmpunion_fields = c.node[o];
				if (!isField(tmpunion_fields)) {
					throw new Error('invalid node list at StructUnionType::union_fields');
				}
				n.union_fields.push(tmpunion_fields);
			}
			const tmpexhaustive = on.body?.exhaustive;
			if (typeof tmpexhaustive !== "boolean") {
				throw new Error('invalid node list at StructUnionType::exhaustive');
			}
			n.exhaustive = on.body.exhaustive;
			break;
		}
		case "union_type": {
			const n :UnionType = cnode as UnionType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof tmpis_explicit !== "boolean") {
				throw new Error('invalid node list at UnionType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpnon_dynamic_allocation = on.body?.non_dynamic_allocation;
			if (typeof tmpnon_dynamic_allocation !== "boolean") {
				throw new Error('invalid node list at UnionType::non_dynamic_allocation');
			}
			n.non_dynamic_allocation = on.body.non_dynamic_allocation;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at UnionType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (tmpbit_size !== null && typeof tmpbit_size !== "number") {
				throw new Error('invalid node list at UnionType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list at UnionType::cond');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isExpr(tmpcond))) {
				throw new Error('invalid node list at UnionType::cond');
			}
			n.cond = tmpcond;
			for (const o of on.body.candidates) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at UnionType::candidates');
				}
				const tmpcandidates = c.node[o];
				if (!isUnionCandidate(tmpcandidates)) {
					throw new Error('invalid node list at UnionType::candidates');
				}
				n.candidates.push(tmpcandidates);
			}
			if (on.body?.base_type !== null && typeof on.body?.base_type !== 'number') {
				throw new Error('invalid node list at UnionType::base_type');
			}
			const tmpbase_type = on.body.base_type === null ? null : c.node[on.body.base_type];
			if (!(tmpbase_type === null || isStructUnionType(tmpbase_type))) {
				throw new Error('invalid node list at UnionType::base_type');
			}
			n.base_type = tmpbase_type;
			if (on.body?.common_type !== null && typeof on.body?.common_type !== 'number') {
				throw new Error('invalid node list at UnionType::common_type');
			}
			const tmpcommon_type = on.body.common_type === null ? null : c.node[on.body.common_type];
			if (!(tmpcommon_type === null || isType(tmpcommon_type))) {
				throw new Error('invalid node list at UnionType::common_type');
			}
			n.common_type = tmpcommon_type;
			for (const o of on.body.member_candidates) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at UnionType::member_candidates');
				}
				const tmpmember_candidates = c.node[o];
				if (!isField(tmpmember_candidates)) {
					throw new Error('invalid node list at UnionType::member_candidates');
				}
				n.member_candidates.push(tmpmember_candidates);
			}
			break;
		}
		case "range_type": {
			const n :RangeType = cnode as RangeType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof tmpis_explicit !== "boolean") {
				throw new Error('invalid node list at RangeType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpnon_dynamic_allocation = on.body?.non_dynamic_allocation;
			if (typeof tmpnon_dynamic_allocation !== "boolean") {
				throw new Error('invalid node list at RangeType::non_dynamic_allocation');
			}
			n.non_dynamic_allocation = on.body.non_dynamic_allocation;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at RangeType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (tmpbit_size !== null && typeof tmpbit_size !== "number") {
				throw new Error('invalid node list at RangeType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			if (on.body?.base_type !== null && typeof on.body?.base_type !== 'number') {
				throw new Error('invalid node list at RangeType::base_type');
			}
			const tmpbase_type = on.body.base_type === null ? null : c.node[on.body.base_type];
			if (!(tmpbase_type === null || isType(tmpbase_type))) {
				throw new Error('invalid node list at RangeType::base_type');
			}
			n.base_type = tmpbase_type;
			if (on.body?.range !== null && typeof on.body?.range !== 'number') {
				throw new Error('invalid node list at RangeType::range');
			}
			const tmprange = on.body.range === null ? null : c.node[on.body.range];
			if (!(tmprange === null || isRange(tmprange))) {
				throw new Error('invalid node list at RangeType::range');
			}
			n.range = tmprange;
			break;
		}
		case "enum_type": {
			const n :EnumType = cnode as EnumType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof tmpis_explicit !== "boolean") {
				throw new Error('invalid node list at EnumType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpnon_dynamic_allocation = on.body?.non_dynamic_allocation;
			if (typeof tmpnon_dynamic_allocation !== "boolean") {
				throw new Error('invalid node list at EnumType::non_dynamic_allocation');
			}
			n.non_dynamic_allocation = on.body.non_dynamic_allocation;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at EnumType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (tmpbit_size !== null && typeof tmpbit_size !== "number") {
				throw new Error('invalid node list at EnumType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at EnumType::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isEnum(tmpbase))) {
				throw new Error('invalid node list at EnumType::base');
			}
			n.base = tmpbase;
			break;
		}
		case "meta_type": {
			const n :MetaType = cnode as MetaType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof tmpis_explicit !== "boolean") {
				throw new Error('invalid node list at MetaType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpnon_dynamic_allocation = on.body?.non_dynamic_allocation;
			if (typeof tmpnon_dynamic_allocation !== "boolean") {
				throw new Error('invalid node list at MetaType::non_dynamic_allocation');
			}
			n.non_dynamic_allocation = on.body.non_dynamic_allocation;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at MetaType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (tmpbit_size !== null && typeof tmpbit_size !== "number") {
				throw new Error('invalid node list at MetaType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			break;
		}
		case "optional_type": {
			const n :OptionalType = cnode as OptionalType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof tmpis_explicit !== "boolean") {
				throw new Error('invalid node list at OptionalType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpnon_dynamic_allocation = on.body?.non_dynamic_allocation;
			if (typeof tmpnon_dynamic_allocation !== "boolean") {
				throw new Error('invalid node list at OptionalType::non_dynamic_allocation');
			}
			n.non_dynamic_allocation = on.body.non_dynamic_allocation;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at OptionalType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (tmpbit_size !== null && typeof tmpbit_size !== "number") {
				throw new Error('invalid node list at OptionalType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			if (on.body?.base_type !== null && typeof on.body?.base_type !== 'number') {
				throw new Error('invalid node list at OptionalType::base_type');
			}
			const tmpbase_type = on.body.base_type === null ? null : c.node[on.body.base_type];
			if (!(tmpbase_type === null || isType(tmpbase_type))) {
				throw new Error('invalid node list at OptionalType::base_type');
			}
			n.base_type = tmpbase_type;
			break;
		}
		case "generic_type": {
			const n :GenericType = cnode as GenericType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof tmpis_explicit !== "boolean") {
				throw new Error('invalid node list at GenericType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpnon_dynamic_allocation = on.body?.non_dynamic_allocation;
			if (typeof tmpnon_dynamic_allocation !== "boolean") {
				throw new Error('invalid node list at GenericType::non_dynamic_allocation');
			}
			n.non_dynamic_allocation = on.body.non_dynamic_allocation;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at GenericType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (tmpbit_size !== null && typeof tmpbit_size !== "number") {
				throw new Error('invalid node list at GenericType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			if (on.body?.belong !== null && typeof on.body?.belong !== 'number') {
				throw new Error('invalid node list at GenericType::belong');
			}
			const tmpbelong = on.body.belong === null ? null : c.node[on.body.belong];
			if (!(tmpbelong === null || isMember(tmpbelong))) {
				throw new Error('invalid node list at GenericType::belong');
			}
			n.belong = tmpbelong;
			break;
		}
		case "int_literal": {
			const n :IntLiteral = cnode as IntLiteral;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at IntLiteral::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at IntLiteral::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at IntLiteral::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmpvalue = on.body?.value;
			if (typeof tmpvalue !== "string") {
				throw new Error('invalid node list at IntLiteral::value');
			}
			n.value = on.body.value;
			break;
		}
		case "bool_literal": {
			const n :BoolLiteral = cnode as BoolLiteral;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at BoolLiteral::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at BoolLiteral::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at BoolLiteral::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmpvalue = on.body?.value;
			if (typeof tmpvalue !== "boolean") {
				throw new Error('invalid node list at BoolLiteral::value');
			}
			n.value = on.body.value;
			break;
		}
		case "str_literal": {
			const n :StrLiteral = cnode as StrLiteral;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at StrLiteral::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at StrLiteral::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at StrLiteral::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmpvalue = on.body?.value;
			if (typeof tmpvalue !== "string") {
				throw new Error('invalid node list at StrLiteral::value');
			}
			n.value = on.body.value;
			const tmplength = on.body?.length;
			if (typeof tmplength !== "number") {
				throw new Error('invalid node list at StrLiteral::length');
			}
			n.length = on.body.length;
			break;
		}
		case "regex_literal": {
			const n :RegexLiteral = cnode as RegexLiteral;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at RegexLiteral::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at RegexLiteral::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at RegexLiteral::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmpvalue = on.body?.value;
			if (typeof tmpvalue !== "string") {
				throw new Error('invalid node list at RegexLiteral::value');
			}
			n.value = on.body.value;
			break;
		}
		case "char_literal": {
			const n :CharLiteral = cnode as CharLiteral;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at CharLiteral::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at CharLiteral::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at CharLiteral::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmpvalue = on.body?.value;
			if (typeof tmpvalue !== "string") {
				throw new Error('invalid node list at CharLiteral::value');
			}
			n.value = on.body.value;
			const tmpcode = on.body?.code;
			if (typeof tmpcode !== "number") {
				throw new Error('invalid node list at CharLiteral::code');
			}
			n.code = on.body.code;
			break;
		}
		case "type_literal": {
			const n :TypeLiteral = cnode as TypeLiteral;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at TypeLiteral::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at TypeLiteral::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at TypeLiteral::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.type_literal !== null && typeof on.body?.type_literal !== 'number') {
				throw new Error('invalid node list at TypeLiteral::type_literal');
			}
			const tmptype_literal = on.body.type_literal === null ? null : c.node[on.body.type_literal];
			if (!(tmptype_literal === null || isType(tmptype_literal))) {
				throw new Error('invalid node list at TypeLiteral::type_literal');
			}
			n.type_literal = tmptype_literal;
			const tmpend_loc = on.body?.end_loc;
			if (!isLoc(tmpend_loc)) {
				throw new Error('invalid node list at TypeLiteral::end_loc');
			}
			n.end_loc = tmpend_loc;
			break;
		}
		case "special_literal": {
			const n :SpecialLiteral = cnode as SpecialLiteral;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at SpecialLiteral::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at SpecialLiteral::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at SpecialLiteral::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmpkind = on.body?.kind;
			if (!isSpecialLiteralKind(tmpkind)) {
				throw new Error('invalid node list at SpecialLiteral::kind');
			}
			n.kind = tmpkind;
			break;
		}
		case "field": {
			const n :Field = cnode as Field;
			if (on.body?.belong !== null && typeof on.body?.belong !== 'number') {
				throw new Error('invalid node list at Field::belong');
			}
			const tmpbelong = on.body.belong === null ? null : c.node[on.body.belong];
			if (!(tmpbelong === null || isMember(tmpbelong))) {
				throw new Error('invalid node list at Field::belong');
			}
			n.belong = tmpbelong;
			if (on.body?.belong_struct !== null && typeof on.body?.belong_struct !== 'number') {
				throw new Error('invalid node list at Field::belong_struct');
			}
			const tmpbelong_struct = on.body.belong_struct === null ? null : c.node[on.body.belong_struct];
			if (!(tmpbelong_struct === null || isStructType(tmpbelong_struct))) {
				throw new Error('invalid node list at Field::belong_struct');
			}
			n.belong_struct = tmpbelong_struct;
			if (on.body?.ident !== null && typeof on.body?.ident !== 'number') {
				throw new Error('invalid node list at Field::ident');
			}
			const tmpident = on.body.ident === null ? null : c.node[on.body.ident];
			if (!(tmpident === null || isIdent(tmpident))) {
				throw new Error('invalid node list at Field::ident');
			}
			n.ident = tmpident;
			const tmpcolon_loc = on.body?.colon_loc;
			if (!isLoc(tmpcolon_loc)) {
				throw new Error('invalid node list at Field::colon_loc');
			}
			n.colon_loc = tmpcolon_loc;
			const tmpis_state_variable = on.body?.is_state_variable;
			if (typeof tmpis_state_variable !== "boolean") {
				throw new Error('invalid node list at Field::is_state_variable');
			}
			n.is_state_variable = on.body.is_state_variable;
			if (on.body?.field_type !== null && typeof on.body?.field_type !== 'number') {
				throw new Error('invalid node list at Field::field_type');
			}
			const tmpfield_type = on.body.field_type === null ? null : c.node[on.body.field_type];
			if (!(tmpfield_type === null || isType(tmpfield_type))) {
				throw new Error('invalid node list at Field::field_type');
			}
			n.field_type = tmpfield_type;
			if (on.body?.arguments !== null && typeof on.body?.arguments !== 'number') {
				throw new Error('invalid node list at Field::arguments');
			}
			const tmparguments = on.body.arguments === null ? null : c.node[on.body.arguments];
			if (!(tmparguments === null || isFieldArgument(tmparguments))) {
				throw new Error('invalid node list at Field::arguments');
			}
			n.arguments = tmparguments;
			const tmpoffset_bit = on.body?.offset_bit;
			if (tmpoffset_bit !== null && typeof tmpoffset_bit !== "number") {
				throw new Error('invalid node list at Field::offset_bit');
			}
			n.offset_bit = on.body.offset_bit;
			const tmpoffset_recent = on.body?.offset_recent;
			if (typeof tmpoffset_recent !== "number") {
				throw new Error('invalid node list at Field::offset_recent');
			}
			n.offset_recent = on.body.offset_recent;
			const tmptail_offset_bit = on.body?.tail_offset_bit;
			if (tmptail_offset_bit !== null && typeof tmptail_offset_bit !== "number") {
				throw new Error('invalid node list at Field::tail_offset_bit');
			}
			n.tail_offset_bit = on.body.tail_offset_bit;
			const tmptail_offset_recent = on.body?.tail_offset_recent;
			if (typeof tmptail_offset_recent !== "number") {
				throw new Error('invalid node list at Field::tail_offset_recent');
			}
			n.tail_offset_recent = on.body.tail_offset_recent;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at Field::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpeventual_bit_alignment = on.body?.eventual_bit_alignment;
			if (!isBitAlignment(tmpeventual_bit_alignment)) {
				throw new Error('invalid node list at Field::eventual_bit_alignment');
			}
			n.eventual_bit_alignment = tmpeventual_bit_alignment;
			const tmpfollow = on.body?.follow;
			if (!isFollow(tmpfollow)) {
				throw new Error('invalid node list at Field::follow');
			}
			n.follow = tmpfollow;
			const tmpeventual_follow = on.body?.eventual_follow;
			if (!isFollow(tmpeventual_follow)) {
				throw new Error('invalid node list at Field::eventual_follow');
			}
			n.eventual_follow = tmpeventual_follow;
			if (on.body?.next !== null && typeof on.body?.next !== 'number') {
				throw new Error('invalid node list at Field::next');
			}
			const tmpnext = on.body.next === null ? null : c.node[on.body.next];
			if (!(tmpnext === null || isField(tmpnext))) {
				throw new Error('invalid node list at Field::next');
			}
			n.next = tmpnext;
			break;
		}
		case "format": {
			const n :Format = cnode as Format;
			if (on.body?.belong !== null && typeof on.body?.belong !== 'number') {
				throw new Error('invalid node list at Format::belong');
			}
			const tmpbelong = on.body.belong === null ? null : c.node[on.body.belong];
			if (!(tmpbelong === null || isMember(tmpbelong))) {
				throw new Error('invalid node list at Format::belong');
			}
			n.belong = tmpbelong;
			if (on.body?.belong_struct !== null && typeof on.body?.belong_struct !== 'number') {
				throw new Error('invalid node list at Format::belong_struct');
			}
			const tmpbelong_struct = on.body.belong_struct === null ? null : c.node[on.body.belong_struct];
			if (!(tmpbelong_struct === null || isStructType(tmpbelong_struct))) {
				throw new Error('invalid node list at Format::belong_struct');
			}
			n.belong_struct = tmpbelong_struct;
			if (on.body?.ident !== null && typeof on.body?.ident !== 'number') {
				throw new Error('invalid node list at Format::ident');
			}
			const tmpident = on.body.ident === null ? null : c.node[on.body.ident];
			if (!(tmpident === null || isIdent(tmpident))) {
				throw new Error('invalid node list at Format::ident');
			}
			n.ident = tmpident;
			if (on.body?.body !== null && typeof on.body?.body !== 'number') {
				throw new Error('invalid node list at Format::body');
			}
			const tmpbody = on.body.body === null ? null : c.node[on.body.body];
			if (!(tmpbody === null || isIndentBlock(tmpbody))) {
				throw new Error('invalid node list at Format::body');
			}
			n.body = tmpbody;
			if (on.body?.encode_fn !== null && typeof on.body?.encode_fn !== 'number') {
				throw new Error('invalid node list at Format::encode_fn');
			}
			const tmpencode_fn = on.body.encode_fn === null ? null : c.node[on.body.encode_fn];
			if (!(tmpencode_fn === null || isFunction(tmpencode_fn))) {
				throw new Error('invalid node list at Format::encode_fn');
			}
			n.encode_fn = tmpencode_fn;
			if (on.body?.decode_fn !== null && typeof on.body?.decode_fn !== 'number') {
				throw new Error('invalid node list at Format::decode_fn');
			}
			const tmpdecode_fn = on.body.decode_fn === null ? null : c.node[on.body.decode_fn];
			if (!(tmpdecode_fn === null || isFunction(tmpdecode_fn))) {
				throw new Error('invalid node list at Format::decode_fn');
			}
			n.decode_fn = tmpdecode_fn;
			for (const o of on.body.cast_fns) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at Format::cast_fns');
				}
				const tmpcast_fns = c.node[o];
				if (!isFunction(tmpcast_fns)) {
					throw new Error('invalid node list at Format::cast_fns');
				}
				n.cast_fns.push(tmpcast_fns);
			}
			for (const o of on.body.depends) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at Format::depends');
				}
				const tmpdepends = c.node[o];
				if (!isIdentType(tmpdepends)) {
					throw new Error('invalid node list at Format::depends');
				}
				n.depends.push(tmpdepends);
			}
			for (const o of on.body.state_variables) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at Format::state_variables');
				}
				const tmpstate_variables = c.node[o];
				if (!isField(tmpstate_variables)) {
					throw new Error('invalid node list at Format::state_variables');
				}
				n.state_variables.push(tmpstate_variables);
			}
			break;
		}
		case "state": {
			const n :State = cnode as State;
			if (on.body?.belong !== null && typeof on.body?.belong !== 'number') {
				throw new Error('invalid node list at State::belong');
			}
			const tmpbelong = on.body.belong === null ? null : c.node[on.body.belong];
			if (!(tmpbelong === null || isMember(tmpbelong))) {
				throw new Error('invalid node list at State::belong');
			}
			n.belong = tmpbelong;
			if (on.body?.belong_struct !== null && typeof on.body?.belong_struct !== 'number') {
				throw new Error('invalid node list at State::belong_struct');
			}
			const tmpbelong_struct = on.body.belong_struct === null ? null : c.node[on.body.belong_struct];
			if (!(tmpbelong_struct === null || isStructType(tmpbelong_struct))) {
				throw new Error('invalid node list at State::belong_struct');
			}
			n.belong_struct = tmpbelong_struct;
			if (on.body?.ident !== null && typeof on.body?.ident !== 'number') {
				throw new Error('invalid node list at State::ident');
			}
			const tmpident = on.body.ident === null ? null : c.node[on.body.ident];
			if (!(tmpident === null || isIdent(tmpident))) {
				throw new Error('invalid node list at State::ident');
			}
			n.ident = tmpident;
			if (on.body?.body !== null && typeof on.body?.body !== 'number') {
				throw new Error('invalid node list at State::body');
			}
			const tmpbody = on.body.body === null ? null : c.node[on.body.body];
			if (!(tmpbody === null || isIndentBlock(tmpbody))) {
				throw new Error('invalid node list at State::body');
			}
			n.body = tmpbody;
			break;
		}
		case "enum": {
			const n :Enum = cnode as Enum;
			if (on.body?.belong !== null && typeof on.body?.belong !== 'number') {
				throw new Error('invalid node list at Enum::belong');
			}
			const tmpbelong = on.body.belong === null ? null : c.node[on.body.belong];
			if (!(tmpbelong === null || isMember(tmpbelong))) {
				throw new Error('invalid node list at Enum::belong');
			}
			n.belong = tmpbelong;
			if (on.body?.belong_struct !== null && typeof on.body?.belong_struct !== 'number') {
				throw new Error('invalid node list at Enum::belong_struct');
			}
			const tmpbelong_struct = on.body.belong_struct === null ? null : c.node[on.body.belong_struct];
			if (!(tmpbelong_struct === null || isStructType(tmpbelong_struct))) {
				throw new Error('invalid node list at Enum::belong_struct');
			}
			n.belong_struct = tmpbelong_struct;
			if (on.body?.ident !== null && typeof on.body?.ident !== 'number') {
				throw new Error('invalid node list at Enum::ident');
			}
			const tmpident = on.body.ident === null ? null : c.node[on.body.ident];
			if (!(tmpident === null || isIdent(tmpident))) {
				throw new Error('invalid node list at Enum::ident');
			}
			n.ident = tmpident;
			if (on.body?.scope !== null && typeof on.body?.scope !== 'number') {
				throw new Error('invalid node list at Enum::scope');
			}
			const tmpscope = on.body.scope === null ? null : c.scope[on.body.scope];
			if (tmpscope !== null && !isScope(tmpscope)) {
				throw new Error('invalid node list at Enum::scope');
			}
			n.scope = tmpscope;
			const tmpcolon_loc = on.body?.colon_loc;
			if (!isLoc(tmpcolon_loc)) {
				throw new Error('invalid node list at Enum::colon_loc');
			}
			n.colon_loc = tmpcolon_loc;
			if (on.body?.base_type !== null && typeof on.body?.base_type !== 'number') {
				throw new Error('invalid node list at Enum::base_type');
			}
			const tmpbase_type = on.body.base_type === null ? null : c.node[on.body.base_type];
			if (!(tmpbase_type === null || isType(tmpbase_type))) {
				throw new Error('invalid node list at Enum::base_type');
			}
			n.base_type = tmpbase_type;
			for (const o of on.body.members) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at Enum::members');
				}
				const tmpmembers = c.node[o];
				if (!isEnumMember(tmpmembers)) {
					throw new Error('invalid node list at Enum::members');
				}
				n.members.push(tmpmembers);
			}
			if (on.body?.enum_type !== null && typeof on.body?.enum_type !== 'number') {
				throw new Error('invalid node list at Enum::enum_type');
			}
			const tmpenum_type = on.body.enum_type === null ? null : c.node[on.body.enum_type];
			if (!(tmpenum_type === null || isEnumType(tmpenum_type))) {
				throw new Error('invalid node list at Enum::enum_type');
			}
			n.enum_type = tmpenum_type;
			break;
		}
		case "enum_member": {
			const n :EnumMember = cnode as EnumMember;
			if (on.body?.belong !== null && typeof on.body?.belong !== 'number') {
				throw new Error('invalid node list at EnumMember::belong');
			}
			const tmpbelong = on.body.belong === null ? null : c.node[on.body.belong];
			if (!(tmpbelong === null || isMember(tmpbelong))) {
				throw new Error('invalid node list at EnumMember::belong');
			}
			n.belong = tmpbelong;
			if (on.body?.belong_struct !== null && typeof on.body?.belong_struct !== 'number') {
				throw new Error('invalid node list at EnumMember::belong_struct');
			}
			const tmpbelong_struct = on.body.belong_struct === null ? null : c.node[on.body.belong_struct];
			if (!(tmpbelong_struct === null || isStructType(tmpbelong_struct))) {
				throw new Error('invalid node list at EnumMember::belong_struct');
			}
			n.belong_struct = tmpbelong_struct;
			if (on.body?.ident !== null && typeof on.body?.ident !== 'number') {
				throw new Error('invalid node list at EnumMember::ident');
			}
			const tmpident = on.body.ident === null ? null : c.node[on.body.ident];
			if (!(tmpident === null || isIdent(tmpident))) {
				throw new Error('invalid node list at EnumMember::ident');
			}
			n.ident = tmpident;
			if (on.body?.raw_expr !== null && typeof on.body?.raw_expr !== 'number') {
				throw new Error('invalid node list at EnumMember::raw_expr');
			}
			const tmpraw_expr = on.body.raw_expr === null ? null : c.node[on.body.raw_expr];
			if (!(tmpraw_expr === null || isExpr(tmpraw_expr))) {
				throw new Error('invalid node list at EnumMember::raw_expr');
			}
			n.raw_expr = tmpraw_expr;
			if (on.body?.value !== null && typeof on.body?.value !== 'number') {
				throw new Error('invalid node list at EnumMember::value');
			}
			const tmpvalue = on.body.value === null ? null : c.node[on.body.value];
			if (!(tmpvalue === null || isExpr(tmpvalue))) {
				throw new Error('invalid node list at EnumMember::value');
			}
			n.value = tmpvalue;
			if (on.body?.str_literal !== null && typeof on.body?.str_literal !== 'number') {
				throw new Error('invalid node list at EnumMember::str_literal');
			}
			const tmpstr_literal = on.body.str_literal === null ? null : c.node[on.body.str_literal];
			if (!(tmpstr_literal === null || isStrLiteral(tmpstr_literal))) {
				throw new Error('invalid node list at EnumMember::str_literal');
			}
			n.str_literal = tmpstr_literal;
			break;
		}
		case "function": {
			const n :Function = cnode as Function;
			if (on.body?.belong !== null && typeof on.body?.belong !== 'number') {
				throw new Error('invalid node list at Function::belong');
			}
			const tmpbelong = on.body.belong === null ? null : c.node[on.body.belong];
			if (!(tmpbelong === null || isMember(tmpbelong))) {
				throw new Error('invalid node list at Function::belong');
			}
			n.belong = tmpbelong;
			if (on.body?.belong_struct !== null && typeof on.body?.belong_struct !== 'number') {
				throw new Error('invalid node list at Function::belong_struct');
			}
			const tmpbelong_struct = on.body.belong_struct === null ? null : c.node[on.body.belong_struct];
			if (!(tmpbelong_struct === null || isStructType(tmpbelong_struct))) {
				throw new Error('invalid node list at Function::belong_struct');
			}
			n.belong_struct = tmpbelong_struct;
			if (on.body?.ident !== null && typeof on.body?.ident !== 'number') {
				throw new Error('invalid node list at Function::ident');
			}
			const tmpident = on.body.ident === null ? null : c.node[on.body.ident];
			if (!(tmpident === null || isIdent(tmpident))) {
				throw new Error('invalid node list at Function::ident');
			}
			n.ident = tmpident;
			for (const o of on.body.parameters) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at Function::parameters');
				}
				const tmpparameters = c.node[o];
				if (!isField(tmpparameters)) {
					throw new Error('invalid node list at Function::parameters');
				}
				n.parameters.push(tmpparameters);
			}
			if (on.body?.return_type !== null && typeof on.body?.return_type !== 'number') {
				throw new Error('invalid node list at Function::return_type');
			}
			const tmpreturn_type = on.body.return_type === null ? null : c.node[on.body.return_type];
			if (!(tmpreturn_type === null || isType(tmpreturn_type))) {
				throw new Error('invalid node list at Function::return_type');
			}
			n.return_type = tmpreturn_type;
			if (on.body?.body !== null && typeof on.body?.body !== 'number') {
				throw new Error('invalid node list at Function::body');
			}
			const tmpbody = on.body.body === null ? null : c.node[on.body.body];
			if (!(tmpbody === null || isIndentBlock(tmpbody))) {
				throw new Error('invalid node list at Function::body');
			}
			n.body = tmpbody;
			if (on.body?.func_type !== null && typeof on.body?.func_type !== 'number') {
				throw new Error('invalid node list at Function::func_type');
			}
			const tmpfunc_type = on.body.func_type === null ? null : c.node[on.body.func_type];
			if (!(tmpfunc_type === null || isFunctionType(tmpfunc_type))) {
				throw new Error('invalid node list at Function::func_type');
			}
			n.func_type = tmpfunc_type;
			const tmpis_cast = on.body?.is_cast;
			if (typeof tmpis_cast !== "boolean") {
				throw new Error('invalid node list at Function::is_cast');
			}
			n.is_cast = on.body.is_cast;
			break;
		}
		}
	}
	for (let i = 0; i < o.scope.length; i++) {
		const os = o.scope[i];
		const cscope = c.scope[i];
		if (os.prev !== null && typeof os.prev !== 'number') {
			throw new Error('invalid node list at Scope::prev');
		}
		const tmpprev = os.prev === null ? null : c.scope[os.prev];
		if (tmpprev !== null && !isScope(tmpprev)) {
			throw new Error('invalid node list at Scope::prev');
		}
		cscope.prev = tmpprev;
		if (os.next !== null && typeof os.next !== 'number') {
			throw new Error('invalid node list at Scope::next');
		}
		const tmpnext = os.next === null ? null : c.scope[os.next];
		if (tmpnext !== null && !isScope(tmpnext)) {
			throw new Error('invalid node list at Scope::next');
		}
		cscope.next = tmpnext;
		if (os.branch !== null && typeof os.branch !== 'number') {
			throw new Error('invalid node list at Scope::branch');
		}
		const tmpbranch = os.branch === null ? null : c.scope[os.branch];
		if (tmpbranch !== null && !isScope(tmpbranch)) {
			throw new Error('invalid node list at Scope::branch');
		}
		cscope.branch = tmpbranch;
		for (const o of os.ident) {
			if (typeof o !== 'number') {
				throw new Error('invalid node list at Scope::ident');
			}
			const tmpident = c.node[o];
			if (!isIdent(tmpident)) {
				throw new Error('invalid node list at Scope::ident');
			}
			cscope.ident.push(tmpident);
		}
		cscope.branch_root = os.branch_root;
	}
	const root = c.node[0];
	if (!isProgram(root)) {
		throw new Error('invalid node list at node[0]');
	}
	return root;
}

export type VisitFn<T> = (f: VisitFn<T>, arg: T) => void|undefined|boolean;

export function walk(node: Node, fn: VisitFn<Node>) {
	switch (node.node_type) {
		case "program": {
			if (!isProgram(node)) {
				break;
			}
			const n :Program = node as Program;
			if (n.struct_type !== null) {
				const result = fn(fn,n.struct_type);
				if (result === false) {
					return;
				}
			}
			for (const e of n.elements) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "comment": {
			if (!isComment(node)) {
				break;
			}
			const n :Comment = node as Comment;
			break;
		}
		case "comment_group": {
			if (!isCommentGroup(node)) {
				break;
			}
			const n :CommentGroup = node as CommentGroup;
			for (const e of n.comments) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "field_argument": {
			if (!isFieldArgument(node)) {
				break;
			}
			const n :FieldArgument = node as FieldArgument;
			if (n.raw_arguments !== null) {
				const result = fn(fn,n.raw_arguments);
				if (result === false) {
					return;
				}
			}
			for (const e of n.arguments) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			for (const e of n.assigns) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			if (n.alignment !== null) {
				const result = fn(fn,n.alignment);
				if (result === false) {
					return;
				}
			}
			if (n.sub_byte_length !== null) {
				const result = fn(fn,n.sub_byte_length);
				if (result === false) {
					return;
				}
			}
			if (n.sub_byte_begin !== null) {
				const result = fn(fn,n.sub_byte_begin);
				if (result === false) {
					return;
				}
			}
			if (n.peek !== null) {
				const result = fn(fn,n.peek);
				if (result === false) {
					return;
				}
			}
			if (n.type_map !== null) {
				const result = fn(fn,n.type_map);
				if (result === false) {
					return;
				}
			}
			for (const e of n.metadata) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "binary": {
			if (!isBinary(node)) {
				break;
			}
			const n :Binary = node as Binary;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.left !== null) {
				const result = fn(fn,n.left);
				if (result === false) {
					return;
				}
			}
			if (n.right !== null) {
				const result = fn(fn,n.right);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "unary": {
			if (!isUnary(node)) {
				break;
			}
			const n :Unary = node as Unary;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.expr !== null) {
				const result = fn(fn,n.expr);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "cond": {
			if (!isCond(node)) {
				break;
			}
			const n :Cond = node as Cond;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.cond !== null) {
				const result = fn(fn,n.cond);
				if (result === false) {
					return;
				}
			}
			if (n.then !== null) {
				const result = fn(fn,n.then);
				if (result === false) {
					return;
				}
			}
			if (n.els !== null) {
				const result = fn(fn,n.els);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "ident": {
			if (!isIdent(node)) {
				break;
			}
			const n :Ident = node as Ident;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "call": {
			if (!isCall(node)) {
				break;
			}
			const n :Call = node as Call;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.callee !== null) {
				const result = fn(fn,n.callee);
				if (result === false) {
					return;
				}
			}
			if (n.raw_arguments !== null) {
				const result = fn(fn,n.raw_arguments);
				if (result === false) {
					return;
				}
			}
			for (const e of n.arguments) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "if": {
			if (!isIf(node)) {
				break;
			}
			const n :If = node as If;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.struct_union_type !== null) {
				const result = fn(fn,n.struct_union_type);
				if (result === false) {
					return;
				}
			}
			if (n.cond !== null) {
				const result = fn(fn,n.cond);
				if (result === false) {
					return;
				}
			}
			if (n.then !== null) {
				const result = fn(fn,n.then);
				if (result === false) {
					return;
				}
			}
			if (n.els !== null) {
				const result = fn(fn,n.els);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "member_access": {
			if (!isMemberAccess(node)) {
				break;
			}
			const n :MemberAccess = node as MemberAccess;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.target !== null) {
				const result = fn(fn,n.target);
				if (result === false) {
					return;
				}
			}
			if (n.member !== null) {
				const result = fn(fn,n.member);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "paren": {
			if (!isParen(node)) {
				break;
			}
			const n :Paren = node as Paren;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.expr !== null) {
				const result = fn(fn,n.expr);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "index": {
			if (!isIndex(node)) {
				break;
			}
			const n :Index = node as Index;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.expr !== null) {
				const result = fn(fn,n.expr);
				if (result === false) {
					return;
				}
			}
			if (n.index !== null) {
				const result = fn(fn,n.index);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "match": {
			if (!isMatch(node)) {
				break;
			}
			const n :Match = node as Match;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.struct_union_type !== null) {
				const result = fn(fn,n.struct_union_type);
				if (result === false) {
					return;
				}
			}
			if (n.cond !== null) {
				const result = fn(fn,n.cond);
				if (result === false) {
					return;
				}
			}
			for (const e of n.branch) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "range": {
			if (!isRange(node)) {
				break;
			}
			const n :Range = node as Range;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.start !== null) {
				const result = fn(fn,n.start);
				if (result === false) {
					return;
				}
			}
			if (n.end !== null) {
				const result = fn(fn,n.end);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "identity": {
			if (!isIdentity(node)) {
				break;
			}
			const n :Identity = node as Identity;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.expr !== null) {
				const result = fn(fn,n.expr);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "tmp_var": {
			if (!isTmpVar(node)) {
				break;
			}
			const n :TmpVar = node as TmpVar;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "import": {
			if (!isImport(node)) {
				break;
			}
			const n :Import = node as Import;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.base !== null) {
				const result = fn(fn,n.base);
				if (result === false) {
					return;
				}
			}
			if (n.import_desc !== null) {
				const result = fn(fn,n.import_desc);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "cast": {
			if (!isCast(node)) {
				break;
			}
			const n :Cast = node as Cast;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.base !== null) {
				const result = fn(fn,n.base);
				if (result === false) {
					return;
				}
			}
			for (const e of n.arguments) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "available": {
			if (!isAvailable(node)) {
				break;
			}
			const n :Available = node as Available;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.base !== null) {
				const result = fn(fn,n.base);
				if (result === false) {
					return;
				}
			}
			if (n.target !== null) {
				const result = fn(fn,n.target);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "specify_order": {
			if (!isSpecifyOrder(node)) {
				break;
			}
			const n :SpecifyOrder = node as SpecifyOrder;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.base !== null) {
				const result = fn(fn,n.base);
				if (result === false) {
					return;
				}
			}
			if (n.order !== null) {
				const result = fn(fn,n.order);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "explicit_error": {
			if (!isExplicitError(node)) {
				break;
			}
			const n :ExplicitError = node as ExplicitError;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.base !== null) {
				const result = fn(fn,n.base);
				if (result === false) {
					return;
				}
			}
			if (n.message !== null) {
				const result = fn(fn,n.message);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "io_operation": {
			if (!isIoOperation(node)) {
				break;
			}
			const n :IoOperation = node as IoOperation;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.base !== null) {
				const result = fn(fn,n.base);
				if (result === false) {
					return;
				}
			}
			for (const e of n.arguments) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "or_cond": {
			if (!isOrCond(node)) {
				break;
			}
			const n :OrCond = node as OrCond;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.base !== null) {
				const result = fn(fn,n.base);
				if (result === false) {
					return;
				}
			}
			for (const e of n.conds) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "bad_expr": {
			if (!isBadExpr(node)) {
				break;
			}
			const n :BadExpr = node as BadExpr;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.bad_expr !== null) {
				const result = fn(fn,n.bad_expr);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "loop": {
			if (!isLoop(node)) {
				break;
			}
			const n :Loop = node as Loop;
			if (n.init !== null) {
				const result = fn(fn,n.init);
				if (result === false) {
					return;
				}
			}
			if (n.cond !== null) {
				const result = fn(fn,n.cond);
				if (result === false) {
					return;
				}
			}
			if (n.step !== null) {
				const result = fn(fn,n.step);
				if (result === false) {
					return;
				}
			}
			if (n.body !== null) {
				const result = fn(fn,n.body);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "indent_block": {
			if (!isIndentBlock(node)) {
				break;
			}
			const n :IndentBlock = node as IndentBlock;
			if (n.struct_type !== null) {
				const result = fn(fn,n.struct_type);
				if (result === false) {
					return;
				}
			}
			for (const e of n.elements) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "scoped_statement": {
			if (!isScopedStatement(node)) {
				break;
			}
			const n :ScopedStatement = node as ScopedStatement;
			if (n.struct_type !== null) {
				const result = fn(fn,n.struct_type);
				if (result === false) {
					return;
				}
			}
			if (n.statement !== null) {
				const result = fn(fn,n.statement);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "match_branch": {
			if (!isMatchBranch(node)) {
				break;
			}
			const n :MatchBranch = node as MatchBranch;
			if (n.cond !== null) {
				const result = fn(fn,n.cond);
				if (result === false) {
					return;
				}
			}
			if (n.then !== null) {
				const result = fn(fn,n.then);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "union_candidate": {
			if (!isUnionCandidate(node)) {
				break;
			}
			const n :UnionCandidate = node as UnionCandidate;
			break;
		}
		case "return": {
			if (!isReturn(node)) {
				break;
			}
			const n :Return = node as Return;
			if (n.expr !== null) {
				const result = fn(fn,n.expr);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "break": {
			if (!isBreak(node)) {
				break;
			}
			const n :Break = node as Break;
			break;
		}
		case "continue": {
			if (!isContinue(node)) {
				break;
			}
			const n :Continue = node as Continue;
			break;
		}
		case "assert": {
			if (!isAssert(node)) {
				break;
			}
			const n :Assert = node as Assert;
			if (n.cond !== null) {
				const result = fn(fn,n.cond);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "implicit_yield": {
			if (!isImplicitYield(node)) {
				break;
			}
			const n :ImplicitYield = node as ImplicitYield;
			if (n.expr !== null) {
				const result = fn(fn,n.expr);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "metadata": {
			if (!isMetadata(node)) {
				break;
			}
			const n :Metadata = node as Metadata;
			if (n.base !== null) {
				const result = fn(fn,n.base);
				if (result === false) {
					return;
				}
			}
			for (const e of n.values) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "int_type": {
			if (!isIntType(node)) {
				break;
			}
			const n :IntType = node as IntType;
			break;
		}
		case "float_type": {
			if (!isFloatType(node)) {
				break;
			}
			const n :FloatType = node as FloatType;
			break;
		}
		case "ident_type": {
			if (!isIdentType(node)) {
				break;
			}
			const n :IdentType = node as IdentType;
			if (n.import_ref !== null) {
				const result = fn(fn,n.import_ref);
				if (result === false) {
					return;
				}
			}
			if (n.ident !== null) {
				const result = fn(fn,n.ident);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "int_literal_type": {
			if (!isIntLiteralType(node)) {
				break;
			}
			const n :IntLiteralType = node as IntLiteralType;
			break;
		}
		case "str_literal_type": {
			if (!isStrLiteralType(node)) {
				break;
			}
			const n :StrLiteralType = node as StrLiteralType;
			if (n.strong_ref !== null) {
				const result = fn(fn,n.strong_ref);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "regex_literal_type": {
			if (!isRegexLiteralType(node)) {
				break;
			}
			const n :RegexLiteralType = node as RegexLiteralType;
			if (n.strong_ref !== null) {
				const result = fn(fn,n.strong_ref);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "void_type": {
			if (!isVoidType(node)) {
				break;
			}
			const n :VoidType = node as VoidType;
			break;
		}
		case "bool_type": {
			if (!isBoolType(node)) {
				break;
			}
			const n :BoolType = node as BoolType;
			break;
		}
		case "array_type": {
			if (!isArrayType(node)) {
				break;
			}
			const n :ArrayType = node as ArrayType;
			if (n.element_type !== null) {
				const result = fn(fn,n.element_type);
				if (result === false) {
					return;
				}
			}
			if (n.length !== null) {
				const result = fn(fn,n.length);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "function_type": {
			if (!isFunctionType(node)) {
				break;
			}
			const n :FunctionType = node as FunctionType;
			if (n.return_type !== null) {
				const result = fn(fn,n.return_type);
				if (result === false) {
					return;
				}
			}
			for (const e of n.parameters) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "struct_type": {
			if (!isStructType(node)) {
				break;
			}
			const n :StructType = node as StructType;
			for (const e of n.fields) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			if (n.type_map !== null) {
				const result = fn(fn,n.type_map);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "struct_union_type": {
			if (!isStructUnionType(node)) {
				break;
			}
			const n :StructUnionType = node as StructUnionType;
			if (n.cond !== null) {
				const result = fn(fn,n.cond);
				if (result === false) {
					return;
				}
			}
			for (const e of n.conds) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			for (const e of n.structs) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "union_type": {
			if (!isUnionType(node)) {
				break;
			}
			const n :UnionType = node as UnionType;
			for (const e of n.candidates) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			if (n.common_type !== null) {
				const result = fn(fn,n.common_type);
				if (result === false) {
					return;
				}
			}
			for (const e of n.member_candidates) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "range_type": {
			if (!isRangeType(node)) {
				break;
			}
			const n :RangeType = node as RangeType;
			if (n.base_type !== null) {
				const result = fn(fn,n.base_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "enum_type": {
			if (!isEnumType(node)) {
				break;
			}
			const n :EnumType = node as EnumType;
			break;
		}
		case "meta_type": {
			if (!isMetaType(node)) {
				break;
			}
			const n :MetaType = node as MetaType;
			break;
		}
		case "optional_type": {
			if (!isOptionalType(node)) {
				break;
			}
			const n :OptionalType = node as OptionalType;
			if (n.base_type !== null) {
				const result = fn(fn,n.base_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "generic_type": {
			if (!isGenericType(node)) {
				break;
			}
			const n :GenericType = node as GenericType;
			break;
		}
		case "int_literal": {
			if (!isIntLiteral(node)) {
				break;
			}
			const n :IntLiteral = node as IntLiteral;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "bool_literal": {
			if (!isBoolLiteral(node)) {
				break;
			}
			const n :BoolLiteral = node as BoolLiteral;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "str_literal": {
			if (!isStrLiteral(node)) {
				break;
			}
			const n :StrLiteral = node as StrLiteral;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "regex_literal": {
			if (!isRegexLiteral(node)) {
				break;
			}
			const n :RegexLiteral = node as RegexLiteral;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "char_literal": {
			if (!isCharLiteral(node)) {
				break;
			}
			const n :CharLiteral = node as CharLiteral;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "type_literal": {
			if (!isTypeLiteral(node)) {
				break;
			}
			const n :TypeLiteral = node as TypeLiteral;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.type_literal !== null) {
				const result = fn(fn,n.type_literal);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "special_literal": {
			if (!isSpecialLiteral(node)) {
				break;
			}
			const n :SpecialLiteral = node as SpecialLiteral;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "field": {
			if (!isField(node)) {
				break;
			}
			const n :Field = node as Field;
			if (n.ident !== null) {
				const result = fn(fn,n.ident);
				if (result === false) {
					return;
				}
			}
			if (n.field_type !== null) {
				const result = fn(fn,n.field_type);
				if (result === false) {
					return;
				}
			}
			if (n.arguments !== null) {
				const result = fn(fn,n.arguments);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "format": {
			if (!isFormat(node)) {
				break;
			}
			const n :Format = node as Format;
			if (n.ident !== null) {
				const result = fn(fn,n.ident);
				if (result === false) {
					return;
				}
			}
			if (n.body !== null) {
				const result = fn(fn,n.body);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "state": {
			if (!isState(node)) {
				break;
			}
			const n :State = node as State;
			if (n.ident !== null) {
				const result = fn(fn,n.ident);
				if (result === false) {
					return;
				}
			}
			if (n.body !== null) {
				const result = fn(fn,n.body);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "enum": {
			if (!isEnum(node)) {
				break;
			}
			const n :Enum = node as Enum;
			if (n.ident !== null) {
				const result = fn(fn,n.ident);
				if (result === false) {
					return;
				}
			}
			if (n.base_type !== null) {
				const result = fn(fn,n.base_type);
				if (result === false) {
					return;
				}
			}
			for (const e of n.members) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			if (n.enum_type !== null) {
				const result = fn(fn,n.enum_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "enum_member": {
			if (!isEnumMember(node)) {
				break;
			}
			const n :EnumMember = node as EnumMember;
			if (n.ident !== null) {
				const result = fn(fn,n.ident);
				if (result === false) {
					return;
				}
			}
			if (n.raw_expr !== null) {
				const result = fn(fn,n.raw_expr);
				if (result === false) {
					return;
				}
			}
			if (n.value !== null) {
				const result = fn(fn,n.value);
				if (result === false) {
					return;
				}
			}
			if (n.str_literal !== null) {
				const result = fn(fn,n.str_literal);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "function": {
			if (!isFunction(node)) {
				break;
			}
			const n :Function = node as Function;
			if (n.ident !== null) {
				const result = fn(fn,n.ident);
				if (result === false) {
					return;
				}
			}
			for (const e of n.parameters) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			if (n.return_type !== null) {
				const result = fn(fn,n.return_type);
				if (result === false) {
					return;
				}
			}
			if (n.body !== null) {
				const result = fn(fn,n.body);
				if (result === false) {
					return;
				}
			}
			if (n.func_type !== null) {
				const result = fn(fn,n.func_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
	}
}

}
