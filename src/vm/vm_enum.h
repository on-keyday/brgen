/*license*/
// Code generated by "enum_gen"; DO NOT EDIT.
#pragma once
#include <string_view>
#include <optional>
#include <array>
namespace brgen::vm {
template<typename T>
constexpr std::optional<T> from_string(std::string_view str);
template<typename T>
constexpr size_t enum_elem_count();
template<typename T>
constexpr std::array<std::pair<T,std::string_view>,enum_elem_count<T>()> make_enum_array();
template<typename T>
constexpr std::array<std::pair<T,std::string_view>,enum_elem_count<T>()> make_enum_name_array();
template<typename T>
constexpr const char* enum_type_name();
template<typename T>
constexpr auto enum_array = make_enum_array<T>();
template<typename T>
constexpr auto enum_name_array = make_enum_name_array<T>();
enum class Op {
    NOP,
    ADD,
    SUB,
    MUL,
    DIV,
    MOD,
    AND,
    OR,
    XOR,
    NOT,
    SHL,
    SHR,
    INC,
    DEC,
    NEG,
    CMP,
    JMP,
    JE,
    JNE,
    JG,
    JGE,
    JL,
    JLE,
    CALL,
    RET,
    PUSH,
    POP,
    TRSF,
    LOAD_IMMEDIATE,
    LOAD_STATIC,
    INIT_VARIABLE,
    LOAD_VARIABLE,
    STORE_VARIABLE,
    MAKE_OBJECT,
    SET_FIELD_LABEL,
    SET_FIELD,
    GET_FIELD,
    MAKE_ARRAY,
    SET_ARRAY,
    GET_ARRAY,
    GET_INPUT_OFFSET,
    SET_INPUT_OFFSET,
    GET_INPUT_REMAIN,
    READ_BYTES,
    PEEK_BYTES,
    WRITE_BYTES,
    READ_BITS,
    PEEK_BITS,
    WRITE_BITS,
    BYTES_TO_INT,
    SET_ENDIAN,
    ERROR,
    NEXT_FUNC,
    FUNC_NAME,
    FUNC_END,
};
constexpr const char* to_string(Op e) {
    switch(e) {
    case Op::NOP: return "NOP";
    case Op::ADD: return "ADD";
    case Op::SUB: return "SUB";
    case Op::MUL: return "MUL";
    case Op::DIV: return "DIV";
    case Op::MOD: return "MOD";
    case Op::AND: return "AND";
    case Op::OR: return "OR";
    case Op::XOR: return "XOR";
    case Op::NOT: return "NOT";
    case Op::SHL: return "SHL";
    case Op::SHR: return "SHR";
    case Op::INC: return "INC";
    case Op::DEC: return "DEC";
    case Op::NEG: return "NEG";
    case Op::CMP: return "CMP";
    case Op::JMP: return "JMP";
    case Op::JE: return "JE";
    case Op::JNE: return "JNE";
    case Op::JG: return "JG";
    case Op::JGE: return "JGE";
    case Op::JL: return "JL";
    case Op::JLE: return "JLE";
    case Op::CALL: return "CALL";
    case Op::RET: return "RET";
    case Op::PUSH: return "PUSH";
    case Op::POP: return "POP";
    case Op::TRSF: return "TRSF";
    case Op::LOAD_IMMEDIATE: return "LOAD_IMMEDIATE";
    case Op::LOAD_STATIC: return "LOAD_STATIC";
    case Op::INIT_VARIABLE: return "INIT_VARIABLE";
    case Op::LOAD_VARIABLE: return "LOAD_VARIABLE";
    case Op::STORE_VARIABLE: return "STORE_VARIABLE";
    case Op::MAKE_OBJECT: return "MAKE_OBJECT";
    case Op::SET_FIELD_LABEL: return "SET_FIELD_LABEL";
    case Op::SET_FIELD: return "SET_FIELD";
    case Op::GET_FIELD: return "GET_FIELD";
    case Op::MAKE_ARRAY: return "MAKE_ARRAY";
    case Op::SET_ARRAY: return "SET_ARRAY";
    case Op::GET_ARRAY: return "GET_ARRAY";
    case Op::GET_INPUT_OFFSET: return "GET_INPUT_OFFSET";
    case Op::SET_INPUT_OFFSET: return "SET_INPUT_OFFSET";
    case Op::GET_INPUT_REMAIN: return "GET_INPUT_REMAIN";
    case Op::READ_BYTES: return "READ_BYTES";
    case Op::PEEK_BYTES: return "PEEK_BYTES";
    case Op::WRITE_BYTES: return "WRITE_BYTES";
    case Op::READ_BITS: return "READ_BITS";
    case Op::PEEK_BITS: return "PEEK_BITS";
    case Op::WRITE_BITS: return "WRITE_BITS";
    case Op::BYTES_TO_INT: return "BYTES_TO_INT";
    case Op::SET_ENDIAN: return "SET_ENDIAN";
    case Op::ERROR: return "ERROR";
    case Op::NEXT_FUNC: return "NEXT_FUNC";
    case Op::FUNC_NAME: return "FUNC_NAME";
    case Op::FUNC_END: return "FUNC_END";
    default: return nullptr;
    }
}
template<>constexpr std::optional<Op> from_string<Op>(std::string_view str) {
    if(str.empty()) return std::nullopt;
    if(str == "NOP") return Op::NOP;
    if(str == "ADD") return Op::ADD;
    if(str == "SUB") return Op::SUB;
    if(str == "MUL") return Op::MUL;
    if(str == "DIV") return Op::DIV;
    if(str == "MOD") return Op::MOD;
    if(str == "AND") return Op::AND;
    if(str == "OR") return Op::OR;
    if(str == "XOR") return Op::XOR;
    if(str == "NOT") return Op::NOT;
    if(str == "SHL") return Op::SHL;
    if(str == "SHR") return Op::SHR;
    if(str == "INC") return Op::INC;
    if(str == "DEC") return Op::DEC;
    if(str == "NEG") return Op::NEG;
    if(str == "CMP") return Op::CMP;
    if(str == "JMP") return Op::JMP;
    if(str == "JE") return Op::JE;
    if(str == "JNE") return Op::JNE;
    if(str == "JG") return Op::JG;
    if(str == "JGE") return Op::JGE;
    if(str == "JL") return Op::JL;
    if(str == "JLE") return Op::JLE;
    if(str == "CALL") return Op::CALL;
    if(str == "RET") return Op::RET;
    if(str == "PUSH") return Op::PUSH;
    if(str == "POP") return Op::POP;
    if(str == "TRSF") return Op::TRSF;
    if(str == "LOAD_IMMEDIATE") return Op::LOAD_IMMEDIATE;
    if(str == "LOAD_STATIC") return Op::LOAD_STATIC;
    if(str == "INIT_VARIABLE") return Op::INIT_VARIABLE;
    if(str == "LOAD_VARIABLE") return Op::LOAD_VARIABLE;
    if(str == "STORE_VARIABLE") return Op::STORE_VARIABLE;
    if(str == "MAKE_OBJECT") return Op::MAKE_OBJECT;
    if(str == "SET_FIELD_LABEL") return Op::SET_FIELD_LABEL;
    if(str == "SET_FIELD") return Op::SET_FIELD;
    if(str == "GET_FIELD") return Op::GET_FIELD;
    if(str == "MAKE_ARRAY") return Op::MAKE_ARRAY;
    if(str == "SET_ARRAY") return Op::SET_ARRAY;
    if(str == "GET_ARRAY") return Op::GET_ARRAY;
    if(str == "GET_INPUT_OFFSET") return Op::GET_INPUT_OFFSET;
    if(str == "SET_INPUT_OFFSET") return Op::SET_INPUT_OFFSET;
    if(str == "GET_INPUT_REMAIN") return Op::GET_INPUT_REMAIN;
    if(str == "READ_BYTES") return Op::READ_BYTES;
    if(str == "PEEK_BYTES") return Op::PEEK_BYTES;
    if(str == "WRITE_BYTES") return Op::WRITE_BYTES;
    if(str == "READ_BITS") return Op::READ_BITS;
    if(str == "PEEK_BITS") return Op::PEEK_BITS;
    if(str == "WRITE_BITS") return Op::WRITE_BITS;
    if(str == "BYTES_TO_INT") return Op::BYTES_TO_INT;
    if(str == "SET_ENDIAN") return Op::SET_ENDIAN;
    if(str == "ERROR") return Op::ERROR;
    if(str == "NEXT_FUNC") return Op::NEXT_FUNC;
    if(str == "FUNC_NAME") return Op::FUNC_NAME;
    if(str == "FUNC_END") return Op::FUNC_END;
    return std::nullopt;
}
template<>constexpr size_t enum_elem_count<Op>() {
    return 55;
}
template<>constexpr std::array<std::pair<Op,std::string_view>,55> make_enum_array<Op>() {
    return {
        std::pair{Op::NOP,"NOP"},
        std::pair{Op::ADD,"ADD"},
        std::pair{Op::SUB,"SUB"},
        std::pair{Op::MUL,"MUL"},
        std::pair{Op::DIV,"DIV"},
        std::pair{Op::MOD,"MOD"},
        std::pair{Op::AND,"AND"},
        std::pair{Op::OR,"OR"},
        std::pair{Op::XOR,"XOR"},
        std::pair{Op::NOT,"NOT"},
        std::pair{Op::SHL,"SHL"},
        std::pair{Op::SHR,"SHR"},
        std::pair{Op::INC,"INC"},
        std::pair{Op::DEC,"DEC"},
        std::pair{Op::NEG,"NEG"},
        std::pair{Op::CMP,"CMP"},
        std::pair{Op::JMP,"JMP"},
        std::pair{Op::JE,"JE"},
        std::pair{Op::JNE,"JNE"},
        std::pair{Op::JG,"JG"},
        std::pair{Op::JGE,"JGE"},
        std::pair{Op::JL,"JL"},
        std::pair{Op::JLE,"JLE"},
        std::pair{Op::CALL,"CALL"},
        std::pair{Op::RET,"RET"},
        std::pair{Op::PUSH,"PUSH"},
        std::pair{Op::POP,"POP"},
        std::pair{Op::TRSF,"TRSF"},
        std::pair{Op::LOAD_IMMEDIATE,"LOAD_IMMEDIATE"},
        std::pair{Op::LOAD_STATIC,"LOAD_STATIC"},
        std::pair{Op::INIT_VARIABLE,"INIT_VARIABLE"},
        std::pair{Op::LOAD_VARIABLE,"LOAD_VARIABLE"},
        std::pair{Op::STORE_VARIABLE,"STORE_VARIABLE"},
        std::pair{Op::MAKE_OBJECT,"MAKE_OBJECT"},
        std::pair{Op::SET_FIELD_LABEL,"SET_FIELD_LABEL"},
        std::pair{Op::SET_FIELD,"SET_FIELD"},
        std::pair{Op::GET_FIELD,"GET_FIELD"},
        std::pair{Op::MAKE_ARRAY,"MAKE_ARRAY"},
        std::pair{Op::SET_ARRAY,"SET_ARRAY"},
        std::pair{Op::GET_ARRAY,"GET_ARRAY"},
        std::pair{Op::GET_INPUT_OFFSET,"GET_INPUT_OFFSET"},
        std::pair{Op::SET_INPUT_OFFSET,"SET_INPUT_OFFSET"},
        std::pair{Op::GET_INPUT_REMAIN,"GET_INPUT_REMAIN"},
        std::pair{Op::READ_BYTES,"READ_BYTES"},
        std::pair{Op::PEEK_BYTES,"PEEK_BYTES"},
        std::pair{Op::WRITE_BYTES,"WRITE_BYTES"},
        std::pair{Op::READ_BITS,"READ_BITS"},
        std::pair{Op::PEEK_BITS,"PEEK_BITS"},
        std::pair{Op::WRITE_BITS,"WRITE_BITS"},
        std::pair{Op::BYTES_TO_INT,"BYTES_TO_INT"},
        std::pair{Op::SET_ENDIAN,"SET_ENDIAN"},
        std::pair{Op::ERROR,"ERROR"},
        std::pair{Op::NEXT_FUNC,"NEXT_FUNC"},
        std::pair{Op::FUNC_NAME,"FUNC_NAME"},
        std::pair{Op::FUNC_END,"FUNC_END"},
    };
}
template<>constexpr std::array<std::pair<Op,std::string_view>,55> make_enum_name_array<Op>() {
    return {
        std::pair{Op::NOP,"NOP"},
        std::pair{Op::ADD,"ADD"},
        std::pair{Op::SUB,"SUB"},
        std::pair{Op::MUL,"MUL"},
        std::pair{Op::DIV,"DIV"},
        std::pair{Op::MOD,"MOD"},
        std::pair{Op::AND,"AND"},
        std::pair{Op::OR,"OR"},
        std::pair{Op::XOR,"XOR"},
        std::pair{Op::NOT,"NOT"},
        std::pair{Op::SHL,"SHL"},
        std::pair{Op::SHR,"SHR"},
        std::pair{Op::INC,"INC"},
        std::pair{Op::DEC,"DEC"},
        std::pair{Op::NEG,"NEG"},
        std::pair{Op::CMP,"CMP"},
        std::pair{Op::JMP,"JMP"},
        std::pair{Op::JE,"JE"},
        std::pair{Op::JNE,"JNE"},
        std::pair{Op::JG,"JG"},
        std::pair{Op::JGE,"JGE"},
        std::pair{Op::JL,"JL"},
        std::pair{Op::JLE,"JLE"},
        std::pair{Op::CALL,"CALL"},
        std::pair{Op::RET,"RET"},
        std::pair{Op::PUSH,"PUSH"},
        std::pair{Op::POP,"POP"},
        std::pair{Op::TRSF,"TRSF"},
        std::pair{Op::LOAD_IMMEDIATE,"LOAD_IMMEDIATE"},
        std::pair{Op::LOAD_STATIC,"LOAD_STATIC"},
        std::pair{Op::INIT_VARIABLE,"INIT_VARIABLE"},
        std::pair{Op::LOAD_VARIABLE,"LOAD_VARIABLE"},
        std::pair{Op::STORE_VARIABLE,"STORE_VARIABLE"},
        std::pair{Op::MAKE_OBJECT,"MAKE_OBJECT"},
        std::pair{Op::SET_FIELD_LABEL,"SET_FIELD_LABEL"},
        std::pair{Op::SET_FIELD,"SET_FIELD"},
        std::pair{Op::GET_FIELD,"GET_FIELD"},
        std::pair{Op::MAKE_ARRAY,"MAKE_ARRAY"},
        std::pair{Op::SET_ARRAY,"SET_ARRAY"},
        std::pair{Op::GET_ARRAY,"GET_ARRAY"},
        std::pair{Op::GET_INPUT_OFFSET,"GET_INPUT_OFFSET"},
        std::pair{Op::SET_INPUT_OFFSET,"SET_INPUT_OFFSET"},
        std::pair{Op::GET_INPUT_REMAIN,"GET_INPUT_REMAIN"},
        std::pair{Op::READ_BYTES,"READ_BYTES"},
        std::pair{Op::PEEK_BYTES,"PEEK_BYTES"},
        std::pair{Op::WRITE_BYTES,"WRITE_BYTES"},
        std::pair{Op::READ_BITS,"READ_BITS"},
        std::pair{Op::PEEK_BITS,"PEEK_BITS"},
        std::pair{Op::WRITE_BITS,"WRITE_BITS"},
        std::pair{Op::BYTES_TO_INT,"BYTES_TO_INT"},
        std::pair{Op::SET_ENDIAN,"SET_ENDIAN"},
        std::pair{Op::ERROR,"ERROR"},
        std::pair{Op::NEXT_FUNC,"NEXT_FUNC"},
        std::pair{Op::FUNC_NAME,"FUNC_NAME"},
        std::pair{Op::FUNC_END,"FUNC_END"},
    };
}
constexpr void as_json(Op e,auto&& d) {
    d.value(enum_array<Op>[int(e)].second);
}
template<>
constexpr const char* enum_type_name<Op>() {
    return "Op";
}
}
