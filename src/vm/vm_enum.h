/*license*/
// Code generated by "enum_gen"; DO NOT EDIT.
#pragma once
#include <string_view>
#include <optional>
#include <array>
namespace brgen::vm {
template<typename T>
constexpr std::optional<T> from_string(std::string_view str);
template<typename T,class K>
constexpr std::optional<T> from_json(K k);
template<typename T>
constexpr size_t enum_elem_count();
template<typename T>
constexpr std::array<std::pair<T,std::string_view>,enum_elem_count<T>()> make_enum_array();
template<typename T>
constexpr std::array<std::pair<T,std::string_view>,enum_elem_count<T>()> make_enum_name_array();
template<typename T>
constexpr const char* enum_type_name();
template<typename T>
constexpr bool is_bit_flag();
template<typename T>
constexpr auto enum_array = make_enum_array<T>();
template<typename T>
constexpr auto enum_name_array = make_enum_name_array<T>();
enum class Op {
    NOP = 0,
    ADD = 1,
    SUB = 2,
    MUL = 3,
    DIV = 4,
    MOD = 5,
    AND = 6,
    OR = 7,
    XOR = 8,
    NOT = 9,
    SHL = 10,
    SHR = 11,
    INC = 12,
    DEC = 13,
    NEG = 14,
    CMP = 15,
    JMP = 16,
    JE = 17,
    JNE = 18,
    JG = 19,
    JGE = 20,
    JL = 21,
    JLE = 22,
    CALL = 23,
    RET = 24,
    PUSH = 25,
    POP = 26,
    TRSF = 27,
    LOAD_IMMEDIATE = 28,
    LOAD_STATIC = 29,
    INIT_GLOBAL_VARIABLE = 30,
    LOAD_GLOBAL_VARIABLE = 31,
    STORE_GLOBAL_VARIABLE = 32,
    INIT_LOCAL_VARIABLE = 33,
    LOAD_LOCAL_VARIABLE = 34,
    STORE_LOCAL_VARIABLE = 35,
    MAKE_OBJECT = 36,
    SET_FIELD_LABEL = 37,
    SET_FIELD = 38,
    GET_FIELD = 39,
    MAKE_ARRAY = 40,
    SET_ARRAY = 41,
    GET_ARRAY = 42,
    GET_INPUT_OFFSET = 43,
    SET_INPUT_OFFSET = 44,
    GET_INPUT_REMAIN = 45,
    READ_BYTES = 46,
    PEEK_BYTES = 47,
    WRITE_BYTES = 48,
    READ_BITS = 49,
    PEEK_BITS = 50,
    WRITE_BITS = 51,
    BYTES_TO_INT = 52,
    SET_ENDIAN = 53,
    ERROR = 54,
    NEXT_FUNC = 55,
    FUNC_NAME = 56,
    FUNC_END = 57,
};
constexpr const char* to_string(Op e) {
    switch(e) {
    case Op::NOP: return "NOP";
    case Op::ADD: return "ADD";
    case Op::SUB: return "SUB";
    case Op::MUL: return "MUL";
    case Op::DIV: return "DIV";
    case Op::MOD: return "MOD";
    case Op::AND: return "AND";
    case Op::OR: return "OR";
    case Op::XOR: return "XOR";
    case Op::NOT: return "NOT";
    case Op::SHL: return "SHL";
    case Op::SHR: return "SHR";
    case Op::INC: return "INC";
    case Op::DEC: return "DEC";
    case Op::NEG: return "NEG";
    case Op::CMP: return "CMP";
    case Op::JMP: return "JMP";
    case Op::JE: return "JE";
    case Op::JNE: return "JNE";
    case Op::JG: return "JG";
    case Op::JGE: return "JGE";
    case Op::JL: return "JL";
    case Op::JLE: return "JLE";
    case Op::CALL: return "CALL";
    case Op::RET: return "RET";
    case Op::PUSH: return "PUSH";
    case Op::POP: return "POP";
    case Op::TRSF: return "TRSF";
    case Op::LOAD_IMMEDIATE: return "LOAD_IMMEDIATE";
    case Op::LOAD_STATIC: return "LOAD_STATIC";
    case Op::INIT_GLOBAL_VARIABLE: return "INIT_GLOBAL_VARIABLE";
    case Op::LOAD_GLOBAL_VARIABLE: return "LOAD_GLOBAL_VARIABLE";
    case Op::STORE_GLOBAL_VARIABLE: return "STORE_GLOBAL_VARIABLE";
    case Op::INIT_LOCAL_VARIABLE: return "INIT_LOCAL_VARIABLE";
    case Op::LOAD_LOCAL_VARIABLE: return "LOAD_LOCAL_VARIABLE";
    case Op::STORE_LOCAL_VARIABLE: return "STORE_LOCAL_VARIABLE";
    case Op::MAKE_OBJECT: return "MAKE_OBJECT";
    case Op::SET_FIELD_LABEL: return "SET_FIELD_LABEL";
    case Op::SET_FIELD: return "SET_FIELD";
    case Op::GET_FIELD: return "GET_FIELD";
    case Op::MAKE_ARRAY: return "MAKE_ARRAY";
    case Op::SET_ARRAY: return "SET_ARRAY";
    case Op::GET_ARRAY: return "GET_ARRAY";
    case Op::GET_INPUT_OFFSET: return "GET_INPUT_OFFSET";
    case Op::SET_INPUT_OFFSET: return "SET_INPUT_OFFSET";
    case Op::GET_INPUT_REMAIN: return "GET_INPUT_REMAIN";
    case Op::READ_BYTES: return "READ_BYTES";
    case Op::PEEK_BYTES: return "PEEK_BYTES";
    case Op::WRITE_BYTES: return "WRITE_BYTES";
    case Op::READ_BITS: return "READ_BITS";
    case Op::PEEK_BITS: return "PEEK_BITS";
    case Op::WRITE_BITS: return "WRITE_BITS";
    case Op::BYTES_TO_INT: return "BYTES_TO_INT";
    case Op::SET_ENDIAN: return "SET_ENDIAN";
    case Op::ERROR: return "ERROR";
    case Op::NEXT_FUNC: return "NEXT_FUNC";
    case Op::FUNC_NAME: return "FUNC_NAME";
    case Op::FUNC_END: return "FUNC_END";
    default: return nullptr;
    }
}
template<>constexpr std::optional<Op> from_string<Op>(std::string_view str) {
    if(str.empty()) return std::nullopt;
    if(str == "NOP") return Op::NOP;
    if(str == "ADD") return Op::ADD;
    if(str == "SUB") return Op::SUB;
    if(str == "MUL") return Op::MUL;
    if(str == "DIV") return Op::DIV;
    if(str == "MOD") return Op::MOD;
    if(str == "AND") return Op::AND;
    if(str == "OR") return Op::OR;
    if(str == "XOR") return Op::XOR;
    if(str == "NOT") return Op::NOT;
    if(str == "SHL") return Op::SHL;
    if(str == "SHR") return Op::SHR;
    if(str == "INC") return Op::INC;
    if(str == "DEC") return Op::DEC;
    if(str == "NEG") return Op::NEG;
    if(str == "CMP") return Op::CMP;
    if(str == "JMP") return Op::JMP;
    if(str == "JE") return Op::JE;
    if(str == "JNE") return Op::JNE;
    if(str == "JG") return Op::JG;
    if(str == "JGE") return Op::JGE;
    if(str == "JL") return Op::JL;
    if(str == "JLE") return Op::JLE;
    if(str == "CALL") return Op::CALL;
    if(str == "RET") return Op::RET;
    if(str == "PUSH") return Op::PUSH;
    if(str == "POP") return Op::POP;
    if(str == "TRSF") return Op::TRSF;
    if(str == "LOAD_IMMEDIATE") return Op::LOAD_IMMEDIATE;
    if(str == "LOAD_STATIC") return Op::LOAD_STATIC;
    if(str == "INIT_GLOBAL_VARIABLE") return Op::INIT_GLOBAL_VARIABLE;
    if(str == "LOAD_GLOBAL_VARIABLE") return Op::LOAD_GLOBAL_VARIABLE;
    if(str == "STORE_GLOBAL_VARIABLE") return Op::STORE_GLOBAL_VARIABLE;
    if(str == "INIT_LOCAL_VARIABLE") return Op::INIT_LOCAL_VARIABLE;
    if(str == "LOAD_LOCAL_VARIABLE") return Op::LOAD_LOCAL_VARIABLE;
    if(str == "STORE_LOCAL_VARIABLE") return Op::STORE_LOCAL_VARIABLE;
    if(str == "MAKE_OBJECT") return Op::MAKE_OBJECT;
    if(str == "SET_FIELD_LABEL") return Op::SET_FIELD_LABEL;
    if(str == "SET_FIELD") return Op::SET_FIELD;
    if(str == "GET_FIELD") return Op::GET_FIELD;
    if(str == "MAKE_ARRAY") return Op::MAKE_ARRAY;
    if(str == "SET_ARRAY") return Op::SET_ARRAY;
    if(str == "GET_ARRAY") return Op::GET_ARRAY;
    if(str == "GET_INPUT_OFFSET") return Op::GET_INPUT_OFFSET;
    if(str == "SET_INPUT_OFFSET") return Op::SET_INPUT_OFFSET;
    if(str == "GET_INPUT_REMAIN") return Op::GET_INPUT_REMAIN;
    if(str == "READ_BYTES") return Op::READ_BYTES;
    if(str == "PEEK_BYTES") return Op::PEEK_BYTES;
    if(str == "WRITE_BYTES") return Op::WRITE_BYTES;
    if(str == "READ_BITS") return Op::READ_BITS;
    if(str == "PEEK_BITS") return Op::PEEK_BITS;
    if(str == "WRITE_BITS") return Op::WRITE_BITS;
    if(str == "BYTES_TO_INT") return Op::BYTES_TO_INT;
    if(str == "SET_ENDIAN") return Op::SET_ENDIAN;
    if(str == "ERROR") return Op::ERROR;
    if(str == "NEXT_FUNC") return Op::NEXT_FUNC;
    if(str == "FUNC_NAME") return Op::FUNC_NAME;
    if(str == "FUNC_END") return Op::FUNC_END;
    return std::nullopt;
}
template<>constexpr size_t enum_elem_count<Op>() {
    return 58;
}
template<>constexpr std::array<std::pair<Op,std::string_view>,58> make_enum_array<Op>() {
    return {
        std::pair{Op::NOP,"NOP"},
        std::pair{Op::ADD,"ADD"},
        std::pair{Op::SUB,"SUB"},
        std::pair{Op::MUL,"MUL"},
        std::pair{Op::DIV,"DIV"},
        std::pair{Op::MOD,"MOD"},
        std::pair{Op::AND,"AND"},
        std::pair{Op::OR,"OR"},
        std::pair{Op::XOR,"XOR"},
        std::pair{Op::NOT,"NOT"},
        std::pair{Op::SHL,"SHL"},
        std::pair{Op::SHR,"SHR"},
        std::pair{Op::INC,"INC"},
        std::pair{Op::DEC,"DEC"},
        std::pair{Op::NEG,"NEG"},
        std::pair{Op::CMP,"CMP"},
        std::pair{Op::JMP,"JMP"},
        std::pair{Op::JE,"JE"},
        std::pair{Op::JNE,"JNE"},
        std::pair{Op::JG,"JG"},
        std::pair{Op::JGE,"JGE"},
        std::pair{Op::JL,"JL"},
        std::pair{Op::JLE,"JLE"},
        std::pair{Op::CALL,"CALL"},
        std::pair{Op::RET,"RET"},
        std::pair{Op::PUSH,"PUSH"},
        std::pair{Op::POP,"POP"},
        std::pair{Op::TRSF,"TRSF"},
        std::pair{Op::LOAD_IMMEDIATE,"LOAD_IMMEDIATE"},
        std::pair{Op::LOAD_STATIC,"LOAD_STATIC"},
        std::pair{Op::INIT_GLOBAL_VARIABLE,"INIT_GLOBAL_VARIABLE"},
        std::pair{Op::LOAD_GLOBAL_VARIABLE,"LOAD_GLOBAL_VARIABLE"},
        std::pair{Op::STORE_GLOBAL_VARIABLE,"STORE_GLOBAL_VARIABLE"},
        std::pair{Op::INIT_LOCAL_VARIABLE,"INIT_LOCAL_VARIABLE"},
        std::pair{Op::LOAD_LOCAL_VARIABLE,"LOAD_LOCAL_VARIABLE"},
        std::pair{Op::STORE_LOCAL_VARIABLE,"STORE_LOCAL_VARIABLE"},
        std::pair{Op::MAKE_OBJECT,"MAKE_OBJECT"},
        std::pair{Op::SET_FIELD_LABEL,"SET_FIELD_LABEL"},
        std::pair{Op::SET_FIELD,"SET_FIELD"},
        std::pair{Op::GET_FIELD,"GET_FIELD"},
        std::pair{Op::MAKE_ARRAY,"MAKE_ARRAY"},
        std::pair{Op::SET_ARRAY,"SET_ARRAY"},
        std::pair{Op::GET_ARRAY,"GET_ARRAY"},
        std::pair{Op::GET_INPUT_OFFSET,"GET_INPUT_OFFSET"},
        std::pair{Op::SET_INPUT_OFFSET,"SET_INPUT_OFFSET"},
        std::pair{Op::GET_INPUT_REMAIN,"GET_INPUT_REMAIN"},
        std::pair{Op::READ_BYTES,"READ_BYTES"},
        std::pair{Op::PEEK_BYTES,"PEEK_BYTES"},
        std::pair{Op::WRITE_BYTES,"WRITE_BYTES"},
        std::pair{Op::READ_BITS,"READ_BITS"},
        std::pair{Op::PEEK_BITS,"PEEK_BITS"},
        std::pair{Op::WRITE_BITS,"WRITE_BITS"},
        std::pair{Op::BYTES_TO_INT,"BYTES_TO_INT"},
        std::pair{Op::SET_ENDIAN,"SET_ENDIAN"},
        std::pair{Op::ERROR,"ERROR"},
        std::pair{Op::NEXT_FUNC,"NEXT_FUNC"},
        std::pair{Op::FUNC_NAME,"FUNC_NAME"},
        std::pair{Op::FUNC_END,"FUNC_END"},
    };
}
template<>constexpr std::array<std::pair<Op,std::string_view>,58> make_enum_name_array<Op>() {
    return {
        std::pair{Op::NOP,"NOP"},
        std::pair{Op::ADD,"ADD"},
        std::pair{Op::SUB,"SUB"},
        std::pair{Op::MUL,"MUL"},
        std::pair{Op::DIV,"DIV"},
        std::pair{Op::MOD,"MOD"},
        std::pair{Op::AND,"AND"},
        std::pair{Op::OR,"OR"},
        std::pair{Op::XOR,"XOR"},
        std::pair{Op::NOT,"NOT"},
        std::pair{Op::SHL,"SHL"},
        std::pair{Op::SHR,"SHR"},
        std::pair{Op::INC,"INC"},
        std::pair{Op::DEC,"DEC"},
        std::pair{Op::NEG,"NEG"},
        std::pair{Op::CMP,"CMP"},
        std::pair{Op::JMP,"JMP"},
        std::pair{Op::JE,"JE"},
        std::pair{Op::JNE,"JNE"},
        std::pair{Op::JG,"JG"},
        std::pair{Op::JGE,"JGE"},
        std::pair{Op::JL,"JL"},
        std::pair{Op::JLE,"JLE"},
        std::pair{Op::CALL,"CALL"},
        std::pair{Op::RET,"RET"},
        std::pair{Op::PUSH,"PUSH"},
        std::pair{Op::POP,"POP"},
        std::pair{Op::TRSF,"TRSF"},
        std::pair{Op::LOAD_IMMEDIATE,"LOAD_IMMEDIATE"},
        std::pair{Op::LOAD_STATIC,"LOAD_STATIC"},
        std::pair{Op::INIT_GLOBAL_VARIABLE,"INIT_GLOBAL_VARIABLE"},
        std::pair{Op::LOAD_GLOBAL_VARIABLE,"LOAD_GLOBAL_VARIABLE"},
        std::pair{Op::STORE_GLOBAL_VARIABLE,"STORE_GLOBAL_VARIABLE"},
        std::pair{Op::INIT_LOCAL_VARIABLE,"INIT_LOCAL_VARIABLE"},
        std::pair{Op::LOAD_LOCAL_VARIABLE,"LOAD_LOCAL_VARIABLE"},
        std::pair{Op::STORE_LOCAL_VARIABLE,"STORE_LOCAL_VARIABLE"},
        std::pair{Op::MAKE_OBJECT,"MAKE_OBJECT"},
        std::pair{Op::SET_FIELD_LABEL,"SET_FIELD_LABEL"},
        std::pair{Op::SET_FIELD,"SET_FIELD"},
        std::pair{Op::GET_FIELD,"GET_FIELD"},
        std::pair{Op::MAKE_ARRAY,"MAKE_ARRAY"},
        std::pair{Op::SET_ARRAY,"SET_ARRAY"},
        std::pair{Op::GET_ARRAY,"GET_ARRAY"},
        std::pair{Op::GET_INPUT_OFFSET,"GET_INPUT_OFFSET"},
        std::pair{Op::SET_INPUT_OFFSET,"SET_INPUT_OFFSET"},
        std::pair{Op::GET_INPUT_REMAIN,"GET_INPUT_REMAIN"},
        std::pair{Op::READ_BYTES,"READ_BYTES"},
        std::pair{Op::PEEK_BYTES,"PEEK_BYTES"},
        std::pair{Op::WRITE_BYTES,"WRITE_BYTES"},
        std::pair{Op::READ_BITS,"READ_BITS"},
        std::pair{Op::PEEK_BITS,"PEEK_BITS"},
        std::pair{Op::WRITE_BITS,"WRITE_BITS"},
        std::pair{Op::BYTES_TO_INT,"BYTES_TO_INT"},
        std::pair{Op::SET_ENDIAN,"SET_ENDIAN"},
        std::pair{Op::ERROR,"ERROR"},
        std::pair{Op::NEXT_FUNC,"NEXT_FUNC"},
        std::pair{Op::FUNC_NAME,"FUNC_NAME"},
        std::pair{Op::FUNC_END,"FUNC_END"},
    };
}
constexpr void as_json(Op e,auto&& d) {
    d.value(static_cast<size_t>(e));
}
template<>
constexpr std::optional<Op> from_json<Op,size_t>(size_t k){
    return static_cast<Op>(k);
}
template<>constexpr bool is_bit_flag<Op>() {
    return true;
}
template<>
constexpr const char* enum_type_name<Op>() {
    return "Op";
}
enum class Op2 {
    NOP = 0,
    TRSF = 1,
    LOAD_MEMORY = 2,
    STORE_MEMORY = 3,
    LOAD_IMMEDIATE = 4,
    ADD = 5,
    SUB = 6,
    MUL = 7,
    DIV = 8,
    MOD = 9,
    AND = 10,
    OR = 11,
    XOR = 12,
    NOT = 13,
    SHL = 14,
    SHR = 15,
    EQ = 16,
    NE = 17,
    LT = 18,
    LE = 19,
    INC = 20,
    DEC = 21,
    NEG = 22,
    JMP = 23,
    JMPIF = 24,
    CALL = 25,
    RET = 26,
    PUSH = 27,
    POP = 28,
    PUSH_IMMEDIATE = 29,
};
constexpr const char* to_string(Op2 e) {
    switch(e) {
    case Op2::NOP: return "NOP";
    case Op2::TRSF: return "TRSF";
    case Op2::LOAD_MEMORY: return "LOAD_MEMORY";
    case Op2::STORE_MEMORY: return "STORE_MEMORY";
    case Op2::LOAD_IMMEDIATE: return "LOAD_IMMEDIATE";
    case Op2::ADD: return "ADD";
    case Op2::SUB: return "SUB";
    case Op2::MUL: return "MUL";
    case Op2::DIV: return "DIV";
    case Op2::MOD: return "MOD";
    case Op2::AND: return "AND";
    case Op2::OR: return "OR";
    case Op2::XOR: return "XOR";
    case Op2::NOT: return "NOT";
    case Op2::SHL: return "SHL";
    case Op2::SHR: return "SHR";
    case Op2::EQ: return "EQ";
    case Op2::NE: return "NE";
    case Op2::LT: return "LT";
    case Op2::LE: return "LE";
    case Op2::INC: return "INC";
    case Op2::DEC: return "DEC";
    case Op2::NEG: return "NEG";
    case Op2::JMP: return "JMP";
    case Op2::JMPIF: return "JMPIF";
    case Op2::CALL: return "CALL";
    case Op2::RET: return "RET";
    case Op2::PUSH: return "PUSH";
    case Op2::POP: return "POP";
    case Op2::PUSH_IMMEDIATE: return "PUSH_IMMEDIATE";
    default: return nullptr;
    }
}
template<>constexpr std::optional<Op2> from_string<Op2>(std::string_view str) {
    if(str.empty()) return std::nullopt;
    if(str == "NOP") return Op2::NOP;
    if(str == "TRSF") return Op2::TRSF;
    if(str == "LOAD_MEMORY") return Op2::LOAD_MEMORY;
    if(str == "STORE_MEMORY") return Op2::STORE_MEMORY;
    if(str == "LOAD_IMMEDIATE") return Op2::LOAD_IMMEDIATE;
    if(str == "ADD") return Op2::ADD;
    if(str == "SUB") return Op2::SUB;
    if(str == "MUL") return Op2::MUL;
    if(str == "DIV") return Op2::DIV;
    if(str == "MOD") return Op2::MOD;
    if(str == "AND") return Op2::AND;
    if(str == "OR") return Op2::OR;
    if(str == "XOR") return Op2::XOR;
    if(str == "NOT") return Op2::NOT;
    if(str == "SHL") return Op2::SHL;
    if(str == "SHR") return Op2::SHR;
    if(str == "EQ") return Op2::EQ;
    if(str == "NE") return Op2::NE;
    if(str == "LT") return Op2::LT;
    if(str == "LE") return Op2::LE;
    if(str == "INC") return Op2::INC;
    if(str == "DEC") return Op2::DEC;
    if(str == "NEG") return Op2::NEG;
    if(str == "JMP") return Op2::JMP;
    if(str == "JMPIF") return Op2::JMPIF;
    if(str == "CALL") return Op2::CALL;
    if(str == "RET") return Op2::RET;
    if(str == "PUSH") return Op2::PUSH;
    if(str == "POP") return Op2::POP;
    if(str == "PUSH_IMMEDIATE") return Op2::PUSH_IMMEDIATE;
    return std::nullopt;
}
template<>constexpr size_t enum_elem_count<Op2>() {
    return 30;
}
template<>constexpr std::array<std::pair<Op2,std::string_view>,30> make_enum_array<Op2>() {
    return {
        std::pair{Op2::NOP,"NOP"},
        std::pair{Op2::TRSF,"TRSF"},
        std::pair{Op2::LOAD_MEMORY,"LOAD_MEMORY"},
        std::pair{Op2::STORE_MEMORY,"STORE_MEMORY"},
        std::pair{Op2::LOAD_IMMEDIATE,"LOAD_IMMEDIATE"},
        std::pair{Op2::ADD,"ADD"},
        std::pair{Op2::SUB,"SUB"},
        std::pair{Op2::MUL,"MUL"},
        std::pair{Op2::DIV,"DIV"},
        std::pair{Op2::MOD,"MOD"},
        std::pair{Op2::AND,"AND"},
        std::pair{Op2::OR,"OR"},
        std::pair{Op2::XOR,"XOR"},
        std::pair{Op2::NOT,"NOT"},
        std::pair{Op2::SHL,"SHL"},
        std::pair{Op2::SHR,"SHR"},
        std::pair{Op2::EQ,"EQ"},
        std::pair{Op2::NE,"NE"},
        std::pair{Op2::LT,"LT"},
        std::pair{Op2::LE,"LE"},
        std::pair{Op2::INC,"INC"},
        std::pair{Op2::DEC,"DEC"},
        std::pair{Op2::NEG,"NEG"},
        std::pair{Op2::JMP,"JMP"},
        std::pair{Op2::JMPIF,"JMPIF"},
        std::pair{Op2::CALL,"CALL"},
        std::pair{Op2::RET,"RET"},
        std::pair{Op2::PUSH,"PUSH"},
        std::pair{Op2::POP,"POP"},
        std::pair{Op2::PUSH_IMMEDIATE,"PUSH_IMMEDIATE"},
    };
}
template<>constexpr std::array<std::pair<Op2,std::string_view>,30> make_enum_name_array<Op2>() {
    return {
        std::pair{Op2::NOP,"NOP"},
        std::pair{Op2::TRSF,"TRSF"},
        std::pair{Op2::LOAD_MEMORY,"LOAD_MEMORY"},
        std::pair{Op2::STORE_MEMORY,"STORE_MEMORY"},
        std::pair{Op2::LOAD_IMMEDIATE,"LOAD_IMMEDIATE"},
        std::pair{Op2::ADD,"ADD"},
        std::pair{Op2::SUB,"SUB"},
        std::pair{Op2::MUL,"MUL"},
        std::pair{Op2::DIV,"DIV"},
        std::pair{Op2::MOD,"MOD"},
        std::pair{Op2::AND,"AND"},
        std::pair{Op2::OR,"OR"},
        std::pair{Op2::XOR,"XOR"},
        std::pair{Op2::NOT,"NOT"},
        std::pair{Op2::SHL,"SHL"},
        std::pair{Op2::SHR,"SHR"},
        std::pair{Op2::EQ,"EQ"},
        std::pair{Op2::NE,"NE"},
        std::pair{Op2::LT,"LT"},
        std::pair{Op2::LE,"LE"},
        std::pair{Op2::INC,"INC"},
        std::pair{Op2::DEC,"DEC"},
        std::pair{Op2::NEG,"NEG"},
        std::pair{Op2::JMP,"JMP"},
        std::pair{Op2::JMPIF,"JMPIF"},
        std::pair{Op2::CALL,"CALL"},
        std::pair{Op2::RET,"RET"},
        std::pair{Op2::PUSH,"PUSH"},
        std::pair{Op2::POP,"POP"},
        std::pair{Op2::PUSH_IMMEDIATE,"PUSH_IMMEDIATE"},
    };
}
constexpr void as_json(Op2 e,auto&& d) {
    d.value(static_cast<size_t>(e));
}
template<>
constexpr std::optional<Op2> from_json<Op2,size_t>(size_t k){
    return static_cast<Op2>(k);
}
template<>constexpr bool is_bit_flag<Op2>() {
    return true;
}
template<>
constexpr const char* enum_type_name<Op2>() {
    return "Op2";
}
}
