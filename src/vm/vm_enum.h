/*license*/
// Code generated by "enum_gen"; DO NOT EDIT.
#pragma once
#include <string_view>
#include <optional>
#include <array>
namespace brgen::vm {
template<typename T>
constexpr std::optional<T> from_string(std::string_view str);
template<typename T>
constexpr size_t enum_elem_count();
template<typename T>
constexpr std::array<std::pair<T,std::string_view>,enum_elem_count<T>()> make_enum_array();
template<typename T>
constexpr std::array<std::pair<T,std::string_view>,enum_elem_count<T>()> make_enum_name_array();
template<typename T>
constexpr const char* enum_type_name();
template<typename T>
constexpr auto enum_array = make_enum_array<T>();
template<typename T>
constexpr auto enum_name_array = make_enum_name_array<T>();
enum class Op {
    NOP,
    ADD,
    SUB,
    MUL,
    DIV,
    MOD,
    AND,
    OR,
    XOR,
    NOT,
    SHL,
    SHR,
    INC,
    DEC,
    NEG,
    CMP,
    JMP,
    JE,
    JNE,
    JG,
    JGE,
    JL,
    JLE,
    CALL,
    RET,
    PUSH,
    POP,
    TRSF,
    SET_VAR_COUNT,
    INIT_VAR,
    LOAD_VAR,
    STORE_VAR,
    STATIC_LOAD,
    GET_OFFSET,
    SET_OFFSET,
    READ_BYTES,
    PEEK_BYTES,
    WRITE_BYTES,
    ERROR,
    NEXT_FUNC,
    FUNC_NAME,
};
constexpr const char* to_string(Op e) {
    switch(e) {
    case Op::NOP: return "NOP";
    case Op::ADD: return "ADD";
    case Op::SUB: return "SUB";
    case Op::MUL: return "MUL";
    case Op::DIV: return "DIV";
    case Op::MOD: return "MOD";
    case Op::AND: return "AND";
    case Op::OR: return "OR";
    case Op::XOR: return "XOR";
    case Op::NOT: return "NOT";
    case Op::SHL: return "SHL";
    case Op::SHR: return "SHR";
    case Op::INC: return "INC";
    case Op::DEC: return "DEC";
    case Op::NEG: return "NEG";
    case Op::CMP: return "CMP";
    case Op::JMP: return "JMP";
    case Op::JE: return "JE";
    case Op::JNE: return "JNE";
    case Op::JG: return "JG";
    case Op::JGE: return "JGE";
    case Op::JL: return "JL";
    case Op::JLE: return "JLE";
    case Op::CALL: return "CALL";
    case Op::RET: return "RET";
    case Op::PUSH: return "PUSH";
    case Op::POP: return "POP";
    case Op::TRSF: return "TRSF";
    case Op::SET_VAR_COUNT: return "SET_VAR_COUNT";
    case Op::INIT_VAR: return "INIT_VAR";
    case Op::LOAD_VAR: return "LOAD_VAR";
    case Op::STORE_VAR: return "STORE_VAR";
    case Op::STATIC_LOAD: return "STATIC_LOAD";
    case Op::GET_OFFSET: return "GET_OFFSET";
    case Op::SET_OFFSET: return "SET_OFFSET";
    case Op::READ_BYTES: return "READ_BYTES";
    case Op::PEEK_BYTES: return "PEEK_BYTES";
    case Op::WRITE_BYTES: return "WRITE_BYTES";
    case Op::ERROR: return "ERROR";
    case Op::NEXT_FUNC: return "NEXT_FUNC";
    case Op::FUNC_NAME: return "FUNC_NAME";
    default: return nullptr;
    }
}
template<>constexpr std::optional<Op> from_string<Op>(std::string_view str) {
    if(str.empty()) return std::nullopt;
    if(str == "NOP") return Op::NOP;
    if(str == "ADD") return Op::ADD;
    if(str == "SUB") return Op::SUB;
    if(str == "MUL") return Op::MUL;
    if(str == "DIV") return Op::DIV;
    if(str == "MOD") return Op::MOD;
    if(str == "AND") return Op::AND;
    if(str == "OR") return Op::OR;
    if(str == "XOR") return Op::XOR;
    if(str == "NOT") return Op::NOT;
    if(str == "SHL") return Op::SHL;
    if(str == "SHR") return Op::SHR;
    if(str == "INC") return Op::INC;
    if(str == "DEC") return Op::DEC;
    if(str == "NEG") return Op::NEG;
    if(str == "CMP") return Op::CMP;
    if(str == "JMP") return Op::JMP;
    if(str == "JE") return Op::JE;
    if(str == "JNE") return Op::JNE;
    if(str == "JG") return Op::JG;
    if(str == "JGE") return Op::JGE;
    if(str == "JL") return Op::JL;
    if(str == "JLE") return Op::JLE;
    if(str == "CALL") return Op::CALL;
    if(str == "RET") return Op::RET;
    if(str == "PUSH") return Op::PUSH;
    if(str == "POP") return Op::POP;
    if(str == "TRSF") return Op::TRSF;
    if(str == "SET_VAR_COUNT") return Op::SET_VAR_COUNT;
    if(str == "INIT_VAR") return Op::INIT_VAR;
    if(str == "LOAD_VAR") return Op::LOAD_VAR;
    if(str == "STORE_VAR") return Op::STORE_VAR;
    if(str == "STATIC_LOAD") return Op::STATIC_LOAD;
    if(str == "GET_OFFSET") return Op::GET_OFFSET;
    if(str == "SET_OFFSET") return Op::SET_OFFSET;
    if(str == "READ_BYTES") return Op::READ_BYTES;
    if(str == "PEEK_BYTES") return Op::PEEK_BYTES;
    if(str == "WRITE_BYTES") return Op::WRITE_BYTES;
    if(str == "ERROR") return Op::ERROR;
    if(str == "NEXT_FUNC") return Op::NEXT_FUNC;
    if(str == "FUNC_NAME") return Op::FUNC_NAME;
    return std::nullopt;
}
template<>constexpr size_t enum_elem_count<Op>() {
    return 41;
}
template<>constexpr std::array<std::pair<Op,std::string_view>,41> make_enum_array<Op>() {
    return {
        std::pair{Op::NOP,"NOP"},
        std::pair{Op::ADD,"ADD"},
        std::pair{Op::SUB,"SUB"},
        std::pair{Op::MUL,"MUL"},
        std::pair{Op::DIV,"DIV"},
        std::pair{Op::MOD,"MOD"},
        std::pair{Op::AND,"AND"},
        std::pair{Op::OR,"OR"},
        std::pair{Op::XOR,"XOR"},
        std::pair{Op::NOT,"NOT"},
        std::pair{Op::SHL,"SHL"},
        std::pair{Op::SHR,"SHR"},
        std::pair{Op::INC,"INC"},
        std::pair{Op::DEC,"DEC"},
        std::pair{Op::NEG,"NEG"},
        std::pair{Op::CMP,"CMP"},
        std::pair{Op::JMP,"JMP"},
        std::pair{Op::JE,"JE"},
        std::pair{Op::JNE,"JNE"},
        std::pair{Op::JG,"JG"},
        std::pair{Op::JGE,"JGE"},
        std::pair{Op::JL,"JL"},
        std::pair{Op::JLE,"JLE"},
        std::pair{Op::CALL,"CALL"},
        std::pair{Op::RET,"RET"},
        std::pair{Op::PUSH,"PUSH"},
        std::pair{Op::POP,"POP"},
        std::pair{Op::TRSF,"TRSF"},
        std::pair{Op::SET_VAR_COUNT,"SET_VAR_COUNT"},
        std::pair{Op::INIT_VAR,"INIT_VAR"},
        std::pair{Op::LOAD_VAR,"LOAD_VAR"},
        std::pair{Op::STORE_VAR,"STORE_VAR"},
        std::pair{Op::STATIC_LOAD,"STATIC_LOAD"},
        std::pair{Op::GET_OFFSET,"GET_OFFSET"},
        std::pair{Op::SET_OFFSET,"SET_OFFSET"},
        std::pair{Op::READ_BYTES,"READ_BYTES"},
        std::pair{Op::PEEK_BYTES,"PEEK_BYTES"},
        std::pair{Op::WRITE_BYTES,"WRITE_BYTES"},
        std::pair{Op::ERROR,"ERROR"},
        std::pair{Op::NEXT_FUNC,"NEXT_FUNC"},
        std::pair{Op::FUNC_NAME,"FUNC_NAME"},
    };
}
template<>constexpr std::array<std::pair<Op,std::string_view>,41> make_enum_name_array<Op>() {
    return {
        std::pair{Op::NOP,"NOP"},
        std::pair{Op::ADD,"ADD"},
        std::pair{Op::SUB,"SUB"},
        std::pair{Op::MUL,"MUL"},
        std::pair{Op::DIV,"DIV"},
        std::pair{Op::MOD,"MOD"},
        std::pair{Op::AND,"AND"},
        std::pair{Op::OR,"OR"},
        std::pair{Op::XOR,"XOR"},
        std::pair{Op::NOT,"NOT"},
        std::pair{Op::SHL,"SHL"},
        std::pair{Op::SHR,"SHR"},
        std::pair{Op::INC,"INC"},
        std::pair{Op::DEC,"DEC"},
        std::pair{Op::NEG,"NEG"},
        std::pair{Op::CMP,"CMP"},
        std::pair{Op::JMP,"JMP"},
        std::pair{Op::JE,"JE"},
        std::pair{Op::JNE,"JNE"},
        std::pair{Op::JG,"JG"},
        std::pair{Op::JGE,"JGE"},
        std::pair{Op::JL,"JL"},
        std::pair{Op::JLE,"JLE"},
        std::pair{Op::CALL,"CALL"},
        std::pair{Op::RET,"RET"},
        std::pair{Op::PUSH,"PUSH"},
        std::pair{Op::POP,"POP"},
        std::pair{Op::TRSF,"TRSF"},
        std::pair{Op::SET_VAR_COUNT,"SET_VAR_COUNT"},
        std::pair{Op::INIT_VAR,"INIT_VAR"},
        std::pair{Op::LOAD_VAR,"LOAD_VAR"},
        std::pair{Op::STORE_VAR,"STORE_VAR"},
        std::pair{Op::STATIC_LOAD,"STATIC_LOAD"},
        std::pair{Op::GET_OFFSET,"GET_OFFSET"},
        std::pair{Op::SET_OFFSET,"SET_OFFSET"},
        std::pair{Op::READ_BYTES,"READ_BYTES"},
        std::pair{Op::PEEK_BYTES,"PEEK_BYTES"},
        std::pair{Op::WRITE_BYTES,"WRITE_BYTES"},
        std::pair{Op::ERROR,"ERROR"},
        std::pair{Op::NEXT_FUNC,"NEXT_FUNC"},
        std::pair{Op::FUNC_NAME,"FUNC_NAME"},
    };
}
constexpr void as_json(Op e,auto&& d) {
    d.value(enum_array<Op>[int(e)].second);
}
template<>
constexpr const char* enum_type_name<Op>() {
    return "Op";
}
}
