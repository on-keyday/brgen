// Code generated by json2go. DO NOT EDIT.
package ssa

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
)

type SsaOp uint8

const (
	SsaOp_Add        SsaOp = 0
	SsaOp_Sub        SsaOp = 1
	SsaOp_Mul        SsaOp = 2
	SsaOp_Div        SsaOp = 3
	SsaOp_Mod        SsaOp = 4
	SsaOp_And        SsaOp = 5
	SsaOp_Or         SsaOp = 6
	SsaOp_Xor        SsaOp = 7
	SsaOp_Shl        SsaOp = 8
	SsaOp_Shr        SsaOp = 9
	SsaOp_Eq         SsaOp = 10
	SsaOp_Ne         SsaOp = 11
	SsaOp_Lt         SsaOp = 12
	SsaOp_Le         SsaOp = 13
	SsaOp_Gt         SsaOp = 14
	SsaOp_Ge         SsaOp = 15
	SsaOp_Land       SsaOp = 16
	SsaOp_Lor        SsaOp = 17
	SsaOp_Neg        SsaOp = 18
	SsaOp_Not        SsaOp = 19
	SsaOp_Phi        SsaOp = 20
	SsaOp_Load       SsaOp = 21
	SsaOp_Store      SsaOp = 22
	SsaOp_Call       SsaOp = 23
	SsaOp_Ret        SsaOp = 24
	SsaOp_Br         SsaOp = 25
	SsaOp_Brc        SsaOp = 26
	SsaOp_BeginBlock SsaOp = 27
	SsaOp_Nop        SsaOp = 28
	SsaOp_Assign     SsaOp = 29
)

func (t SsaOp) String() string {
	switch t {
	case SsaOp_Add:
		return "Add"
	case SsaOp_Sub:
		return "Sub"
	case SsaOp_Mul:
		return "Mul"
	case SsaOp_Div:
		return "Div"
	case SsaOp_Mod:
		return "Mod"
	case SsaOp_And:
		return "And"
	case SsaOp_Or:
		return "Or"
	case SsaOp_Xor:
		return "Xor"
	case SsaOp_Shl:
		return "Shl"
	case SsaOp_Shr:
		return "Shr"
	case SsaOp_Eq:
		return "Eq"
	case SsaOp_Ne:
		return "Ne"
	case SsaOp_Lt:
		return "Lt"
	case SsaOp_Le:
		return "Le"
	case SsaOp_Gt:
		return "Gt"
	case SsaOp_Ge:
		return "Ge"
	case SsaOp_Land:
		return "Land"
	case SsaOp_Lor:
		return "Lor"
	case SsaOp_Neg:
		return "Neg"
	case SsaOp_Not:
		return "Not"
	case SsaOp_Phi:
		return "Phi"
	case SsaOp_Load:
		return "Load"
	case SsaOp_Store:
		return "Store"
	case SsaOp_Call:
		return "Call"
	case SsaOp_Ret:
		return "Ret"
	case SsaOp_Br:
		return "Br"
	case SsaOp_Brc:
		return "Brc"
	case SsaOp_BeginBlock:
		return "BeginBlock"
	case SsaOp_Nop:
		return "Nop"
	case SsaOp_Assign:
		return "Assign"
	}
	return fmt.Sprintf("SsaOp(%d)", t)
}

type Ssa struct {
	Op     SsaOp
	ArgLen uint8
	Args   []uint32
}
type VisitorLUQSZ interface {
	Visit(v VisitorLUQSZ, name string, field any)
}
type VisitorLUQSZFunc func(v VisitorLUQSZ, name string, field any)

func (f VisitorLUQSZFunc) Visit(v VisitorLUQSZ, name string, field any) {
	f(v, name, field)
}
func (t *Ssa) SetArgs(v []uint32) bool {
	if len(v) > int(^uint8(0)) {
		return false
	}
	t.ArgLen = uint8(len(v))
	t.Args = v
	return true
}
func (t *Ssa) Visit(v VisitorLUQSZ) {
	v.Visit(v, "Op", t.Op)
	v.Visit(v, "ArgLen", t.ArgLen)
	v.Visit(v, "Args", t.Args)
}
func (t *Ssa) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Op)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Op: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.ArgLen)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.ArgLen: %w", err)
	}
	len_Args := int(t.ArgLen)
	if len(t.Args) != len_Args {
		return fmt.Errorf("encode Args: expect %d bytes but got %d bytes", len_Args, len(t.Args))
	}
	for _, v := range t.Args {
		tmp1 := [4]byte{}
		binary.BigEndian.PutUint32(tmp1[:], uint32(v))
		if n, err := w.Write(tmp1[:]); err != nil || n != 4 {
			return fmt.Errorf("encode v: %w", err)
		}
	}
	return nil
}
func (t *Ssa) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Ssa) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Ssa) Read(r io.Reader) (err error) {
	tmpOp := [1]byte{}
	n_Op, err := io.ReadFull(r, tmpOp[:])
	if err != nil {
		if err == io.ErrUnexpectedEOF || n_Op != 1 /*stdlib bug?*/ {
			return fmt.Errorf("read Op: %w: expect 1 byte but read %d bytes", io.ErrUnexpectedEOF, n_Op)
		}
		return err
	}
	t.Op = SsaOp(tmpOp[0])
	tmpArgLen := [1]byte{}
	n_ArgLen, err := io.ReadFull(r, tmpArgLen[:])
	if err != nil {
		if err == io.ErrUnexpectedEOF || n_ArgLen != 1 /*stdlib bug?*/ {
			return fmt.Errorf("read ArgLen: %w: expect 1 byte but read %d bytes", io.ErrUnexpectedEOF, n_ArgLen)
		}
		return err
	}
	t.ArgLen = uint8(tmpArgLen[0])
	len_Args := int(t.ArgLen)
	for i_2 := 0; i_2 < len_Args; i_2++ {
		var tmp3_ uint32
		tmpArgs := [4]byte{}
		n_Args, err := io.ReadFull(r, tmpArgs[:])
		if err != nil {
			if err == io.ErrUnexpectedEOF || n_Args != 4 /*stdlib bug?*/ {
				return fmt.Errorf("read Args: %w: expect 4 bytes but read %d bytes", io.ErrUnexpectedEOF, n_Args)
			}
			return err
		}
		tmp3_ = uint32(binary.BigEndian.Uint32(tmpArgs[:]))
		t.Args = append(t.Args, tmp3_)
	}
	return nil
}

func (t *Ssa) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Ssa) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Ssa: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
