/*license*/
#pragma once
#include <core/ast/ast.h>
#include <core/ast/tool/sort.h>
#include <writer/writer.h>
#include <core/ast/tool/stringer.h>
#include "../common/line_map.h"

namespace json2c {
    namespace ast = brgen::ast;
    struct Generator {
        brgen::writer::Writer h_w;
        brgen::writer::Writer c_w;
        ast::tool::Stringer str;
        std::vector<std::string> struct_names;
        std::vector<LineMap> line_map;

        void write_field(ast::Field* field) {
            if (auto int_ty = ast::as<ast::IntType>(field->field_type)) {
                auto bit = *int_ty->bit_size;
                if (int_ty->is_common_supported) {
                    h_w.writeln(int_ty->is_signed ? "" : "u", "int", brgen::nums(bit), "_t ", field->ident->ident, ";");
                }
                else if (bit < 64) {
                    if (field->eventual_bit_alignment != field->bit_alignment) {
                        return;  // skip
                    }
                }
            }
        }

        void write_struct_type(const std::shared_ptr<ast::StructType>& typ) {
            for (auto& field : typ->fields) {
                if (auto f = ast::as<ast::Field>(field)) {
                    write_field(f);
                }
            }
        }

        void write_format(const std::shared_ptr<ast::Format>& fmt) {
            auto typ = fmt->body->struct_type;
            auto ident = fmt->ident->ident;
            h_w.writeln("typedef struct ", ident, " {");
            write_struct_type(typ);
            h_w.writeln("} ", ident, ";");
        }

        void write_enum(const std::shared_ptr<ast::Enum>& e) {
            auto& enum_ident = e->ident->ident;
            h_w.writeln("typedef enum ", enum_ident, " {");
            for (auto& member : e->members) {
                auto& member_ident = member->ident->ident;
                auto value = str.to_string(member->value);
                h_w.writeln(enum_ident, "_", member_ident, " = ", value, ",");
            }
            h_w.writeln("} ", enum_ident, ";");
        }

        void write_program(const std::shared_ptr<ast::Program>& prog) {
            h_w.writeln("//Code generated by json2c");
            h_w.writeln("#pragma once");
            h_w.writeln("#include <stddef.h>");
            h_w.writeln("#include <stdint.h>");

            for (auto& fmt : prog->elements) {
                if (auto b = ast::as<ast::Binary>(fmt); b && b->op == ast::BinaryOp::const_assign && b->right->constant_level == ast::ConstantLevel::constant) {
                    auto ident = ast::as<ast::Ident>(b->left);
                    assert(ident);
                    h_w.writeln("#define ", ident->ident, " ", str.to_string(b->right));
                    str.map_ident(ast::cast_to<ast::Ident>(b->left), ident->ident);
                }
                if (auto e = ast::as<ast::Enum>(fmt); e) {
                    write_enum(ast::cast_to<ast::Enum>(fmt));
                }
            }
            ast::tool::FormatSorter s;
            auto sorted = s.topological_sort(prog);
            for (auto& fmt : sorted) {
                write_format(ast::cast_to<ast::Format>(fmt));
            }
        }
    };
}  // namespace json2c
