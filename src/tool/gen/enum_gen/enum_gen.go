package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"

	"github.com/on-keyday/brgen/ast2go/ast"
	"github.com/on-keyday/brgen/ast2go/gen"
)

var nameSpace = flag.String("namespace", "", "namespace of the enum")

func main() {
	flag.Parse()
	a := &ast.AstFile{}

	err := json.NewDecoder(os.Stdin).Decode(a)
	if err != nil {
		log.Fatal(err)
	}
	p, err := ast.ParseAST(a.Ast)
	if err != nil {
		log.Fatal(err)
	}
	err = gen.ConfigFromProgram(p, func(configName string, asCall bool, args ...ast.Expr) error {
		if configName == "config.cpp.namespace" && !asCall {
			v, ok := args[0].(*ast.StrLiteral)
			if !ok {
				return fmt.Errorf("expected string literal")
			}
			q, err := strconv.Unquote(v.Value)
			if err != nil {
				return err
			}
			*nameSpace = q
		}
		return nil
	})
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("/*license*/\n")
	fmt.Printf("// Code generated by \"enum_gen\"; DO NOT EDIT.\n")
	fmt.Printf("#pragma once\n")
	fmt.Printf("#include <string_view>\n")
	fmt.Printf("#include <optional>\n")
	fmt.Printf("#include <array>\n")
	if *nameSpace != "" {
		fmt.Printf("namespace %s {\n", *nameSpace)
		defer fmt.Printf("}\n")
	}

	fmt.Printf("template<typename T>\n")
	fmt.Printf("constexpr std::optional<T> from_string(std::string_view str);\n")
	fmt.Printf("template<typename T>\n")
	fmt.Printf("constexpr size_t enum_elem_count();\n")
	fmt.Printf("template<typename T>\n")
	fmt.Printf("constexpr std::array<std::pair<T,std::string_view>,enum_elem_count<T>()> make_enum_array();\n")
	fmt.Printf("template<typename T>\n")
	fmt.Printf("constexpr std::array<std::pair<T,std::string_view>,enum_elem_count<T>()> make_enum_name_array();\n")
	fmt.Printf("template<typename T>\n")
	fmt.Printf("constexpr const char* enum_type_name();\n")

	fmt.Printf("template<typename T>\n")
	fmt.Printf("constexpr auto enum_array = make_enum_array<T>();\n")

	fmt.Printf("template<typename T>\n")
	fmt.Printf("constexpr auto enum_name_array = make_enum_name_array<T>();\n")
	s := gen.NewExprStringer()
	for _, v := range p.Elements {
		if e, ok := v.(*ast.Enum); ok {
			enumName := e.Ident.Ident
			fmt.Printf("enum class %s {\n", enumName)
			for _, v := range e.Members {
				fmt.Printf("    %s = %s,\n", v.Ident.Ident, s.ExprString(v.Value))
			}
			fmt.Printf("};\n")
			fmt.Printf("constexpr const char* to_string(%s e) {\n", enumName)
			fmt.Printf("    switch(e) {\n")

			normalizeName := func(s string) string {
				if len(s) > 1 && strings.HasSuffix(s, "_") {
					return s[:len(s)-1]
				}
				return s
			}
			toStr := func(s *ast.EnumMember) string {
				if s.StrLiteral != nil {
					return s.StrLiteral.Value
				}
				return fmt.Sprintf("%q", normalizeName(s.Ident.Ident))
			}
			for _, v := range e.Members {
				fmt.Printf("    case %s::%s: return %s;\n", enumName, v.Ident.Ident, toStr(v))
			}
			fmt.Printf("    default: return nullptr;\n")
			fmt.Printf("    }\n")
			fmt.Printf("}\n")

			fmt.Printf("template<>")
			fmt.Printf("constexpr std::optional<%s> from_string<%s>(std::string_view str) {\n", enumName, enumName)
			fmt.Printf("    if(str.empty()) return std::nullopt;\n")
			for _, v := range e.Members {
				fmt.Printf("    if(str == %s) return %s::%s;\n", toStr(v), enumName, v.Ident.Ident)
			}
			fmt.Printf("    return std::nullopt;\n")
			fmt.Printf("}\n")

			fmt.Printf("template<>")
			fmt.Printf("constexpr size_t enum_elem_count<%s>() {\n", enumName)
			fmt.Printf("    return %d;\n", len(e.Members))
			fmt.Printf("}\n")

			fmt.Printf("template<>")
			fmt.Printf("constexpr std::array<std::pair<%s,std::string_view>,%d> make_enum_array<%s>() {\n", enumName, len(e.Members), enumName)
			fmt.Printf("    return {\n")
			for _, v := range e.Members {
				fmt.Printf("        std::pair{%s::%s,%s},\n", enumName, v.Ident.Ident, toStr(v))
			}
			fmt.Printf("    };\n")
			fmt.Printf("}\n")

			fmt.Printf("template<>")
			fmt.Printf("constexpr std::array<std::pair<%s,std::string_view>,%d> make_enum_name_array<%s>() {\n", enumName, len(e.Members), enumName)
			fmt.Printf("    return {\n")
			for _, v := range e.Members {
				fmt.Printf("        std::pair{%s::%s,%q},\n", enumName, v.Ident.Ident, normalizeName(v.Ident.Ident))
			}
			fmt.Printf("    };\n")
			fmt.Printf("}\n")

			fmt.Printf("constexpr void as_json(%s e,auto&& d) {\n", enumName)
			fmt.Printf("    d.value(enum_array<%s>[int(e)].second);\n", enumName)
			fmt.Printf("}\n")

			fmt.Printf("template<>\n")
			fmt.Printf("constexpr const char* enum_type_name<%s>() {\n", enumName)
			fmt.Printf("    return \"%s\";\n", enumName)
			fmt.Printf("}\n")
		}
	}
}
