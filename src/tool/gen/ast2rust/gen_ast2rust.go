package main

import (
	"io"
	"log"
	"os"
	"path/filepath"

	"github.com/iancoleman/strcase"
	"github.com/on-keyday/brgen/src/tool/gen"
)

func generate(rw io.Writer, defs *gen.Defs) {
	w := gen.NewWriter(rw)
	w.Printf("// Code generated by ast2rust. DO NOT EDIT.\n")
	w.Printf("use std::rc::{Rc,Weak};\n")
	w.Printf("use std::cell::RefCell;\n")
	w.Printf("use std::convert::TryFrom;\n")
	w.Printf("use serde_derive::{Serialize,Deserialize};\n\n")
	w.Printf("use std::collections::HashMap;\n\n")

	w.Printf("pub enum Error {\n")
	w.Printf("	UnknownNodeType(NodeType),\n")
	w.Printf("	MismatchNodeType(NodeType,NodeType),\n")
	w.Printf("	JSONError(serde_json::Error),\n")
	w.Printf("	MissingField(NodeType,&'static str),\n")
	w.Printf("}\n\n")

	w.Printf("#[derive(Debug,Clone,Copy,Serialize,Deserialize)]\n")
	w.Printf("#[serde(rename_all = \"snake_case\",untagged)]\n")
	w.Printf("pub enum NodeType {\n")
	for _, nodeType := range defs.NodeTypes {
		w.Printf("	%s,\n", strcase.ToCamel(nodeType))
	}
	w.Printf("}\n\n")

	w.Printf("impl TryFrom<&str> for NodeType {\n")
	w.Printf("	type Error = ();\n")
	w.Printf("	fn try_from(s:&str)->Result<Self,Self::Error>{\n")
	w.Printf("		match s{\n")
	for _, nodeType := range defs.NodeTypes {
		w.Printf("			%q =>Ok(Self::%s),\n", nodeType, strcase.ToCamel(nodeType))
	}
	w.Printf("			_=> Err(()),\n")
	w.Printf("		}\n")
	w.Printf("	}\n")
	w.Printf("}\n\n")

	w.Printf("impl TryFrom<&Node> for NodeType {\n")
	w.Printf("	type Error = ();\n")
	w.Printf("	fn try_from(node:&Node)->Result<Self,Self::Error>{\n")
	w.Printf("		match node {\n")
	for _, nodeType := range defs.NodeTypes {
		w.Printf("			Node::%s(_) =>Ok(Self::%s),\n", strcase.ToCamel(nodeType), strcase.ToCamel(nodeType))
	}
	w.Printf("			_=> Err(()),\n")
	w.Printf("		}\n")
	w.Printf("	}\n")
	w.Printf("}\n\n")

	for _, def := range defs.Defs {
		switch d := def.(type) {
		case *gen.Interface:
			w.Printf("#[derive(Debug,Clone)]\n")
			w.Printf("pub enum %s {\n", d.Name)
			for _, field := range d.Derived {
				found, ok := defs.Structs[field]
				if !ok {
					continue
				}
				w.Printf("	%s(Rc<RefCell<%s>>),\n", field, found.Name)
			}
			w.Printf("}\n\n")
		case *gen.Struct:
			if len(d.Implements) == 0 && d.Name != "Scope" {
				w.Printf("#[derive(Debug,Clone,Copy,Serialize,Deserialize)]\n")
			} else {
				w.Printf("#[derive(Debug,Clone)]\n")
			}
			w.Printf("pub struct %s {\n", d.Name)
			for _, field := range d.Fields {
				w.Printf("	pub %s: %s,\n", field.Name, field.Type.RustString())
			}
			w.Printf("}\n\n")
		case *gen.Enum:
			w.Printf("#[derive(Debug,Clone,Copy,Serialize,Deserialize)]\n")
			w.Printf("#[serde(rename_all = \"snake_case\",untagged)]\n")
			w.Printf("pub enum %s {\n", d.Name)
			for _, field := range d.Values {
				field.Name = strcase.ToCamel(field.Name)
				w.Printf("	%s,\n", field.Name)
			}
			w.Printf("}\n\n")
			w.Printf("impl TryFrom<&str> for %s {\n", d.Name)
			w.Printf("	type Error = ();\n")
			w.Printf("	fn try_from(s:&str)->Result<Self,Self::Error>{\n")
			w.Printf("		match s{\n")
			for _, field := range d.Values {
				w.Printf("			%q =>Ok(Self::%s),\n", field.Str, field.Name)
			}
			w.Printf("			_=> Err(()),\n")
			w.Printf("		}\n")
			w.Printf("	}\n")
			w.Printf("}\n\n")
		}
	}

	w.Printf("#[derive(Debug,Clone,Serialize,Deserialize)]\n")
	w.Printf("pub struct RawNode {\n")
	w.Printf("	pub node_type: NodeType,\n")
	w.Printf("	pub loc :Loc,\n")
	w.Printf("	pub body: HashMap<String,serde_json::Value>,\n")
	w.Printf("}\n\n")

	w.Printf("#[derive(Debug,Clone,Serialize,Deserialize)]\n")
	w.Printf("pub struct RawScope {\n")
	w.Printf("	pub prev :Option<u64>,\n")
	w.Printf("	pub next :Option<u64>,\n")
	w.Printf("	pub branch :Option<u64>,\n")
	w.Printf("	pub ident :Vec<u64>,\n")
	w.Printf("}\n\n")

	w.Printf("#[derive(Debug,Clone,Serialize,Deserialize)]\n")
	w.Printf("pub struct AST {\n")
	w.Printf("	pub node: Vec<RawNode>,\n")
	w.Printf("	pub scope: Vec<RawScope>,\n")
	w.Printf("}\n\n")

	w.Printf("pub fn parse_ast(ast:AST)->Result<Rc<RefCell<Program>> ,Error>{\n")
	defer w.Printf("}\n\n")
	w.Printf("	let mut nodes = Vec::new();\n")
	w.Printf("	let mut scopes = Vec::new();\n")
	w.Printf("	for raw_node in &ast.node{\n")
	w.Printf("		let node = match raw_node.node_type {\n")
	for _, nodeType := range defs.Defs {
		switch d := nodeType.(type) {
		case *gen.Struct:
			if len(d.Implements) == 0 {
				continue
			}
			w.Printf("			NodeType::%s => {\n", d.Name)
			w.Printf("				Node::%s(Rc::new(RefCell::new(%s {\n", d.Name, d.Name)
			for _, field := range d.Fields {
				if field.Type.IsArray {
					w.Printf("				%s: Vec::new(),\n", field.Name)
				} else if field.Type.IsPtr || field.Type.IsInterface {
					w.Printf("				%s: None,\n", field.Name)
				} else if field.Type.Name == "u64" {
					w.Printf("				%s: 0,\n", field.Name)
				} else if field.Type.Name == "String" {
					w.Printf("				%s: String::new(),\n", field.Name)
				} else if field.Type.Name == "bool" {
					w.Printf("				%s: false,\n", field.Name)
				} else if field.Type.Name == "Loc" {
					w.Printf("				%s: raw_node.loc.clone(),\n", field.Name)
				} else {
					found, ok := defs.Enums[field.Type.Name]
					if !ok {
						continue
					}
					w.Printf("				%s: %s::%s,\n", field.Name, field.Type.Name, found.Values[0].Name)
				}
			}
			w.Printf("				})))\n")
			w.Printf("			},\n")
		}
	}
	w.Printf("			_=>return Err(Error::UnknownNodeType(raw_node.node_type)),\n")
	w.Printf("		};\n")
	w.Printf("		nodes.push(node);\n")
	w.Printf("	}\n")
	w.Printf("	for raw_scope in &ast.scope{\n")
	w.Printf("		let scope = Scope{\n")
	w.Printf("			prev: None,\n")
	w.Printf("			next: None,\n")
	w.Printf("			branch: None,\n")
	w.Printf("			ident: Vec::new(),\n")
	w.Printf("		};\n")
	w.Printf("		scopes.push(scope);\n")
	w.Printf("	}\n")

	w.Printf("	for (i,raw_node) in ast.node.into_iter().enumerate(){\n")
	w.Printf("		match raw_node.node_type {\n")
	for _, nodeType := range defs.Defs {
		switch d := nodeType.(type) {
		case *gen.Struct:
			if len(d.Implements) == 0 {
				continue
			}
			w.Printf("			NodeType::%s => {\n", d.Name)
			w.Printf("				let node = nodes[i].clone();\n")
			w.Printf("				let node = match node {\n")
			w.Printf("					Node::%s(node)=>node,\n", d.Name)
			w.Printf("					_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),\n")
			w.Printf("				};\n")
			for _, field := range d.Fields {
				w.Printf("				let %s_body = match raw_node.body.get(%q) {\n", field.Name, field.Tag)
				w.Printf("					Some(v)=>v,\n")
				w.Printf("					None=>return Err(Error::MissingField(raw_node.node_type,%q)),\n", field.Tag)
				w.Printf("				};\n")
				if field.Type.IsArray {
					w.Printf("				let %s_body = match %s_body.as_array(){\n", field.Name, field.Name)
					w.Printf("					Some(v)=>v,\n")
					w.Printf("					None=>return Err(Error::JSONError(serde_json::Error::custom(\"%s is not array\"))),\n", field.Name)
					w.Printf("				};\n")
					w.Printf("				for (i,raw_node) in raw_node.body.%s.iter().enumerate(){\n", field.Name)
					w.Printf("					let node = nodes[*raw_node as usize].clone();\n")
					w.Printf("					let node = match node {\n")
					w.Printf("						Node::%s(node)=>node,\n", field.Type.Name)
					w.Printf("						_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),\n")
					w.Printf("					};\n")
					w.Printf("					node.%s.push(node);\n", field.Name)
					w.Printf("				}\n")
				} else if field.Type.IsPtr || field.Type.IsInterface {
					w.Printf("				if let Some(raw_node) = raw_node.body.%s{\n", field.Name)
					w.Printf("					let node = nodes[raw_node as usize].clone();\n")
					w.Printf("					let node = match node {\n")
					w.Printf("						Node::%s(node)=>node,\n", field.Type.Name)
					w.Printf("						_=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),\n")
					w.Printf("					};\n")
					w.Printf("					node.%s = Some(node);\n", field.Name)
					w.Printf("				}\n")
				} else if field.Type.Name == "u64" {
					w.Printf("				node.%s = raw_node.body.%s;\n", field.Name, field.Name)
				} else if field.Type.Name == "String" {
					w.Printf("				node.%s = raw_node.body.%s.clone();\n", field.Name, field.Name)
				} else if field.Type.Name == "bool" {
					w.Printf("				node.%s = raw_node.body.%s;\n", field.Name, field.Name)
				} else if field.Type.Name == "Loc" {
					w.Printf("				node.%s = raw_node.loc.clone();\n", field.Name)
				} else {
					_, ok := defs.Enums[field.Type.Name]
					if !ok {
						continue
					}
					w.Printf("				node.%s = match %s::try_from(&raw_node.body.%s){\n", field.Name, field.Type.Name, field.Name)
					w.Printf("					Ok(v)=>v,\n")
					w.Printf("					Err(_)=>return Err(Error::MismatchNodeType(raw_node.node_type,node.into())),\n")
					w.Printf("				};\n")
				}
			}
			w.Printf("			},\n")
		}
	}
	w.Printf("			_=>return Err(Error::UnknownNodeType(raw_node.node_type)),\n")
	w.Printf("		};\n")
	w.Printf("	}\n")
}

func main() {
	if len(os.Args) != 2 {
		log.Println("usage: gen_ast2ts <file>")
		return
	}

	file := os.Args[1]

	log.SetFlags(log.Flags() | log.Lshortfile)

	list, err := gen.LoadFromDefaultSrc2JSON()

	if err != nil {
		log.Println(err)
		return
	}

	defs, err := gen.CollectDefinition(list, strcase.ToSnake, strcase.ToCamel, map[string]string{
		"uint":    "u64",
		"uintptr": "usize",
		"string":  "String",
	})

	if err != nil {
		log.Println(err)
		return
	}

	if file == "/dev/stdout" {
		generate(os.Stdout, defs)
		return
	}

	file, err = filepath.Abs(file)

	if err != nil {
		log.Println(err)
		return
	}

	f, err := os.Create(file)

	if err != nil {
		log.Println(err)
		return
	}
	defer f.Close()

	generate(f, defs)

}
