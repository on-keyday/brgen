package main

import (
	"io"
	"log"
	"os"
	"path/filepath"

	"github.com/iancoleman/strcase"
	"github.com/on-keyday/brgen/src/tool/gen"
)

func generate(rw io.Writer, defs *gen.Defs) {
	w := gen.NewWriter(rw)
	w.Printf("// Code generated by gen_ast2ts; DO NOT EDIT.\n")
	w.Printf("\n")
	w.Printf("export namespace ast2ts {\n")
	w.Printf("\n")
	defer w.Printf("}\n")

	w.Printf("export type NodeType = ")
	for i, typ := range defs.NodeTypes {
		if i != 0 {
			w.Printf(" | ")
		}
		w.Printf("%q", typ)
	}
	w.Printf(";\n\n")
	for _, def := range defs.Defs {
		switch d := def.(type) {
		case *gen.Interface:
			w.Printf("export interface %s", d.Name)
			commonFields := map[string]struct{}{}
			if d.Embed != "" {
				w.Printf(" extends %s", d.Embed)
				embed := d.Embed
				for embed != "" {
					iface := defs.Interfaces[embed]
					for _, field := range iface.Fields {
						commonFields[field.Name] = struct{}{}
					}
					embed = iface.Embed
				}
			}
			w.Printf(" {\n")
			if d.Name == "Node" {
				w.Printf("	readonly node_type: NodeType;\n")
			}
			for _, field := range d.Fields {
				if _, ok := commonFields[field.Name]; ok {
					continue
				}
				w.Printf("	%s: %s;\n", field.Name, field.Type.TsString())
			}
			w.Printf("}\n\n")

			w.Printf("export function is%s(obj: any): obj is %s {\n", d.Name, d.Name)
			for _, types := range d.Derived {
				found, ok := defs.Structs[types]
				if !ok {
					continue
				}
				w.Printf("	if (is%s(obj)) return true;\n", found.Name)
			}
			w.Printf("	return false;\n")
			w.Printf("}\n\n")
		case *gen.Struct:
			w.Printf("export interface %s ", d.Name)
			commonFields := map[string]struct{}{}
			if len(d.Implements) > 0 {
				w.Printf("extends %s ", d.Implements[0])
				for _, iface := range d.Implements {
					for _, field := range defs.Interfaces[iface].Fields {
						commonFields[field.Name] = struct{}{}
					}
				}
			}
			w.Printf("{\n")
			for _, field := range d.Fields {
				if _, ok := commonFields[field.Name]; ok {
					continue
				}
				w.Printf("	%s: %s;\n", field.Name, field.Type.TsString())
			}
			w.Printf("}\n\n")
			if len(d.Implements) > 0 {
				w.Printf("export function is%s(obj: any): obj is %s {\n", d.Name, d.Name)
				w.Printf("	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === %q\n", d.NodeType)
				w.Printf("}\n\n")
			} else {
				w.Printf("export function is%s(obj: any): obj is %s {\n", d.Name, d.Name)
				w.Printf("	return obj && typeof obj === 'object' && ")
				for i, field := range d.Fields {
					if field.Type.IsArray {
						continue // omit check
					}
					if i != 0 {
						w.Printf(" && ")
					}
					if field.Type.Name == "number" || field.Type.Name == "string" || field.Type.Name == "boolean" {
						w.Printf("typeof obj?.%s === 'number'", field.Name)
					} else if field.Type.IsPtr {
						w.Printf("(obj?.%s === null || is%s(obj?.%s))", field.Name, field.Type.Name, field.Name)
					} else {
						w.Printf("is%s(obj?.%s)", field.Type.Name, field.Name)
					}
				}
				w.Printf("\n")
				w.Printf("}\n\n")
			}
		case *gen.Enum:
			w.Printf("export type %s = ", d.Name)
			for i, val := range d.Values {
				if i != 0 {
					w.Printf(" | ")
				}
				w.Printf("%q", val.Str)
			}
			w.Printf(";\n\n")
			w.Printf("export function is%s(obj: any): obj is %s {\n", d.Name, d.Name)
			w.Printf("	return obj && typeof obj === 'string' && (")
			for i, val := range d.Values {
				if i != 0 {
					w.Printf(" || ")
				}
				w.Printf("obj === %q", val.Str)
			}
			w.Printf(")\n")
			w.Printf("}\n\n")

		}
	}

}

func main() {
	if len(os.Args) != 2 {
		log.Println("usage: gen_ast2ts <file>")
		return
	}

	file := os.Args[1]

	log.SetFlags(log.Flags() | log.Lshortfile)

	list, err := gen.LoadFromDefaultSrc2JSON()

	if err != nil {
		log.Println(err)
		return
	}

	defs, err := gen.CollectDefinition(list, strcase.ToSnake, strcase.ToCamel, map[string]string{
		"uint":    "number",
		"uintptr": "number",
		"bool":    "boolean",
	})

	if err != nil {
		log.Println(err)
		return
	}

	if file == "/dev/stdout" {
		generate(os.Stdout, defs)
		return
	}

	file, err = filepath.Abs(file)

	if err != nil {
		log.Println(err)
		return
	}

	f, err := os.Create(file)

	if err != nil {
		log.Println(err)
		return
	}
	defer f.Close()

	generate(f, defs)

}
