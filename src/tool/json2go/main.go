package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"os"
	"strings"

	ast2go "github.com/on-keyday/brgen/ast2go/ast"
	"github.com/on-keyday/brgen/ast2go/gen"
)

var f = flag.Bool("s", false, "tell spec of json2go")
var filename = flag.String("f", "", "file to parse")

type IndentPrinter struct {
	w      io.Writer
	indent int
}

func (i *IndentPrinter) Indent(plus int) {
	i.indent += plus
}

func (i *IndentPrinter) IndentAbs(abs int) (prev int) {
	prev = i.indent
	i.indent = abs
	return
}

func (i *IndentPrinter) IndentStr() string {
	return strings.Repeat("    ", i.indent)
}

func (i *IndentPrinter) Printf(format string, args ...interface{}) {
	fmt.Fprintf(i.w, i.IndentStr()+format, args...)
}

type Generator struct {
	w         io.Writer
	func_area bytes.Buffer
	seq       int
	bitFields map[*ast2go.Field]string
	indent    int
}

func (g *Generator) Indent(plus int) {
	g.indent += plus
}

func (g *Generator) IndentStr() string {
	return strings.Repeat("    ", g.indent)
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(g.w, g.IndentStr()+format, args...)
}

func (g *Generator) PrintfFunc(format string, args ...interface{}) {
	fmt.Fprintf(&g.func_area, g.IndentStr()+format, args...)
}

func (g *Generator) getSeq() int {
	g.seq++
	return g.seq
}

func (g *Generator) getType(typ ast2go.Type) string {
	if i_type, ok := typ.(*ast2go.IntType); ok {
		if i_type.IsCommonSupported {
			if i_type.IsSigned {
				return fmt.Sprintf("int%d", i_type.BitSize)
			} else {
				return fmt.Sprintf("uint%d", i_type.BitSize)
			}
		}
	}
	if e_type, ok := typ.(*ast2go.EnumType); ok {
		return fmt.Sprintf("%s", e_type.Base.Ident.Ident)
	}
	return ""
}

func (g *Generator) writeBitField(belong string, fields []*ast2go.Field, size uint64, intSet, simple bool) {
	if intSet && simple {
		seq := g.getSeq()
		g.Printf("flags%d uint%d\n", seq, size)
		offset := uint64(0)
		for _, v := range fields {
			g.PrintfFunc("func (t *%s) %s() uint%d {\n", belong, v.Ident.Ident, size)
			field_size := v.FieldType.GetBitSize()
			shift := (size - field_size - offset)
			bitMask := ((1 << field_size) - 1) << shift
			g.PrintfFunc("return (t.flags%d & 0x%x) >> %d \n", seq, bitMask, shift)
			g.PrintfFunc("}\n")
			offset += field_size
		}
		g.bitFields[fields[len(fields)-1]] = fmt.Sprintf("flags%d", seq)
		return
	}
}

func (g *Generator) writeStructType(belong string, s *ast2go.StructType) {
	var non_aligned []*ast2go.Field
	var (
		is_int_set        = true
		is_simple         = true
		size       uint64 = 0
	)
	for _, v := range s.Fields {
		if field, ok := v.(*ast2go.Field); ok {
			if field.BitAlignment == ast2go.BitAlignmentNotTarget {
				continue
			}
			typ := field.FieldType
			if i_typ, ok := typ.(*ast2go.IdentType); ok {
				typ = i_typ.Base
			}
			if field.BitAlignment != ast2go.BitAlignmentByteAligned {
				non_aligned = append(non_aligned, field)
				is_int_set = is_int_set && typ.GetIsIntSet()
				is_simple = is_simple &&
					(typ.GetNodeType() == ast2go.NodeTypeIntType ||
						typ.GetNodeType() == ast2go.NodeTypeEnumType)
				size += typ.GetBitSize()
				continue
			}
			if len(non_aligned) > 0 {
				non_aligned = append(non_aligned, field)
				is_int_set = is_int_set && typ.GetIsIntSet()
				is_simple = is_simple &&
					(typ.GetNodeType() == ast2go.NodeTypeIntType ||
						typ.GetNodeType() == ast2go.NodeTypeEnumType)
				size += typ.GetBitSize()
				g.writeBitField(belong, non_aligned, size, is_int_set, is_simple)
				non_aligned = nil
				is_int_set = true
				is_simple = true
				size = 0
				continue
			}
			if i_type, ok := typ.(*ast2go.IntType); ok {
				if i_type.IsCommonSupported {
					if i_type.IsSigned {
						g.Printf("%s int%d\n", field.Ident.Ident, i_type.BitSize)
					} else {
						g.Printf("%s uint%d\n", field.Ident.Ident, i_type.BitSize)
					}
					continue
				}
			}
		}
	}
}

func (g *Generator) writeFormat(p *ast2go.Format) {
	g.Printf("type %s struct {\n", p.Ident.Ident)
	g.Indent(1)
	g.writeStructType(p.Ident.Ident, p.Body.StructType)
	g.Indent(-1)
	g.Printf("}\n")
}

func (g *Generator) writeProgram(p *ast2go.Program) {
	conf := &gen.GenConfig{}
	conf.LookupGoConfig(p)
	if conf.PackageName == "" {
		conf.PackageName = "main"
	}
	g.Printf("// Code generated by brgen. DO NOT EDIT.\n")
	g.Printf("package %s\n", conf.PackageName)
	g.Printf("import (\n")
	g.Indent(1)
	g.Printf("\"encoding/binary\"\n")
	g.Printf("\"io\"\n")
	g.Indent(-1)
	g.Printf(")\n")
	for _, v := range p.Elements {
		if v, ok := v.(*ast2go.Format); ok {
			if v.Body.StructType.BitAlignment != ast2go.BitAlignmentByteAligned {
				continue
			}
			g.writeFormat(v)
		}
	}
	g.w.Write(g.func_area.Bytes())
}

func NewGenerator(w io.Writer) *Generator {
	return &Generator{
		w:         w,
		bitFields: make(map[*ast2go.Field]string),
	}
}

func (g *Generator) Generate(file *ast2go.AstFile) error {
	p, err := ast2go.ParseAST(file.Ast)
	if err != nil {
		return err
	}
	g.writeProgram(p)
	return nil
}

func main() {
	flag.Parse()
	if *f {
		fmt.Println(`{
			"langs" : ["go"],
			"pass_by" : "stdin",
			"suffix" : ".go"
		}`)
		return
	}
	file := ast2go.AstFile{}
	if *filename != "" {
		f, err := os.Open(*filename)
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
			return
		}
		defer f.Close()
		err = json.NewDecoder(f).Decode(&file)
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
			return
		}
	} else {
		err := json.NewDecoder(os.Stdin).Decode(&file)
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
			return
		}
	}
	g := NewGenerator(os.Stdout)

	err := g.Generate(&file)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
		return
	}

}
