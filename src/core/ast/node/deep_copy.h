// Code generated by gen_cpp_deep_copy; DO NOT EDIT.

#pragma once

#include <core/ast/ast.h>

namespace brgen::ast {

    template <class T, class NodeM, class ScopeM>
    std::shared_ptr<T> deep_copy(const std::shared_ptr<T>& node, NodeM&& node_map, ScopeM&& scope_map);

    template <class NodeM, class ScopeM>
    std::shared_ptr<Node> deep_copy(const std::shared_ptr<Node>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (ast::as<Program>(node)) {
            return deep_copy(ast::cast_to<Program>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Comment>(node)) {
            return deep_copy(ast::cast_to<Comment>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<CommentGroup>(node)) {
            return deep_copy(ast::cast_to<CommentGroup>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<FieldArgument>(node)) {
            return deep_copy(ast::cast_to<FieldArgument>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Binary>(node)) {
            return deep_copy(ast::cast_to<Binary>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Unary>(node)) {
            return deep_copy(ast::cast_to<Unary>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Cond>(node)) {
            return deep_copy(ast::cast_to<Cond>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Ident>(node)) {
            return deep_copy(ast::cast_to<Ident>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Call>(node)) {
            return deep_copy(ast::cast_to<Call>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<If>(node)) {
            return deep_copy(ast::cast_to<If>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<MemberAccess>(node)) {
            return deep_copy(ast::cast_to<MemberAccess>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Paren>(node)) {
            return deep_copy(ast::cast_to<Paren>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Index>(node)) {
            return deep_copy(ast::cast_to<Index>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Match>(node)) {
            return deep_copy(ast::cast_to<Match>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Range>(node)) {
            return deep_copy(ast::cast_to<Range>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Identity>(node)) {
            return deep_copy(ast::cast_to<Identity>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<TmpVar>(node)) {
            return deep_copy(ast::cast_to<TmpVar>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Import>(node)) {
            return deep_copy(ast::cast_to<Import>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Cast>(node)) {
            return deep_copy(ast::cast_to<Cast>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Available>(node)) {
            return deep_copy(ast::cast_to<Available>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<SpecifyOrder>(node)) {
            return deep_copy(ast::cast_to<SpecifyOrder>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<ExplicitError>(node)) {
            return deep_copy(ast::cast_to<ExplicitError>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IOOperation>(node)) {
            return deep_copy(ast::cast_to<IOOperation>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<OrCond>(node)) {
            return deep_copy(ast::cast_to<OrCond>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<BadExpr>(node)) {
            return deep_copy(ast::cast_to<BadExpr>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Loop>(node)) {
            return deep_copy(ast::cast_to<Loop>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IndentBlock>(node)) {
            return deep_copy(ast::cast_to<IndentBlock>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<ScopedStatement>(node)) {
            return deep_copy(ast::cast_to<ScopedStatement>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<MatchBranch>(node)) {
            return deep_copy(ast::cast_to<MatchBranch>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<UnionCandidate>(node)) {
            return deep_copy(ast::cast_to<UnionCandidate>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Return>(node)) {
            return deep_copy(ast::cast_to<Return>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Break>(node)) {
            return deep_copy(ast::cast_to<Break>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Continue>(node)) {
            return deep_copy(ast::cast_to<Continue>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Assert>(node)) {
            return deep_copy(ast::cast_to<Assert>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<ImplicitYield>(node)) {
            return deep_copy(ast::cast_to<ImplicitYield>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Metadata>(node)) {
            return deep_copy(ast::cast_to<Metadata>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IntType>(node)) {
            return deep_copy(ast::cast_to<IntType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<FloatType>(node)) {
            return deep_copy(ast::cast_to<FloatType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IdentType>(node)) {
            return deep_copy(ast::cast_to<IdentType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IntLiteralType>(node)) {
            return deep_copy(ast::cast_to<IntLiteralType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<StrLiteralType>(node)) {
            return deep_copy(ast::cast_to<StrLiteralType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<RegexLiteralType>(node)) {
            return deep_copy(ast::cast_to<RegexLiteralType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<VoidType>(node)) {
            return deep_copy(ast::cast_to<VoidType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<BoolType>(node)) {
            return deep_copy(ast::cast_to<BoolType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<ArrayType>(node)) {
            return deep_copy(ast::cast_to<ArrayType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<FunctionType>(node)) {
            return deep_copy(ast::cast_to<FunctionType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<StructType>(node)) {
            return deep_copy(ast::cast_to<StructType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<StructUnionType>(node)) {
            return deep_copy(ast::cast_to<StructUnionType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<UnionType>(node)) {
            return deep_copy(ast::cast_to<UnionType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<RangeType>(node)) {
            return deep_copy(ast::cast_to<RangeType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<EnumType>(node)) {
            return deep_copy(ast::cast_to<EnumType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<MetaType>(node)) {
            return deep_copy(ast::cast_to<MetaType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<OptionalType>(node)) {
            return deep_copy(ast::cast_to<OptionalType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<GenericType>(node)) {
            return deep_copy(ast::cast_to<GenericType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IntLiteral>(node)) {
            return deep_copy(ast::cast_to<IntLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<BoolLiteral>(node)) {
            return deep_copy(ast::cast_to<BoolLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<StrLiteral>(node)) {
            return deep_copy(ast::cast_to<StrLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<RegexLiteral>(node)) {
            return deep_copy(ast::cast_to<RegexLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<CharLiteral>(node)) {
            return deep_copy(ast::cast_to<CharLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<TypeLiteral>(node)) {
            return deep_copy(ast::cast_to<TypeLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<SpecialLiteral>(node)) {
            return deep_copy(ast::cast_to<SpecialLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Field>(node)) {
            return deep_copy(ast::cast_to<Field>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Format>(node)) {
            return deep_copy(ast::cast_to<Format>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<State>(node)) {
            return deep_copy(ast::cast_to<State>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Enum>(node)) {
            return deep_copy(ast::cast_to<Enum>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<EnumMember>(node)) {
            return deep_copy(ast::cast_to<EnumMember>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Function>(node)) {
            return deep_copy(ast::cast_to<Function>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        return nullptr;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Expr> deep_copy(const std::shared_ptr<Expr>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (ast::as<Binary>(node)) {
            return deep_copy(ast::cast_to<Binary>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Unary>(node)) {
            return deep_copy(ast::cast_to<Unary>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Cond>(node)) {
            return deep_copy(ast::cast_to<Cond>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Ident>(node)) {
            return deep_copy(ast::cast_to<Ident>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Call>(node)) {
            return deep_copy(ast::cast_to<Call>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<If>(node)) {
            return deep_copy(ast::cast_to<If>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<MemberAccess>(node)) {
            return deep_copy(ast::cast_to<MemberAccess>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Paren>(node)) {
            return deep_copy(ast::cast_to<Paren>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Index>(node)) {
            return deep_copy(ast::cast_to<Index>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Match>(node)) {
            return deep_copy(ast::cast_to<Match>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Range>(node)) {
            return deep_copy(ast::cast_to<Range>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Identity>(node)) {
            return deep_copy(ast::cast_to<Identity>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<TmpVar>(node)) {
            return deep_copy(ast::cast_to<TmpVar>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Import>(node)) {
            return deep_copy(ast::cast_to<Import>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Cast>(node)) {
            return deep_copy(ast::cast_to<Cast>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Available>(node)) {
            return deep_copy(ast::cast_to<Available>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<SpecifyOrder>(node)) {
            return deep_copy(ast::cast_to<SpecifyOrder>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<ExplicitError>(node)) {
            return deep_copy(ast::cast_to<ExplicitError>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IOOperation>(node)) {
            return deep_copy(ast::cast_to<IOOperation>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<OrCond>(node)) {
            return deep_copy(ast::cast_to<OrCond>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<BadExpr>(node)) {
            return deep_copy(ast::cast_to<BadExpr>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IntLiteral>(node)) {
            return deep_copy(ast::cast_to<IntLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<BoolLiteral>(node)) {
            return deep_copy(ast::cast_to<BoolLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<StrLiteral>(node)) {
            return deep_copy(ast::cast_to<StrLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<RegexLiteral>(node)) {
            return deep_copy(ast::cast_to<RegexLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<CharLiteral>(node)) {
            return deep_copy(ast::cast_to<CharLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<TypeLiteral>(node)) {
            return deep_copy(ast::cast_to<TypeLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<SpecialLiteral>(node)) {
            return deep_copy(ast::cast_to<SpecialLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        return nullptr;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Stmt> deep_copy(const std::shared_ptr<Stmt>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (ast::as<Loop>(node)) {
            return deep_copy(ast::cast_to<Loop>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IndentBlock>(node)) {
            return deep_copy(ast::cast_to<IndentBlock>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<ScopedStatement>(node)) {
            return deep_copy(ast::cast_to<ScopedStatement>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<MatchBranch>(node)) {
            return deep_copy(ast::cast_to<MatchBranch>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<UnionCandidate>(node)) {
            return deep_copy(ast::cast_to<UnionCandidate>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Return>(node)) {
            return deep_copy(ast::cast_to<Return>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Break>(node)) {
            return deep_copy(ast::cast_to<Break>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Continue>(node)) {
            return deep_copy(ast::cast_to<Continue>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Assert>(node)) {
            return deep_copy(ast::cast_to<Assert>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<ImplicitYield>(node)) {
            return deep_copy(ast::cast_to<ImplicitYield>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Metadata>(node)) {
            return deep_copy(ast::cast_to<Metadata>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Field>(node)) {
            return deep_copy(ast::cast_to<Field>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Format>(node)) {
            return deep_copy(ast::cast_to<Format>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<State>(node)) {
            return deep_copy(ast::cast_to<State>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Enum>(node)) {
            return deep_copy(ast::cast_to<Enum>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<EnumMember>(node)) {
            return deep_copy(ast::cast_to<EnumMember>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Function>(node)) {
            return deep_copy(ast::cast_to<Function>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        return nullptr;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Type> deep_copy(const std::shared_ptr<Type>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (ast::as<IntType>(node)) {
            return deep_copy(ast::cast_to<IntType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<FloatType>(node)) {
            return deep_copy(ast::cast_to<FloatType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IdentType>(node)) {
            return deep_copy(ast::cast_to<IdentType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IntLiteralType>(node)) {
            return deep_copy(ast::cast_to<IntLiteralType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<StrLiteralType>(node)) {
            return deep_copy(ast::cast_to<StrLiteralType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<RegexLiteralType>(node)) {
            return deep_copy(ast::cast_to<RegexLiteralType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<VoidType>(node)) {
            return deep_copy(ast::cast_to<VoidType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<BoolType>(node)) {
            return deep_copy(ast::cast_to<BoolType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<ArrayType>(node)) {
            return deep_copy(ast::cast_to<ArrayType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<FunctionType>(node)) {
            return deep_copy(ast::cast_to<FunctionType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<StructType>(node)) {
            return deep_copy(ast::cast_to<StructType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<StructUnionType>(node)) {
            return deep_copy(ast::cast_to<StructUnionType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<UnionType>(node)) {
            return deep_copy(ast::cast_to<UnionType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<RangeType>(node)) {
            return deep_copy(ast::cast_to<RangeType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<EnumType>(node)) {
            return deep_copy(ast::cast_to<EnumType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<MetaType>(node)) {
            return deep_copy(ast::cast_to<MetaType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<OptionalType>(node)) {
            return deep_copy(ast::cast_to<OptionalType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<GenericType>(node)) {
            return deep_copy(ast::cast_to<GenericType>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        return nullptr;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Literal> deep_copy(const std::shared_ptr<Literal>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (ast::as<IntLiteral>(node)) {
            return deep_copy(ast::cast_to<IntLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<BoolLiteral>(node)) {
            return deep_copy(ast::cast_to<BoolLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<StrLiteral>(node)) {
            return deep_copy(ast::cast_to<StrLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<RegexLiteral>(node)) {
            return deep_copy(ast::cast_to<RegexLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<CharLiteral>(node)) {
            return deep_copy(ast::cast_to<CharLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<TypeLiteral>(node)) {
            return deep_copy(ast::cast_to<TypeLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<SpecialLiteral>(node)) {
            return deep_copy(ast::cast_to<SpecialLiteral>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        return nullptr;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Member> deep_copy(const std::shared_ptr<Member>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (ast::as<Field>(node)) {
            return deep_copy(ast::cast_to<Field>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Format>(node)) {
            return deep_copy(ast::cast_to<Format>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<State>(node)) {
            return deep_copy(ast::cast_to<State>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Enum>(node)) {
            return deep_copy(ast::cast_to<Enum>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<EnumMember>(node)) {
            return deep_copy(ast::cast_to<EnumMember>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Function>(node)) {
            return deep_copy(ast::cast_to<Function>(node), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        return nullptr;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Program> deep_copy(const std::shared_ptr<Program>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Program>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->struct_type); it != node_map.end()) {
            new_node->struct_type = ast::cast_to<StructType>(it->second);
        }
        else {
            new_node->struct_type = ast::cast_to<StructType>(deep_copy(node->struct_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        for (auto& i : node->elements) {
            new_node->elements.push_back(deep_copy(i, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = scope_map.find(node->global_scope); it != scope_map.end()) {
            new_node->global_scope = it->second;
        }
        else {
            new_node->global_scope = deep_copy(node->global_scope, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        for (auto& i : node->metadata) {
            new_node->metadata.push_back(deep_copy(i.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Comment> deep_copy(const std::shared_ptr<Comment>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Comment>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        new_node->comment = node->comment;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<CommentGroup> deep_copy(const std::shared_ptr<CommentGroup>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<CommentGroup>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        for (auto& i : node->comments) {
            new_node->comments.push_back(deep_copy(i, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<FieldArgument> deep_copy(const std::shared_ptr<FieldArgument>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<FieldArgument>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->raw_arguments); it != node_map.end()) {
            new_node->raw_arguments = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->raw_arguments = ast::cast_to<Expr>(deep_copy(node->raw_arguments, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->end_loc = node->end_loc;
        for (auto& i : node->collected_arguments) {
            new_node->collected_arguments.push_back(deep_copy(i.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        for (auto& i : node->arguments) {
            new_node->arguments.push_back(deep_copy(i, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->alignment); it != node_map.end()) {
            new_node->alignment = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->alignment = ast::cast_to<Expr>(deep_copy(node->alignment, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->alignment_value = node->alignment_value;
        if (auto it = node_map.find(node->sub_byte_length); it != node_map.end()) {
            new_node->sub_byte_length = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->sub_byte_length = ast::cast_to<Expr>(deep_copy(node->sub_byte_length, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->sub_byte_begin); it != node_map.end()) {
            new_node->sub_byte_begin = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->sub_byte_begin = ast::cast_to<Expr>(deep_copy(node->sub_byte_begin, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->peek); it != node_map.end()) {
            new_node->peek = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->peek = ast::cast_to<Expr>(deep_copy(node->peek, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->peek_value = node->peek_value;
        if (auto it = node_map.find(node->type_map); it != node_map.end()) {
            new_node->type_map = ast::cast_to<TypeLiteral>(it->second);
        }
        else {
            new_node->type_map = ast::cast_to<TypeLiteral>(deep_copy(node->type_map, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        for (auto& i : node->metadata) {
            new_node->metadata.push_back(deep_copy(i, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Binary> deep_copy(const std::shared_ptr<Binary>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Binary>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        new_node->op = node->op;
        if (auto it = node_map.find(node->left); it != node_map.end()) {
            new_node->left = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->left = ast::cast_to<Expr>(deep_copy(node->left, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->right); it != node_map.end()) {
            new_node->right = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->right = ast::cast_to<Expr>(deep_copy(node->right, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Unary> deep_copy(const std::shared_ptr<Unary>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Unary>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        new_node->op = node->op;
        if (auto it = node_map.find(node->expr); it != node_map.end()) {
            new_node->expr = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->expr = ast::cast_to<Expr>(deep_copy(node->expr, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Cond> deep_copy(const std::shared_ptr<Cond>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Cond>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        if (auto it = node_map.find(node->cond); it != node_map.end()) {
            new_node->cond = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->cond = ast::cast_to<Expr>(deep_copy(node->cond, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->then); it != node_map.end()) {
            new_node->then = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->then = ast::cast_to<Expr>(deep_copy(node->then, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->els_loc = node->els_loc;
        if (auto it = node_map.find(node->els); it != node_map.end()) {
            new_node->els = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->els = ast::cast_to<Expr>(deep_copy(node->els, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Ident> deep_copy(const std::shared_ptr<Ident>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Ident>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        new_node->ident = node->ident;
        new_node->usage = node->usage;
        if (auto it = node_map.find(node->base.lock()); it != node_map.end()) {
            new_node->base = ast::cast_to<Node>(it->second);
        }
        else {
            new_node->base = ast::cast_to<Node>(deep_copy(node->base.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = scope_map.find(node->scope); it != scope_map.end()) {
            new_node->scope = it->second;
        }
        else {
            new_node->scope = deep_copy(node->scope, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Call> deep_copy(const std::shared_ptr<Call>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Call>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        if (auto it = node_map.find(node->callee); it != node_map.end()) {
            new_node->callee = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->callee = ast::cast_to<Expr>(deep_copy(node->callee, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->raw_arguments); it != node_map.end()) {
            new_node->raw_arguments = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->raw_arguments = ast::cast_to<Expr>(deep_copy(node->raw_arguments, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        for (auto& i : node->arguments) {
            new_node->arguments.push_back(deep_copy(i, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->end_loc = node->end_loc;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<If> deep_copy(const std::shared_ptr<If>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<If>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        if (auto it = node_map.find(node->struct_union_type); it != node_map.end()) {
            new_node->struct_union_type = ast::cast_to<StructUnionType>(it->second);
        }
        else {
            new_node->struct_union_type = ast::cast_to<StructUnionType>(deep_copy(node->struct_union_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = scope_map.find(node->cond_scope); it != scope_map.end()) {
            new_node->cond_scope = it->second;
        }
        else {
            new_node->cond_scope = deep_copy(node->cond_scope, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (auto it = node_map.find(node->cond); it != node_map.end()) {
            new_node->cond = ast::cast_to<Identity>(it->second);
        }
        else {
            new_node->cond = ast::cast_to<Identity>(deep_copy(node->cond, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->then); it != node_map.end()) {
            new_node->then = ast::cast_to<IndentBlock>(it->second);
        }
        else {
            new_node->then = ast::cast_to<IndentBlock>(deep_copy(node->then, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->els); it != node_map.end()) {
            new_node->els = ast::cast_to<Node>(it->second);
        }
        else {
            new_node->els = ast::cast_to<Node>(deep_copy(node->els, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<MemberAccess> deep_copy(const std::shared_ptr<MemberAccess>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<MemberAccess>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        if (auto it = node_map.find(node->target); it != node_map.end()) {
            new_node->target = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->target = ast::cast_to<Expr>(deep_copy(node->target, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->member); it != node_map.end()) {
            new_node->member = ast::cast_to<Ident>(it->second);
        }
        else {
            new_node->member = ast::cast_to<Ident>(deep_copy(node->member, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->base.lock()); it != node_map.end()) {
            new_node->base = ast::cast_to<Ident>(it->second);
        }
        else {
            new_node->base = ast::cast_to<Ident>(deep_copy(node->base.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Paren> deep_copy(const std::shared_ptr<Paren>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Paren>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        if (auto it = node_map.find(node->expr); it != node_map.end()) {
            new_node->expr = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->expr = ast::cast_to<Expr>(deep_copy(node->expr, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->end_loc = node->end_loc;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Index> deep_copy(const std::shared_ptr<Index>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Index>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        if (auto it = node_map.find(node->expr); it != node_map.end()) {
            new_node->expr = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->expr = ast::cast_to<Expr>(deep_copy(node->expr, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->index); it != node_map.end()) {
            new_node->index = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->index = ast::cast_to<Expr>(deep_copy(node->index, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->end_loc = node->end_loc;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Match> deep_copy(const std::shared_ptr<Match>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Match>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        if (auto it = node_map.find(node->struct_union_type); it != node_map.end()) {
            new_node->struct_union_type = ast::cast_to<StructUnionType>(it->second);
        }
        else {
            new_node->struct_union_type = ast::cast_to<StructUnionType>(deep_copy(node->struct_union_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = scope_map.find(node->cond_scope); it != scope_map.end()) {
            new_node->cond_scope = it->second;
        }
        else {
            new_node->cond_scope = deep_copy(node->cond_scope, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (auto it = node_map.find(node->cond); it != node_map.end()) {
            new_node->cond = ast::cast_to<Identity>(it->second);
        }
        else {
            new_node->cond = ast::cast_to<Identity>(deep_copy(node->cond, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        for (auto& i : node->branch) {
            new_node->branch.push_back(deep_copy(i, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Range> deep_copy(const std::shared_ptr<Range>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Range>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        new_node->op = node->op;
        if (auto it = node_map.find(node->start); it != node_map.end()) {
            new_node->start = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->start = ast::cast_to<Expr>(deep_copy(node->start, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->end); it != node_map.end()) {
            new_node->end = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->end = ast::cast_to<Expr>(deep_copy(node->end, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Identity> deep_copy(const std::shared_ptr<Identity>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Identity>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        if (auto it = node_map.find(node->expr); it != node_map.end()) {
            new_node->expr = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->expr = ast::cast_to<Expr>(deep_copy(node->expr, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<TmpVar> deep_copy(const std::shared_ptr<TmpVar>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<TmpVar>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        new_node->tmp_var = node->tmp_var;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Import> deep_copy(const std::shared_ptr<Import>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Import>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        new_node->path = node->path;
        if (auto it = node_map.find(node->base); it != node_map.end()) {
            new_node->base = ast::cast_to<Call>(it->second);
        }
        else {
            new_node->base = ast::cast_to<Call>(deep_copy(node->base, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->import_desc); it != node_map.end()) {
            new_node->import_desc = ast::cast_to<Program>(it->second);
        }
        else {
            new_node->import_desc = ast::cast_to<Program>(deep_copy(node->import_desc, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Cast> deep_copy(const std::shared_ptr<Cast>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Cast>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        if (auto it = node_map.find(node->base); it != node_map.end()) {
            new_node->base = ast::cast_to<Call>(it->second);
        }
        else {
            new_node->base = ast::cast_to<Call>(deep_copy(node->base, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->expr); it != node_map.end()) {
            new_node->expr = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->expr = ast::cast_to<Expr>(deep_copy(node->expr, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Available> deep_copy(const std::shared_ptr<Available>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Available>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        if (auto it = node_map.find(node->base); it != node_map.end()) {
            new_node->base = ast::cast_to<Call>(it->second);
        }
        else {
            new_node->base = ast::cast_to<Call>(deep_copy(node->base, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->target); it != node_map.end()) {
            new_node->target = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->target = ast::cast_to<Expr>(deep_copy(node->target, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<SpecifyOrder> deep_copy(const std::shared_ptr<SpecifyOrder>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<SpecifyOrder>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        if (auto it = node_map.find(node->base); it != node_map.end()) {
            new_node->base = ast::cast_to<Binary>(it->second);
        }
        else {
            new_node->base = ast::cast_to<Binary>(deep_copy(node->base, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->order_type = node->order_type;
        if (auto it = node_map.find(node->order); it != node_map.end()) {
            new_node->order = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->order = ast::cast_to<Expr>(deep_copy(node->order, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->order_value = node->order_value;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<ExplicitError> deep_copy(const std::shared_ptr<ExplicitError>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<ExplicitError>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        if (auto it = node_map.find(node->base); it != node_map.end()) {
            new_node->base = ast::cast_to<Call>(it->second);
        }
        else {
            new_node->base = ast::cast_to<Call>(deep_copy(node->base, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->message); it != node_map.end()) {
            new_node->message = ast::cast_to<StrLiteral>(it->second);
        }
        else {
            new_node->message = ast::cast_to<StrLiteral>(deep_copy(node->message, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<IOOperation> deep_copy(const std::shared_ptr<IOOperation>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<IOOperation>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        if (auto it = node_map.find(node->base); it != node_map.end()) {
            new_node->base = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->base = ast::cast_to<Expr>(deep_copy(node->base, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->method = node->method;
        for (auto& i : node->arguments) {
            new_node->arguments.push_back(deep_copy(i, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<OrCond> deep_copy(const std::shared_ptr<OrCond>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<OrCond>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        if (auto it = node_map.find(node->base); it != node_map.end()) {
            new_node->base = ast::cast_to<Binary>(it->second);
        }
        else {
            new_node->base = ast::cast_to<Binary>(deep_copy(node->base, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        for (auto& i : node->conds) {
            new_node->conds.push_back(deep_copy(i, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<BadExpr> deep_copy(const std::shared_ptr<BadExpr>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<BadExpr>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        new_node->content = node->content;
        if (auto it = node_map.find(node->bad_expr); it != node_map.end()) {
            new_node->bad_expr = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->bad_expr = ast::cast_to<Expr>(deep_copy(node->bad_expr, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Loop> deep_copy(const std::shared_ptr<Loop>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Loop>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = scope_map.find(node->cond_scope); it != scope_map.end()) {
            new_node->cond_scope = it->second;
        }
        else {
            new_node->cond_scope = deep_copy(node->cond_scope, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (auto it = node_map.find(node->init); it != node_map.end()) {
            new_node->init = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->init = ast::cast_to<Expr>(deep_copy(node->init, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->cond); it != node_map.end()) {
            new_node->cond = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->cond = ast::cast_to<Expr>(deep_copy(node->cond, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->step); it != node_map.end()) {
            new_node->step = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->step = ast::cast_to<Expr>(deep_copy(node->step, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->body); it != node_map.end()) {
            new_node->body = ast::cast_to<IndentBlock>(it->second);
        }
        else {
            new_node->body = ast::cast_to<IndentBlock>(deep_copy(node->body, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<IndentBlock> deep_copy(const std::shared_ptr<IndentBlock>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<IndentBlock>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->struct_type); it != node_map.end()) {
            new_node->struct_type = ast::cast_to<StructType>(it->second);
        }
        else {
            new_node->struct_type = ast::cast_to<StructType>(deep_copy(node->struct_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        for (auto& i : node->elements) {
            new_node->elements.push_back(deep_copy(i, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = scope_map.find(node->scope); it != scope_map.end()) {
            new_node->scope = it->second;
        }
        else {
            new_node->scope = deep_copy(node->scope, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        for (auto& i : node->metadata) {
            new_node->metadata.push_back(deep_copy(i.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<ScopedStatement> deep_copy(const std::shared_ptr<ScopedStatement>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<ScopedStatement>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->struct_type); it != node_map.end()) {
            new_node->struct_type = ast::cast_to<StructType>(it->second);
        }
        else {
            new_node->struct_type = ast::cast_to<StructType>(deep_copy(node->struct_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->statement); it != node_map.end()) {
            new_node->statement = ast::cast_to<Node>(it->second);
        }
        else {
            new_node->statement = ast::cast_to<Node>(deep_copy(node->statement, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = scope_map.find(node->scope); it != scope_map.end()) {
            new_node->scope = it->second;
        }
        else {
            new_node->scope = deep_copy(node->scope, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<MatchBranch> deep_copy(const std::shared_ptr<MatchBranch>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<MatchBranch>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->belong.lock()); it != node_map.end()) {
            new_node->belong = ast::cast_to<Match>(it->second);
        }
        else {
            new_node->belong = ast::cast_to<Match>(deep_copy(node->belong.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->cond); it != node_map.end()) {
            new_node->cond = ast::cast_to<Identity>(it->second);
        }
        else {
            new_node->cond = ast::cast_to<Identity>(deep_copy(node->cond, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->sym_loc = node->sym_loc;
        if (auto it = node_map.find(node->then); it != node_map.end()) {
            new_node->then = ast::cast_to<Node>(it->second);
        }
        else {
            new_node->then = ast::cast_to<Node>(deep_copy(node->then, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<UnionCandidate> deep_copy(const std::shared_ptr<UnionCandidate>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<UnionCandidate>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->cond.lock()); it != node_map.end()) {
            new_node->cond = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->cond = ast::cast_to<Expr>(deep_copy(node->cond.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->field.lock()); it != node_map.end()) {
            new_node->field = ast::cast_to<Field>(it->second);
        }
        else {
            new_node->field = ast::cast_to<Field>(deep_copy(node->field.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Return> deep_copy(const std::shared_ptr<Return>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Return>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr); it != node_map.end()) {
            new_node->expr = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->expr = ast::cast_to<Expr>(deep_copy(node->expr, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->related_function.lock()); it != node_map.end()) {
            new_node->related_function = ast::cast_to<Function>(it->second);
        }
        else {
            new_node->related_function = ast::cast_to<Function>(deep_copy(node->related_function.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Break> deep_copy(const std::shared_ptr<Break>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Break>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->related_loop.lock()); it != node_map.end()) {
            new_node->related_loop = ast::cast_to<Loop>(it->second);
        }
        else {
            new_node->related_loop = ast::cast_to<Loop>(deep_copy(node->related_loop.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Continue> deep_copy(const std::shared_ptr<Continue>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Continue>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->related_loop.lock()); it != node_map.end()) {
            new_node->related_loop = ast::cast_to<Loop>(it->second);
        }
        else {
            new_node->related_loop = ast::cast_to<Loop>(deep_copy(node->related_loop.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Assert> deep_copy(const std::shared_ptr<Assert>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Assert>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->cond); it != node_map.end()) {
            new_node->cond = ast::cast_to<Binary>(it->second);
        }
        else {
            new_node->cond = ast::cast_to<Binary>(deep_copy(node->cond, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->is_io_related = node->is_io_related;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<ImplicitYield> deep_copy(const std::shared_ptr<ImplicitYield>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<ImplicitYield>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr); it != node_map.end()) {
            new_node->expr = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->expr = ast::cast_to<Expr>(deep_copy(node->expr, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Metadata> deep_copy(const std::shared_ptr<Metadata>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Metadata>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->base); it != node_map.end()) {
            new_node->base = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->base = ast::cast_to<Expr>(deep_copy(node->base, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->name = node->name;
        for (auto& i : node->values) {
            new_node->values.push_back(deep_copy(i, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<IntType> deep_copy(const std::shared_ptr<IntType>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<IntType>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        new_node->is_explicit = node->is_explicit;
        new_node->non_dynamic_allocation = node->non_dynamic_allocation;
        new_node->bit_alignment = node->bit_alignment;
        new_node->bit_size = node->bit_size;
        new_node->endian = node->endian;
        new_node->is_signed = node->is_signed;
        new_node->is_common_supported = node->is_common_supported;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<FloatType> deep_copy(const std::shared_ptr<FloatType>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<FloatType>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        new_node->is_explicit = node->is_explicit;
        new_node->non_dynamic_allocation = node->non_dynamic_allocation;
        new_node->bit_alignment = node->bit_alignment;
        new_node->bit_size = node->bit_size;
        new_node->endian = node->endian;
        new_node->is_common_supported = node->is_common_supported;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<IdentType> deep_copy(const std::shared_ptr<IdentType>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<IdentType>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        new_node->is_explicit = node->is_explicit;
        new_node->non_dynamic_allocation = node->non_dynamic_allocation;
        new_node->bit_alignment = node->bit_alignment;
        new_node->bit_size = node->bit_size;
        if (auto it = node_map.find(node->import_ref); it != node_map.end()) {
            new_node->import_ref = ast::cast_to<MemberAccess>(it->second);
        }
        else {
            new_node->import_ref = ast::cast_to<MemberAccess>(deep_copy(node->import_ref, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->ident); it != node_map.end()) {
            new_node->ident = ast::cast_to<Ident>(it->second);
        }
        else {
            new_node->ident = ast::cast_to<Ident>(deep_copy(node->ident, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->base.lock()); it != node_map.end()) {
            new_node->base = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->base = ast::cast_to<Type>(deep_copy(node->base.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<IntLiteralType> deep_copy(const std::shared_ptr<IntLiteralType>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<IntLiteralType>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        new_node->is_explicit = node->is_explicit;
        new_node->non_dynamic_allocation = node->non_dynamic_allocation;
        new_node->bit_alignment = node->bit_alignment;
        new_node->bit_size = node->bit_size;
        if (auto it = node_map.find(node->base.lock()); it != node_map.end()) {
            new_node->base = ast::cast_to<IntLiteral>(it->second);
        }
        else {
            new_node->base = ast::cast_to<IntLiteral>(deep_copy(node->base.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<StrLiteralType> deep_copy(const std::shared_ptr<StrLiteralType>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<StrLiteralType>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        new_node->is_explicit = node->is_explicit;
        new_node->non_dynamic_allocation = node->non_dynamic_allocation;
        new_node->bit_alignment = node->bit_alignment;
        new_node->bit_size = node->bit_size;
        if (auto it = node_map.find(node->base.lock()); it != node_map.end()) {
            new_node->base = ast::cast_to<StrLiteral>(it->second);
        }
        else {
            new_node->base = ast::cast_to<StrLiteral>(deep_copy(node->base.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->strong_ref); it != node_map.end()) {
            new_node->strong_ref = ast::cast_to<StrLiteral>(it->second);
        }
        else {
            new_node->strong_ref = ast::cast_to<StrLiteral>(deep_copy(node->strong_ref, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<RegexLiteralType> deep_copy(const std::shared_ptr<RegexLiteralType>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<RegexLiteralType>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        new_node->is_explicit = node->is_explicit;
        new_node->non_dynamic_allocation = node->non_dynamic_allocation;
        new_node->bit_alignment = node->bit_alignment;
        new_node->bit_size = node->bit_size;
        if (auto it = node_map.find(node->base.lock()); it != node_map.end()) {
            new_node->base = ast::cast_to<RegexLiteral>(it->second);
        }
        else {
            new_node->base = ast::cast_to<RegexLiteral>(deep_copy(node->base.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->strong_ref); it != node_map.end()) {
            new_node->strong_ref = ast::cast_to<RegexLiteral>(it->second);
        }
        else {
            new_node->strong_ref = ast::cast_to<RegexLiteral>(deep_copy(node->strong_ref, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<VoidType> deep_copy(const std::shared_ptr<VoidType>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<VoidType>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        new_node->is_explicit = node->is_explicit;
        new_node->non_dynamic_allocation = node->non_dynamic_allocation;
        new_node->bit_alignment = node->bit_alignment;
        new_node->bit_size = node->bit_size;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<BoolType> deep_copy(const std::shared_ptr<BoolType>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<BoolType>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        new_node->is_explicit = node->is_explicit;
        new_node->non_dynamic_allocation = node->non_dynamic_allocation;
        new_node->bit_alignment = node->bit_alignment;
        new_node->bit_size = node->bit_size;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<ArrayType> deep_copy(const std::shared_ptr<ArrayType>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<ArrayType>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        new_node->is_explicit = node->is_explicit;
        new_node->non_dynamic_allocation = node->non_dynamic_allocation;
        new_node->bit_alignment = node->bit_alignment;
        new_node->bit_size = node->bit_size;
        new_node->end_loc = node->end_loc;
        if (auto it = node_map.find(node->element_type); it != node_map.end()) {
            new_node->element_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->element_type = ast::cast_to<Type>(deep_copy(node->element_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->length); it != node_map.end()) {
            new_node->length = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->length = ast::cast_to<Expr>(deep_copy(node->length, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->length_value = node->length_value;
        new_node->is_bytes = node->is_bytes;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<FunctionType> deep_copy(const std::shared_ptr<FunctionType>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<FunctionType>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        new_node->is_explicit = node->is_explicit;
        new_node->non_dynamic_allocation = node->non_dynamic_allocation;
        new_node->bit_alignment = node->bit_alignment;
        new_node->bit_size = node->bit_size;
        if (auto it = node_map.find(node->return_type); it != node_map.end()) {
            new_node->return_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->return_type = ast::cast_to<Type>(deep_copy(node->return_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        for (auto& i : node->parameters) {
            new_node->parameters.push_back(deep_copy(i, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<StructType> deep_copy(const std::shared_ptr<StructType>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<StructType>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        new_node->is_explicit = node->is_explicit;
        new_node->non_dynamic_allocation = node->non_dynamic_allocation;
        new_node->bit_alignment = node->bit_alignment;
        new_node->bit_size = node->bit_size;
        for (auto& i : node->fields) {
            new_node->fields.push_back(deep_copy(i, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->base.lock()); it != node_map.end()) {
            new_node->base = ast::cast_to<Node>(it->second);
        }
        else {
            new_node->base = ast::cast_to<Node>(deep_copy(node->base.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->recursive = node->recursive;
        new_node->fixed_header_size = node->fixed_header_size;
        new_node->fixed_tail_size = node->fixed_tail_size;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<StructUnionType> deep_copy(const std::shared_ptr<StructUnionType>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<StructUnionType>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        new_node->is_explicit = node->is_explicit;
        new_node->non_dynamic_allocation = node->non_dynamic_allocation;
        new_node->bit_alignment = node->bit_alignment;
        new_node->bit_size = node->bit_size;
        if (auto it = node_map.find(node->cond); it != node_map.end()) {
            new_node->cond = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->cond = ast::cast_to<Expr>(deep_copy(node->cond, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        for (auto& i : node->conds) {
            new_node->conds.push_back(deep_copy(i, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        for (auto& i : node->structs) {
            new_node->structs.push_back(deep_copy(i, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->base.lock()); it != node_map.end()) {
            new_node->base = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->base = ast::cast_to<Expr>(deep_copy(node->base.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        for (auto& i : node->union_fields) {
            new_node->union_fields.push_back(deep_copy(i.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->exhaustive = node->exhaustive;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<UnionType> deep_copy(const std::shared_ptr<UnionType>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<UnionType>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        new_node->is_explicit = node->is_explicit;
        new_node->non_dynamic_allocation = node->non_dynamic_allocation;
        new_node->bit_alignment = node->bit_alignment;
        new_node->bit_size = node->bit_size;
        if (auto it = node_map.find(node->cond.lock()); it != node_map.end()) {
            new_node->cond = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->cond = ast::cast_to<Expr>(deep_copy(node->cond.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        for (auto& i : node->candidates) {
            new_node->candidates.push_back(deep_copy(i, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->base_type.lock()); it != node_map.end()) {
            new_node->base_type = ast::cast_to<StructUnionType>(it->second);
        }
        else {
            new_node->base_type = ast::cast_to<StructUnionType>(deep_copy(node->base_type.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->common_type); it != node_map.end()) {
            new_node->common_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->common_type = ast::cast_to<Type>(deep_copy(node->common_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        for (auto& i : node->member_candidates) {
            new_node->member_candidates.push_back(deep_copy(i, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<RangeType> deep_copy(const std::shared_ptr<RangeType>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<RangeType>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        new_node->is_explicit = node->is_explicit;
        new_node->non_dynamic_allocation = node->non_dynamic_allocation;
        new_node->bit_alignment = node->bit_alignment;
        new_node->bit_size = node->bit_size;
        if (auto it = node_map.find(node->base_type); it != node_map.end()) {
            new_node->base_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->base_type = ast::cast_to<Type>(deep_copy(node->base_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->range.lock()); it != node_map.end()) {
            new_node->range = ast::cast_to<Range>(it->second);
        }
        else {
            new_node->range = ast::cast_to<Range>(deep_copy(node->range.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<EnumType> deep_copy(const std::shared_ptr<EnumType>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<EnumType>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        new_node->is_explicit = node->is_explicit;
        new_node->non_dynamic_allocation = node->non_dynamic_allocation;
        new_node->bit_alignment = node->bit_alignment;
        new_node->bit_size = node->bit_size;
        if (auto it = node_map.find(node->base.lock()); it != node_map.end()) {
            new_node->base = ast::cast_to<Enum>(it->second);
        }
        else {
            new_node->base = ast::cast_to<Enum>(deep_copy(node->base.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<MetaType> deep_copy(const std::shared_ptr<MetaType>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<MetaType>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        new_node->is_explicit = node->is_explicit;
        new_node->non_dynamic_allocation = node->non_dynamic_allocation;
        new_node->bit_alignment = node->bit_alignment;
        new_node->bit_size = node->bit_size;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<OptionalType> deep_copy(const std::shared_ptr<OptionalType>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<OptionalType>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        new_node->is_explicit = node->is_explicit;
        new_node->non_dynamic_allocation = node->non_dynamic_allocation;
        new_node->bit_alignment = node->bit_alignment;
        new_node->bit_size = node->bit_size;
        if (auto it = node_map.find(node->base_type); it != node_map.end()) {
            new_node->base_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->base_type = ast::cast_to<Type>(deep_copy(node->base_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<GenericType> deep_copy(const std::shared_ptr<GenericType>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<GenericType>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        new_node->is_explicit = node->is_explicit;
        new_node->non_dynamic_allocation = node->non_dynamic_allocation;
        new_node->bit_alignment = node->bit_alignment;
        new_node->bit_size = node->bit_size;
        if (auto it = node_map.find(node->belong.lock()); it != node_map.end()) {
            new_node->belong = ast::cast_to<Member>(it->second);
        }
        else {
            new_node->belong = ast::cast_to<Member>(deep_copy(node->belong.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<IntLiteral> deep_copy(const std::shared_ptr<IntLiteral>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<IntLiteral>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        new_node->value = node->value;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<BoolLiteral> deep_copy(const std::shared_ptr<BoolLiteral>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<BoolLiteral>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        new_node->value = node->value;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<StrLiteral> deep_copy(const std::shared_ptr<StrLiteral>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<StrLiteral>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        new_node->value = node->value;
        new_node->length = node->length;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<RegexLiteral> deep_copy(const std::shared_ptr<RegexLiteral>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<RegexLiteral>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        new_node->value = node->value;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<CharLiteral> deep_copy(const std::shared_ptr<CharLiteral>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<CharLiteral>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        new_node->value = node->value;
        new_node->code = node->code;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<TypeLiteral> deep_copy(const std::shared_ptr<TypeLiteral>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<TypeLiteral>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        if (auto it = node_map.find(node->type_literal); it != node_map.end()) {
            new_node->type_literal = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->type_literal = ast::cast_to<Type>(deep_copy(node->type_literal, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->end_loc = node->end_loc;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<SpecialLiteral> deep_copy(const std::shared_ptr<SpecialLiteral>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<SpecialLiteral>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->expr_type); it != node_map.end()) {
            new_node->expr_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->expr_type = ast::cast_to<Type>(deep_copy(node->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->constant_level = node->constant_level;
        new_node->kind = node->kind;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Field> deep_copy(const std::shared_ptr<Field>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Field>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->belong.lock()); it != node_map.end()) {
            new_node->belong = ast::cast_to<Member>(it->second);
        }
        else {
            new_node->belong = ast::cast_to<Member>(deep_copy(node->belong.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->belong_struct.lock()); it != node_map.end()) {
            new_node->belong_struct = ast::cast_to<StructType>(it->second);
        }
        else {
            new_node->belong_struct = ast::cast_to<StructType>(deep_copy(node->belong_struct.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->ident); it != node_map.end()) {
            new_node->ident = ast::cast_to<Ident>(it->second);
        }
        else {
            new_node->ident = ast::cast_to<Ident>(deep_copy(node->ident, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->colon_loc = node->colon_loc;
        new_node->is_state_variable = node->is_state_variable;
        if (auto it = node_map.find(node->field_type); it != node_map.end()) {
            new_node->field_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->field_type = ast::cast_to<Type>(deep_copy(node->field_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->arguments); it != node_map.end()) {
            new_node->arguments = ast::cast_to<FieldArgument>(it->second);
        }
        else {
            new_node->arguments = ast::cast_to<FieldArgument>(deep_copy(node->arguments, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->offset_bit = node->offset_bit;
        new_node->offset_recent = node->offset_recent;
        new_node->tail_offset_bit = node->tail_offset_bit;
        new_node->tail_offset_recent = node->tail_offset_recent;
        new_node->bit_alignment = node->bit_alignment;
        new_node->eventual_bit_alignment = node->eventual_bit_alignment;
        new_node->follow = node->follow;
        new_node->eventual_follow = node->eventual_follow;
        if (auto it = node_map.find(node->next.lock()); it != node_map.end()) {
            new_node->next = ast::cast_to<Field>(it->second);
        }
        else {
            new_node->next = ast::cast_to<Field>(deep_copy(node->next.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Format> deep_copy(const std::shared_ptr<Format>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Format>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->belong.lock()); it != node_map.end()) {
            new_node->belong = ast::cast_to<Member>(it->second);
        }
        else {
            new_node->belong = ast::cast_to<Member>(deep_copy(node->belong.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->belong_struct.lock()); it != node_map.end()) {
            new_node->belong_struct = ast::cast_to<StructType>(it->second);
        }
        else {
            new_node->belong_struct = ast::cast_to<StructType>(deep_copy(node->belong_struct.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->ident); it != node_map.end()) {
            new_node->ident = ast::cast_to<Ident>(it->second);
        }
        else {
            new_node->ident = ast::cast_to<Ident>(deep_copy(node->ident, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->body); it != node_map.end()) {
            new_node->body = ast::cast_to<IndentBlock>(it->second);
        }
        else {
            new_node->body = ast::cast_to<IndentBlock>(deep_copy(node->body, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->encode_fn.lock()); it != node_map.end()) {
            new_node->encode_fn = ast::cast_to<Function>(it->second);
        }
        else {
            new_node->encode_fn = ast::cast_to<Function>(deep_copy(node->encode_fn.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->decode_fn.lock()); it != node_map.end()) {
            new_node->decode_fn = ast::cast_to<Function>(it->second);
        }
        else {
            new_node->decode_fn = ast::cast_to<Function>(deep_copy(node->decode_fn.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        for (auto& i : node->cast_fns) {
            new_node->cast_fns.push_back(deep_copy(i.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        for (auto& i : node->depends) {
            new_node->depends.push_back(deep_copy(i.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        for (auto& i : node->state_variables) {
            new_node->state_variables.push_back(deep_copy(i.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->format_trait = node->format_trait;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<State> deep_copy(const std::shared_ptr<State>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<State>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->belong.lock()); it != node_map.end()) {
            new_node->belong = ast::cast_to<Member>(it->second);
        }
        else {
            new_node->belong = ast::cast_to<Member>(deep_copy(node->belong.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->belong_struct.lock()); it != node_map.end()) {
            new_node->belong_struct = ast::cast_to<StructType>(it->second);
        }
        else {
            new_node->belong_struct = ast::cast_to<StructType>(deep_copy(node->belong_struct.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->ident); it != node_map.end()) {
            new_node->ident = ast::cast_to<Ident>(it->second);
        }
        else {
            new_node->ident = ast::cast_to<Ident>(deep_copy(node->ident, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->body); it != node_map.end()) {
            new_node->body = ast::cast_to<IndentBlock>(it->second);
        }
        else {
            new_node->body = ast::cast_to<IndentBlock>(deep_copy(node->body, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Enum> deep_copy(const std::shared_ptr<Enum>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Enum>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->belong.lock()); it != node_map.end()) {
            new_node->belong = ast::cast_to<Member>(it->second);
        }
        else {
            new_node->belong = ast::cast_to<Member>(deep_copy(node->belong.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->belong_struct.lock()); it != node_map.end()) {
            new_node->belong_struct = ast::cast_to<StructType>(it->second);
        }
        else {
            new_node->belong_struct = ast::cast_to<StructType>(deep_copy(node->belong_struct.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->ident); it != node_map.end()) {
            new_node->ident = ast::cast_to<Ident>(it->second);
        }
        else {
            new_node->ident = ast::cast_to<Ident>(deep_copy(node->ident, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = scope_map.find(node->scope); it != scope_map.end()) {
            new_node->scope = it->second;
        }
        else {
            new_node->scope = deep_copy(node->scope, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        new_node->colon_loc = node->colon_loc;
        if (auto it = node_map.find(node->base_type); it != node_map.end()) {
            new_node->base_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->base_type = ast::cast_to<Type>(deep_copy(node->base_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        for (auto& i : node->members) {
            new_node->members.push_back(deep_copy(i, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->enum_type); it != node_map.end()) {
            new_node->enum_type = ast::cast_to<EnumType>(it->second);
        }
        else {
            new_node->enum_type = ast::cast_to<EnumType>(deep_copy(node->enum_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<EnumMember> deep_copy(const std::shared_ptr<EnumMember>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<EnumMember>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->belong.lock()); it != node_map.end()) {
            new_node->belong = ast::cast_to<Member>(it->second);
        }
        else {
            new_node->belong = ast::cast_to<Member>(deep_copy(node->belong.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->belong_struct.lock()); it != node_map.end()) {
            new_node->belong_struct = ast::cast_to<StructType>(it->second);
        }
        else {
            new_node->belong_struct = ast::cast_to<StructType>(deep_copy(node->belong_struct.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->ident); it != node_map.end()) {
            new_node->ident = ast::cast_to<Ident>(it->second);
        }
        else {
            new_node->ident = ast::cast_to<Ident>(deep_copy(node->ident, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->raw_expr); it != node_map.end()) {
            new_node->raw_expr = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->raw_expr = ast::cast_to<Expr>(deep_copy(node->raw_expr, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->value); it != node_map.end()) {
            new_node->value = ast::cast_to<Expr>(it->second);
        }
        else {
            new_node->value = ast::cast_to<Expr>(deep_copy(node->value, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->str_literal); it != node_map.end()) {
            new_node->str_literal = ast::cast_to<StrLiteral>(it->second);
        }
        else {
            new_node->str_literal = ast::cast_to<StrLiteral>(deep_copy(node->str_literal, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Function> deep_copy(const std::shared_ptr<Function>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Function>();
        node_map[node] = new_node;
        new_node->loc = node->loc;
        if (auto it = node_map.find(node->belong.lock()); it != node_map.end()) {
            new_node->belong = ast::cast_to<Member>(it->second);
        }
        else {
            new_node->belong = ast::cast_to<Member>(deep_copy(node->belong.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->belong_struct.lock()); it != node_map.end()) {
            new_node->belong_struct = ast::cast_to<StructType>(it->second);
        }
        else {
            new_node->belong_struct = ast::cast_to<StructType>(deep_copy(node->belong_struct.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->ident); it != node_map.end()) {
            new_node->ident = ast::cast_to<Ident>(it->second);
        }
        else {
            new_node->ident = ast::cast_to<Ident>(deep_copy(node->ident, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        for (auto& i : node->parameters) {
            new_node->parameters.push_back(deep_copy(i, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->return_type); it != node_map.end()) {
            new_node->return_type = ast::cast_to<Type>(it->second);
        }
        else {
            new_node->return_type = ast::cast_to<Type>(deep_copy(node->return_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->body); it != node_map.end()) {
            new_node->body = ast::cast_to<IndentBlock>(it->second);
        }
        else {
            new_node->body = ast::cast_to<IndentBlock>(deep_copy(node->body, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->func_type); it != node_map.end()) {
            new_node->func_type = ast::cast_to<FunctionType>(it->second);
        }
        else {
            new_node->func_type = ast::cast_to<FunctionType>(deep_copy(node->func_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->is_cast = node->is_cast;
        return new_node;
    }
    template <class NodeM, class ScopeM>
    std::shared_ptr<Scope> deep_copy(const std::shared_ptr<Scope>& node, NodeM&& node_map, ScopeM&& scope_map) {
        if (!node) {
            return nullptr;
        }
        auto new_node = std::make_shared<Scope>();
        scope_map[node] = new_node;
        if (auto it = scope_map.find(node->prev.lock()); it != scope_map.end()) {
            new_node->prev = it->second;
        }
        else {
            new_node->prev = deep_copy(node->prev.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (auto it = scope_map.find(node->next); it != scope_map.end()) {
            new_node->next = it->second;
        }
        else {
            new_node->next = deep_copy(node->next, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (auto it = scope_map.find(node->branch); it != scope_map.end()) {
            new_node->branch = it->second;
        }
        else {
            new_node->branch = deep_copy(node->branch, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        for (auto& i : node->objects) {
            new_node->objects.push_back(deep_copy(i.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        if (auto it = node_map.find(node->owner.lock()); it != node_map.end()) {
            new_node->owner = ast::cast_to<Node>(it->second);
        }
        else {
            new_node->owner = ast::cast_to<Node>(deep_copy(node->owner.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map)));
        }
        new_node->branch_root = node->branch_root;
        return new_node;
    }

    template <class T, class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<T>& a, const std::shared_ptr<T>& b, NodeM&& node_map, ScopeM&& scope_map);

    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Node>& a, const std::shared_ptr<Node>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (ast::as<Program>(a)) {
            if (!ast::as<Program>(b)) return false;
            return deep_equal(ast::cast_to<Program>(a), ast::cast_to<Program>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Comment>(a)) {
            if (!ast::as<Comment>(b)) return false;
            return deep_equal(ast::cast_to<Comment>(a), ast::cast_to<Comment>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<CommentGroup>(a)) {
            if (!ast::as<CommentGroup>(b)) return false;
            return deep_equal(ast::cast_to<CommentGroup>(a), ast::cast_to<CommentGroup>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<FieldArgument>(a)) {
            if (!ast::as<FieldArgument>(b)) return false;
            return deep_equal(ast::cast_to<FieldArgument>(a), ast::cast_to<FieldArgument>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Binary>(a)) {
            if (!ast::as<Binary>(b)) return false;
            return deep_equal(ast::cast_to<Binary>(a), ast::cast_to<Binary>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Unary>(a)) {
            if (!ast::as<Unary>(b)) return false;
            return deep_equal(ast::cast_to<Unary>(a), ast::cast_to<Unary>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Cond>(a)) {
            if (!ast::as<Cond>(b)) return false;
            return deep_equal(ast::cast_to<Cond>(a), ast::cast_to<Cond>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Ident>(a)) {
            if (!ast::as<Ident>(b)) return false;
            return deep_equal(ast::cast_to<Ident>(a), ast::cast_to<Ident>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Call>(a)) {
            if (!ast::as<Call>(b)) return false;
            return deep_equal(ast::cast_to<Call>(a), ast::cast_to<Call>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<If>(a)) {
            if (!ast::as<If>(b)) return false;
            return deep_equal(ast::cast_to<If>(a), ast::cast_to<If>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<MemberAccess>(a)) {
            if (!ast::as<MemberAccess>(b)) return false;
            return deep_equal(ast::cast_to<MemberAccess>(a), ast::cast_to<MemberAccess>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Paren>(a)) {
            if (!ast::as<Paren>(b)) return false;
            return deep_equal(ast::cast_to<Paren>(a), ast::cast_to<Paren>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Index>(a)) {
            if (!ast::as<Index>(b)) return false;
            return deep_equal(ast::cast_to<Index>(a), ast::cast_to<Index>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Match>(a)) {
            if (!ast::as<Match>(b)) return false;
            return deep_equal(ast::cast_to<Match>(a), ast::cast_to<Match>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Range>(a)) {
            if (!ast::as<Range>(b)) return false;
            return deep_equal(ast::cast_to<Range>(a), ast::cast_to<Range>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Identity>(a)) {
            if (!ast::as<Identity>(b)) return false;
            return deep_equal(ast::cast_to<Identity>(a), ast::cast_to<Identity>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<TmpVar>(a)) {
            if (!ast::as<TmpVar>(b)) return false;
            return deep_equal(ast::cast_to<TmpVar>(a), ast::cast_to<TmpVar>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Import>(a)) {
            if (!ast::as<Import>(b)) return false;
            return deep_equal(ast::cast_to<Import>(a), ast::cast_to<Import>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Cast>(a)) {
            if (!ast::as<Cast>(b)) return false;
            return deep_equal(ast::cast_to<Cast>(a), ast::cast_to<Cast>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Available>(a)) {
            if (!ast::as<Available>(b)) return false;
            return deep_equal(ast::cast_to<Available>(a), ast::cast_to<Available>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<SpecifyOrder>(a)) {
            if (!ast::as<SpecifyOrder>(b)) return false;
            return deep_equal(ast::cast_to<SpecifyOrder>(a), ast::cast_to<SpecifyOrder>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<ExplicitError>(a)) {
            if (!ast::as<ExplicitError>(b)) return false;
            return deep_equal(ast::cast_to<ExplicitError>(a), ast::cast_to<ExplicitError>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IOOperation>(a)) {
            if (!ast::as<IOOperation>(b)) return false;
            return deep_equal(ast::cast_to<IOOperation>(a), ast::cast_to<IOOperation>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<OrCond>(a)) {
            if (!ast::as<OrCond>(b)) return false;
            return deep_equal(ast::cast_to<OrCond>(a), ast::cast_to<OrCond>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<BadExpr>(a)) {
            if (!ast::as<BadExpr>(b)) return false;
            return deep_equal(ast::cast_to<BadExpr>(a), ast::cast_to<BadExpr>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Loop>(a)) {
            if (!ast::as<Loop>(b)) return false;
            return deep_equal(ast::cast_to<Loop>(a), ast::cast_to<Loop>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IndentBlock>(a)) {
            if (!ast::as<IndentBlock>(b)) return false;
            return deep_equal(ast::cast_to<IndentBlock>(a), ast::cast_to<IndentBlock>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<ScopedStatement>(a)) {
            if (!ast::as<ScopedStatement>(b)) return false;
            return deep_equal(ast::cast_to<ScopedStatement>(a), ast::cast_to<ScopedStatement>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<MatchBranch>(a)) {
            if (!ast::as<MatchBranch>(b)) return false;
            return deep_equal(ast::cast_to<MatchBranch>(a), ast::cast_to<MatchBranch>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<UnionCandidate>(a)) {
            if (!ast::as<UnionCandidate>(b)) return false;
            return deep_equal(ast::cast_to<UnionCandidate>(a), ast::cast_to<UnionCandidate>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Return>(a)) {
            if (!ast::as<Return>(b)) return false;
            return deep_equal(ast::cast_to<Return>(a), ast::cast_to<Return>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Break>(a)) {
            if (!ast::as<Break>(b)) return false;
            return deep_equal(ast::cast_to<Break>(a), ast::cast_to<Break>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Continue>(a)) {
            if (!ast::as<Continue>(b)) return false;
            return deep_equal(ast::cast_to<Continue>(a), ast::cast_to<Continue>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Assert>(a)) {
            if (!ast::as<Assert>(b)) return false;
            return deep_equal(ast::cast_to<Assert>(a), ast::cast_to<Assert>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<ImplicitYield>(a)) {
            if (!ast::as<ImplicitYield>(b)) return false;
            return deep_equal(ast::cast_to<ImplicitYield>(a), ast::cast_to<ImplicitYield>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Metadata>(a)) {
            if (!ast::as<Metadata>(b)) return false;
            return deep_equal(ast::cast_to<Metadata>(a), ast::cast_to<Metadata>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IntType>(a)) {
            if (!ast::as<IntType>(b)) return false;
            return deep_equal(ast::cast_to<IntType>(a), ast::cast_to<IntType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<FloatType>(a)) {
            if (!ast::as<FloatType>(b)) return false;
            return deep_equal(ast::cast_to<FloatType>(a), ast::cast_to<FloatType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IdentType>(a)) {
            if (!ast::as<IdentType>(b)) return false;
            return deep_equal(ast::cast_to<IdentType>(a), ast::cast_to<IdentType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IntLiteralType>(a)) {
            if (!ast::as<IntLiteralType>(b)) return false;
            return deep_equal(ast::cast_to<IntLiteralType>(a), ast::cast_to<IntLiteralType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<StrLiteralType>(a)) {
            if (!ast::as<StrLiteralType>(b)) return false;
            return deep_equal(ast::cast_to<StrLiteralType>(a), ast::cast_to<StrLiteralType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<RegexLiteralType>(a)) {
            if (!ast::as<RegexLiteralType>(b)) return false;
            return deep_equal(ast::cast_to<RegexLiteralType>(a), ast::cast_to<RegexLiteralType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<VoidType>(a)) {
            if (!ast::as<VoidType>(b)) return false;
            return deep_equal(ast::cast_to<VoidType>(a), ast::cast_to<VoidType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<BoolType>(a)) {
            if (!ast::as<BoolType>(b)) return false;
            return deep_equal(ast::cast_to<BoolType>(a), ast::cast_to<BoolType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<ArrayType>(a)) {
            if (!ast::as<ArrayType>(b)) return false;
            return deep_equal(ast::cast_to<ArrayType>(a), ast::cast_to<ArrayType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<FunctionType>(a)) {
            if (!ast::as<FunctionType>(b)) return false;
            return deep_equal(ast::cast_to<FunctionType>(a), ast::cast_to<FunctionType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<StructType>(a)) {
            if (!ast::as<StructType>(b)) return false;
            return deep_equal(ast::cast_to<StructType>(a), ast::cast_to<StructType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<StructUnionType>(a)) {
            if (!ast::as<StructUnionType>(b)) return false;
            return deep_equal(ast::cast_to<StructUnionType>(a), ast::cast_to<StructUnionType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<UnionType>(a)) {
            if (!ast::as<UnionType>(b)) return false;
            return deep_equal(ast::cast_to<UnionType>(a), ast::cast_to<UnionType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<RangeType>(a)) {
            if (!ast::as<RangeType>(b)) return false;
            return deep_equal(ast::cast_to<RangeType>(a), ast::cast_to<RangeType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<EnumType>(a)) {
            if (!ast::as<EnumType>(b)) return false;
            return deep_equal(ast::cast_to<EnumType>(a), ast::cast_to<EnumType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<MetaType>(a)) {
            if (!ast::as<MetaType>(b)) return false;
            return deep_equal(ast::cast_to<MetaType>(a), ast::cast_to<MetaType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<OptionalType>(a)) {
            if (!ast::as<OptionalType>(b)) return false;
            return deep_equal(ast::cast_to<OptionalType>(a), ast::cast_to<OptionalType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<GenericType>(a)) {
            if (!ast::as<GenericType>(b)) return false;
            return deep_equal(ast::cast_to<GenericType>(a), ast::cast_to<GenericType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IntLiteral>(a)) {
            if (!ast::as<IntLiteral>(b)) return false;
            return deep_equal(ast::cast_to<IntLiteral>(a), ast::cast_to<IntLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<BoolLiteral>(a)) {
            if (!ast::as<BoolLiteral>(b)) return false;
            return deep_equal(ast::cast_to<BoolLiteral>(a), ast::cast_to<BoolLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<StrLiteral>(a)) {
            if (!ast::as<StrLiteral>(b)) return false;
            return deep_equal(ast::cast_to<StrLiteral>(a), ast::cast_to<StrLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<RegexLiteral>(a)) {
            if (!ast::as<RegexLiteral>(b)) return false;
            return deep_equal(ast::cast_to<RegexLiteral>(a), ast::cast_to<RegexLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<CharLiteral>(a)) {
            if (!ast::as<CharLiteral>(b)) return false;
            return deep_equal(ast::cast_to<CharLiteral>(a), ast::cast_to<CharLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<TypeLiteral>(a)) {
            if (!ast::as<TypeLiteral>(b)) return false;
            return deep_equal(ast::cast_to<TypeLiteral>(a), ast::cast_to<TypeLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<SpecialLiteral>(a)) {
            if (!ast::as<SpecialLiteral>(b)) return false;
            return deep_equal(ast::cast_to<SpecialLiteral>(a), ast::cast_to<SpecialLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Field>(a)) {
            if (!ast::as<Field>(b)) return false;
            return deep_equal(ast::cast_to<Field>(a), ast::cast_to<Field>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Format>(a)) {
            if (!ast::as<Format>(b)) return false;
            return deep_equal(ast::cast_to<Format>(a), ast::cast_to<Format>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<State>(a)) {
            if (!ast::as<State>(b)) return false;
            return deep_equal(ast::cast_to<State>(a), ast::cast_to<State>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Enum>(a)) {
            if (!ast::as<Enum>(b)) return false;
            return deep_equal(ast::cast_to<Enum>(a), ast::cast_to<Enum>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<EnumMember>(a)) {
            if (!ast::as<EnumMember>(b)) return false;
            return deep_equal(ast::cast_to<EnumMember>(a), ast::cast_to<EnumMember>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Function>(a)) {
            if (!ast::as<Function>(b)) return false;
            return deep_equal(ast::cast_to<Function>(a), ast::cast_to<Function>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        return false;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Expr>& a, const std::shared_ptr<Expr>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (ast::as<Binary>(a)) {
            if (!ast::as<Binary>(b)) return false;
            return deep_equal(ast::cast_to<Binary>(a), ast::cast_to<Binary>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Unary>(a)) {
            if (!ast::as<Unary>(b)) return false;
            return deep_equal(ast::cast_to<Unary>(a), ast::cast_to<Unary>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Cond>(a)) {
            if (!ast::as<Cond>(b)) return false;
            return deep_equal(ast::cast_to<Cond>(a), ast::cast_to<Cond>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Ident>(a)) {
            if (!ast::as<Ident>(b)) return false;
            return deep_equal(ast::cast_to<Ident>(a), ast::cast_to<Ident>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Call>(a)) {
            if (!ast::as<Call>(b)) return false;
            return deep_equal(ast::cast_to<Call>(a), ast::cast_to<Call>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<If>(a)) {
            if (!ast::as<If>(b)) return false;
            return deep_equal(ast::cast_to<If>(a), ast::cast_to<If>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<MemberAccess>(a)) {
            if (!ast::as<MemberAccess>(b)) return false;
            return deep_equal(ast::cast_to<MemberAccess>(a), ast::cast_to<MemberAccess>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Paren>(a)) {
            if (!ast::as<Paren>(b)) return false;
            return deep_equal(ast::cast_to<Paren>(a), ast::cast_to<Paren>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Index>(a)) {
            if (!ast::as<Index>(b)) return false;
            return deep_equal(ast::cast_to<Index>(a), ast::cast_to<Index>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Match>(a)) {
            if (!ast::as<Match>(b)) return false;
            return deep_equal(ast::cast_to<Match>(a), ast::cast_to<Match>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Range>(a)) {
            if (!ast::as<Range>(b)) return false;
            return deep_equal(ast::cast_to<Range>(a), ast::cast_to<Range>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Identity>(a)) {
            if (!ast::as<Identity>(b)) return false;
            return deep_equal(ast::cast_to<Identity>(a), ast::cast_to<Identity>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<TmpVar>(a)) {
            if (!ast::as<TmpVar>(b)) return false;
            return deep_equal(ast::cast_to<TmpVar>(a), ast::cast_to<TmpVar>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Import>(a)) {
            if (!ast::as<Import>(b)) return false;
            return deep_equal(ast::cast_to<Import>(a), ast::cast_to<Import>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Cast>(a)) {
            if (!ast::as<Cast>(b)) return false;
            return deep_equal(ast::cast_to<Cast>(a), ast::cast_to<Cast>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Available>(a)) {
            if (!ast::as<Available>(b)) return false;
            return deep_equal(ast::cast_to<Available>(a), ast::cast_to<Available>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<SpecifyOrder>(a)) {
            if (!ast::as<SpecifyOrder>(b)) return false;
            return deep_equal(ast::cast_to<SpecifyOrder>(a), ast::cast_to<SpecifyOrder>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<ExplicitError>(a)) {
            if (!ast::as<ExplicitError>(b)) return false;
            return deep_equal(ast::cast_to<ExplicitError>(a), ast::cast_to<ExplicitError>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IOOperation>(a)) {
            if (!ast::as<IOOperation>(b)) return false;
            return deep_equal(ast::cast_to<IOOperation>(a), ast::cast_to<IOOperation>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<OrCond>(a)) {
            if (!ast::as<OrCond>(b)) return false;
            return deep_equal(ast::cast_to<OrCond>(a), ast::cast_to<OrCond>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<BadExpr>(a)) {
            if (!ast::as<BadExpr>(b)) return false;
            return deep_equal(ast::cast_to<BadExpr>(a), ast::cast_to<BadExpr>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IntLiteral>(a)) {
            if (!ast::as<IntLiteral>(b)) return false;
            return deep_equal(ast::cast_to<IntLiteral>(a), ast::cast_to<IntLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<BoolLiteral>(a)) {
            if (!ast::as<BoolLiteral>(b)) return false;
            return deep_equal(ast::cast_to<BoolLiteral>(a), ast::cast_to<BoolLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<StrLiteral>(a)) {
            if (!ast::as<StrLiteral>(b)) return false;
            return deep_equal(ast::cast_to<StrLiteral>(a), ast::cast_to<StrLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<RegexLiteral>(a)) {
            if (!ast::as<RegexLiteral>(b)) return false;
            return deep_equal(ast::cast_to<RegexLiteral>(a), ast::cast_to<RegexLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<CharLiteral>(a)) {
            if (!ast::as<CharLiteral>(b)) return false;
            return deep_equal(ast::cast_to<CharLiteral>(a), ast::cast_to<CharLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<TypeLiteral>(a)) {
            if (!ast::as<TypeLiteral>(b)) return false;
            return deep_equal(ast::cast_to<TypeLiteral>(a), ast::cast_to<TypeLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<SpecialLiteral>(a)) {
            if (!ast::as<SpecialLiteral>(b)) return false;
            return deep_equal(ast::cast_to<SpecialLiteral>(a), ast::cast_to<SpecialLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        return false;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Stmt>& a, const std::shared_ptr<Stmt>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (ast::as<Loop>(a)) {
            if (!ast::as<Loop>(b)) return false;
            return deep_equal(ast::cast_to<Loop>(a), ast::cast_to<Loop>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IndentBlock>(a)) {
            if (!ast::as<IndentBlock>(b)) return false;
            return deep_equal(ast::cast_to<IndentBlock>(a), ast::cast_to<IndentBlock>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<ScopedStatement>(a)) {
            if (!ast::as<ScopedStatement>(b)) return false;
            return deep_equal(ast::cast_to<ScopedStatement>(a), ast::cast_to<ScopedStatement>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<MatchBranch>(a)) {
            if (!ast::as<MatchBranch>(b)) return false;
            return deep_equal(ast::cast_to<MatchBranch>(a), ast::cast_to<MatchBranch>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<UnionCandidate>(a)) {
            if (!ast::as<UnionCandidate>(b)) return false;
            return deep_equal(ast::cast_to<UnionCandidate>(a), ast::cast_to<UnionCandidate>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Return>(a)) {
            if (!ast::as<Return>(b)) return false;
            return deep_equal(ast::cast_to<Return>(a), ast::cast_to<Return>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Break>(a)) {
            if (!ast::as<Break>(b)) return false;
            return deep_equal(ast::cast_to<Break>(a), ast::cast_to<Break>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Continue>(a)) {
            if (!ast::as<Continue>(b)) return false;
            return deep_equal(ast::cast_to<Continue>(a), ast::cast_to<Continue>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Assert>(a)) {
            if (!ast::as<Assert>(b)) return false;
            return deep_equal(ast::cast_to<Assert>(a), ast::cast_to<Assert>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<ImplicitYield>(a)) {
            if (!ast::as<ImplicitYield>(b)) return false;
            return deep_equal(ast::cast_to<ImplicitYield>(a), ast::cast_to<ImplicitYield>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Metadata>(a)) {
            if (!ast::as<Metadata>(b)) return false;
            return deep_equal(ast::cast_to<Metadata>(a), ast::cast_to<Metadata>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Field>(a)) {
            if (!ast::as<Field>(b)) return false;
            return deep_equal(ast::cast_to<Field>(a), ast::cast_to<Field>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Format>(a)) {
            if (!ast::as<Format>(b)) return false;
            return deep_equal(ast::cast_to<Format>(a), ast::cast_to<Format>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<State>(a)) {
            if (!ast::as<State>(b)) return false;
            return deep_equal(ast::cast_to<State>(a), ast::cast_to<State>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Enum>(a)) {
            if (!ast::as<Enum>(b)) return false;
            return deep_equal(ast::cast_to<Enum>(a), ast::cast_to<Enum>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<EnumMember>(a)) {
            if (!ast::as<EnumMember>(b)) return false;
            return deep_equal(ast::cast_to<EnumMember>(a), ast::cast_to<EnumMember>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Function>(a)) {
            if (!ast::as<Function>(b)) return false;
            return deep_equal(ast::cast_to<Function>(a), ast::cast_to<Function>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        return false;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Type>& a, const std::shared_ptr<Type>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (ast::as<IntType>(a)) {
            if (!ast::as<IntType>(b)) return false;
            return deep_equal(ast::cast_to<IntType>(a), ast::cast_to<IntType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<FloatType>(a)) {
            if (!ast::as<FloatType>(b)) return false;
            return deep_equal(ast::cast_to<FloatType>(a), ast::cast_to<FloatType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IdentType>(a)) {
            if (!ast::as<IdentType>(b)) return false;
            return deep_equal(ast::cast_to<IdentType>(a), ast::cast_to<IdentType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<IntLiteralType>(a)) {
            if (!ast::as<IntLiteralType>(b)) return false;
            return deep_equal(ast::cast_to<IntLiteralType>(a), ast::cast_to<IntLiteralType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<StrLiteralType>(a)) {
            if (!ast::as<StrLiteralType>(b)) return false;
            return deep_equal(ast::cast_to<StrLiteralType>(a), ast::cast_to<StrLiteralType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<RegexLiteralType>(a)) {
            if (!ast::as<RegexLiteralType>(b)) return false;
            return deep_equal(ast::cast_to<RegexLiteralType>(a), ast::cast_to<RegexLiteralType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<VoidType>(a)) {
            if (!ast::as<VoidType>(b)) return false;
            return deep_equal(ast::cast_to<VoidType>(a), ast::cast_to<VoidType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<BoolType>(a)) {
            if (!ast::as<BoolType>(b)) return false;
            return deep_equal(ast::cast_to<BoolType>(a), ast::cast_to<BoolType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<ArrayType>(a)) {
            if (!ast::as<ArrayType>(b)) return false;
            return deep_equal(ast::cast_to<ArrayType>(a), ast::cast_to<ArrayType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<FunctionType>(a)) {
            if (!ast::as<FunctionType>(b)) return false;
            return deep_equal(ast::cast_to<FunctionType>(a), ast::cast_to<FunctionType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<StructType>(a)) {
            if (!ast::as<StructType>(b)) return false;
            return deep_equal(ast::cast_to<StructType>(a), ast::cast_to<StructType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<StructUnionType>(a)) {
            if (!ast::as<StructUnionType>(b)) return false;
            return deep_equal(ast::cast_to<StructUnionType>(a), ast::cast_to<StructUnionType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<UnionType>(a)) {
            if (!ast::as<UnionType>(b)) return false;
            return deep_equal(ast::cast_to<UnionType>(a), ast::cast_to<UnionType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<RangeType>(a)) {
            if (!ast::as<RangeType>(b)) return false;
            return deep_equal(ast::cast_to<RangeType>(a), ast::cast_to<RangeType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<EnumType>(a)) {
            if (!ast::as<EnumType>(b)) return false;
            return deep_equal(ast::cast_to<EnumType>(a), ast::cast_to<EnumType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<MetaType>(a)) {
            if (!ast::as<MetaType>(b)) return false;
            return deep_equal(ast::cast_to<MetaType>(a), ast::cast_to<MetaType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<OptionalType>(a)) {
            if (!ast::as<OptionalType>(b)) return false;
            return deep_equal(ast::cast_to<OptionalType>(a), ast::cast_to<OptionalType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<GenericType>(a)) {
            if (!ast::as<GenericType>(b)) return false;
            return deep_equal(ast::cast_to<GenericType>(a), ast::cast_to<GenericType>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        return false;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Literal>& a, const std::shared_ptr<Literal>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (ast::as<IntLiteral>(a)) {
            if (!ast::as<IntLiteral>(b)) return false;
            return deep_equal(ast::cast_to<IntLiteral>(a), ast::cast_to<IntLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<BoolLiteral>(a)) {
            if (!ast::as<BoolLiteral>(b)) return false;
            return deep_equal(ast::cast_to<BoolLiteral>(a), ast::cast_to<BoolLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<StrLiteral>(a)) {
            if (!ast::as<StrLiteral>(b)) return false;
            return deep_equal(ast::cast_to<StrLiteral>(a), ast::cast_to<StrLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<RegexLiteral>(a)) {
            if (!ast::as<RegexLiteral>(b)) return false;
            return deep_equal(ast::cast_to<RegexLiteral>(a), ast::cast_to<RegexLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<CharLiteral>(a)) {
            if (!ast::as<CharLiteral>(b)) return false;
            return deep_equal(ast::cast_to<CharLiteral>(a), ast::cast_to<CharLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<TypeLiteral>(a)) {
            if (!ast::as<TypeLiteral>(b)) return false;
            return deep_equal(ast::cast_to<TypeLiteral>(a), ast::cast_to<TypeLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<SpecialLiteral>(a)) {
            if (!ast::as<SpecialLiteral>(b)) return false;
            return deep_equal(ast::cast_to<SpecialLiteral>(a), ast::cast_to<SpecialLiteral>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        return false;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Member>& a, const std::shared_ptr<Member>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (ast::as<Field>(a)) {
            if (!ast::as<Field>(b)) return false;
            return deep_equal(ast::cast_to<Field>(a), ast::cast_to<Field>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Format>(a)) {
            if (!ast::as<Format>(b)) return false;
            return deep_equal(ast::cast_to<Format>(a), ast::cast_to<Format>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<State>(a)) {
            if (!ast::as<State>(b)) return false;
            return deep_equal(ast::cast_to<State>(a), ast::cast_to<State>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Enum>(a)) {
            if (!ast::as<Enum>(b)) return false;
            return deep_equal(ast::cast_to<Enum>(a), ast::cast_to<Enum>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<EnumMember>(a)) {
            if (!ast::as<EnumMember>(b)) return false;
            return deep_equal(ast::cast_to<EnumMember>(a), ast::cast_to<EnumMember>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        if (ast::as<Function>(a)) {
            if (!ast::as<Function>(b)) return false;
            return deep_equal(ast::cast_to<Function>(a), ast::cast_to<Function>(b), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map));
        }
        return false;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Program>& a, const std::shared_ptr<Program>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->struct_type); it != node_map.end()) {
            if (ast::cast_to<StructType>(it->second) != b->struct_type) return false;
        }
        else {
            if (!deep_equal(a->struct_type, b->struct_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->elements.size() != b->elements.size()) return false;
        for (size_t i = 0; i < a->elements.size(); i++) {
            if (!deep_equal(a->elements[i], b->elements[i], std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = scope_map.find(a->global_scope); it != scope_map.end()) {
            if (it->second != b->global_scope) return false;
        }
        else {
            if (!deep_equal(a->global_scope, b->global_scope, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->metadata.size() != b->metadata.size()) return false;
        for (size_t i = 0; i < a->metadata.size(); i++) {
            if (!deep_equal(a->metadata[i].lock(), b->metadata[i].lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Comment>& a, const std::shared_ptr<Comment>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (a->comment != b->comment) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<CommentGroup>& a, const std::shared_ptr<CommentGroup>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (a->comments.size() != b->comments.size()) return false;
        for (size_t i = 0; i < a->comments.size(); i++) {
            if (!deep_equal(a->comments[i], b->comments[i], std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<FieldArgument>& a, const std::shared_ptr<FieldArgument>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->raw_arguments); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->raw_arguments) return false;
        }
        else {
            if (!deep_equal(a->raw_arguments, b->raw_arguments, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->end_loc != b->end_loc) return false;
        if (a->collected_arguments.size() != b->collected_arguments.size()) return false;
        for (size_t i = 0; i < a->collected_arguments.size(); i++) {
            if (!deep_equal(a->collected_arguments[i].lock(), b->collected_arguments[i].lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->arguments.size() != b->arguments.size()) return false;
        for (size_t i = 0; i < a->arguments.size(); i++) {
            if (!deep_equal(a->arguments[i], b->arguments[i], std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->alignment); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->alignment) return false;
        }
        else {
            if (!deep_equal(a->alignment, b->alignment, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->alignment_value != b->alignment_value) return false;
        if (auto it = node_map.find(a->sub_byte_length); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->sub_byte_length) return false;
        }
        else {
            if (!deep_equal(a->sub_byte_length, b->sub_byte_length, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->sub_byte_begin); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->sub_byte_begin) return false;
        }
        else {
            if (!deep_equal(a->sub_byte_begin, b->sub_byte_begin, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->peek); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->peek) return false;
        }
        else {
            if (!deep_equal(a->peek, b->peek, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->peek_value != b->peek_value) return false;
        if (auto it = node_map.find(a->type_map); it != node_map.end()) {
            if (ast::cast_to<TypeLiteral>(it->second) != b->type_map) return false;
        }
        else {
            if (!deep_equal(a->type_map, b->type_map, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->metadata.size() != b->metadata.size()) return false;
        for (size_t i = 0; i < a->metadata.size(); i++) {
            if (!deep_equal(a->metadata[i], b->metadata[i], std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Binary>& a, const std::shared_ptr<Binary>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (a->op != b->op) return false;
        if (auto it = node_map.find(a->left); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->left) return false;
        }
        else {
            if (!deep_equal(a->left, b->left, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->right); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->right) return false;
        }
        else {
            if (!deep_equal(a->right, b->right, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Unary>& a, const std::shared_ptr<Unary>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (a->op != b->op) return false;
        if (auto it = node_map.find(a->expr); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->expr) return false;
        }
        else {
            if (!deep_equal(a->expr, b->expr, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Cond>& a, const std::shared_ptr<Cond>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (auto it = node_map.find(a->cond); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->cond) return false;
        }
        else {
            if (!deep_equal(a->cond, b->cond, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->then); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->then) return false;
        }
        else {
            if (!deep_equal(a->then, b->then, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->els_loc != b->els_loc) return false;
        if (auto it = node_map.find(a->els); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->els) return false;
        }
        else {
            if (!deep_equal(a->els, b->els, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Ident>& a, const std::shared_ptr<Ident>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (a->ident != b->ident) return false;
        if (a->usage != b->usage) return false;
        if (auto it = node_map.find(a->base.lock()); it != node_map.end()) {
            if (ast::cast_to<Node>(it->second) != b->base.lock()) return false;
        }
        else {
            if (!deep_equal(a->base.lock(), b->base.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = scope_map.find(a->scope); it != scope_map.end()) {
            if (it->second != b->scope) return false;
        }
        else {
            if (!deep_equal(a->scope, b->scope, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Call>& a, const std::shared_ptr<Call>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (auto it = node_map.find(a->callee); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->callee) return false;
        }
        else {
            if (!deep_equal(a->callee, b->callee, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->raw_arguments); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->raw_arguments) return false;
        }
        else {
            if (!deep_equal(a->raw_arguments, b->raw_arguments, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->arguments.size() != b->arguments.size()) return false;
        for (size_t i = 0; i < a->arguments.size(); i++) {
            if (!deep_equal(a->arguments[i], b->arguments[i], std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->end_loc != b->end_loc) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<If>& a, const std::shared_ptr<If>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (auto it = node_map.find(a->struct_union_type); it != node_map.end()) {
            if (ast::cast_to<StructUnionType>(it->second) != b->struct_union_type) return false;
        }
        else {
            if (!deep_equal(a->struct_union_type, b->struct_union_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = scope_map.find(a->cond_scope); it != scope_map.end()) {
            if (it->second != b->cond_scope) return false;
        }
        else {
            if (!deep_equal(a->cond_scope, b->cond_scope, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->cond); it != node_map.end()) {
            if (ast::cast_to<Identity>(it->second) != b->cond) return false;
        }
        else {
            if (!deep_equal(a->cond, b->cond, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->then); it != node_map.end()) {
            if (ast::cast_to<IndentBlock>(it->second) != b->then) return false;
        }
        else {
            if (!deep_equal(a->then, b->then, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->els); it != node_map.end()) {
            if (ast::cast_to<Node>(it->second) != b->els) return false;
        }
        else {
            if (!deep_equal(a->els, b->els, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<MemberAccess>& a, const std::shared_ptr<MemberAccess>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (auto it = node_map.find(a->target); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->target) return false;
        }
        else {
            if (!deep_equal(a->target, b->target, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->member); it != node_map.end()) {
            if (ast::cast_to<Ident>(it->second) != b->member) return false;
        }
        else {
            if (!deep_equal(a->member, b->member, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->base.lock()); it != node_map.end()) {
            if (ast::cast_to<Ident>(it->second) != b->base.lock()) return false;
        }
        else {
            if (!deep_equal(a->base.lock(), b->base.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Paren>& a, const std::shared_ptr<Paren>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (auto it = node_map.find(a->expr); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->expr) return false;
        }
        else {
            if (!deep_equal(a->expr, b->expr, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->end_loc != b->end_loc) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Index>& a, const std::shared_ptr<Index>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (auto it = node_map.find(a->expr); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->expr) return false;
        }
        else {
            if (!deep_equal(a->expr, b->expr, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->index); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->index) return false;
        }
        else {
            if (!deep_equal(a->index, b->index, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->end_loc != b->end_loc) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Match>& a, const std::shared_ptr<Match>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (auto it = node_map.find(a->struct_union_type); it != node_map.end()) {
            if (ast::cast_to<StructUnionType>(it->second) != b->struct_union_type) return false;
        }
        else {
            if (!deep_equal(a->struct_union_type, b->struct_union_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = scope_map.find(a->cond_scope); it != scope_map.end()) {
            if (it->second != b->cond_scope) return false;
        }
        else {
            if (!deep_equal(a->cond_scope, b->cond_scope, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->cond); it != node_map.end()) {
            if (ast::cast_to<Identity>(it->second) != b->cond) return false;
        }
        else {
            if (!deep_equal(a->cond, b->cond, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->branch.size() != b->branch.size()) return false;
        for (size_t i = 0; i < a->branch.size(); i++) {
            if (!deep_equal(a->branch[i], b->branch[i], std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Range>& a, const std::shared_ptr<Range>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (a->op != b->op) return false;
        if (auto it = node_map.find(a->start); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->start) return false;
        }
        else {
            if (!deep_equal(a->start, b->start, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->end); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->end) return false;
        }
        else {
            if (!deep_equal(a->end, b->end, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Identity>& a, const std::shared_ptr<Identity>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (auto it = node_map.find(a->expr); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->expr) return false;
        }
        else {
            if (!deep_equal(a->expr, b->expr, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<TmpVar>& a, const std::shared_ptr<TmpVar>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (a->tmp_var != b->tmp_var) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Import>& a, const std::shared_ptr<Import>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (a->path != b->path) return false;
        if (auto it = node_map.find(a->base); it != node_map.end()) {
            if (ast::cast_to<Call>(it->second) != b->base) return false;
        }
        else {
            if (!deep_equal(a->base, b->base, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->import_desc); it != node_map.end()) {
            if (ast::cast_to<Program>(it->second) != b->import_desc) return false;
        }
        else {
            if (!deep_equal(a->import_desc, b->import_desc, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Cast>& a, const std::shared_ptr<Cast>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (auto it = node_map.find(a->base); it != node_map.end()) {
            if (ast::cast_to<Call>(it->second) != b->base) return false;
        }
        else {
            if (!deep_equal(a->base, b->base, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->expr); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->expr) return false;
        }
        else {
            if (!deep_equal(a->expr, b->expr, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Available>& a, const std::shared_ptr<Available>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (auto it = node_map.find(a->base); it != node_map.end()) {
            if (ast::cast_to<Call>(it->second) != b->base) return false;
        }
        else {
            if (!deep_equal(a->base, b->base, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->target); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->target) return false;
        }
        else {
            if (!deep_equal(a->target, b->target, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<SpecifyOrder>& a, const std::shared_ptr<SpecifyOrder>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (auto it = node_map.find(a->base); it != node_map.end()) {
            if (ast::cast_to<Binary>(it->second) != b->base) return false;
        }
        else {
            if (!deep_equal(a->base, b->base, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->order_type != b->order_type) return false;
        if (auto it = node_map.find(a->order); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->order) return false;
        }
        else {
            if (!deep_equal(a->order, b->order, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->order_value != b->order_value) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<ExplicitError>& a, const std::shared_ptr<ExplicitError>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (auto it = node_map.find(a->base); it != node_map.end()) {
            if (ast::cast_to<Call>(it->second) != b->base) return false;
        }
        else {
            if (!deep_equal(a->base, b->base, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->message); it != node_map.end()) {
            if (ast::cast_to<StrLiteral>(it->second) != b->message) return false;
        }
        else {
            if (!deep_equal(a->message, b->message, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<IOOperation>& a, const std::shared_ptr<IOOperation>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (auto it = node_map.find(a->base); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->base) return false;
        }
        else {
            if (!deep_equal(a->base, b->base, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->method != b->method) return false;
        if (a->arguments.size() != b->arguments.size()) return false;
        for (size_t i = 0; i < a->arguments.size(); i++) {
            if (!deep_equal(a->arguments[i], b->arguments[i], std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<OrCond>& a, const std::shared_ptr<OrCond>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (auto it = node_map.find(a->base); it != node_map.end()) {
            if (ast::cast_to<Binary>(it->second) != b->base) return false;
        }
        else {
            if (!deep_equal(a->base, b->base, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->conds.size() != b->conds.size()) return false;
        for (size_t i = 0; i < a->conds.size(); i++) {
            if (!deep_equal(a->conds[i], b->conds[i], std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<BadExpr>& a, const std::shared_ptr<BadExpr>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (a->content != b->content) return false;
        if (auto it = node_map.find(a->bad_expr); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->bad_expr) return false;
        }
        else {
            if (!deep_equal(a->bad_expr, b->bad_expr, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Loop>& a, const std::shared_ptr<Loop>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = scope_map.find(a->cond_scope); it != scope_map.end()) {
            if (it->second != b->cond_scope) return false;
        }
        else {
            if (!deep_equal(a->cond_scope, b->cond_scope, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->init); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->init) return false;
        }
        else {
            if (!deep_equal(a->init, b->init, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->cond); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->cond) return false;
        }
        else {
            if (!deep_equal(a->cond, b->cond, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->step); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->step) return false;
        }
        else {
            if (!deep_equal(a->step, b->step, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->body); it != node_map.end()) {
            if (ast::cast_to<IndentBlock>(it->second) != b->body) return false;
        }
        else {
            if (!deep_equal(a->body, b->body, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<IndentBlock>& a, const std::shared_ptr<IndentBlock>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->struct_type); it != node_map.end()) {
            if (ast::cast_to<StructType>(it->second) != b->struct_type) return false;
        }
        else {
            if (!deep_equal(a->struct_type, b->struct_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->elements.size() != b->elements.size()) return false;
        for (size_t i = 0; i < a->elements.size(); i++) {
            if (!deep_equal(a->elements[i], b->elements[i], std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = scope_map.find(a->scope); it != scope_map.end()) {
            if (it->second != b->scope) return false;
        }
        else {
            if (!deep_equal(a->scope, b->scope, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->metadata.size() != b->metadata.size()) return false;
        for (size_t i = 0; i < a->metadata.size(); i++) {
            if (!deep_equal(a->metadata[i].lock(), b->metadata[i].lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<ScopedStatement>& a, const std::shared_ptr<ScopedStatement>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->struct_type); it != node_map.end()) {
            if (ast::cast_to<StructType>(it->second) != b->struct_type) return false;
        }
        else {
            if (!deep_equal(a->struct_type, b->struct_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->statement); it != node_map.end()) {
            if (ast::cast_to<Node>(it->second) != b->statement) return false;
        }
        else {
            if (!deep_equal(a->statement, b->statement, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = scope_map.find(a->scope); it != scope_map.end()) {
            if (it->second != b->scope) return false;
        }
        else {
            if (!deep_equal(a->scope, b->scope, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<MatchBranch>& a, const std::shared_ptr<MatchBranch>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->belong.lock()); it != node_map.end()) {
            if (ast::cast_to<Match>(it->second) != b->belong.lock()) return false;
        }
        else {
            if (!deep_equal(a->belong.lock(), b->belong.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->cond); it != node_map.end()) {
            if (ast::cast_to<Identity>(it->second) != b->cond) return false;
        }
        else {
            if (!deep_equal(a->cond, b->cond, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->sym_loc != b->sym_loc) return false;
        if (auto it = node_map.find(a->then); it != node_map.end()) {
            if (ast::cast_to<Node>(it->second) != b->then) return false;
        }
        else {
            if (!deep_equal(a->then, b->then, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<UnionCandidate>& a, const std::shared_ptr<UnionCandidate>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->cond.lock()); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->cond.lock()) return false;
        }
        else {
            if (!deep_equal(a->cond.lock(), b->cond.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->field.lock()); it != node_map.end()) {
            if (ast::cast_to<Field>(it->second) != b->field.lock()) return false;
        }
        else {
            if (!deep_equal(a->field.lock(), b->field.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Return>& a, const std::shared_ptr<Return>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->expr) return false;
        }
        else {
            if (!deep_equal(a->expr, b->expr, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->related_function.lock()); it != node_map.end()) {
            if (ast::cast_to<Function>(it->second) != b->related_function.lock()) return false;
        }
        else {
            if (!deep_equal(a->related_function.lock(), b->related_function.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Break>& a, const std::shared_ptr<Break>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->related_loop.lock()); it != node_map.end()) {
            if (ast::cast_to<Loop>(it->second) != b->related_loop.lock()) return false;
        }
        else {
            if (!deep_equal(a->related_loop.lock(), b->related_loop.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Continue>& a, const std::shared_ptr<Continue>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->related_loop.lock()); it != node_map.end()) {
            if (ast::cast_to<Loop>(it->second) != b->related_loop.lock()) return false;
        }
        else {
            if (!deep_equal(a->related_loop.lock(), b->related_loop.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Assert>& a, const std::shared_ptr<Assert>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->cond); it != node_map.end()) {
            if (ast::cast_to<Binary>(it->second) != b->cond) return false;
        }
        else {
            if (!deep_equal(a->cond, b->cond, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->is_io_related != b->is_io_related) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<ImplicitYield>& a, const std::shared_ptr<ImplicitYield>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->expr) return false;
        }
        else {
            if (!deep_equal(a->expr, b->expr, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Metadata>& a, const std::shared_ptr<Metadata>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->base); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->base) return false;
        }
        else {
            if (!deep_equal(a->base, b->base, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->name != b->name) return false;
        if (a->values.size() != b->values.size()) return false;
        for (size_t i = 0; i < a->values.size(); i++) {
            if (!deep_equal(a->values[i], b->values[i], std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<IntType>& a, const std::shared_ptr<IntType>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (a->is_explicit != b->is_explicit) return false;
        if (a->non_dynamic_allocation != b->non_dynamic_allocation) return false;
        if (a->bit_alignment != b->bit_alignment) return false;
        if (a->bit_size != b->bit_size) return false;
        if (a->endian != b->endian) return false;
        if (a->is_signed != b->is_signed) return false;
        if (a->is_common_supported != b->is_common_supported) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<FloatType>& a, const std::shared_ptr<FloatType>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (a->is_explicit != b->is_explicit) return false;
        if (a->non_dynamic_allocation != b->non_dynamic_allocation) return false;
        if (a->bit_alignment != b->bit_alignment) return false;
        if (a->bit_size != b->bit_size) return false;
        if (a->endian != b->endian) return false;
        if (a->is_common_supported != b->is_common_supported) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<IdentType>& a, const std::shared_ptr<IdentType>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (a->is_explicit != b->is_explicit) return false;
        if (a->non_dynamic_allocation != b->non_dynamic_allocation) return false;
        if (a->bit_alignment != b->bit_alignment) return false;
        if (a->bit_size != b->bit_size) return false;
        if (auto it = node_map.find(a->import_ref); it != node_map.end()) {
            if (ast::cast_to<MemberAccess>(it->second) != b->import_ref) return false;
        }
        else {
            if (!deep_equal(a->import_ref, b->import_ref, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->ident); it != node_map.end()) {
            if (ast::cast_to<Ident>(it->second) != b->ident) return false;
        }
        else {
            if (!deep_equal(a->ident, b->ident, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->base.lock()); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->base.lock()) return false;
        }
        else {
            if (!deep_equal(a->base.lock(), b->base.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<IntLiteralType>& a, const std::shared_ptr<IntLiteralType>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (a->is_explicit != b->is_explicit) return false;
        if (a->non_dynamic_allocation != b->non_dynamic_allocation) return false;
        if (a->bit_alignment != b->bit_alignment) return false;
        if (a->bit_size != b->bit_size) return false;
        if (auto it = node_map.find(a->base.lock()); it != node_map.end()) {
            if (ast::cast_to<IntLiteral>(it->second) != b->base.lock()) return false;
        }
        else {
            if (!deep_equal(a->base.lock(), b->base.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<StrLiteralType>& a, const std::shared_ptr<StrLiteralType>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (a->is_explicit != b->is_explicit) return false;
        if (a->non_dynamic_allocation != b->non_dynamic_allocation) return false;
        if (a->bit_alignment != b->bit_alignment) return false;
        if (a->bit_size != b->bit_size) return false;
        if (auto it = node_map.find(a->base.lock()); it != node_map.end()) {
            if (ast::cast_to<StrLiteral>(it->second) != b->base.lock()) return false;
        }
        else {
            if (!deep_equal(a->base.lock(), b->base.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->strong_ref); it != node_map.end()) {
            if (ast::cast_to<StrLiteral>(it->second) != b->strong_ref) return false;
        }
        else {
            if (!deep_equal(a->strong_ref, b->strong_ref, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<RegexLiteralType>& a, const std::shared_ptr<RegexLiteralType>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (a->is_explicit != b->is_explicit) return false;
        if (a->non_dynamic_allocation != b->non_dynamic_allocation) return false;
        if (a->bit_alignment != b->bit_alignment) return false;
        if (a->bit_size != b->bit_size) return false;
        if (auto it = node_map.find(a->base.lock()); it != node_map.end()) {
            if (ast::cast_to<RegexLiteral>(it->second) != b->base.lock()) return false;
        }
        else {
            if (!deep_equal(a->base.lock(), b->base.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->strong_ref); it != node_map.end()) {
            if (ast::cast_to<RegexLiteral>(it->second) != b->strong_ref) return false;
        }
        else {
            if (!deep_equal(a->strong_ref, b->strong_ref, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<VoidType>& a, const std::shared_ptr<VoidType>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (a->is_explicit != b->is_explicit) return false;
        if (a->non_dynamic_allocation != b->non_dynamic_allocation) return false;
        if (a->bit_alignment != b->bit_alignment) return false;
        if (a->bit_size != b->bit_size) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<BoolType>& a, const std::shared_ptr<BoolType>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (a->is_explicit != b->is_explicit) return false;
        if (a->non_dynamic_allocation != b->non_dynamic_allocation) return false;
        if (a->bit_alignment != b->bit_alignment) return false;
        if (a->bit_size != b->bit_size) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<ArrayType>& a, const std::shared_ptr<ArrayType>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (a->is_explicit != b->is_explicit) return false;
        if (a->non_dynamic_allocation != b->non_dynamic_allocation) return false;
        if (a->bit_alignment != b->bit_alignment) return false;
        if (a->bit_size != b->bit_size) return false;
        if (a->end_loc != b->end_loc) return false;
        if (auto it = node_map.find(a->element_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->element_type) return false;
        }
        else {
            if (!deep_equal(a->element_type, b->element_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->length); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->length) return false;
        }
        else {
            if (!deep_equal(a->length, b->length, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->length_value != b->length_value) return false;
        if (a->is_bytes != b->is_bytes) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<FunctionType>& a, const std::shared_ptr<FunctionType>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (a->is_explicit != b->is_explicit) return false;
        if (a->non_dynamic_allocation != b->non_dynamic_allocation) return false;
        if (a->bit_alignment != b->bit_alignment) return false;
        if (a->bit_size != b->bit_size) return false;
        if (auto it = node_map.find(a->return_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->return_type) return false;
        }
        else {
            if (!deep_equal(a->return_type, b->return_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->parameters.size() != b->parameters.size()) return false;
        for (size_t i = 0; i < a->parameters.size(); i++) {
            if (!deep_equal(a->parameters[i], b->parameters[i], std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<StructType>& a, const std::shared_ptr<StructType>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (a->is_explicit != b->is_explicit) return false;
        if (a->non_dynamic_allocation != b->non_dynamic_allocation) return false;
        if (a->bit_alignment != b->bit_alignment) return false;
        if (a->bit_size != b->bit_size) return false;
        if (a->fields.size() != b->fields.size()) return false;
        for (size_t i = 0; i < a->fields.size(); i++) {
            if (!deep_equal(a->fields[i], b->fields[i], std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->base.lock()); it != node_map.end()) {
            if (ast::cast_to<Node>(it->second) != b->base.lock()) return false;
        }
        else {
            if (!deep_equal(a->base.lock(), b->base.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->recursive != b->recursive) return false;
        if (a->fixed_header_size != b->fixed_header_size) return false;
        if (a->fixed_tail_size != b->fixed_tail_size) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<StructUnionType>& a, const std::shared_ptr<StructUnionType>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (a->is_explicit != b->is_explicit) return false;
        if (a->non_dynamic_allocation != b->non_dynamic_allocation) return false;
        if (a->bit_alignment != b->bit_alignment) return false;
        if (a->bit_size != b->bit_size) return false;
        if (auto it = node_map.find(a->cond); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->cond) return false;
        }
        else {
            if (!deep_equal(a->cond, b->cond, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->conds.size() != b->conds.size()) return false;
        for (size_t i = 0; i < a->conds.size(); i++) {
            if (!deep_equal(a->conds[i], b->conds[i], std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->structs.size() != b->structs.size()) return false;
        for (size_t i = 0; i < a->structs.size(); i++) {
            if (!deep_equal(a->structs[i], b->structs[i], std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->base.lock()); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->base.lock()) return false;
        }
        else {
            if (!deep_equal(a->base.lock(), b->base.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->union_fields.size() != b->union_fields.size()) return false;
        for (size_t i = 0; i < a->union_fields.size(); i++) {
            if (!deep_equal(a->union_fields[i].lock(), b->union_fields[i].lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->exhaustive != b->exhaustive) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<UnionType>& a, const std::shared_ptr<UnionType>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (a->is_explicit != b->is_explicit) return false;
        if (a->non_dynamic_allocation != b->non_dynamic_allocation) return false;
        if (a->bit_alignment != b->bit_alignment) return false;
        if (a->bit_size != b->bit_size) return false;
        if (auto it = node_map.find(a->cond.lock()); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->cond.lock()) return false;
        }
        else {
            if (!deep_equal(a->cond.lock(), b->cond.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->candidates.size() != b->candidates.size()) return false;
        for (size_t i = 0; i < a->candidates.size(); i++) {
            if (!deep_equal(a->candidates[i], b->candidates[i], std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->base_type.lock()); it != node_map.end()) {
            if (ast::cast_to<StructUnionType>(it->second) != b->base_type.lock()) return false;
        }
        else {
            if (!deep_equal(a->base_type.lock(), b->base_type.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->common_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->common_type) return false;
        }
        else {
            if (!deep_equal(a->common_type, b->common_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->member_candidates.size() != b->member_candidates.size()) return false;
        for (size_t i = 0; i < a->member_candidates.size(); i++) {
            if (!deep_equal(a->member_candidates[i], b->member_candidates[i], std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<RangeType>& a, const std::shared_ptr<RangeType>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (a->is_explicit != b->is_explicit) return false;
        if (a->non_dynamic_allocation != b->non_dynamic_allocation) return false;
        if (a->bit_alignment != b->bit_alignment) return false;
        if (a->bit_size != b->bit_size) return false;
        if (auto it = node_map.find(a->base_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->base_type) return false;
        }
        else {
            if (!deep_equal(a->base_type, b->base_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->range.lock()); it != node_map.end()) {
            if (ast::cast_to<Range>(it->second) != b->range.lock()) return false;
        }
        else {
            if (!deep_equal(a->range.lock(), b->range.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<EnumType>& a, const std::shared_ptr<EnumType>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (a->is_explicit != b->is_explicit) return false;
        if (a->non_dynamic_allocation != b->non_dynamic_allocation) return false;
        if (a->bit_alignment != b->bit_alignment) return false;
        if (a->bit_size != b->bit_size) return false;
        if (auto it = node_map.find(a->base.lock()); it != node_map.end()) {
            if (ast::cast_to<Enum>(it->second) != b->base.lock()) return false;
        }
        else {
            if (!deep_equal(a->base.lock(), b->base.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<MetaType>& a, const std::shared_ptr<MetaType>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (a->is_explicit != b->is_explicit) return false;
        if (a->non_dynamic_allocation != b->non_dynamic_allocation) return false;
        if (a->bit_alignment != b->bit_alignment) return false;
        if (a->bit_size != b->bit_size) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<OptionalType>& a, const std::shared_ptr<OptionalType>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (a->is_explicit != b->is_explicit) return false;
        if (a->non_dynamic_allocation != b->non_dynamic_allocation) return false;
        if (a->bit_alignment != b->bit_alignment) return false;
        if (a->bit_size != b->bit_size) return false;
        if (auto it = node_map.find(a->base_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->base_type) return false;
        }
        else {
            if (!deep_equal(a->base_type, b->base_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<GenericType>& a, const std::shared_ptr<GenericType>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (a->is_explicit != b->is_explicit) return false;
        if (a->non_dynamic_allocation != b->non_dynamic_allocation) return false;
        if (a->bit_alignment != b->bit_alignment) return false;
        if (a->bit_size != b->bit_size) return false;
        if (auto it = node_map.find(a->belong.lock()); it != node_map.end()) {
            if (ast::cast_to<Member>(it->second) != b->belong.lock()) return false;
        }
        else {
            if (!deep_equal(a->belong.lock(), b->belong.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<IntLiteral>& a, const std::shared_ptr<IntLiteral>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (a->value != b->value) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<BoolLiteral>& a, const std::shared_ptr<BoolLiteral>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (a->value != b->value) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<StrLiteral>& a, const std::shared_ptr<StrLiteral>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (a->value != b->value) return false;
        if (a->length != b->length) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<RegexLiteral>& a, const std::shared_ptr<RegexLiteral>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (a->value != b->value) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<CharLiteral>& a, const std::shared_ptr<CharLiteral>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (a->value != b->value) return false;
        if (a->code != b->code) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<TypeLiteral>& a, const std::shared_ptr<TypeLiteral>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (auto it = node_map.find(a->type_literal); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->type_literal) return false;
        }
        else {
            if (!deep_equal(a->type_literal, b->type_literal, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->end_loc != b->end_loc) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<SpecialLiteral>& a, const std::shared_ptr<SpecialLiteral>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->expr_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->expr_type) return false;
        }
        else {
            if (!deep_equal(a->expr_type, b->expr_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->constant_level != b->constant_level) return false;
        if (a->kind != b->kind) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Field>& a, const std::shared_ptr<Field>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->belong.lock()); it != node_map.end()) {
            if (ast::cast_to<Member>(it->second) != b->belong.lock()) return false;
        }
        else {
            if (!deep_equal(a->belong.lock(), b->belong.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->belong_struct.lock()); it != node_map.end()) {
            if (ast::cast_to<StructType>(it->second) != b->belong_struct.lock()) return false;
        }
        else {
            if (!deep_equal(a->belong_struct.lock(), b->belong_struct.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->ident); it != node_map.end()) {
            if (ast::cast_to<Ident>(it->second) != b->ident) return false;
        }
        else {
            if (!deep_equal(a->ident, b->ident, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->colon_loc != b->colon_loc) return false;
        if (a->is_state_variable != b->is_state_variable) return false;
        if (auto it = node_map.find(a->field_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->field_type) return false;
        }
        else {
            if (!deep_equal(a->field_type, b->field_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->arguments); it != node_map.end()) {
            if (ast::cast_to<FieldArgument>(it->second) != b->arguments) return false;
        }
        else {
            if (!deep_equal(a->arguments, b->arguments, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->offset_bit != b->offset_bit) return false;
        if (a->offset_recent != b->offset_recent) return false;
        if (a->tail_offset_bit != b->tail_offset_bit) return false;
        if (a->tail_offset_recent != b->tail_offset_recent) return false;
        if (a->bit_alignment != b->bit_alignment) return false;
        if (a->eventual_bit_alignment != b->eventual_bit_alignment) return false;
        if (a->follow != b->follow) return false;
        if (a->eventual_follow != b->eventual_follow) return false;
        if (auto it = node_map.find(a->next.lock()); it != node_map.end()) {
            if (ast::cast_to<Field>(it->second) != b->next.lock()) return false;
        }
        else {
            if (!deep_equal(a->next.lock(), b->next.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Format>& a, const std::shared_ptr<Format>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->belong.lock()); it != node_map.end()) {
            if (ast::cast_to<Member>(it->second) != b->belong.lock()) return false;
        }
        else {
            if (!deep_equal(a->belong.lock(), b->belong.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->belong_struct.lock()); it != node_map.end()) {
            if (ast::cast_to<StructType>(it->second) != b->belong_struct.lock()) return false;
        }
        else {
            if (!deep_equal(a->belong_struct.lock(), b->belong_struct.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->ident); it != node_map.end()) {
            if (ast::cast_to<Ident>(it->second) != b->ident) return false;
        }
        else {
            if (!deep_equal(a->ident, b->ident, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->body); it != node_map.end()) {
            if (ast::cast_to<IndentBlock>(it->second) != b->body) return false;
        }
        else {
            if (!deep_equal(a->body, b->body, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->encode_fn.lock()); it != node_map.end()) {
            if (ast::cast_to<Function>(it->second) != b->encode_fn.lock()) return false;
        }
        else {
            if (!deep_equal(a->encode_fn.lock(), b->encode_fn.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->decode_fn.lock()); it != node_map.end()) {
            if (ast::cast_to<Function>(it->second) != b->decode_fn.lock()) return false;
        }
        else {
            if (!deep_equal(a->decode_fn.lock(), b->decode_fn.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->cast_fns.size() != b->cast_fns.size()) return false;
        for (size_t i = 0; i < a->cast_fns.size(); i++) {
            if (!deep_equal(a->cast_fns[i].lock(), b->cast_fns[i].lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->depends.size() != b->depends.size()) return false;
        for (size_t i = 0; i < a->depends.size(); i++) {
            if (!deep_equal(a->depends[i].lock(), b->depends[i].lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->state_variables.size() != b->state_variables.size()) return false;
        for (size_t i = 0; i < a->state_variables.size(); i++) {
            if (!deep_equal(a->state_variables[i].lock(), b->state_variables[i].lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->format_trait != b->format_trait) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<State>& a, const std::shared_ptr<State>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->belong.lock()); it != node_map.end()) {
            if (ast::cast_to<Member>(it->second) != b->belong.lock()) return false;
        }
        else {
            if (!deep_equal(a->belong.lock(), b->belong.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->belong_struct.lock()); it != node_map.end()) {
            if (ast::cast_to<StructType>(it->second) != b->belong_struct.lock()) return false;
        }
        else {
            if (!deep_equal(a->belong_struct.lock(), b->belong_struct.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->ident); it != node_map.end()) {
            if (ast::cast_to<Ident>(it->second) != b->ident) return false;
        }
        else {
            if (!deep_equal(a->ident, b->ident, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->body); it != node_map.end()) {
            if (ast::cast_to<IndentBlock>(it->second) != b->body) return false;
        }
        else {
            if (!deep_equal(a->body, b->body, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Enum>& a, const std::shared_ptr<Enum>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->belong.lock()); it != node_map.end()) {
            if (ast::cast_to<Member>(it->second) != b->belong.lock()) return false;
        }
        else {
            if (!deep_equal(a->belong.lock(), b->belong.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->belong_struct.lock()); it != node_map.end()) {
            if (ast::cast_to<StructType>(it->second) != b->belong_struct.lock()) return false;
        }
        else {
            if (!deep_equal(a->belong_struct.lock(), b->belong_struct.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->ident); it != node_map.end()) {
            if (ast::cast_to<Ident>(it->second) != b->ident) return false;
        }
        else {
            if (!deep_equal(a->ident, b->ident, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = scope_map.find(a->scope); it != scope_map.end()) {
            if (it->second != b->scope) return false;
        }
        else {
            if (!deep_equal(a->scope, b->scope, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->colon_loc != b->colon_loc) return false;
        if (auto it = node_map.find(a->base_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->base_type) return false;
        }
        else {
            if (!deep_equal(a->base_type, b->base_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->members.size() != b->members.size()) return false;
        for (size_t i = 0; i < a->members.size(); i++) {
            if (!deep_equal(a->members[i], b->members[i], std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->enum_type); it != node_map.end()) {
            if (ast::cast_to<EnumType>(it->second) != b->enum_type) return false;
        }
        else {
            if (!deep_equal(a->enum_type, b->enum_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<EnumMember>& a, const std::shared_ptr<EnumMember>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->belong.lock()); it != node_map.end()) {
            if (ast::cast_to<Member>(it->second) != b->belong.lock()) return false;
        }
        else {
            if (!deep_equal(a->belong.lock(), b->belong.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->belong_struct.lock()); it != node_map.end()) {
            if (ast::cast_to<StructType>(it->second) != b->belong_struct.lock()) return false;
        }
        else {
            if (!deep_equal(a->belong_struct.lock(), b->belong_struct.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->ident); it != node_map.end()) {
            if (ast::cast_to<Ident>(it->second) != b->ident) return false;
        }
        else {
            if (!deep_equal(a->ident, b->ident, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->raw_expr); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->raw_expr) return false;
        }
        else {
            if (!deep_equal(a->raw_expr, b->raw_expr, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->value); it != node_map.end()) {
            if (ast::cast_to<Expr>(it->second) != b->value) return false;
        }
        else {
            if (!deep_equal(a->value, b->value, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->str_literal); it != node_map.end()) {
            if (ast::cast_to<StrLiteral>(it->second) != b->str_literal) return false;
        }
        else {
            if (!deep_equal(a->str_literal, b->str_literal, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Function>& a, const std::shared_ptr<Function>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->loc != b->loc) return false;
        if (auto it = node_map.find(a->belong.lock()); it != node_map.end()) {
            if (ast::cast_to<Member>(it->second) != b->belong.lock()) return false;
        }
        else {
            if (!deep_equal(a->belong.lock(), b->belong.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->belong_struct.lock()); it != node_map.end()) {
            if (ast::cast_to<StructType>(it->second) != b->belong_struct.lock()) return false;
        }
        else {
            if (!deep_equal(a->belong_struct.lock(), b->belong_struct.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->ident); it != node_map.end()) {
            if (ast::cast_to<Ident>(it->second) != b->ident) return false;
        }
        else {
            if (!deep_equal(a->ident, b->ident, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->parameters.size() != b->parameters.size()) return false;
        for (size_t i = 0; i < a->parameters.size(); i++) {
            if (!deep_equal(a->parameters[i], b->parameters[i], std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->return_type); it != node_map.end()) {
            if (ast::cast_to<Type>(it->second) != b->return_type) return false;
        }
        else {
            if (!deep_equal(a->return_type, b->return_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->body); it != node_map.end()) {
            if (ast::cast_to<IndentBlock>(it->second) != b->body) return false;
        }
        else {
            if (!deep_equal(a->body, b->body, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->func_type); it != node_map.end()) {
            if (ast::cast_to<FunctionType>(it->second) != b->func_type) return false;
        }
        else {
            if (!deep_equal(a->func_type, b->func_type, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->is_cast != b->is_cast) return false;
        return true;
    }
    template <class NodeM, class ScopeM>
    constexpr bool deep_equal(const std::shared_ptr<Scope>& a, const std::shared_ptr<Scope>& b, NodeM&& node_map, ScopeM&& scope_map) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (auto it = scope_map.find(a->prev.lock()); it != scope_map.end()) {
            if (it->second != b->prev.lock()) return false;
        }
        else {
            if (!deep_equal(a->prev.lock(), b->prev.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = scope_map.find(a->next); it != scope_map.end()) {
            if (it->second != b->next) return false;
        }
        else {
            if (!deep_equal(a->next, b->next, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = scope_map.find(a->branch); it != scope_map.end()) {
            if (it->second != b->branch) return false;
        }
        else {
            if (!deep_equal(a->branch, b->branch, std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->objects.size() != b->objects.size()) return false;
        for (size_t i = 0; i < a->objects.size(); i++) {
            if (!deep_equal(a->objects[i].lock(), b->objects[i].lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (auto it = node_map.find(a->owner.lock()); it != node_map.end()) {
            if (ast::cast_to<Node>(it->second) != b->owner.lock()) return false;
        }
        else {
            if (!deep_equal(a->owner.lock(), b->owner.lock(), std::forward<NodeM>(node_map), std::forward<ScopeM>(scope_map))) return false;
        }
        if (a->branch_root != b->branch_root) return false;
        return true;
    }
    namespace test {
        template <class NodeM, class ScopeM>
        inline bool test_single_deep_copy(const std::shared_ptr<Node>& n) {
            const auto copy = deep_copy(n, NodeM{}, ScopeM{});
            return deep_equal(n, copy, NodeM{}, ScopeM{});
        }
    }  // namespace test
}  // namespace brgen::ast
