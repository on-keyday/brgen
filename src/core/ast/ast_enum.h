/*license*/
// Code generated by "enum_gen"; DO NOT EDIT.
#pragma once
#include <string_view>
#include <optional>
#include <array>
namespace brgen::ast {
    template <typename T>
    constexpr std::optional<T> from_string(std::string_view str);
    template <typename T>
    constexpr size_t enum_elem_count();
    template <typename T, size_t s = enum_elem_count<T>()>
    constexpr std::array<std::pair<T, std::string_view>, s> make_enum_array();
    template <typename T>
    constexpr auto enum_array = make_enum_array<T>();
    enum class Follow {
        unknown,
        reference,
        define_variable,
        define_const,
        define_field,
        define_format,
        define_state,
        define_enum,
        define_enum_member,
        define_fn,
        define_cast_fn,
        define_arg,
        reference_type,
        reference_member,
        maybe_type,
        reference_builtin_fn,
    };
    constexpr const char* to_string(Follow e) {
        switch (e) {
            case Follow::unknown:
                return "unknown";
            case Follow::reference:
                return "reference";
            case Follow::define_variable:
                return "define_variable";
            case Follow::define_const:
                return "define_const";
            case Follow::define_field:
                return "define_field";
            case Follow::define_format:
                return "define_format";
            case Follow::define_state:
                return "define_state";
            case Follow::define_enum:
                return "define_enum";
            case Follow::define_enum_member:
                return "define_enum_member";
            case Follow::define_fn:
                return "define_fn";
            case Follow::define_cast_fn:
                return "define_cast_fn";
            case Follow::define_arg:
                return "define_arg";
            case Follow::reference_type:
                return "reference_type";
            case Follow::reference_member:
                return "reference_member";
            case Follow::maybe_type:
                return "maybe_type";
            case Follow::reference_builtin_fn:
                return "reference_builtin_fn";
            default:
                return nullptr;
        }
    }
    template <>
    constexpr std::optional<Follow> from_string<Follow>(std::string_view str) {
        if (str.empty()) return std::nullopt;
        if (str == "unknown") return Follow::unknown;
        if (str == "reference") return Follow::reference;
        if (str == "define_variable") return Follow::define_variable;
        if (str == "define_const") return Follow::define_const;
        if (str == "define_field") return Follow::define_field;
        if (str == "define_format") return Follow::define_format;
        if (str == "define_state") return Follow::define_state;
        if (str == "define_enum") return Follow::define_enum;
        if (str == "define_enum_member") return Follow::define_enum_member;
        if (str == "define_fn") return Follow::define_fn;
        if (str == "define_cast_fn") return Follow::define_cast_fn;
        if (str == "define_arg") return Follow::define_arg;
        if (str == "reference_type") return Follow::reference_type;
        if (str == "reference_member") return Follow::reference_member;
        if (str == "maybe_type") return Follow::maybe_type;
        if (str == "reference_builtin_fn") return Follow::reference_builtin_fn;
        return std::nullopt;
    }
    template <>
    constexpr size_t enum_elem_count<Follow>() {
        return 16;
    }
    template <>
    constexpr std::array<std::pair<Follow, std::string_view>, 16> make_enum_array<Follow, 16>() {
        return {
            std::pair{Follow::unknown, "unknown"},
            std::pair{Follow::reference, "reference"},
            std::pair{Follow::define_variable, "define_variable"},
            std::pair{Follow::define_const, "define_const"},
            std::pair{Follow::define_field, "define_field"},
            std::pair{Follow::define_format, "define_format"},
            std::pair{Follow::define_state, "define_state"},
            std::pair{Follow::define_enum, "define_enum"},
            std::pair{Follow::define_enum_member, "define_enum_member"},
            std::pair{Follow::define_fn, "define_fn"},
            std::pair{Follow::define_cast_fn, "define_cast_fn"},
            std::pair{Follow::define_arg, "define_arg"},
            std::pair{Follow::reference_type, "reference_type"},
            std::pair{Follow::reference_member, "reference_member"},
            std::pair{Follow::maybe_type, "maybe_type"},
            std::pair{Follow::reference_builtin_fn, "reference_builtin_fn"},
        };
    }
    constexpr void as_json(Follow e, auto&& d) {
        d.value(enum_array<Follow>[int(e)].second);
    }
    enum class BinaryOp {
        mul,
        div,
        mod,
        left_arithmetic_shift,
        right_arithmetic_shift,
        left_logical_shift,
        right_logical_shift,
        bit_and,
        add,
        sub,
        bit_or,
        bit_xor,
        equal,
        not_equal,
        less,
        less_or_eq,
        grater,
        grater_or_eq,
        logical_and,
        logical_or,
        cond_op1,
        cond_op2,
        range_exclusive,
        range_inclusive,
        assign,
        define_assign,
        const_assign,
        add_assign,
        sub_assign,
        mul_assign,
        div_assign,
        mod_assign,
        left_shift_assign,
        right_shift_assign,
        bit_and_assign,
        bit_or_assign,
        bit_xor_assign,
        comma,
    };
    constexpr const char* to_string(BinaryOp e) {
        switch (e) {
            case BinaryOp::mul:
                return "*";
            case BinaryOp::div:
                return "/";
            case BinaryOp::mod:
                return "%";
            case BinaryOp::left_arithmetic_shift:
                return "<<";
            case BinaryOp::right_arithmetic_shift:
                return ">>";
            case BinaryOp::left_logical_shift:
                return "<<<";
            case BinaryOp::right_logical_shift:
                return ">>>";
            case BinaryOp::bit_and:
                return "&";
            case BinaryOp::add:
                return "+";
            case BinaryOp::sub:
                return "-";
            case BinaryOp::bit_or:
                return "|";
            case BinaryOp::bit_xor:
                return "^";
            case BinaryOp::equal:
                return "==";
            case BinaryOp::not_equal:
                return "!=";
            case BinaryOp::less:
                return "<";
            case BinaryOp::less_or_eq:
                return "<=";
            case BinaryOp::grater:
                return ">";
            case BinaryOp::grater_or_eq:
                return ">=";
            case BinaryOp::logical_and:
                return "&&";
            case BinaryOp::logical_or:
                return "||";
            case BinaryOp::cond_op1:
                return "?";
            case BinaryOp::cond_op2:
                return ":";
            case BinaryOp::range_exclusive:
                return "..";
            case BinaryOp::range_inclusive:
                return "..=";
            case BinaryOp::assign:
                return "=";
            case BinaryOp::define_assign:
                return ":=";
            case BinaryOp::const_assign:
                return "::=";
            case BinaryOp::add_assign:
                return "+=";
            case BinaryOp::sub_assign:
                return "-=";
            case BinaryOp::mul_assign:
                return "*=";
            case BinaryOp::div_assign:
                return "/=";
            case BinaryOp::mod_assign:
                return "%=";
            case BinaryOp::left_shift_assign:
                return "<<=";
            case BinaryOp::right_shift_assign:
                return ">>=";
            case BinaryOp::bit_and_assign:
                return "&=";
            case BinaryOp::bit_or_assign:
                return "|=";
            case BinaryOp::bit_xor_assign:
                return "^=";
            case BinaryOp::comma:
                return ",";
            default:
                return nullptr;
        }
    }
    template <>
    constexpr std::optional<BinaryOp> from_string<BinaryOp>(std::string_view str) {
        if (str.empty()) return std::nullopt;
        if (str == "*") return BinaryOp::mul;
        if (str == "/") return BinaryOp::div;
        if (str == "%") return BinaryOp::mod;
        if (str == "<<") return BinaryOp::left_arithmetic_shift;
        if (str == ">>") return BinaryOp::right_arithmetic_shift;
        if (str == "<<<") return BinaryOp::left_logical_shift;
        if (str == ">>>") return BinaryOp::right_logical_shift;
        if (str == "&") return BinaryOp::bit_and;
        if (str == "+") return BinaryOp::add;
        if (str == "-") return BinaryOp::sub;
        if (str == "|") return BinaryOp::bit_or;
        if (str == "^") return BinaryOp::bit_xor;
        if (str == "==") return BinaryOp::equal;
        if (str == "!=") return BinaryOp::not_equal;
        if (str == "<") return BinaryOp::less;
        if (str == "<=") return BinaryOp::less_or_eq;
        if (str == ">") return BinaryOp::grater;
        if (str == ">=") return BinaryOp::grater_or_eq;
        if (str == "&&") return BinaryOp::logical_and;
        if (str == "||") return BinaryOp::logical_or;
        if (str == "?") return BinaryOp::cond_op1;
        if (str == ":") return BinaryOp::cond_op2;
        if (str == "..") return BinaryOp::range_exclusive;
        if (str == "..=") return BinaryOp::range_inclusive;
        if (str == "=") return BinaryOp::assign;
        if (str == ":=") return BinaryOp::define_assign;
        if (str == "::=") return BinaryOp::const_assign;
        if (str == "+=") return BinaryOp::add_assign;
        if (str == "-=") return BinaryOp::sub_assign;
        if (str == "*=") return BinaryOp::mul_assign;
        if (str == "/=") return BinaryOp::div_assign;
        if (str == "%=") return BinaryOp::mod_assign;
        if (str == "<<=") return BinaryOp::left_shift_assign;
        if (str == ">>=") return BinaryOp::right_shift_assign;
        if (str == "&=") return BinaryOp::bit_and_assign;
        if (str == "|=") return BinaryOp::bit_or_assign;
        if (str == "^=") return BinaryOp::bit_xor_assign;
        if (str == ",") return BinaryOp::comma;
        return std::nullopt;
    }
    template <>
    constexpr size_t enum_elem_count<BinaryOp>() {
        return 38;
    }
    template <>
    constexpr std::array<std::pair<BinaryOp, std::string_view>, 38> make_enum_array<BinaryOp, 38>() {
        return {
            std::pair{BinaryOp::mul, "*"},
            std::pair{BinaryOp::div, "/"},
            std::pair{BinaryOp::mod, "%"},
            std::pair{BinaryOp::left_arithmetic_shift, "<<"},
            std::pair{BinaryOp::right_arithmetic_shift, ">>"},
            std::pair{BinaryOp::left_logical_shift, "<<<"},
            std::pair{BinaryOp::right_logical_shift, ">>>"},
            std::pair{BinaryOp::bit_and, "&"},
            std::pair{BinaryOp::add, "+"},
            std::pair{BinaryOp::sub, "-"},
            std::pair{BinaryOp::bit_or, "|"},
            std::pair{BinaryOp::bit_xor, "^"},
            std::pair{BinaryOp::equal, "=="},
            std::pair{BinaryOp::not_equal, "!="},
            std::pair{BinaryOp::less, "<"},
            std::pair{BinaryOp::less_or_eq, "<="},
            std::pair{BinaryOp::grater, ">"},
            std::pair{BinaryOp::grater_or_eq, ">="},
            std::pair{BinaryOp::logical_and, "&&"},
            std::pair{BinaryOp::logical_or, "||"},
            std::pair{BinaryOp::cond_op1, "?"},
            std::pair{BinaryOp::cond_op2, ":"},
            std::pair{BinaryOp::range_exclusive, ".."},
            std::pair{BinaryOp::range_inclusive, "..="},
            std::pair{BinaryOp::assign, "="},
            std::pair{BinaryOp::define_assign, ":="},
            std::pair{BinaryOp::const_assign, "::="},
            std::pair{BinaryOp::add_assign, "+="},
            std::pair{BinaryOp::sub_assign, "-="},
            std::pair{BinaryOp::mul_assign, "*="},
            std::pair{BinaryOp::div_assign, "/="},
            std::pair{BinaryOp::mod_assign, "%="},
            std::pair{BinaryOp::left_shift_assign, "<<="},
            std::pair{BinaryOp::right_shift_assign, ">>="},
            std::pair{BinaryOp::bit_and_assign, "&="},
            std::pair{BinaryOp::bit_or_assign, "|="},
            std::pair{BinaryOp::bit_xor_assign, "^="},
            std::pair{BinaryOp::comma, ","},
        };
    }
    constexpr void as_json(BinaryOp e, auto&& d) {
        d.value(enum_array<BinaryOp>[int(e)].second);
    }
    enum class UnaryOp {
        not_,
        bit_not,
    };
    constexpr const char* to_string(UnaryOp e) {
        switch (e) {
            case UnaryOp::not_:
                return "!";
            case UnaryOp::bit_not:
                return "~";
            default:
                return nullptr;
        }
    }
    template <>
    constexpr std::optional<UnaryOp> from_string<UnaryOp>(std::string_view str) {
        if (str.empty()) return std::nullopt;
        if (str == "!") return UnaryOp::not_;
        if (str == "~") return UnaryOp::bit_not;
        return std::nullopt;
    }
    template <>
    constexpr size_t enum_elem_count<UnaryOp>() {
        return 2;
    }
    template <>
    constexpr std::array<std::pair<UnaryOp, std::string_view>, 2> make_enum_array<UnaryOp, 2>() {
        return {
            std::pair{UnaryOp::not_, "!"},
            std::pair{UnaryOp::bit_not, "~"},
        };
    }
    constexpr void as_json(UnaryOp e, auto&& d) {
        d.value(enum_array<UnaryOp>[int(e)].second);
    }
    enum class BitAlignment {
        byte_aligned,
        bit_1,
        bit_2,
        bit_3,
        bit_4,
        bit_5,
        bit_6,
        bit_7,
        not_target,
        not_decidable,
    };
    constexpr const char* to_string(BitAlignment e) {
        switch (e) {
            case BitAlignment::byte_aligned:
                return "byte_aligned";
            case BitAlignment::bit_1:
                return "bit_1";
            case BitAlignment::bit_2:
                return "bit_2";
            case BitAlignment::bit_3:
                return "bit_3";
            case BitAlignment::bit_4:
                return "bit_4";
            case BitAlignment::bit_5:
                return "bit_5";
            case BitAlignment::bit_6:
                return "bit_6";
            case BitAlignment::bit_7:
                return "bit_7";
            case BitAlignment::not_target:
                return "not_target";
            case BitAlignment::not_decidable:
                return "not_decidable";
            default:
                return nullptr;
        }
    }
    template <>
    constexpr std::optional<BitAlignment> from_string<BitAlignment>(std::string_view str) {
        if (str.empty()) return std::nullopt;
        if (str == "byte_aligned") return BitAlignment::byte_aligned;
        if (str == "bit_1") return BitAlignment::bit_1;
        if (str == "bit_2") return BitAlignment::bit_2;
        if (str == "bit_3") return BitAlignment::bit_3;
        if (str == "bit_4") return BitAlignment::bit_4;
        if (str == "bit_5") return BitAlignment::bit_5;
        if (str == "bit_6") return BitAlignment::bit_6;
        if (str == "bit_7") return BitAlignment::bit_7;
        if (str == "not_target") return BitAlignment::not_target;
        if (str == "not_decidable") return BitAlignment::not_decidable;
        return std::nullopt;
    }
    template <>
    constexpr size_t enum_elem_count<BitAlignment>() {
        return 10;
    }
    template <>
    constexpr std::array<std::pair<BitAlignment, std::string_view>, 10> make_enum_array<BitAlignment, 10>() {
        return {
            std::pair{BitAlignment::byte_aligned, "byte_aligned"},
            std::pair{BitAlignment::bit_1, "bit_1"},
            std::pair{BitAlignment::bit_2, "bit_2"},
            std::pair{BitAlignment::bit_3, "bit_3"},
            std::pair{BitAlignment::bit_4, "bit_4"},
            std::pair{BitAlignment::bit_5, "bit_5"},
            std::pair{BitAlignment::bit_6, "bit_6"},
            std::pair{BitAlignment::bit_7, "bit_7"},
            std::pair{BitAlignment::not_target, "not_target"},
            std::pair{BitAlignment::not_decidable, "not_decidable"},
        };
    }
    constexpr void as_json(BitAlignment e, auto&& d) {
        d.value(enum_array<BitAlignment>[int(e)].second);
    }
    enum class ConstantLevel {
        unknown,
        constant,
        const_variable,
        variable,
    };
    constexpr const char* to_string(ConstantLevel e) {
        switch (e) {
            case ConstantLevel::unknown:
                return "unknown";
            case ConstantLevel::constant:
                return "constant";
            case ConstantLevel::const_variable:
                return "const_variable";
            case ConstantLevel::variable:
                return "variable";
            default:
                return nullptr;
        }
    }
    template <>
    constexpr std::optional<ConstantLevel> from_string<ConstantLevel>(std::string_view str) {
        if (str.empty()) return std::nullopt;
        if (str == "unknown") return ConstantLevel::unknown;
        if (str == "constant") return ConstantLevel::constant;
        if (str == "const_variable") return ConstantLevel::const_variable;
        if (str == "variable") return ConstantLevel::variable;
        return std::nullopt;
    }
    template <>
    constexpr size_t enum_elem_count<ConstantLevel>() {
        return 4;
    }
    template <>
    constexpr std::array<std::pair<ConstantLevel, std::string_view>, 4> make_enum_array<ConstantLevel, 4>() {
        return {
            std::pair{ConstantLevel::unknown, "unknown"},
            std::pair{ConstantLevel::constant, "constant"},
            std::pair{ConstantLevel::const_variable, "const_variable"},
            std::pair{ConstantLevel::variable, "variable"},
        };
    }
    constexpr void as_json(ConstantLevel e, auto&& d) {
        d.value(enum_array<ConstantLevel>[int(e)].second);
    }
    enum class IdentUsage {
        unknown,
        reference,
        define_variable,
        define_const,
        define_field,
        define_format,
        define_state,
        define_enum,
        define_enum_member,
        define_fn,
        define_cast_fn,
        define_arg,
        reference_type,
        reference_member,
        maybe_type,
        reference_builtin_fn,
    };
    constexpr const char* to_string(IdentUsage e) {
        switch (e) {
            case IdentUsage::unknown:
                return "unknown";
            case IdentUsage::reference:
                return "reference";
            case IdentUsage::define_variable:
                return "define_variable";
            case IdentUsage::define_const:
                return "define_const";
            case IdentUsage::define_field:
                return "define_field";
            case IdentUsage::define_format:
                return "define_format";
            case IdentUsage::define_state:
                return "define_state";
            case IdentUsage::define_enum:
                return "define_enum";
            case IdentUsage::define_enum_member:
                return "define_enum_member";
            case IdentUsage::define_fn:
                return "define_fn";
            case IdentUsage::define_cast_fn:
                return "define_cast_fn";
            case IdentUsage::define_arg:
                return "define_arg";
            case IdentUsage::reference_type:
                return "reference_type";
            case IdentUsage::reference_member:
                return "reference_member";
            case IdentUsage::maybe_type:
                return "maybe_type";
            case IdentUsage::reference_builtin_fn:
                return "reference_builtin_fn";
            default:
                return nullptr;
        }
    }
    template <>
    constexpr std::optional<IdentUsage> from_string<IdentUsage>(std::string_view str) {
        if (str.empty()) return std::nullopt;
        if (str == "unknown") return IdentUsage::unknown;
        if (str == "reference") return IdentUsage::reference;
        if (str == "define_variable") return IdentUsage::define_variable;
        if (str == "define_const") return IdentUsage::define_const;
        if (str == "define_field") return IdentUsage::define_field;
        if (str == "define_format") return IdentUsage::define_format;
        if (str == "define_state") return IdentUsage::define_state;
        if (str == "define_enum") return IdentUsage::define_enum;
        if (str == "define_enum_member") return IdentUsage::define_enum_member;
        if (str == "define_fn") return IdentUsage::define_fn;
        if (str == "define_cast_fn") return IdentUsage::define_cast_fn;
        if (str == "define_arg") return IdentUsage::define_arg;
        if (str == "reference_type") return IdentUsage::reference_type;
        if (str == "reference_member") return IdentUsage::reference_member;
        if (str == "maybe_type") return IdentUsage::maybe_type;
        if (str == "reference_builtin_fn") return IdentUsage::reference_builtin_fn;
        return std::nullopt;
    }
    template <>
    constexpr size_t enum_elem_count<IdentUsage>() {
        return 16;
    }
    template <>
    constexpr std::array<std::pair<IdentUsage, std::string_view>, 16> make_enum_array<IdentUsage, 16>() {
        return {
            std::pair{IdentUsage::unknown, "unknown"},
            std::pair{IdentUsage::reference, "reference"},
            std::pair{IdentUsage::define_variable, "define_variable"},
            std::pair{IdentUsage::define_const, "define_const"},
            std::pair{IdentUsage::define_field, "define_field"},
            std::pair{IdentUsage::define_format, "define_format"},
            std::pair{IdentUsage::define_state, "define_state"},
            std::pair{IdentUsage::define_enum, "define_enum"},
            std::pair{IdentUsage::define_enum_member, "define_enum_member"},
            std::pair{IdentUsage::define_fn, "define_fn"},
            std::pair{IdentUsage::define_cast_fn, "define_cast_fn"},
            std::pair{IdentUsage::define_arg, "define_arg"},
            std::pair{IdentUsage::reference_type, "reference_type"},
            std::pair{IdentUsage::reference_member, "reference_member"},
            std::pair{IdentUsage::maybe_type, "maybe_type"},
            std::pair{IdentUsage::reference_builtin_fn, "reference_builtin_fn"},
        };
    }
    constexpr void as_json(IdentUsage e, auto&& d) {
        d.value(enum_array<IdentUsage>[int(e)].second);
    }
    enum class Endian {
        unspec,
        big,
        little,
    };
    constexpr const char* to_string(Endian e) {
        switch (e) {
            case Endian::unspec:
                return "unspec";
            case Endian::big:
                return "big";
            case Endian::little:
                return "little";
            default:
                return nullptr;
        }
    }
    template <>
    constexpr std::optional<Endian> from_string<Endian>(std::string_view str) {
        if (str.empty()) return std::nullopt;
        if (str == "unspec") return Endian::unspec;
        if (str == "big") return Endian::big;
        if (str == "little") return Endian::little;
        return std::nullopt;
    }
    template <>
    constexpr size_t enum_elem_count<Endian>() {
        return 3;
    }
    template <>
    constexpr std::array<std::pair<Endian, std::string_view>, 3> make_enum_array<Endian, 3>() {
        return {
            std::pair{Endian::unspec, "unspec"},
            std::pair{Endian::big, "big"},
            std::pair{Endian::little, "little"},
        };
    }
    constexpr void as_json(Endian e, auto&& d) {
        d.value(enum_array<Endian>[int(e)].second);
    }
}  // namespace brgen::ast
