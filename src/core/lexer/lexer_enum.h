/*license*/
// Code generated by "enum_gen"; DO NOT EDIT.
#pragma once
#include <string_view>
#include <optional>
#include <array>
namespace brgen::lexer {
template<typename T>
constexpr std::optional<T> from_string(std::string_view str);
template<typename T,class K>
constexpr std::optional<T> from_json(K k);
template<typename T>
constexpr size_t enum_elem_count();
template<typename T>
constexpr std::array<std::pair<T,std::string_view>,enum_elem_count<T>()> make_enum_array();
template<typename T>
constexpr std::array<std::pair<T,std::string_view>,enum_elem_count<T>()> make_enum_name_array();
template<typename T>
constexpr const char* enum_type_name();
template<typename T>
constexpr bool is_bit_flag();
template<typename T>
constexpr auto enum_array = make_enum_array<T>();
template<typename T>
constexpr auto enum_name_array = make_enum_name_array<T>();
enum class Tag {
    indent = 0,
    space = 1,
    line = 2,
    punct = 3,
    int_literal = 4,
    bool_literal = 5,
    str_literal = 6,
    regex_literal = 7,
    char_literal = 8,
    keyword = 9,
    ident = 10,
    comment = 11,
    error = 12,
    unknown = 13,
    partial_str_literal = 14,
    partial_char_literal = 15,
    partial_regex_literal = 16,
};
constexpr const char* to_string(Tag e) {
    switch(e) {
    case Tag::indent: return "indent";
    case Tag::space: return "space";
    case Tag::line: return "line";
    case Tag::punct: return "punct";
    case Tag::int_literal: return "int_literal";
    case Tag::bool_literal: return "bool_literal";
    case Tag::str_literal: return "str_literal";
    case Tag::regex_literal: return "regex_literal";
    case Tag::char_literal: return "char_literal";
    case Tag::keyword: return "keyword";
    case Tag::ident: return "ident";
    case Tag::comment: return "comment";
    case Tag::error: return "error";
    case Tag::unknown: return "unknown";
    case Tag::partial_str_literal: return "partial_str_literal";
    case Tag::partial_char_literal: return "partial_char_literal";
    case Tag::partial_regex_literal: return "partial_regex_literal";
    default: return nullptr;
    }
}
template<>constexpr std::optional<Tag> from_string<Tag>(std::string_view str) {
    if(str.empty()) return std::nullopt;
    if(str == "indent") return Tag::indent;
    if(str == "space") return Tag::space;
    if(str == "line") return Tag::line;
    if(str == "punct") return Tag::punct;
    if(str == "int_literal") return Tag::int_literal;
    if(str == "bool_literal") return Tag::bool_literal;
    if(str == "str_literal") return Tag::str_literal;
    if(str == "regex_literal") return Tag::regex_literal;
    if(str == "char_literal") return Tag::char_literal;
    if(str == "keyword") return Tag::keyword;
    if(str == "ident") return Tag::ident;
    if(str == "comment") return Tag::comment;
    if(str == "error") return Tag::error;
    if(str == "unknown") return Tag::unknown;
    if(str == "partial_str_literal") return Tag::partial_str_literal;
    if(str == "partial_char_literal") return Tag::partial_char_literal;
    if(str == "partial_regex_literal") return Tag::partial_regex_literal;
    return std::nullopt;
}
template<>constexpr size_t enum_elem_count<Tag>() {
    return 17;
}
template<>constexpr std::array<std::pair<Tag,std::string_view>,17> make_enum_array<Tag>() {
    return {
        std::pair{Tag::indent,"indent"},
        std::pair{Tag::space,"space"},
        std::pair{Tag::line,"line"},
        std::pair{Tag::punct,"punct"},
        std::pair{Tag::int_literal,"int_literal"},
        std::pair{Tag::bool_literal,"bool_literal"},
        std::pair{Tag::str_literal,"str_literal"},
        std::pair{Tag::regex_literal,"regex_literal"},
        std::pair{Tag::char_literal,"char_literal"},
        std::pair{Tag::keyword,"keyword"},
        std::pair{Tag::ident,"ident"},
        std::pair{Tag::comment,"comment"},
        std::pair{Tag::error,"error"},
        std::pair{Tag::unknown,"unknown"},
        std::pair{Tag::partial_str_literal,"partial_str_literal"},
        std::pair{Tag::partial_char_literal,"partial_char_literal"},
        std::pair{Tag::partial_regex_literal,"partial_regex_literal"},
    };
}
template<>constexpr std::array<std::pair<Tag,std::string_view>,17> make_enum_name_array<Tag>() {
    return {
        std::pair{Tag::indent,"indent"},
        std::pair{Tag::space,"space"},
        std::pair{Tag::line,"line"},
        std::pair{Tag::punct,"punct"},
        std::pair{Tag::int_literal,"int_literal"},
        std::pair{Tag::bool_literal,"bool_literal"},
        std::pair{Tag::str_literal,"str_literal"},
        std::pair{Tag::regex_literal,"regex_literal"},
        std::pair{Tag::char_literal,"char_literal"},
        std::pair{Tag::keyword,"keyword"},
        std::pair{Tag::ident,"ident"},
        std::pair{Tag::comment,"comment"},
        std::pair{Tag::error,"error"},
        std::pair{Tag::unknown,"unknown"},
        std::pair{Tag::partial_str_literal,"partial_str_literal"},
        std::pair{Tag::partial_char_literal,"partial_char_literal"},
        std::pair{Tag::partial_regex_literal,"partial_regex_literal"},
    };
}
constexpr void as_json(Tag e,auto&& d) {
    d.value(to_string(e));
}
template<>
constexpr std::optional<Tag> from_json<Tag,std::string_view>(std::string_view k){
    return from_string<Tag>(k);
}
template<>constexpr bool is_bit_flag<Tag>() {
    return false;
}
template<>
constexpr const char* enum_type_name<Tag>() {
    return "Tag";
}
}
