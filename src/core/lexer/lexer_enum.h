/*license*/
// Code generated by "enum_gen"; DO NOT EDIT.
#pragma once
#include <string_view>
#include <optional>
#include <array>
namespace brgen::lexer {
template<typename T>
constexpr std::optional<T> from_string(std::string_view str);
template<typename T>
constexpr size_t enum_elem_count();
template<typename T>
constexpr std::array<std::pair<T,std::string_view>,enum_elem_count<T>()> make_enum_array();
template<typename T>
constexpr std::array<std::pair<T,std::string_view>,enum_elem_count<T>()> make_enum_name_array();
template<typename T>
constexpr const char* enum_type_name();
template<typename T>
constexpr auto enum_array = make_enum_array<T>();
template<typename T>
constexpr auto enum_name_array = make_enum_name_array<T>();
enum class Tag {
    indent,
    space,
    line,
    punct,
    int_literal,
    bool_literal,
    str_literal,
    char_literal,
    keyword,
    ident,
    comment,
    error,
    unknown,
};
constexpr const char* to_string(Tag e) {
    switch(e) {
    case Tag::indent: return "indent";
    case Tag::space: return "space";
    case Tag::line: return "line";
    case Tag::punct: return "punct";
    case Tag::int_literal: return "int_literal";
    case Tag::bool_literal: return "bool_literal";
    case Tag::str_literal: return "str_literal";
    case Tag::char_literal: return "char_literal";
    case Tag::keyword: return "keyword";
    case Tag::ident: return "ident";
    case Tag::comment: return "comment";
    case Tag::error: return "error";
    case Tag::unknown: return "unknown";
    default: return nullptr;
    }
}
template<>constexpr std::optional<Tag> from_string<Tag>(std::string_view str) {
    if(str.empty()) return std::nullopt;
    if(str == "indent") return Tag::indent;
    if(str == "space") return Tag::space;
    if(str == "line") return Tag::line;
    if(str == "punct") return Tag::punct;
    if(str == "int_literal") return Tag::int_literal;
    if(str == "bool_literal") return Tag::bool_literal;
    if(str == "str_literal") return Tag::str_literal;
    if(str == "char_literal") return Tag::char_literal;
    if(str == "keyword") return Tag::keyword;
    if(str == "ident") return Tag::ident;
    if(str == "comment") return Tag::comment;
    if(str == "error") return Tag::error;
    if(str == "unknown") return Tag::unknown;
    return std::nullopt;
}
template<>constexpr size_t enum_elem_count<Tag>() {
    return 13;
}
template<>constexpr std::array<std::pair<Tag,std::string_view>,13> make_enum_array<Tag>() {
    return {
        std::pair{Tag::indent,"indent"},
        std::pair{Tag::space,"space"},
        std::pair{Tag::line,"line"},
        std::pair{Tag::punct,"punct"},
        std::pair{Tag::int_literal,"int_literal"},
        std::pair{Tag::bool_literal,"bool_literal"},
        std::pair{Tag::str_literal,"str_literal"},
        std::pair{Tag::char_literal,"char_literal"},
        std::pair{Tag::keyword,"keyword"},
        std::pair{Tag::ident,"ident"},
        std::pair{Tag::comment,"comment"},
        std::pair{Tag::error,"error"},
        std::pair{Tag::unknown,"unknown"},
    };
}
template<>constexpr std::array<std::pair<Tag,std::string_view>,13> make_enum_name_array<Tag>() {
    return {
        std::pair{Tag::indent,"indent"},
        std::pair{Tag::space,"space"},
        std::pair{Tag::line,"line"},
        std::pair{Tag::punct,"punct"},
        std::pair{Tag::int_literal,"int_literal"},
        std::pair{Tag::bool_literal,"bool_literal"},
        std::pair{Tag::str_literal,"str_literal"},
        std::pair{Tag::char_literal,"char_literal"},
        std::pair{Tag::keyword,"keyword"},
        std::pair{Tag::ident,"ident"},
        std::pair{Tag::comment,"comment"},
        std::pair{Tag::error,"error"},
        std::pair{Tag::unknown,"unknown"},
    };
}
constexpr void as_json(Tag e,auto&& d) {
    d.value(enum_array<Tag>[int(e)].second);
}
template<>
constexpr const char* enum_type_name<Tag>() {
    return "Tag";
}
}
