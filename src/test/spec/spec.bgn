
// brgen language specialization (draft)

// 1. Introduction
// goal of this language is simple/powerful/portable DSL for binary encoder/decoder/validator/logger/document etc... generator
// simple - easy to write and read
// powerful - enough to represent network protocol/file format
// portable - write once, generate in any language

// this document are example of usage and it's parsable by brgen 

// this is comment
/* 
   this is also comment
   can be multiline
*/

// 2. Word Definition
// GID - generator implementation defined - decided by generator implementer
// MUST - generator implementer must implement that

// 3. Scope and Syntax
// in global scope, there are format,enum,and import
// in local scope, there are format,enum,import,field definition statement,loop statement,expressions (including if,match and assertion)
// field definition statement and assignment expression makes identifier definition in it scope
// format and enum makes type definition in it scope
// identifier definition lookup rule are 

// in AST level, any of above can be written in anywhere but exclude above can be omitted by generator
// usage of optional statements and expressions are GID but some attribute explained after are recommended to implement

// 4. Literal
// boolean literal
true || false
// integer literal
1 == 3
// floating point literal if GID
1.0 - 1.0
// string literal
"Hello World"
// are supported

// 4.1. Input and Output, Environment
// there are three special literal; input, output, and env
// input means decoder input
// output means encoder output
// env means environment and configuration of generator
// you can access these objects anywhere
// some situation, access to these object makes separation of encoding and decoding
// these keywords are represented as ident
// these have some method or property, explained in 
input
output
env

// 5. Expressions
// expressions are used for several purpose, assignment,assertion, condition of if expr, length of VLA
// expressions are finally evaluated as bool,int,float,string, custom enum type,or custom format type.
// it is GID that evaluation of format type and float; if not supported, it should be evaluated as void

// 5.1 Binary Operator
// +  addition
1 + 2
"a"+"b" // strings are allowed
// -  subtraction
1 - 2
// * multiplication
1 * 2
// / division
1 / 2
// % modulo
1 % 2
// & bit and
1 & 0x7 // hexadecimal support
// | bit or
1 | 2
// ^ bit xor
1 ^ 2
// >> bit right shift
2 >> 1
// << bit left shift
1 << 2
// logical operator finally evaluated as bool
// == equal
1 == 2
// != not equal
1 != 2
// < less
1 < 2
// > greater
1 > 2
// >= greater or equal
1 >= 2
// <= less or equal
1 <= 2

// 5.2 Unary Operator
// - minus sign
-1
// logical/bit not
!1 // this is bit not
!true // this is logical not
// increment and decrement are not supported

// 5.3 Other
// () brackets 
// (1 + 2)* 3
// a.b member access
a.b
// this syntax is allowed if a is enum name, imported name, or format instance
// call(arg1,arg2) call
a(b)
// in this language function call is specially treated explained below
// arr_or_map[1] index
a[1]
// user only can define array
// if GID, builtin function can return map like object

// 5.3 Assignment Statement
// assignment makes temporary identifier 
// 3 types of assignment are defined
// := define variable
// define variable identifier
x := 10
// = assign
// rewrite variable
x = 2 
// ::= define constant
// define constant value
X ::= 30
// assignment to constant are invalid
// define constant should be implemented even if global scope

// 6. Format
// format is a unit of data structure that is converted to struct and encoder/decoder/logger/validator etc.. functions 
// 6.1. As-is Format
// As-is format is represent encoding/decoding format as is
// field is interpreted in order
format ExampleFormat:
    // fundamental types
    // integer number
    // support for integer number
    // belows are endian unspecified (endian will decided by environment)
    // uN -> N bit unsigned integer
    // sN -> N bit signed integer
    // belows are endian specified
    // ubN -> N bit big endian unsigned integer
    // usN -> N bit big endian signed integer
    // ulN -> N bit little endian unsigned integer
    // slN -> N bit little endian signed integer
    // N is larger than 0 (not 0 and smaller)
    // maximum limits and valid ranges are GID
    // but MUST support u8,s8,u16,s16,u32,s32,u64,s64
    sample1 :u8
    sample2 :u16
    sample3 :u32
    sample4 :u64
    sample5 :s8
    sample6 :s16
    sample7 :s32
    sample8 :s64

    // support for floating point number are GID
    // representation are fN and 
   

    // less than 8 bit also allowed if generator allowed
    // representation in program (packed in one byte? or using bit field?), 
    // and byte alignment requirement (allow non-byte aligned format or disallow) are GID
    prefix :u1
    data1 :u7

    // conditional format support are GID but implementing is recommended
    // for example, when decoding format, read prefix prior then judge and read data2 as u8 if prefix == 1 else read data2 as u16
    //              when encoding format, write data2 as u8 if prefix == 1 else write data2 as u16
    //              when logging format, if text format, write as text, else if binary format then write like encoding format
    // detail of how to hold data(union in C?std::variant in C++?enum in Rust?interface in Go?interface and derivative in C#/Java?) is GID
    if prefix == 1:
        data2 :u8
    else:
        data2 :u16

    // array types are supported if GID
    // generator implementation should support 2 type array
    // first is fixed length array that inner brackets value are constant
    // second is variable length array(VLA) decided by other field 
    // VLA length decision field MUST be prior to VLA field
    // to explain define:
    // len   :u8
    // value :[len]type
    // if generated format is symmetric (len is only represented by field to define length in this format; such as C's set of char* and int)
    // encoding and decoding are simply defined (encode/decode as is)
    // if generated format is asymmetric (representation of value also holds length field; such as C++'s std::vector)
    // generator should use len to decide value's length when decoding and should use length of value if encoding
    // if value length is like `value :[len+1]type` use it directly when decoding
    // and when encoding, len should be calculated from `len = value.length - 1` with solving linear equation
    // when value length is like `value :[len1+len2]`, decoding is easy but decision of `len1` and `len2` are too difficult to solve when encoding
    // generator implementer can provide other mechanism to decide len1 or len2, or make it an error; that is GID
    fixed :[16]u8
    len :u8
    data3 :[len]u8

    // boolean expression that is unused for any other purpose is
    // represented as assertion
    // assertion failure makes error or warning.
    // error or waring selection are GID
    sample1 == 2 || sample2 > 2

    // yes we can define format inner format
    format Embed:
        data :u8

    // this is embed representation of type 
    // how to represent this (expand in the class?using class inner class?or using embed representation in Go?) is GID
    :Embed


// 7. Enum
// enum are enumeration of numbers or strings or one type selection
enum ExampleEnum:
    :u8  // this prefer base type definition
    A :0 // here define A and it's number as 0
    B
    C    // B and C are interpreted as 1 and 3 like C enum or Go iota
    D :0xFF // yes this is 0xFF
    E:"hello" // here string are also allowed (but in this situation,maybe error)
    F         // E is also be "hello"
    G :"foo" 

// 8. Special Literals
// 8.1 Input
// TODO(on-keyday): write this

// 8.3 Output
// TODO(on-keyday): write this

// 8.3 Environment
// TODO(on-keyday): write this

// 9. Builtin
// generator implementer MUST provide allowed name (builtin) list of input,output,and env methods and property 
// and global name definition 
// below are implemented by parser that is resolved at meta level 
// exists(name) - name is exists in current scope
// is_builtin(name) - name is exists as builtin symbol
// has_method(name,method) - name has method
// has_property(name,property) - name has property

// 10. Error Handling
// in this language, error handling should be implicit
// that is generator should insert appropriate error handling method for each field/Format, encoding/decoding
// when encoding, validation should appear in first step of encoding
// when decoding, validation should appear in each step of decoding
// 10.1 Assertion
// floating boolean expression is interpreted as assertion
// assertion with error should be treated with same error handling mechanism of normal encode/decode error

// Appendix A. AST representation
// representation of ast
/*
    node_type: AST node type
    loc: location in source code and source file
       pos: position in source code
          begin: start position of source code
          end: end position of source code
       file: file index
    
    
*/

// Appendix B. Operator Precedence and Associative Order
// high
// postfix        () []
// (here ident and literal, inner brackets expression)
// unary          - !
// multiplicative *  /  %  <<  >>  &  left to right
// additive       +  -  |  ^          left to right
// compare        == != < > <= >=     unbounded (appear in same level is an error)
// logical and    &&                  left to right
// logical or     ||                  left to right
// low


// C. Generator Implementer Guide
// this is guide for code generator implementation 
// TODO(on-keyday): write this
