// Code generated by json2cpp2
#pragma once
#include <cstdint>
#include <vector>
#include <array>
#include <optional>
#include <variant>

#include <binary/flags.h>
#include <binary/float.h>
#include <view/iovec.h>
#include <binary/number.h>
#include <error/error.h>
#include <string>
namespace brgen::request {
    enum class ResponseType {
        CODE = 0,
        END_OF_CODE = 1,
    };
    enum class ResponseStatus {
        OK = 0,
        ERROR = 1,
    };
    struct GenerateSource {
        std::uint64_t id = 0;
        std::uint64_t name_len = 0;
        std::string name;
        bool set_name(auto&& v) {
            if (v.size() > ~std::uint64_t(0)) {
                return false;
            }
            (*this).name_len = v.size();
            (*this).name = std::forward<decltype(v)>(v);
            return true;
        }
        std::uint64_t len = 0;
        std::string json_text;
        bool set_json_text(auto&& v) {
            if (v.size() > ~std::uint64_t(0)) {
                return false;
            }
            (*this).len = v.size();
            (*this).json_text = std::forward<decltype(v)>(v);
            return true;
        }
        GenerateSource() {}
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 16;
    };
    inline ::futils::error::Error<> GenerateSource::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).id), true)) {
            return ::futils::error::Error<>("encode: GenerateSource::id: write std::uint64_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).name_len), true)) {
            return ::futils::error::Error<>("encode: GenerateSource::name_len: write std::uint64_t failed", ::futils::error::Category::lib);
        }
        auto tmp_0_ = (*this).name_len;
        if (tmp_0_ != (*this).name.size()) {
            return ::futils::error::Error<>("encode: GenerateSource::name: dynamic length is not compatible with its length; tmp_0_!=(*this).name.size()", ::futils::error::Category::lib);
        }
        if (!w.write((*this).name)) {
            return ::futils::error::Error<>("encode: GenerateSource::name: write array failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).len), true)) {
            return ::futils::error::Error<>("encode: GenerateSource::len: write std::uint64_t failed", ::futils::error::Category::lib);
        }
        auto tmp_1_ = (*this).len;
        if (tmp_1_ != (*this).json_text.size()) {
            return ::futils::error::Error<>("encode: GenerateSource::json_text: dynamic length is not compatible with its length; tmp_1_!=(*this).json_text.size()", ::futils::error::Category::lib);
        }
        if (!w.write((*this).json_text)) {
            return ::futils::error::Error<>("encode: GenerateSource::json_text: write array failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>{};
    }
    inline ::futils::error::Error<> GenerateSource::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).id, true)) {
            return ::futils::error::Error<>("decode: GenerateSource::id: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).name_len, true)) {
            return ::futils::error::Error<>("decode: GenerateSource::name_len: read int failed", ::futils::error::Category::lib);
        }
        auto tmp_2_ = (*this).name_len;
        if (!r.read((*this).name, tmp_2_)) {
            return ::futils::error::Error<>("decode: GenerateSource::name: read byte array failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).len, true)) {
            return ::futils::error::Error<>("decode: GenerateSource::len: read int failed", ::futils::error::Category::lib);
        }
        auto tmp_3_ = (*this).len;
        if (!r.read((*this).json_text, tmp_3_)) {
            return ::futils::error::Error<>("decode: GenerateSource::json_text: read byte array failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>{};
    }
    struct GeneratorRequestHeader {
        std::uint32_t version = 0;
        GeneratorRequestHeader() {}
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> GeneratorRequestHeader::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).version), true)) {
            return ::futils::error::Error<>("encode: GeneratorRequestHeader::version: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!((*this).version == 1)) {
            return ::futils::error::Error<>("encode: GeneratorRequestHeader: assertion failed; ((*this).version == 1)", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>{};
    }
    inline ::futils::error::Error<> GeneratorRequestHeader::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).version, true)) {
            return ::futils::error::Error<>("decode: GeneratorRequestHeader::version: read int failed", ::futils::error::Category::lib);
        }
        if (!((*this).version == 1)) {
            return ::futils::error::Error<>("decode: GeneratorRequestHeader: assertion failed; ((*this).version == 1)", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>{};
    }
    struct EndOfCode {
        std::uint64_t id = 0;
        EndOfCode() {}
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> EndOfCode::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).id), true)) {
            return ::futils::error::Error<>("encode: EndOfCode::id: write std::uint64_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>{};
    }
    inline ::futils::error::Error<> EndOfCode::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).id, true)) {
            return ::futils::error::Error<>("decode: EndOfCode::id: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>{};
    }
    struct SourceCode {
        std::uint64_t id = 0;
        ResponseStatus status{};
        std::uint64_t name_len = 0;
        std::string name;
        bool set_name(auto&& v) {
            if (v.size() > ~std::uint64_t(0)) {
                return false;
            }
            (*this).name_len = v.size();
            (*this).name = std::forward<decltype(v)>(v);
            return true;
        }
        std::uint64_t error_len = 0;
        std::string error_message;
        bool set_error_message(auto&& v) {
            if (v.size() > ~std::uint64_t(0)) {
                return false;
            }
            (*this).error_len = v.size();
            (*this).error_message = std::forward<decltype(v)>(v);
            return true;
        }
        std::uint64_t len = 0;
        std::string code;
        bool set_code(auto&& v) {
            if (v.size() > ~std::uint64_t(0)) {
                return false;
            }
            (*this).len = v.size();
            (*this).code = std::forward<decltype(v)>(v);
            return true;
        }
        SourceCode() {}
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 17;
    };
    inline ::futils::error::Error<> SourceCode::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).id), true)) {
            return ::futils::error::Error<>("encode: SourceCode::id: write std::uint64_t failed", ::futils::error::Category::lib);
        }
        auto tmp_4_ = static_cast<std::uint8_t>((*this).status);
        if (!::futils::binary::write_num(w, static_cast<std::uint8_t>(tmp_4_), true)) {
            return ::futils::error::Error<>("encode: SourceCode::status: write std::uint8_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).name_len), true)) {
            return ::futils::error::Error<>("encode: SourceCode::name_len: write std::uint64_t failed", ::futils::error::Category::lib);
        }
        auto tmp_5_ = (*this).name_len;
        if (tmp_5_ != (*this).name.size()) {
            return ::futils::error::Error<>("encode: SourceCode::name: dynamic length is not compatible with its length; tmp_5_!=(*this).name.size()", ::futils::error::Category::lib);
        }
        if (!w.write((*this).name)) {
            return ::futils::error::Error<>("encode: SourceCode::name: write array failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).error_len), true)) {
            return ::futils::error::Error<>("encode: SourceCode::error_len: write std::uint64_t failed", ::futils::error::Category::lib);
        }
        auto tmp_6_ = (*this).error_len;
        if (tmp_6_ != (*this).error_message.size()) {
            return ::futils::error::Error<>("encode: SourceCode::error_message: dynamic length is not compatible with its length; tmp_6_!=(*this).error_message.size()", ::futils::error::Category::lib);
        }
        if (!w.write((*this).error_message)) {
            return ::futils::error::Error<>("encode: SourceCode::error_message: write array failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).len), true)) {
            return ::futils::error::Error<>("encode: SourceCode::len: write std::uint64_t failed", ::futils::error::Category::lib);
        }
        auto tmp_7_ = (*this).len;
        if (tmp_7_ != (*this).code.size()) {
            return ::futils::error::Error<>("encode: SourceCode::code: dynamic length is not compatible with its length; tmp_7_!=(*this).code.size()", ::futils::error::Category::lib);
        }
        if (!w.write((*this).code)) {
            return ::futils::error::Error<>("encode: SourceCode::code: write array failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>{};
    }
    inline ::futils::error::Error<> SourceCode::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).id, true)) {
            return ::futils::error::Error<>("decode: SourceCode::id: read int failed", ::futils::error::Category::lib);
        }
        std::uint8_t tmp_8_ = 0;
        if (!::futils::binary::read_num(r, tmp_8_, true)) {
            return ::futils::error::Error<>("decode: SourceCode::status: read int failed", ::futils::error::Category::lib);
        }
        (*this).status = static_cast<ResponseStatus>(tmp_8_);
        if (!::futils::binary::read_num(r, (*this).name_len, true)) {
            return ::futils::error::Error<>("decode: SourceCode::name_len: read int failed", ::futils::error::Category::lib);
        }
        auto tmp_9_ = (*this).name_len;
        if (!r.read((*this).name, tmp_9_)) {
            return ::futils::error::Error<>("decode: SourceCode::name: read byte array failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).error_len, true)) {
            return ::futils::error::Error<>("decode: SourceCode::error_len: read int failed", ::futils::error::Category::lib);
        }
        auto tmp_10_ = (*this).error_len;
        if (!r.read((*this).error_message, tmp_10_)) {
            return ::futils::error::Error<>("decode: SourceCode::error_message: read byte array failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).len, true)) {
            return ::futils::error::Error<>("decode: SourceCode::len: read int failed", ::futils::error::Category::lib);
        }
        auto tmp_11_ = (*this).len;
        if (!r.read((*this).code, tmp_11_)) {
            return ::futils::error::Error<>("decode: SourceCode::code: read byte array failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>{};
    }
    struct GeneratorResponseHeader {
        std::uint32_t version = 0;
        GeneratorResponseHeader() {}
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> GeneratorResponseHeader::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).version), true)) {
            return ::futils::error::Error<>("encode: GeneratorResponseHeader::version: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!((*this).version == 1)) {
            return ::futils::error::Error<>("encode: GeneratorResponseHeader: assertion failed; ((*this).version == 1)", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>{};
    }
    inline ::futils::error::Error<> GeneratorResponseHeader::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).version, true)) {
            return ::futils::error::Error<>("decode: GeneratorResponseHeader::version: read int failed", ::futils::error::Category::lib);
        }
        if (!((*this).version == 1)) {
            return ::futils::error::Error<>("decode: GeneratorResponseHeader: assertion failed; ((*this).version == 1)", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>{};
    }
    struct GeneratorRequest {
        GeneratorRequestHeader header;
        std::vector<GenerateSource> source;
        GeneratorRequest() {}
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> GeneratorRequest::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).header.encode(w)) {
            return err;
        }
        for (auto& tmp_12_ : (*this).source) {
            if (auto err = tmp_12_.encode(w)) {
                return err;
            }
        }
        return ::futils::error::Error<>{};
    }
    inline ::futils::error::Error<> GeneratorRequest::decode(::futils::binary::reader& r) {
        if (auto err = (*this).header.decode(r)) {
            return err;
        }
        (*this).source.clear();
        for (;;) {
            if (!r.load_stream(1)) {
                break;  // reached EOF
            }
            GenerateSource tmp_13_;
            if (auto err = tmp_13_.decode(r)) {
                return err;
            }
            (*this).source.push_back(std::move(tmp_13_));
        }
        return ::futils::error::Error<>{};
    }
    struct Response {
        ResponseType type{};
        struct union_struct_16 {
            SourceCode source;
        };
        struct union_struct_17 {
            EndOfCode end;
        };
        std::variant<std::monostate, union_struct_16, union_struct_17> union_variant_15;
        std::optional<EndOfCode> end() const {
            if (ResponseType::CODE == (*this).type) {
                return std::nullopt;
            }
            if (ResponseType::END_OF_CODE == (*this).type) {
                if (!std::holds_alternative<union_struct_17>(union_variant_15)) {
                    return std::nullopt;
                }
                return std::get<2>((*this).union_variant_15).end;
            }
            return std::nullopt;
        }
        bool end(const EndOfCode& v) {
            if (ResponseType::CODE == (*this).type) {
                return false;
            }
            if (ResponseType::END_OF_CODE == (*this).type) {
                if (!std::holds_alternative<union_struct_17>(union_variant_15)) {
                    union_variant_15 = union_struct_17();
                }
                std::get<2>((*this).union_variant_15).end = v;
                return true;
            }
            return false;
        }
        std::optional<SourceCode> source() const {
            if (ResponseType::CODE == (*this).type) {
                if (!std::holds_alternative<union_struct_16>(union_variant_15)) {
                    return std::nullopt;
                }
                return std::get<1>((*this).union_variant_15).source;
            }
            return std::nullopt;
        }
        bool source(const SourceCode& v) {
            if (ResponseType::CODE == (*this).type) {
                if (!std::holds_alternative<union_struct_16>(union_variant_15)) {
                    union_variant_15 = union_struct_16();
                }
                std::get<1>((*this).union_variant_15).source = v;
                return true;
            }
            return false;
        }
        Response() {}
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
    };
    inline ::futils::error::Error<> Response::encode(::futils::binary::writer& w) const {
        auto tmp_18_ = static_cast<std::uint8_t>((*this).type);
        if (!::futils::binary::write_num(w, static_cast<std::uint8_t>(tmp_18_), true)) {
            return ::futils::error::Error<>("encode: Response::type: write std::uint8_t failed", ::futils::error::Category::lib);
        }
        if (ResponseType::CODE == (*this).type) {
            if (!std::holds_alternative<union_struct_16>(union_variant_15)) {
                return ::futils::error::Error<>("encode: Response: union_variant_15 variant alternative union_struct_16 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<1>((*this).union_variant_15).source.encode(w)) {
                return err;
            }
        }
        else if (ResponseType::END_OF_CODE == (*this).type) {
            if (!std::holds_alternative<union_struct_17>(union_variant_15)) {
                return ::futils::error::Error<>("encode: Response: union_variant_15 variant alternative union_struct_17 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<2>((*this).union_variant_15).end.encode(w)) {
                return err;
            }
        }
        return ::futils::error::Error<>{};
    }
    inline ::futils::error::Error<> Response::decode(::futils::binary::reader& r) {
        std::uint8_t tmp_19_ = 0;
        if (!::futils::binary::read_num(r, tmp_19_, true)) {
            return ::futils::error::Error<>("decode: Response::type: read int failed", ::futils::error::Category::lib);
        }
        (*this).type = static_cast<ResponseType>(tmp_19_);
        if (ResponseType::CODE == (*this).type) {
            if (!std::holds_alternative<union_struct_16>(union_variant_15)) {
                union_variant_15 = union_struct_16();
            }
            if (auto err = std::get<1>((*this).union_variant_15).source.decode(r)) {
                return err;
            }
        }
        else if (ResponseType::END_OF_CODE == (*this).type) {
            if (!std::holds_alternative<union_struct_17>(union_variant_15)) {
                union_variant_15 = union_struct_17();
            }
            if (auto err = std::get<2>((*this).union_variant_15).end.decode(r)) {
                return err;
            }
        }
        return ::futils::error::Error<>{};
    }
    struct GeneratorResponse {
        GeneratorResponseHeader header;
        std::vector<Response> source;
        GeneratorResponse() {}
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> GeneratorResponse::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).header.encode(w)) {
            return err;
        }
        for (auto& tmp_20_ : (*this).source) {
            if (auto err = tmp_20_.encode(w)) {
                return err;
            }
        }
        return ::futils::error::Error<>{};
    }
    inline ::futils::error::Error<> GeneratorResponse::decode(::futils::binary::reader& r) {
        if (auto err = (*this).header.decode(r)) {
            return err;
        }
        (*this).source.clear();
        for (;;) {
            if (!r.load_stream(1)) {
                break;  // reached EOF
            }
            Response tmp_21_;
            if (auto err = tmp_21_.decode(r)) {
                return err;
            }
            (*this).source.push_back(std::move(tmp_21_));
        }
        return ::futils::error::Error<>{};
    }
}  // namespace brgen::request
