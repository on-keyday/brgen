// Code generated by json2cpp2
#pragma once
#include <cstdint>
#include <vector>
#include <array>
#include <optional>
#include <variant>

#include <binary/flags.h>
#include <binary/float.h>
#include <view/iovec.h>
#include <binary/number.h>
#include <error/error.h>
#include <string>
namespace brgen::request {
    enum class ResponseStatus {
        OK = 0,
        ERROR = 1,
    };
    struct GenerateSource {
        std::uint64_t len = 0;
        std::string json_text;
        bool set_json_text(auto&& v) {
            if (v.size() > ~std::uint64_t(0)) {
                return false;
            }
            (*this).len = v.size();
            (*this).json_text = std::forward<decltype(v)>(v);
            return true;
        }
        GenerateSource() {}
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> GenerateSource::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).len), true)) {
            return ::futils::error::Error<>("encode: GenerateSource::len: write std::uint64_t failed", ::futils::error::Category::lib);
        }
        auto tmp_0_ = (*this).len;
        if (tmp_0_ != (*this).json_text.size()) {
            return ::futils::error::Error<>("encode: GenerateSource::json_text: dynamic length is not compatible with its length; tmp_0_!=(*this).json_text.size()", ::futils::error::Category::lib);
        }
        if (!w.write((*this).json_text)) {
            return ::futils::error::Error<>("encode: GenerateSource::json_text: write array failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>{};
    }
    inline ::futils::error::Error<> GenerateSource::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).len, true)) {
            return ::futils::error::Error<>("decode: GenerateSource::len: read int failed", ::futils::error::Category::lib);
        }
        auto tmp_1_ = (*this).len;
        if (!r.read((*this).json_text, tmp_1_)) {
            return ::futils::error::Error<>("decode: GenerateSource::json_text: read byte array failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>{};
    }
    struct GeneratorRequestHeader {
        std::uint32_t version = 0;
        std::uint64_t request_len = 0;
        GeneratorRequestHeader() {}
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 12;
    };
    inline ::futils::error::Error<> GeneratorRequestHeader::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).version), true)) {
            return ::futils::error::Error<>("encode: GeneratorRequestHeader::version: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!((*this).version == 1)) {
            return ::futils::error::Error<>("encode: GeneratorRequestHeader: assertion failed; ((*this).version == 1)", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).request_len), true)) {
            return ::futils::error::Error<>("encode: GeneratorRequestHeader::request_len: write std::uint64_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>{};
    }
    inline ::futils::error::Error<> GeneratorRequestHeader::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).version, true)) {
            return ::futils::error::Error<>("decode: GeneratorRequestHeader::version: read int failed", ::futils::error::Category::lib);
        }
        if (!((*this).version == 1)) {
            return ::futils::error::Error<>("decode: GeneratorRequestHeader: assertion failed; ((*this).version == 1)", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).request_len, true)) {
            return ::futils::error::Error<>("decode: GeneratorRequestHeader::request_len: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>{};
    }
    struct SourceCode {
        std::uint64_t name_len = 0;
        std::string name;
        bool set_name(auto&& v) {
            if (v.size() > ~std::uint64_t(0)) {
                return false;
            }
            (*this).name_len = v.size();
            (*this).name = std::forward<decltype(v)>(v);
            return true;
        }
        std::uint64_t len = 0;
        std::string code;
        bool set_code(auto&& v) {
            if (v.size() > ~std::uint64_t(0)) {
                return false;
            }
            (*this).len = v.size();
            (*this).code = std::forward<decltype(v)>(v);
            return true;
        }
        SourceCode() {}
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> SourceCode::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).name_len), true)) {
            return ::futils::error::Error<>("encode: SourceCode::name_len: write std::uint64_t failed", ::futils::error::Category::lib);
        }
        auto tmp_2_ = (*this).name_len;
        if (tmp_2_ != (*this).name.size()) {
            return ::futils::error::Error<>("encode: SourceCode::name: dynamic length is not compatible with its length; tmp_2_!=(*this).name.size()", ::futils::error::Category::lib);
        }
        if (!w.write((*this).name)) {
            return ::futils::error::Error<>("encode: SourceCode::name: write array failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).len), true)) {
            return ::futils::error::Error<>("encode: SourceCode::len: write std::uint64_t failed", ::futils::error::Category::lib);
        }
        auto tmp_3_ = (*this).len;
        if (tmp_3_ != (*this).code.size()) {
            return ::futils::error::Error<>("encode: SourceCode::code: dynamic length is not compatible with its length; tmp_3_!=(*this).code.size()", ::futils::error::Category::lib);
        }
        if (!w.write((*this).code)) {
            return ::futils::error::Error<>("encode: SourceCode::code: write array failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>{};
    }
    inline ::futils::error::Error<> SourceCode::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).name_len, true)) {
            return ::futils::error::Error<>("decode: SourceCode::name_len: read int failed", ::futils::error::Category::lib);
        }
        auto tmp_4_ = (*this).name_len;
        if (!r.read((*this).name, tmp_4_)) {
            return ::futils::error::Error<>("decode: SourceCode::name: read byte array failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).len, true)) {
            return ::futils::error::Error<>("decode: SourceCode::len: read int failed", ::futils::error::Category::lib);
        }
        auto tmp_5_ = (*this).len;
        if (!r.read((*this).code, tmp_5_)) {
            return ::futils::error::Error<>("decode: SourceCode::code: read byte array failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>{};
    }
    struct GeneratorRequest {
        GeneratorRequestHeader header;
        std::vector<GenerateSource> source;
        GeneratorRequest() {}
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 12;
    };
    inline ::futils::error::Error<> GeneratorRequest::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).header.encode(w)) {
            return err;
        }
        auto tmp_6_ = (*this).header.request_len;
        if (tmp_6_ != (*this).source.size()) {
            return ::futils::error::Error<>("encode: GeneratorRequest::source: dynamic length is not compatible with its length; tmp_6_!=(*this).source.size()", ::futils::error::Category::lib);
        }
        for (auto& tmp_7_ : (*this).source) {
            if (auto err = tmp_7_.encode(w)) {
                return err;
            }
        }
        return ::futils::error::Error<>{};
    }
    inline ::futils::error::Error<> GeneratorRequest::decode(::futils::binary::reader& r) {
        if (auto err = (*this).header.decode(r)) {
            return err;
        }
        auto tmp_8_ = (*this).header.request_len;
        (*this).source.clear();
        for (size_t tmp_10_ = 0; tmp_10_ < tmp_8_; ++tmp_10_) {
            GenerateSource tmp_9_;
            if (auto err = tmp_9_.decode(r)) {
                return err;
            }
            (*this).source.push_back(std::move(tmp_9_));
        }
        return ::futils::error::Error<>{};
    }
}  // namespace brgen::request
