// Code generated by gen_ast2ts; DO NOT EDIT.

export namespace ast2ts {

export type NodeType = "node" | "program" | "expr" | "binary" | "unary" | "cond" | "ident" | "call" | "if" | "member_access" | "paren" | "index" | "match" | "range" | "tmp_var" | "block_expr" | "import" | "literal" | "int_literal" | "bool_literal" | "str_literal" | "input" | "output" | "config" | "stmt" | "loop" | "indent_scope" | "match_branch" | "return" | "break" | "continue" | "assert" | "implicit_yield" | "member" | "field" | "format" | "function" | "type" | "int_type" | "ident_type" | "int_literal_type" | "str_literal_type" | "void_type" | "bool_type" | "array_type" | "function_type" | "struct_type" | "union_type" | "cast" | "comment" | "comment_group";

export function isNodeType(obj: any): obj is NodeType {
	return obj && typeof obj === 'string' && (obj === "node" || obj === "program" || obj === "expr" || obj === "binary" || obj === "unary" || obj === "cond" || obj === "ident" || obj === "call" || obj === "if" || obj === "member_access" || obj === "paren" || obj === "index" || obj === "match" || obj === "range" || obj === "tmp_var" || obj === "block_expr" || obj === "import" || obj === "literal" || obj === "int_literal" || obj === "bool_literal" || obj === "str_literal" || obj === "input" || obj === "output" || obj === "config" || obj === "stmt" || obj === "loop" || obj === "indent_scope" || obj === "match_branch" || obj === "return" || obj === "break" || obj === "continue" || obj === "assert" || obj === "implicit_yield" || obj === "member" || obj === "field" || obj === "format" || obj === "function" || obj === "type" || obj === "int_type" || obj === "ident_type" || obj === "int_literal_type" || obj === "str_literal_type" || obj === "void_type" || obj === "bool_type" || obj === "array_type" || obj === "function_type" || obj === "struct_type" || obj === "union_type" || obj === "cast" || obj === "comment" || obj === "comment_group")
}

export interface Node {
	readonly node_type: NodeType;
	loc: Loc;
}

export function isNode(obj: any): obj is Node {
	if (isProgram(obj)) return true;
	if (isBinary(obj)) return true;
	if (isUnary(obj)) return true;
	if (isCond(obj)) return true;
	if (isIdent(obj)) return true;
	if (isCall(obj)) return true;
	if (isIf(obj)) return true;
	if (isMemberAccess(obj)) return true;
	if (isParen(obj)) return true;
	if (isIndex(obj)) return true;
	if (isMatch(obj)) return true;
	if (isRange(obj)) return true;
	if (isTmpVar(obj)) return true;
	if (isBlockExpr(obj)) return true;
	if (isImport(obj)) return true;
	if (isIntLiteral(obj)) return true;
	if (isBoolLiteral(obj)) return true;
	if (isStrLiteral(obj)) return true;
	if (isInput(obj)) return true;
	if (isOutput(obj)) return true;
	if (isConfig(obj)) return true;
	if (isLoop(obj)) return true;
	if (isIndentScope(obj)) return true;
	if (isMatchBranch(obj)) return true;
	if (isReturn(obj)) return true;
	if (isBreak(obj)) return true;
	if (isContinue(obj)) return true;
	if (isAssert(obj)) return true;
	if (isImplicitYield(obj)) return true;
	if (isField(obj)) return true;
	if (isFormat(obj)) return true;
	if (isFunction(obj)) return true;
	if (isIntType(obj)) return true;
	if (isIdentType(obj)) return true;
	if (isIntLiteralType(obj)) return true;
	if (isStrLiteralType(obj)) return true;
	if (isVoidType(obj)) return true;
	if (isBoolType(obj)) return true;
	if (isArrayType(obj)) return true;
	if (isFunctionType(obj)) return true;
	if (isStructType(obj)) return true;
	if (isUnionType(obj)) return true;
	if (isCast(obj)) return true;
	if (isComment(obj)) return true;
	if (isCommentGroup(obj)) return true;
	return false;
}

export interface Expr extends Node {
	expr_type: Type|null;
}

export function isExpr(obj: any): obj is Expr {
	if (isBinary(obj)) return true;
	if (isUnary(obj)) return true;
	if (isCond(obj)) return true;
	if (isIdent(obj)) return true;
	if (isCall(obj)) return true;
	if (isIf(obj)) return true;
	if (isMemberAccess(obj)) return true;
	if (isParen(obj)) return true;
	if (isIndex(obj)) return true;
	if (isMatch(obj)) return true;
	if (isRange(obj)) return true;
	if (isTmpVar(obj)) return true;
	if (isBlockExpr(obj)) return true;
	if (isImport(obj)) return true;
	if (isIntLiteral(obj)) return true;
	if (isBoolLiteral(obj)) return true;
	if (isStrLiteral(obj)) return true;
	if (isInput(obj)) return true;
	if (isOutput(obj)) return true;
	if (isConfig(obj)) return true;
	if (isCast(obj)) return true;
	return false;
}

export interface Literal extends Expr {
}

export function isLiteral(obj: any): obj is Literal {
	if (isIntLiteral(obj)) return true;
	if (isBoolLiteral(obj)) return true;
	if (isStrLiteral(obj)) return true;
	if (isInput(obj)) return true;
	if (isOutput(obj)) return true;
	if (isConfig(obj)) return true;
	return false;
}

export interface Stmt extends Node {
}

export function isStmt(obj: any): obj is Stmt {
	if (isLoop(obj)) return true;
	if (isIndentScope(obj)) return true;
	if (isMatchBranch(obj)) return true;
	if (isReturn(obj)) return true;
	if (isBreak(obj)) return true;
	if (isContinue(obj)) return true;
	if (isAssert(obj)) return true;
	if (isImplicitYield(obj)) return true;
	if (isField(obj)) return true;
	if (isFormat(obj)) return true;
	if (isFunction(obj)) return true;
	return false;
}

export interface Member extends Stmt {
}

export function isMember(obj: any): obj is Member {
	if (isField(obj)) return true;
	if (isFormat(obj)) return true;
	if (isFunction(obj)) return true;
	return false;
}

export interface Type extends Node {
}

export function isType(obj: any): obj is Type {
	if (isIntType(obj)) return true;
	if (isIdentType(obj)) return true;
	if (isIntLiteralType(obj)) return true;
	if (isStrLiteralType(obj)) return true;
	if (isVoidType(obj)) return true;
	if (isBoolType(obj)) return true;
	if (isArrayType(obj)) return true;
	if (isFunctionType(obj)) return true;
	if (isStructType(obj)) return true;
	if (isUnionType(obj)) return true;
	return false;
}

export interface Program extends Node {
	struct_type: StructType|null;
	elements: Node[];
	global_scope: Scope|null;
}

export function isProgram(obj: any): obj is Program {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "program"
}

export interface Binary extends Expr {
	op: BinaryOp;
	left: Expr|null;
	right: Expr|null;
}

export function isBinary(obj: any): obj is Binary {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "binary"
}

export interface Unary extends Expr {
	op: UnaryOp;
	expr: Expr|null;
}

export function isUnary(obj: any): obj is Unary {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "unary"
}

export interface Cond extends Expr {
	cond: Expr|null;
	then: Expr|null;
	els_loc: Loc;
	els: Expr|null;
}

export function isCond(obj: any): obj is Cond {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "cond"
}

export interface Ident extends Expr {
	ident: string;
	usage: IdentUsage;
	base: Node|null;
	scope: Scope|null;
}

export function isIdent(obj: any): obj is Ident {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "ident"
}

export interface Call extends Expr {
	callee: Expr|null;
	raw_arguments: Expr|null;
	arguments: Expr[];
	end_loc: Loc;
}

export function isCall(obj: any): obj is Call {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "call"
}

export interface If extends Expr {
	cond: Expr|null;
	then: IndentScope|null;
	els: Node|null;
}

export function isIf(obj: any): obj is If {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "if"
}

export interface MemberAccess extends Expr {
	target: Expr|null;
	member: string;
	member_loc: Loc;
}

export function isMemberAccess(obj: any): obj is MemberAccess {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "member_access"
}

export interface Paren extends Expr {
	expr: Expr|null;
	end_loc: Loc;
}

export function isParen(obj: any): obj is Paren {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "paren"
}

export interface Index extends Expr {
	expr: Expr|null;
	index: Expr|null;
	end_loc: Loc;
}

export function isIndex(obj: any): obj is Index {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "index"
}

export interface Match extends Expr {
	cond: Expr|null;
	branch: Node[];
	scope: Scope|null;
}

export function isMatch(obj: any): obj is Match {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "match"
}

export interface Range extends Expr {
	op: BinaryOp;
	start: Expr|null;
	end: Expr|null;
}

export function isRange(obj: any): obj is Range {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "range"
}

export interface TmpVar extends Expr {
	tmp_var: number;
}

export function isTmpVar(obj: any): obj is TmpVar {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "tmp_var"
}

export interface BlockExpr extends Expr {
	calls: Node[];
	expr: Expr|null;
}

export function isBlockExpr(obj: any): obj is BlockExpr {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "block_expr"
}

export interface Import extends Expr {
	path: string;
	base: Call|null;
	import_desc: Program|null;
}

export function isImport(obj: any): obj is Import {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "import"
}

export interface IntLiteral extends Literal {
	value: string;
}

export function isIntLiteral(obj: any): obj is IntLiteral {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "int_literal"
}

export interface BoolLiteral extends Literal {
	value: boolean;
}

export function isBoolLiteral(obj: any): obj is BoolLiteral {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "bool_literal"
}

export interface StrLiteral extends Literal {
	value: string;
}

export function isStrLiteral(obj: any): obj is StrLiteral {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "str_literal"
}

export interface Input extends Literal {
}

export function isInput(obj: any): obj is Input {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "input"
}

export interface Output extends Literal {
}

export function isOutput(obj: any): obj is Output {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "output"
}

export interface Config extends Literal {
}

export function isConfig(obj: any): obj is Config {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "config"
}

export interface Loop extends Stmt {
	init: Expr|null;
	cond: Expr|null;
	step: Expr|null;
	body: IndentScope|null;
}

export function isLoop(obj: any): obj is Loop {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "loop"
}

export interface IndentScope extends Stmt {
	elements: Node[];
	scope: Scope|null;
}

export function isIndentScope(obj: any): obj is IndentScope {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "indent_scope"
}

export interface MatchBranch extends Stmt {
	cond: Expr|null;
	sym_loc: Loc;
	then: Node|null;
}

export function isMatchBranch(obj: any): obj is MatchBranch {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "match_branch"
}

export interface Return extends Stmt {
	expr: Expr|null;
}

export function isReturn(obj: any): obj is Return {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "return"
}

export interface Break extends Stmt {
}

export function isBreak(obj: any): obj is Break {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "break"
}

export interface Continue extends Stmt {
}

export function isContinue(obj: any): obj is Continue {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "continue"
}

export interface Assert extends Stmt {
	cond: Binary|null;
}

export function isAssert(obj: any): obj is Assert {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "assert"
}

export interface ImplicitYield extends Stmt {
	expr: Expr|null;
}

export function isImplicitYield(obj: any): obj is ImplicitYield {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "implicit_yield"
}

export interface Field extends Member {
	ident: Ident|null;
	colon_loc: Loc;
	field_type: Type|null;
	raw_arguments: Expr|null;
	arguments: Expr[];
	belong: Format|null;
}

export function isField(obj: any): obj is Field {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "field"
}

export interface Format extends Member {
	is_enum: boolean;
	ident: Ident|null;
	body: IndentScope|null;
	belong: Format|null;
	struct_type: StructType|null;
}

export function isFormat(obj: any): obj is Format {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "format"
}

export interface Function extends Member {
	ident: Ident|null;
	parameters: Field[];
	return_type: Type|null;
	belong: Format|null;
	body: IndentScope|null;
	func_type: FunctionType|null;
}

export function isFunction(obj: any): obj is Function {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "function"
}

export interface IntType extends Type {
	bit_size: number;
	endian: Endian;
	is_signed: boolean;
}

export function isIntType(obj: any): obj is IntType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "int_type"
}

export interface IdentType extends Type {
	ident: Ident|null;
	base: Format|null;
}

export function isIdentType(obj: any): obj is IdentType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "ident_type"
}

export interface IntLiteralType extends Type {
	base: IntLiteral|null;
}

export function isIntLiteralType(obj: any): obj is IntLiteralType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "int_literal_type"
}

export interface StrLiteralType extends Type {
	base: StrLiteral|null;
}

export function isStrLiteralType(obj: any): obj is StrLiteralType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "str_literal_type"
}

export interface VoidType extends Type {
}

export function isVoidType(obj: any): obj is VoidType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "void_type"
}

export interface BoolType extends Type {
}

export function isBoolType(obj: any): obj is BoolType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "bool_type"
}

export interface ArrayType extends Type {
	end_loc: Loc;
	base_type: Type|null;
	length: Expr|null;
}

export function isArrayType(obj: any): obj is ArrayType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "array_type"
}

export interface FunctionType extends Type {
	return_type: Type|null;
	parameters: Type[];
}

export function isFunctionType(obj: any): obj is FunctionType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "function_type"
}

export interface StructType extends Type {
	fields: Member[];
}

export function isStructType(obj: any): obj is StructType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "struct_type"
}

export interface UnionType extends Type {
	fields: StructType[];
	base: Expr|null;
}

export function isUnionType(obj: any): obj is UnionType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "union_type"
}

export interface Cast extends Expr {
	base: Call|null;
	expr: Expr|null;
}

export function isCast(obj: any): obj is Cast {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "cast"
}

export interface Comment extends Node {
	comment: string;
}

export function isComment(obj: any): obj is Comment {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "comment"
}

export interface CommentGroup extends Node {
	comments: Comment[];
}

export function isCommentGroup(obj: any): obj is CommentGroup {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "comment_group"
}

export enum UnaryOp {
	not = "!",
	minus_sign = "-",
};

export function isUnaryOp(obj: any): obj is UnaryOp {
	return obj && typeof obj === 'string' && (obj === "!" || obj === "-")
}

export enum BinaryOp {
	mul = "*",
	div = "/",
	mod = "%",
	left_arithmetic_shift = "<<<",
	right_arithmetic_shift = ">>>",
	left_logical_shift = "<<",
	right_logical_shift = ">>",
	bit_and = "&",
	add = "+",
	sub = "-",
	bit_or = "|",
	bit_xor = "^",
	equal = "==",
	not_equal = "!=",
	less = "<",
	less_or_eq = "<=",
	grater = ">",
	grater_or_eq = ">=",
	logical_and = "&&",
	logical_or = "||",
	cond_op_1 = "if",
	cond_op_2 = "else",
	range_exclusive = "..",
	range_inclusive = "..=",
	assign = "=",
	define_assign = ":=",
	const_assign = "::=",
	add_assign = "+=",
	sub_assign = "-=",
	mul_assign = "*=",
	div_assign = "/=",
	mod_assign = "%=",
	left_shift_assign = "<<=",
	right_shift_assign = ">>=",
	bit_and_assign = "&=",
	bit_or_assign = "|=",
	bit_xor_assign = "^=",
	comma = ",",
};

export function isBinaryOp(obj: any): obj is BinaryOp {
	return obj && typeof obj === 'string' && (obj === "*" || obj === "/" || obj === "%" || obj === "<<<" || obj === ">>>" || obj === "<<" || obj === ">>" || obj === "&" || obj === "+" || obj === "-" || obj === "|" || obj === "^" || obj === "==" || obj === "!=" || obj === "<" || obj === "<=" || obj === ">" || obj === ">=" || obj === "&&" || obj === "||" || obj === "if" || obj === "else" || obj === ".." || obj === "..=" || obj === "=" || obj === ":=" || obj === "::=" || obj === "+=" || obj === "-=" || obj === "*=" || obj === "/=" || obj === "%=" || obj === "<<=" || obj === ">>=" || obj === "&=" || obj === "|=" || obj === "^=" || obj === ",")
}

export enum IdentUsage {
	unknown = "unknown",
	reference = "reference",
	define_variable = "define_variable",
	define_const = "define_const",
	define_field = "define_field",
	define_format = "define_format",
	define_enum = "define_enum",
	define_fn = "define_fn",
	define_arg = "define_arg",
	reference_type = "reference_type",
};

export function isIdentUsage(obj: any): obj is IdentUsage {
	return obj && typeof obj === 'string' && (obj === "unknown" || obj === "reference" || obj === "define_variable" || obj === "define_const" || obj === "define_field" || obj === "define_format" || obj === "define_enum" || obj === "define_fn" || obj === "define_arg" || obj === "reference_type")
}

export enum Endian {
	unspec = "unspec",
	big = "big",
	little = "little",
};

export function isEndian(obj: any): obj is Endian {
	return obj && typeof obj === 'string' && (obj === "unspec" || obj === "big" || obj === "little")
}

export enum TokenTag {
	indent = "indent",
	space = "space",
	line = "line",
	punct = "punct",
	int_literal = "int_literal",
	bool_literal = "bool_literal",
	str_literal = "str_literal",
	keyword = "keyword",
	ident = "ident",
	comment = "comment",
	error = "error",
	unknown = "unknown",
};

export function isTokenTag(obj: any): obj is TokenTag {
	return obj && typeof obj === 'string' && (obj === "indent" || obj === "space" || obj === "line" || obj === "punct" || obj === "int_literal" || obj === "bool_literal" || obj === "str_literal" || obj === "keyword" || obj === "ident" || obj === "comment" || obj === "error" || obj === "unknown")
}

export interface Scope {
	prev: Scope|null;
	next: Scope|null;
	branch: Scope|null;
	ident: Ident[];
}

export function isScope(obj: any): obj is Scope {
	return obj && typeof obj === 'object' && typeof obj?.prev === 'object' && typeof obj?.next === 'object' && typeof obj?.branch === 'object' && Array.isArray(obj?.ident)
}

export interface Pos {
	begin: number;
	end: number;
}

export function isPos(obj: any): obj is Pos {
	return obj && typeof obj === 'object' && typeof obj?.begin === 'number' && typeof obj?.end === 'number'
}

export interface Loc {
	pos: Pos;
	file: number;
	line: number;
	col: number;
}

export function isLoc(obj: any): obj is Loc {
	return obj && typeof obj === 'object' && isPos(obj?.pos) && typeof obj?.file === 'number' && typeof obj?.line === 'number' && typeof obj?.col === 'number'
}

export interface Token {
	tag: TokenTag;
	token: string;
	loc: Loc;
}

export function isToken(obj: any): obj is Token {
	return obj && typeof obj === 'object' && isTokenTag(obj?.tag) && typeof obj?.token === 'string' && isLoc(obj?.loc)
}

export interface SrcErrorEntry {
	msg: string;
	file: string;
	loc: Loc;
	src: string;
	warn: boolean;
}

export function isSrcErrorEntry(obj: any): obj is SrcErrorEntry {
	return obj && typeof obj === 'object' && typeof obj?.msg === 'string' && typeof obj?.file === 'string' && isLoc(obj?.loc) && typeof obj?.src === 'string' && typeof obj?.warn === 'boolean'
}

export interface SrcError {
	errs: SrcErrorEntry[];
}

export function isSrcError(obj: any): obj is SrcError {
	return obj && typeof obj === 'object' && Array.isArray(obj?.errs)
}

export interface RawNode {
	node_type: NodeType;
	loc :Loc;
	body :any;
}

export function isRawNode(obj: any): obj is RawNode {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && isLoc(obj?.loc) && typeof obj?.body === 'object'
}

export interface RawScope {
	prev: number | null;
	next : number | null;
	branch : number | null;
 	ident: number[];
}

export function isRawScope(obj: any): obj is RawScope {
  return obj && typeof obj === 'object' && (typeof obj?.is_global === 'boolean') && (obj?.prev === null || typeof obj?.prev == 'number') && (obj?.next === null || typeof obj?.next == 'number') && (obj?.branch === null || typeof obj?.branch == 'number') && Array.isArray(obj?.ident)
}

export interface Ast {
	node: RawNode[];
	scope :RawScope[];
}
export function isAst(obj: any): obj is Ast {
	return obj && typeof obj === 'object' && Array.isArray(obj?.node) && Array.isArray(obj?.scope)
}

interface astConstructor {
	node : Node[];
	scope : Scope[];
}

export function parseAST(obj: any): Program {
	if (!isAst(obj)) {
		throw new Error('invalid ast');
	}
	const o :Ast = {
		node: obj.node.map((n: any) => {
			if (!isRawNode(n)) {
				throw new Error('invalid node');
			}
			return n;
		}),
		scope: obj.scope.map((s: any) => {
			if (!isRawScope(s)) {
				throw new Error('invalid scope');
			}
			return s;
		})
	}
	const c :astConstructor = {
		node: [],
		scope: []
	}
	for (const on of o.node) {
		switch (on.node_type) {
		case "program": {
			const n :Program = {
				node_type: "program",
				struct_type: null,
				elements: [],
				global_scope: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "binary": {
			const n :Binary = {
				node_type: "binary",
				expr_type: null,
				op: BinaryOp.mul,
				left: null,
				right: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "unary": {
			const n :Unary = {
				node_type: "unary",
				expr_type: null,
				op: UnaryOp.not,
				expr: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "cond": {
			const n :Cond = {
				node_type: "cond",
				expr_type: null,
				cond: null,
				then: null,
				els_loc: on.loc,
				els: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "ident": {
			const n :Ident = {
				node_type: "ident",
				expr_type: null,
				ident: '',
				usage: IdentUsage.unknown,
				base: null,
				scope: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "call": {
			const n :Call = {
				node_type: "call",
				expr_type: null,
				callee: null,
				raw_arguments: null,
				arguments: [],
				end_loc: on.loc,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "if": {
			const n :If = {
				node_type: "if",
				expr_type: null,
				cond: null,
				then: null,
				els: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "member_access": {
			const n :MemberAccess = {
				node_type: "member_access",
				expr_type: null,
				target: null,
				member: '',
				member_loc: on.loc,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "paren": {
			const n :Paren = {
				node_type: "paren",
				expr_type: null,
				expr: null,
				end_loc: on.loc,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "index": {
			const n :Index = {
				node_type: "index",
				expr_type: null,
				expr: null,
				index: null,
				end_loc: on.loc,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "match": {
			const n :Match = {
				node_type: "match",
				expr_type: null,
				cond: null,
				branch: [],
				scope: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "range": {
			const n :Range = {
				node_type: "range",
				expr_type: null,
				op: BinaryOp.mul,
				start: null,
				end: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "tmp_var": {
			const n :TmpVar = {
				node_type: "tmp_var",
				expr_type: null,
				tmp_var: 0,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "block_expr": {
			const n :BlockExpr = {
				node_type: "block_expr",
				expr_type: null,
				calls: [],
				expr: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "import": {
			const n :Import = {
				node_type: "import",
				expr_type: null,
				path: '',
				base: null,
				import_desc: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "int_literal": {
			const n :IntLiteral = {
				node_type: "int_literal",
				expr_type: null,
				value: '',
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "bool_literal": {
			const n :BoolLiteral = {
				node_type: "bool_literal",
				expr_type: null,
				value: false,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "str_literal": {
			const n :StrLiteral = {
				node_type: "str_literal",
				expr_type: null,
				value: '',
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "input": {
			const n :Input = {
				node_type: "input",
				expr_type: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "output": {
			const n :Output = {
				node_type: "output",
				expr_type: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "config": {
			const n :Config = {
				node_type: "config",
				expr_type: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "loop": {
			const n :Loop = {
				node_type: "loop",
				init: null,
				cond: null,
				step: null,
				body: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "indent_scope": {
			const n :IndentScope = {
				node_type: "indent_scope",
				elements: [],
				scope: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "match_branch": {
			const n :MatchBranch = {
				node_type: "match_branch",
				cond: null,
				sym_loc: on.loc,
				then: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "return": {
			const n :Return = {
				node_type: "return",
				expr: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "break": {
			const n :Break = {
				node_type: "break",
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "continue": {
			const n :Continue = {
				node_type: "continue",
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "assert": {
			const n :Assert = {
				node_type: "assert",
				cond: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "implicit_yield": {
			const n :ImplicitYield = {
				node_type: "implicit_yield",
				expr: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "field": {
			const n :Field = {
				node_type: "field",
				ident: null,
				colon_loc: on.loc,
				field_type: null,
				raw_arguments: null,
				arguments: [],
				belong: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "format": {
			const n :Format = {
				node_type: "format",
				is_enum: false,
				ident: null,
				body: null,
				belong: null,
				struct_type: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "function": {
			const n :Function = {
				node_type: "function",
				ident: null,
				parameters: [],
				return_type: null,
				belong: null,
				body: null,
				func_type: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "int_type": {
			const n :IntType = {
				node_type: "int_type",
				bit_size: 0,
				endian: Endian.unspec,
				is_signed: false,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "ident_type": {
			const n :IdentType = {
				node_type: "ident_type",
				ident: null,
				base: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "int_literal_type": {
			const n :IntLiteralType = {
				node_type: "int_literal_type",
				base: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "str_literal_type": {
			const n :StrLiteralType = {
				node_type: "str_literal_type",
				base: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "void_type": {
			const n :VoidType = {
				node_type: "void_type",
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "bool_type": {
			const n :BoolType = {
				node_type: "bool_type",
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "array_type": {
			const n :ArrayType = {
				node_type: "array_type",
				end_loc: on.loc,
				base_type: null,
				length: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "function_type": {
			const n :FunctionType = {
				node_type: "function_type",
				return_type: null,
				parameters: [],
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "struct_type": {
			const n :StructType = {
				node_type: "struct_type",
				fields: [],
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "union_type": {
			const n :UnionType = {
				node_type: "union_type",
				fields: [],
				base: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "cast": {
			const n :Cast = {
				node_type: "cast",
				expr_type: null,
				base: null,
				expr: null,
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "comment": {
			const n :Comment = {
				node_type: "comment",
				comment: '',
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "comment_group": {
			const n :CommentGroup = {
				node_type: "comment_group",
				comments: [],
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		default:
			throw new Error('invalid node type');
		}
	}
	for (const _ of o.scope) {
		const n :Scope = {
			prev: null,
			next: null,
			branch: null,
			ident: [],
		}
		c.scope.push(n);
	}
	for (let i = 0; i < o.node.length; i++) {
		const on = o.node[i];
		const cnode = c.node[i];
		switch (cnode.node_type) {
		case "program": {
			const n :Program = cnode as Program;
			if (on.body?.struct_type !== null && typeof on.body?.struct_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpstruct_type = on.body.struct_type === null ? null : c.node[on.body.struct_type];
			if (!(tmpstruct_type === null || isStructType(tmpstruct_type))) {
				throw new Error('invalid node list');
			}
			n.struct_type = tmpstruct_type;
			for (const o of on.body.elements) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list');
				}
				const tmpelements = c.node[o];
				n.elements.push(tmpelements);
			}
			if (on.body?.global_scope !== null && typeof on.body?.global_scope !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpglobal_scope = on.body.global_scope === null ? null : c.scope[on.body.global_scope];
			if (tmpglobal_scope !== null && !isScope(tmpglobal_scope)) {
				throw new Error('invalid node list');
			}
			n.global_scope = tmpglobal_scope;
			break;
		}
		case "binary": {
			const n :Binary = cnode as Binary;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			const tmpop = on.body?.op;
			if (!isBinaryOp(tmpop)) {
				throw new Error('invalid node list');
			}
			n.op = tmpop;
			if (on.body?.left !== null && typeof on.body?.left !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpleft = on.body.left === null ? null : c.node[on.body.left];
			if (!(tmpleft === null || isExpr(tmpleft))) {
				throw new Error('invalid node list');
			}
			n.left = tmpleft;
			if (on.body?.right !== null && typeof on.body?.right !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpright = on.body.right === null ? null : c.node[on.body.right];
			if (!(tmpright === null || isExpr(tmpright))) {
				throw new Error('invalid node list');
			}
			n.right = tmpright;
			break;
		}
		case "unary": {
			const n :Unary = cnode as Unary;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			const tmpop = on.body?.op;
			if (!isUnaryOp(tmpop)) {
				throw new Error('invalid node list');
			}
			n.op = tmpop;
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list');
			}
			n.expr = tmpexpr;
			break;
		}
		case "cond": {
			const n :Cond = cnode as Cond;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isExpr(tmpcond))) {
				throw new Error('invalid node list');
			}
			n.cond = tmpcond;
			if (on.body?.then !== null && typeof on.body?.then !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpthen = on.body.then === null ? null : c.node[on.body.then];
			if (!(tmpthen === null || isExpr(tmpthen))) {
				throw new Error('invalid node list');
			}
			n.then = tmpthen;
			const tmpels_loc = on.body?.els_loc;
			if (!isLoc(tmpels_loc)) {
				throw new Error('invalid node list');
			}
			n.els_loc = tmpels_loc;
			if (on.body?.els !== null && typeof on.body?.els !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpels = on.body.els === null ? null : c.node[on.body.els];
			if (!(tmpels === null || isExpr(tmpels))) {
				throw new Error('invalid node list');
			}
			n.els = tmpels;
			break;
		}
		case "ident": {
			const n :Ident = cnode as Ident;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			const tmpident = on.body?.ident;
			if (typeof on.body?.ident !== "string") {
				throw new Error('invalid node list');
			}
			n.ident = on.body.ident;
			const tmpusage = on.body?.usage;
			if (!isIdentUsage(tmpusage)) {
				throw new Error('invalid node list');
			}
			n.usage = tmpusage;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isNode(tmpbase))) {
				throw new Error('invalid node list');
			}
			n.base = tmpbase;
			if (on.body?.scope !== null && typeof on.body?.scope !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpscope = on.body.scope === null ? null : c.scope[on.body.scope];
			if (tmpscope !== null && !isScope(tmpscope)) {
				throw new Error('invalid node list');
			}
			n.scope = tmpscope;
			break;
		}
		case "call": {
			const n :Call = cnode as Call;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			if (on.body?.callee !== null && typeof on.body?.callee !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpcallee = on.body.callee === null ? null : c.node[on.body.callee];
			if (!(tmpcallee === null || isExpr(tmpcallee))) {
				throw new Error('invalid node list');
			}
			n.callee = tmpcallee;
			if (on.body?.raw_arguments !== null && typeof on.body?.raw_arguments !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpraw_arguments = on.body.raw_arguments === null ? null : c.node[on.body.raw_arguments];
			if (!(tmpraw_arguments === null || isExpr(tmpraw_arguments))) {
				throw new Error('invalid node list');
			}
			n.raw_arguments = tmpraw_arguments;
			for (const o of on.body.arguments) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list');
				}
				const tmparguments = c.node[o];
				if (!isExpr(tmparguments)) {
					throw new Error('invalid node list');
				}
				n.arguments.push(tmparguments);
			}
			const tmpend_loc = on.body?.end_loc;
			if (!isLoc(tmpend_loc)) {
				throw new Error('invalid node list');
			}
			n.end_loc = tmpend_loc;
			break;
		}
		case "if": {
			const n :If = cnode as If;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isExpr(tmpcond))) {
				throw new Error('invalid node list');
			}
			n.cond = tmpcond;
			if (on.body?.then !== null && typeof on.body?.then !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpthen = on.body.then === null ? null : c.node[on.body.then];
			if (!(tmpthen === null || isIndentScope(tmpthen))) {
				throw new Error('invalid node list');
			}
			n.then = tmpthen;
			if (on.body?.els !== null && typeof on.body?.els !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpels = on.body.els === null ? null : c.node[on.body.els];
			if (!(tmpels === null || isNode(tmpels))) {
				throw new Error('invalid node list');
			}
			n.els = tmpels;
			break;
		}
		case "member_access": {
			const n :MemberAccess = cnode as MemberAccess;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			if (on.body?.target !== null && typeof on.body?.target !== 'number') {
				throw new Error('invalid node list');
			}
			const tmptarget = on.body.target === null ? null : c.node[on.body.target];
			if (!(tmptarget === null || isExpr(tmptarget))) {
				throw new Error('invalid node list');
			}
			n.target = tmptarget;
			const tmpmember = on.body?.member;
			if (typeof on.body?.member !== "string") {
				throw new Error('invalid node list');
			}
			n.member = on.body.member;
			const tmpmember_loc = on.body?.member_loc;
			if (!isLoc(tmpmember_loc)) {
				throw new Error('invalid node list');
			}
			n.member_loc = tmpmember_loc;
			break;
		}
		case "paren": {
			const n :Paren = cnode as Paren;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list');
			}
			n.expr = tmpexpr;
			const tmpend_loc = on.body?.end_loc;
			if (!isLoc(tmpend_loc)) {
				throw new Error('invalid node list');
			}
			n.end_loc = tmpend_loc;
			break;
		}
		case "index": {
			const n :Index = cnode as Index;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list');
			}
			n.expr = tmpexpr;
			if (on.body?.index !== null && typeof on.body?.index !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpindex = on.body.index === null ? null : c.node[on.body.index];
			if (!(tmpindex === null || isExpr(tmpindex))) {
				throw new Error('invalid node list');
			}
			n.index = tmpindex;
			const tmpend_loc = on.body?.end_loc;
			if (!isLoc(tmpend_loc)) {
				throw new Error('invalid node list');
			}
			n.end_loc = tmpend_loc;
			break;
		}
		case "match": {
			const n :Match = cnode as Match;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isExpr(tmpcond))) {
				throw new Error('invalid node list');
			}
			n.cond = tmpcond;
			for (const o of on.body.branch) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list');
				}
				const tmpbranch = c.node[o];
				n.branch.push(tmpbranch);
			}
			if (on.body?.scope !== null && typeof on.body?.scope !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpscope = on.body.scope === null ? null : c.scope[on.body.scope];
			if (tmpscope !== null && !isScope(tmpscope)) {
				throw new Error('invalid node list');
			}
			n.scope = tmpscope;
			break;
		}
		case "range": {
			const n :Range = cnode as Range;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			const tmpop = on.body?.op;
			if (!isBinaryOp(tmpop)) {
				throw new Error('invalid node list');
			}
			n.op = tmpop;
			if (on.body?.start !== null && typeof on.body?.start !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpstart = on.body.start === null ? null : c.node[on.body.start];
			if (!(tmpstart === null || isExpr(tmpstart))) {
				throw new Error('invalid node list');
			}
			n.start = tmpstart;
			if (on.body?.end !== null && typeof on.body?.end !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpend = on.body.end === null ? null : c.node[on.body.end];
			if (!(tmpend === null || isExpr(tmpend))) {
				throw new Error('invalid node list');
			}
			n.end = tmpend;
			break;
		}
		case "tmp_var": {
			const n :TmpVar = cnode as TmpVar;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			const tmptmp_var = on.body?.tmp_var;
			if (typeof on.body?.tmp_var !== "number") {
				throw new Error('invalid node list');
			}
			n.tmp_var = on.body.tmp_var;
			break;
		}
		case "block_expr": {
			const n :BlockExpr = cnode as BlockExpr;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			for (const o of on.body.calls) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list');
				}
				const tmpcalls = c.node[o];
				n.calls.push(tmpcalls);
			}
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list');
			}
			n.expr = tmpexpr;
			break;
		}
		case "import": {
			const n :Import = cnode as Import;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			const tmppath = on.body?.path;
			if (typeof on.body?.path !== "string") {
				throw new Error('invalid node list');
			}
			n.path = on.body.path;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isCall(tmpbase))) {
				throw new Error('invalid node list');
			}
			n.base = tmpbase;
			if (on.body?.import_desc !== null && typeof on.body?.import_desc !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpimport_desc = on.body.import_desc === null ? null : c.node[on.body.import_desc];
			if (!(tmpimport_desc === null || isProgram(tmpimport_desc))) {
				throw new Error('invalid node list');
			}
			n.import_desc = tmpimport_desc;
			break;
		}
		case "int_literal": {
			const n :IntLiteral = cnode as IntLiteral;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			const tmpvalue = on.body?.value;
			if (typeof on.body?.value !== "string") {
				throw new Error('invalid node list');
			}
			n.value = on.body.value;
			break;
		}
		case "bool_literal": {
			const n :BoolLiteral = cnode as BoolLiteral;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			const tmpvalue = on.body?.value;
			if (typeof on.body?.value !== "boolean") {
				throw new Error('invalid node list');
			}
			n.value = on.body.value;
			break;
		}
		case "str_literal": {
			const n :StrLiteral = cnode as StrLiteral;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			const tmpvalue = on.body?.value;
			if (typeof on.body?.value !== "string") {
				throw new Error('invalid node list');
			}
			n.value = on.body.value;
			break;
		}
		case "input": {
			const n :Input = cnode as Input;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			break;
		}
		case "output": {
			const n :Output = cnode as Output;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			break;
		}
		case "config": {
			const n :Config = cnode as Config;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			break;
		}
		case "loop": {
			const n :Loop = cnode as Loop;
			if (on.body?.init !== null && typeof on.body?.init !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpinit = on.body.init === null ? null : c.node[on.body.init];
			if (!(tmpinit === null || isExpr(tmpinit))) {
				throw new Error('invalid node list');
			}
			n.init = tmpinit;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isExpr(tmpcond))) {
				throw new Error('invalid node list');
			}
			n.cond = tmpcond;
			if (on.body?.step !== null && typeof on.body?.step !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpstep = on.body.step === null ? null : c.node[on.body.step];
			if (!(tmpstep === null || isExpr(tmpstep))) {
				throw new Error('invalid node list');
			}
			n.step = tmpstep;
			if (on.body?.body !== null && typeof on.body?.body !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpbody = on.body.body === null ? null : c.node[on.body.body];
			if (!(tmpbody === null || isIndentScope(tmpbody))) {
				throw new Error('invalid node list');
			}
			n.body = tmpbody;
			break;
		}
		case "indent_scope": {
			const n :IndentScope = cnode as IndentScope;
			for (const o of on.body.elements) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list');
				}
				const tmpelements = c.node[o];
				n.elements.push(tmpelements);
			}
			if (on.body?.scope !== null && typeof on.body?.scope !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpscope = on.body.scope === null ? null : c.scope[on.body.scope];
			if (tmpscope !== null && !isScope(tmpscope)) {
				throw new Error('invalid node list');
			}
			n.scope = tmpscope;
			break;
		}
		case "match_branch": {
			const n :MatchBranch = cnode as MatchBranch;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isExpr(tmpcond))) {
				throw new Error('invalid node list');
			}
			n.cond = tmpcond;
			const tmpsym_loc = on.body?.sym_loc;
			if (!isLoc(tmpsym_loc)) {
				throw new Error('invalid node list');
			}
			n.sym_loc = tmpsym_loc;
			if (on.body?.then !== null && typeof on.body?.then !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpthen = on.body.then === null ? null : c.node[on.body.then];
			if (!(tmpthen === null || isNode(tmpthen))) {
				throw new Error('invalid node list');
			}
			n.then = tmpthen;
			break;
		}
		case "return": {
			const n :Return = cnode as Return;
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list');
			}
			n.expr = tmpexpr;
			break;
		}
		case "break": {
			const n :Break = cnode as Break;
			break;
		}
		case "continue": {
			const n :Continue = cnode as Continue;
			break;
		}
		case "assert": {
			const n :Assert = cnode as Assert;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isBinary(tmpcond))) {
				throw new Error('invalid node list');
			}
			n.cond = tmpcond;
			break;
		}
		case "implicit_yield": {
			const n :ImplicitYield = cnode as ImplicitYield;
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list');
			}
			n.expr = tmpexpr;
			break;
		}
		case "field": {
			const n :Field = cnode as Field;
			if (on.body?.ident !== null && typeof on.body?.ident !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpident = on.body.ident === null ? null : c.node[on.body.ident];
			if (!(tmpident === null || isIdent(tmpident))) {
				throw new Error('invalid node list');
			}
			n.ident = tmpident;
			const tmpcolon_loc = on.body?.colon_loc;
			if (!isLoc(tmpcolon_loc)) {
				throw new Error('invalid node list');
			}
			n.colon_loc = tmpcolon_loc;
			if (on.body?.field_type !== null && typeof on.body?.field_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpfield_type = on.body.field_type === null ? null : c.node[on.body.field_type];
			if (!(tmpfield_type === null || isType(tmpfield_type))) {
				throw new Error('invalid node list');
			}
			n.field_type = tmpfield_type;
			if (on.body?.raw_arguments !== null && typeof on.body?.raw_arguments !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpraw_arguments = on.body.raw_arguments === null ? null : c.node[on.body.raw_arguments];
			if (!(tmpraw_arguments === null || isExpr(tmpraw_arguments))) {
				throw new Error('invalid node list');
			}
			n.raw_arguments = tmpraw_arguments;
			for (const o of on.body.arguments) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list');
				}
				const tmparguments = c.node[o];
				if (!isExpr(tmparguments)) {
					throw new Error('invalid node list');
				}
				n.arguments.push(tmparguments);
			}
			if (on.body?.belong !== null && typeof on.body?.belong !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpbelong = on.body.belong === null ? null : c.node[on.body.belong];
			if (!(tmpbelong === null || isFormat(tmpbelong))) {
				throw new Error('invalid node list');
			}
			n.belong = tmpbelong;
			break;
		}
		case "format": {
			const n :Format = cnode as Format;
			const tmpis_enum = on.body?.is_enum;
			if (typeof on.body?.is_enum !== "boolean") {
				throw new Error('invalid node list');
			}
			n.is_enum = on.body.is_enum;
			if (on.body?.ident !== null && typeof on.body?.ident !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpident = on.body.ident === null ? null : c.node[on.body.ident];
			if (!(tmpident === null || isIdent(tmpident))) {
				throw new Error('invalid node list');
			}
			n.ident = tmpident;
			if (on.body?.body !== null && typeof on.body?.body !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpbody = on.body.body === null ? null : c.node[on.body.body];
			if (!(tmpbody === null || isIndentScope(tmpbody))) {
				throw new Error('invalid node list');
			}
			n.body = tmpbody;
			if (on.body?.belong !== null && typeof on.body?.belong !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpbelong = on.body.belong === null ? null : c.node[on.body.belong];
			if (!(tmpbelong === null || isFormat(tmpbelong))) {
				throw new Error('invalid node list');
			}
			n.belong = tmpbelong;
			if (on.body?.struct_type !== null && typeof on.body?.struct_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpstruct_type = on.body.struct_type === null ? null : c.node[on.body.struct_type];
			if (!(tmpstruct_type === null || isStructType(tmpstruct_type))) {
				throw new Error('invalid node list');
			}
			n.struct_type = tmpstruct_type;
			break;
		}
		case "function": {
			const n :Function = cnode as Function;
			if (on.body?.ident !== null && typeof on.body?.ident !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpident = on.body.ident === null ? null : c.node[on.body.ident];
			if (!(tmpident === null || isIdent(tmpident))) {
				throw new Error('invalid node list');
			}
			n.ident = tmpident;
			for (const o of on.body.parameters) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list');
				}
				const tmpparameters = c.node[o];
				if (!isField(tmpparameters)) {
					throw new Error('invalid node list');
				}
				n.parameters.push(tmpparameters);
			}
			if (on.body?.return_type !== null && typeof on.body?.return_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpreturn_type = on.body.return_type === null ? null : c.node[on.body.return_type];
			if (!(tmpreturn_type === null || isType(tmpreturn_type))) {
				throw new Error('invalid node list');
			}
			n.return_type = tmpreturn_type;
			if (on.body?.belong !== null && typeof on.body?.belong !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpbelong = on.body.belong === null ? null : c.node[on.body.belong];
			if (!(tmpbelong === null || isFormat(tmpbelong))) {
				throw new Error('invalid node list');
			}
			n.belong = tmpbelong;
			if (on.body?.body !== null && typeof on.body?.body !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpbody = on.body.body === null ? null : c.node[on.body.body];
			if (!(tmpbody === null || isIndentScope(tmpbody))) {
				throw new Error('invalid node list');
			}
			n.body = tmpbody;
			if (on.body?.func_type !== null && typeof on.body?.func_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpfunc_type = on.body.func_type === null ? null : c.node[on.body.func_type];
			if (!(tmpfunc_type === null || isFunctionType(tmpfunc_type))) {
				throw new Error('invalid node list');
			}
			n.func_type = tmpfunc_type;
			break;
		}
		case "int_type": {
			const n :IntType = cnode as IntType;
			const tmpbit_size = on.body?.bit_size;
			if (typeof on.body?.bit_size !== "number") {
				throw new Error('invalid node list');
			}
			n.bit_size = on.body.bit_size;
			const tmpendian = on.body?.endian;
			if (!isEndian(tmpendian)) {
				throw new Error('invalid node list');
			}
			n.endian = tmpendian;
			const tmpis_signed = on.body?.is_signed;
			if (typeof on.body?.is_signed !== "boolean") {
				throw new Error('invalid node list');
			}
			n.is_signed = on.body.is_signed;
			break;
		}
		case "ident_type": {
			const n :IdentType = cnode as IdentType;
			if (on.body?.ident !== null && typeof on.body?.ident !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpident = on.body.ident === null ? null : c.node[on.body.ident];
			if (!(tmpident === null || isIdent(tmpident))) {
				throw new Error('invalid node list');
			}
			n.ident = tmpident;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isFormat(tmpbase))) {
				throw new Error('invalid node list');
			}
			n.base = tmpbase;
			break;
		}
		case "int_literal_type": {
			const n :IntLiteralType = cnode as IntLiteralType;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isIntLiteral(tmpbase))) {
				throw new Error('invalid node list');
			}
			n.base = tmpbase;
			break;
		}
		case "str_literal_type": {
			const n :StrLiteralType = cnode as StrLiteralType;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isStrLiteral(tmpbase))) {
				throw new Error('invalid node list');
			}
			n.base = tmpbase;
			break;
		}
		case "void_type": {
			const n :VoidType = cnode as VoidType;
			break;
		}
		case "bool_type": {
			const n :BoolType = cnode as BoolType;
			break;
		}
		case "array_type": {
			const n :ArrayType = cnode as ArrayType;
			const tmpend_loc = on.body?.end_loc;
			if (!isLoc(tmpend_loc)) {
				throw new Error('invalid node list');
			}
			n.end_loc = tmpend_loc;
			if (on.body?.base_type !== null && typeof on.body?.base_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpbase_type = on.body.base_type === null ? null : c.node[on.body.base_type];
			if (!(tmpbase_type === null || isType(tmpbase_type))) {
				throw new Error('invalid node list');
			}
			n.base_type = tmpbase_type;
			if (on.body?.length !== null && typeof on.body?.length !== 'number') {
				throw new Error('invalid node list');
			}
			const tmplength = on.body.length === null ? null : c.node[on.body.length];
			if (!(tmplength === null || isExpr(tmplength))) {
				throw new Error('invalid node list');
			}
			n.length = tmplength;
			break;
		}
		case "function_type": {
			const n :FunctionType = cnode as FunctionType;
			if (on.body?.return_type !== null && typeof on.body?.return_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpreturn_type = on.body.return_type === null ? null : c.node[on.body.return_type];
			if (!(tmpreturn_type === null || isType(tmpreturn_type))) {
				throw new Error('invalid node list');
			}
			n.return_type = tmpreturn_type;
			for (const o of on.body.parameters) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list');
				}
				const tmpparameters = c.node[o];
				if (!isType(tmpparameters)) {
					throw new Error('invalid node list');
				}
				n.parameters.push(tmpparameters);
			}
			break;
		}
		case "struct_type": {
			const n :StructType = cnode as StructType;
			for (const o of on.body.fields) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list');
				}
				const tmpfields = c.node[o];
				if (!isMember(tmpfields)) {
					throw new Error('invalid node list');
				}
				n.fields.push(tmpfields);
			}
			break;
		}
		case "union_type": {
			const n :UnionType = cnode as UnionType;
			for (const o of on.body.fields) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list');
				}
				const tmpfields = c.node[o];
				if (!isStructType(tmpfields)) {
					throw new Error('invalid node list');
				}
				n.fields.push(tmpfields);
			}
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isExpr(tmpbase))) {
				throw new Error('invalid node list');
			}
			n.base = tmpbase;
			break;
		}
		case "cast": {
			const n :Cast = cnode as Cast;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list');
			}
			n.expr_type = tmpexpr_type;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isCall(tmpbase))) {
				throw new Error('invalid node list');
			}
			n.base = tmpbase;
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list');
			}
			n.expr = tmpexpr;
			break;
		}
		case "comment": {
			const n :Comment = cnode as Comment;
			const tmpcomment = on.body?.comment;
			if (typeof on.body?.comment !== "string") {
				throw new Error('invalid node list');
			}
			n.comment = on.body.comment;
			break;
		}
		case "comment_group": {
			const n :CommentGroup = cnode as CommentGroup;
			for (const o of on.body.comments) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list');
				}
				const tmpcomments = c.node[o];
				if (!isComment(tmpcomments)) {
					throw new Error('invalid node list');
				}
				n.comments.push(tmpcomments);
			}
			break;
		}
		}
	}
	for (let i = 0; i < o.scope.length; i++) {
		const os = o.scope[i];
		const cscope = c.scope[i];
		cscope.prev = os.prev === null ? null : c.scope[os.prev];
		cscope.next = os.next === null ? null : c.scope[os.next];
		cscope.branch = os.branch === null ? null : c.scope[os.branch];
		cscope.ident = os.ident.map((o: any) => {
			if (typeof o !== 'number') {
				throw new Error('invalid node list');
			}
			const c_node = c.node[o];
			if(!isIdent(c_node)) {
				throw new Error('invalid node list');
			}
			return c_node;
		})
	}
	const root = c.node[0];
	if (!isProgram(root)) {
		throw new Error('invalid node list');
	}
	return root;
}

export interface AstFile {
	files :string[];
	ast :Ast | null;
	error :SrcError | null
}

export function isAstFile(obj: any): obj is AstFile {
	return obj && typeof obj === 'object' && Array.isArray(obj?.files) && (obj?.ast === null || isAst(obj?.ast)) && (obj?.error === null || isSrcError(obj?.error));
}

export interface TokenFile {
	files :string[];
	tokens :Token[] | null;
	error :SrcError | null
}

export function isTokenFile(obj: any): obj is TokenFile {
	return obj && typeof obj === 'object' && Array.isArray(obj?.files) && (obj?.tokens === null || Array.isArray(obj?.tokens)) && (obj?.error === null || isSrcError(obj?.error));
}

export type VisitFn<T> = (f: VisitFn<T>, arg: T) => void;export function walk(node: Node, fn: VisitFn<Node>) {
	switch (node.node_type) {
		case "program": {
			if (!isProgram(node)) {
				break;
			}
			const n :Program = node as Program;
			if (n.struct_type !== null) {
				fn(fn,n.struct_type);
			}
			for (const e of n.elements) {
				fn(fn,e);
			}
			break;
		}
		case "binary": {
			if (!isBinary(node)) {
				break;
			}
			const n :Binary = node as Binary;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			if (n.left !== null) {
				fn(fn,n.left);
			}
			if (n.right !== null) {
				fn(fn,n.right);
			}
			break;
		}
		case "unary": {
			if (!isUnary(node)) {
				break;
			}
			const n :Unary = node as Unary;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			if (n.expr !== null) {
				fn(fn,n.expr);
			}
			break;
		}
		case "cond": {
			if (!isCond(node)) {
				break;
			}
			const n :Cond = node as Cond;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			if (n.cond !== null) {
				fn(fn,n.cond);
			}
			if (n.then !== null) {
				fn(fn,n.then);
			}
			if (n.els !== null) {
				fn(fn,n.els);
			}
			break;
		}
		case "ident": {
			if (!isIdent(node)) {
				break;
			}
			const n :Ident = node as Ident;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			break;
		}
		case "call": {
			if (!isCall(node)) {
				break;
			}
			const n :Call = node as Call;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			if (n.callee !== null) {
				fn(fn,n.callee);
			}
			if (n.raw_arguments !== null) {
				fn(fn,n.raw_arguments);
			}
			for (const e of n.arguments) {
				fn(fn,e);
			}
			break;
		}
		case "if": {
			if (!isIf(node)) {
				break;
			}
			const n :If = node as If;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			if (n.cond !== null) {
				fn(fn,n.cond);
			}
			if (n.then !== null) {
				fn(fn,n.then);
			}
			if (n.els !== null) {
				fn(fn,n.els);
			}
			break;
		}
		case "member_access": {
			if (!isMemberAccess(node)) {
				break;
			}
			const n :MemberAccess = node as MemberAccess;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			if (n.target !== null) {
				fn(fn,n.target);
			}
			break;
		}
		case "paren": {
			if (!isParen(node)) {
				break;
			}
			const n :Paren = node as Paren;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			if (n.expr !== null) {
				fn(fn,n.expr);
			}
			break;
		}
		case "index": {
			if (!isIndex(node)) {
				break;
			}
			const n :Index = node as Index;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			if (n.expr !== null) {
				fn(fn,n.expr);
			}
			if (n.index !== null) {
				fn(fn,n.index);
			}
			break;
		}
		case "match": {
			if (!isMatch(node)) {
				break;
			}
			const n :Match = node as Match;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			if (n.cond !== null) {
				fn(fn,n.cond);
			}
			for (const e of n.branch) {
				fn(fn,e);
			}
			break;
		}
		case "range": {
			if (!isRange(node)) {
				break;
			}
			const n :Range = node as Range;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			if (n.start !== null) {
				fn(fn,n.start);
			}
			if (n.end !== null) {
				fn(fn,n.end);
			}
			break;
		}
		case "tmp_var": {
			if (!isTmpVar(node)) {
				break;
			}
			const n :TmpVar = node as TmpVar;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			break;
		}
		case "block_expr": {
			if (!isBlockExpr(node)) {
				break;
			}
			const n :BlockExpr = node as BlockExpr;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			for (const e of n.calls) {
				fn(fn,e);
			}
			if (n.expr !== null) {
				fn(fn,n.expr);
			}
			break;
		}
		case "import": {
			if (!isImport(node)) {
				break;
			}
			const n :Import = node as Import;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			if (n.base !== null) {
				fn(fn,n.base);
			}
			if (n.import_desc !== null) {
				fn(fn,n.import_desc);
			}
			break;
		}
		case "int_literal": {
			if (!isIntLiteral(node)) {
				break;
			}
			const n :IntLiteral = node as IntLiteral;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			break;
		}
		case "bool_literal": {
			if (!isBoolLiteral(node)) {
				break;
			}
			const n :BoolLiteral = node as BoolLiteral;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			break;
		}
		case "str_literal": {
			if (!isStrLiteral(node)) {
				break;
			}
			const n :StrLiteral = node as StrLiteral;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			break;
		}
		case "input": {
			if (!isInput(node)) {
				break;
			}
			const n :Input = node as Input;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			break;
		}
		case "output": {
			if (!isOutput(node)) {
				break;
			}
			const n :Output = node as Output;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			break;
		}
		case "config": {
			if (!isConfig(node)) {
				break;
			}
			const n :Config = node as Config;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			break;
		}
		case "loop": {
			if (!isLoop(node)) {
				break;
			}
			const n :Loop = node as Loop;
			if (n.init !== null) {
				fn(fn,n.init);
			}
			if (n.cond !== null) {
				fn(fn,n.cond);
			}
			if (n.step !== null) {
				fn(fn,n.step);
			}
			if (n.body !== null) {
				fn(fn,n.body);
			}
			break;
		}
		case "indent_scope": {
			if (!isIndentScope(node)) {
				break;
			}
			const n :IndentScope = node as IndentScope;
			for (const e of n.elements) {
				fn(fn,e);
			}
			break;
		}
		case "match_branch": {
			if (!isMatchBranch(node)) {
				break;
			}
			const n :MatchBranch = node as MatchBranch;
			if (n.cond !== null) {
				fn(fn,n.cond);
			}
			if (n.then !== null) {
				fn(fn,n.then);
			}
			break;
		}
		case "return": {
			if (!isReturn(node)) {
				break;
			}
			const n :Return = node as Return;
			if (n.expr !== null) {
				fn(fn,n.expr);
			}
			break;
		}
		case "break": {
			if (!isBreak(node)) {
				break;
			}
			const n :Break = node as Break;
			break;
		}
		case "continue": {
			if (!isContinue(node)) {
				break;
			}
			const n :Continue = node as Continue;
			break;
		}
		case "assert": {
			if (!isAssert(node)) {
				break;
			}
			const n :Assert = node as Assert;
			if (n.cond !== null) {
				fn(fn,n.cond);
			}
			break;
		}
		case "implicit_yield": {
			if (!isImplicitYield(node)) {
				break;
			}
			const n :ImplicitYield = node as ImplicitYield;
			if (n.expr !== null) {
				fn(fn,n.expr);
			}
			break;
		}
		case "field": {
			if (!isField(node)) {
				break;
			}
			const n :Field = node as Field;
			if (n.ident !== null) {
				fn(fn,n.ident);
			}
			if (n.field_type !== null) {
				fn(fn,n.field_type);
			}
			if (n.raw_arguments !== null) {
				fn(fn,n.raw_arguments);
			}
			for (const e of n.arguments) {
				fn(fn,e);
			}
			break;
		}
		case "format": {
			if (!isFormat(node)) {
				break;
			}
			const n :Format = node as Format;
			if (n.ident !== null) {
				fn(fn,n.ident);
			}
			if (n.body !== null) {
				fn(fn,n.body);
			}
			if (n.struct_type !== null) {
				fn(fn,n.struct_type);
			}
			break;
		}
		case "function": {
			if (!isFunction(node)) {
				break;
			}
			const n :Function = node as Function;
			if (n.ident !== null) {
				fn(fn,n.ident);
			}
			for (const e of n.parameters) {
				fn(fn,e);
			}
			if (n.return_type !== null) {
				fn(fn,n.return_type);
			}
			if (n.body !== null) {
				fn(fn,n.body);
			}
			if (n.func_type !== null) {
				fn(fn,n.func_type);
			}
			break;
		}
		case "int_type": {
			if (!isIntType(node)) {
				break;
			}
			const n :IntType = node as IntType;
			break;
		}
		case "ident_type": {
			if (!isIdentType(node)) {
				break;
			}
			const n :IdentType = node as IdentType;
			if (n.ident !== null) {
				fn(fn,n.ident);
			}
			break;
		}
		case "int_literal_type": {
			if (!isIntLiteralType(node)) {
				break;
			}
			const n :IntLiteralType = node as IntLiteralType;
			break;
		}
		case "str_literal_type": {
			if (!isStrLiteralType(node)) {
				break;
			}
			const n :StrLiteralType = node as StrLiteralType;
			break;
		}
		case "void_type": {
			if (!isVoidType(node)) {
				break;
			}
			const n :VoidType = node as VoidType;
			break;
		}
		case "bool_type": {
			if (!isBoolType(node)) {
				break;
			}
			const n :BoolType = node as BoolType;
			break;
		}
		case "array_type": {
			if (!isArrayType(node)) {
				break;
			}
			const n :ArrayType = node as ArrayType;
			if (n.base_type !== null) {
				fn(fn,n.base_type);
			}
			if (n.length !== null) {
				fn(fn,n.length);
			}
			break;
		}
		case "function_type": {
			if (!isFunctionType(node)) {
				break;
			}
			const n :FunctionType = node as FunctionType;
			if (n.return_type !== null) {
				fn(fn,n.return_type);
			}
			for (const e of n.parameters) {
				fn(fn,e);
			}
			break;
		}
		case "struct_type": {
			if (!isStructType(node)) {
				break;
			}
			const n :StructType = node as StructType;
			for (const e of n.fields) {
				fn(fn,e);
			}
			break;
		}
		case "union_type": {
			if (!isUnionType(node)) {
				break;
			}
			const n :UnionType = node as UnionType;
			for (const e of n.fields) {
				fn(fn,e);
			}
			break;
		}
		case "cast": {
			if (!isCast(node)) {
				break;
			}
			const n :Cast = node as Cast;
			if (n.expr_type !== null) {
				fn(fn,n.expr_type);
			}
			if (n.base !== null) {
				fn(fn,n.base);
			}
			if (n.expr !== null) {
				fn(fn,n.expr);
			}
			break;
		}
		case "comment": {
			if (!isComment(node)) {
				break;
			}
			const n :Comment = node as Comment;
			break;
		}
		case "comment_group": {
			if (!isCommentGroup(node)) {
				break;
			}
			const n :CommentGroup = node as CommentGroup;
			for (const e of n.comments) {
				fn(fn,e);
			}
			break;
		}
	}
	return true;
}

}
