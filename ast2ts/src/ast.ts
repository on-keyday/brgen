// Code generated by gen_ast2ts; DO NOT EDIT.

export namespace ast2ts {

export type NodeType = "program" | "comment" | "comment_group" | "expr" | "binary" | "unary" | "cond" | "ident" | "call" | "if" | "member_access" | "paren" | "index" | "match" | "range" | "tmp_var" | "block_expr" | "import" | "cast" | "available" | "stmt" | "loop" | "indent_block" | "match_branch" | "union_candidate" | "return" | "break" | "continue" | "assert" | "implicit_yield" | "type" | "int_type" | "ident_type" | "int_literal_type" | "str_literal_type" | "void_type" | "bool_type" | "array_type" | "function_type" | "struct_type" | "struct_union_type" | "union_type" | "range_type" | "enum_type" | "literal" | "int_literal" | "bool_literal" | "str_literal" | "input" | "output" | "config" | "member" | "field" | "format" | "state" | "enum" | "enum_member" | "function" | "builtin_function";

export function isNodeType(obj: any): obj is NodeType {
	return obj && typeof obj === 'string' && (obj === "program" || obj === "comment" || obj === "comment_group" || obj === "expr" || obj === "binary" || obj === "unary" || obj === "cond" || obj === "ident" || obj === "call" || obj === "if" || obj === "member_access" || obj === "paren" || obj === "index" || obj === "match" || obj === "range" || obj === "tmp_var" || obj === "block_expr" || obj === "import" || obj === "cast" || obj === "available" || obj === "stmt" || obj === "loop" || obj === "indent_block" || obj === "match_branch" || obj === "union_candidate" || obj === "return" || obj === "break" || obj === "continue" || obj === "assert" || obj === "implicit_yield" || obj === "type" || obj === "int_type" || obj === "ident_type" || obj === "int_literal_type" || obj === "str_literal_type" || obj === "void_type" || obj === "bool_type" || obj === "array_type" || obj === "function_type" || obj === "struct_type" || obj === "struct_union_type" || obj === "union_type" || obj === "range_type" || obj === "enum_type" || obj === "literal" || obj === "int_literal" || obj === "bool_literal" || obj === "str_literal" || obj === "input" || obj === "output" || obj === "config" || obj === "member" || obj === "field" || obj === "format" || obj === "state" || obj === "enum" || obj === "enum_member" || obj === "function" || obj === "builtin_function")
}

export enum UnaryOp {
	not = "!",
	minus_sign = "-",
};

export function isUnaryOp(obj: any): obj is UnaryOp {
	return obj && typeof obj === 'string' && (obj === "!" || obj === "-")
}

export enum BinaryOp {
	mul = "*",
	div = "/",
	mod = "%",
	left_arithmetic_shift = "<<<",
	right_arithmetic_shift = ">>>",
	left_logical_shift = "<<",
	right_logical_shift = ">>",
	bit_and = "&",
	add = "+",
	sub = "-",
	bit_or = "|",
	bit_xor = "^",
	equal = "==",
	not_equal = "!=",
	less = "<",
	less_or_eq = "<=",
	grater = ">",
	grater_or_eq = ">=",
	logical_and = "&&",
	logical_or = "||",
	cond_op_1 = "?",
	cond_op_2 = ":",
	range_exclusive = "..",
	range_inclusive = "..=",
	assign = "=",
	define_assign = ":=",
	const_assign = "::=",
	add_assign = "+=",
	sub_assign = "-=",
	mul_assign = "*=",
	div_assign = "/=",
	mod_assign = "%=",
	left_shift_assign = "<<=",
	right_shift_assign = ">>=",
	bit_and_assign = "&=",
	bit_or_assign = "|=",
	bit_xor_assign = "^=",
	comma = ",",
};

export function isBinaryOp(obj: any): obj is BinaryOp {
	return obj && typeof obj === 'string' && (obj === "*" || obj === "/" || obj === "%" || obj === "<<<" || obj === ">>>" || obj === "<<" || obj === ">>" || obj === "&" || obj === "+" || obj === "-" || obj === "|" || obj === "^" || obj === "==" || obj === "!=" || obj === "<" || obj === "<=" || obj === ">" || obj === ">=" || obj === "&&" || obj === "||" || obj === "?" || obj === ":" || obj === ".." || obj === "..=" || obj === "=" || obj === ":=" || obj === "::=" || obj === "+=" || obj === "-=" || obj === "*=" || obj === "/=" || obj === "%=" || obj === "<<=" || obj === ">>=" || obj === "&=" || obj === "|=" || obj === "^=" || obj === ",")
}

export enum IdentUsage {
	unknown = "unknown",
	reference = "reference",
	define_variable = "define_variable",
	define_const = "define_const",
	define_field = "define_field",
	define_format = "define_format",
	define_state = "define_state",
	define_enum = "define_enum",
	define_enum_member = "define_enum_member",
	define_fn = "define_fn",
	define_cast_fn = "define_cast_fn",
	define_arg = "define_arg",
	reference_type = "reference_type",
	reference_member = "reference_member",
	maybe_type = "maybe_type",
	reference_builtin_fn = "reference_builtin_fn",
};

export function isIdentUsage(obj: any): obj is IdentUsage {
	return obj && typeof obj === 'string' && (obj === "unknown" || obj === "reference" || obj === "define_variable" || obj === "define_const" || obj === "define_field" || obj === "define_format" || obj === "define_state" || obj === "define_enum" || obj === "define_enum_member" || obj === "define_fn" || obj === "define_cast_fn" || obj === "define_arg" || obj === "reference_type" || obj === "reference_member" || obj === "maybe_type" || obj === "reference_builtin_fn")
}

export enum Endian {
	unspec = "unspec",
	big = "big",
	little = "little",
};

export function isEndian(obj: any): obj is Endian {
	return obj && typeof obj === 'string' && (obj === "unspec" || obj === "big" || obj === "little")
}

export enum TokenTag {
	indent = "indent",
	space = "space",
	line = "line",
	punct = "punct",
	int_literal = "int_literal",
	bool_literal = "bool_literal",
	str_literal = "str_literal",
	keyword = "keyword",
	ident = "ident",
	comment = "comment",
	error = "error",
	unknown = "unknown",
};

export function isTokenTag(obj: any): obj is TokenTag {
	return obj && typeof obj === 'string' && (obj === "indent" || obj === "space" || obj === "line" || obj === "punct" || obj === "int_literal" || obj === "bool_literal" || obj === "str_literal" || obj === "keyword" || obj === "ident" || obj === "comment" || obj === "error" || obj === "unknown")
}

export enum ConstantLevel {
	unknown = "unknown",
	constant = "constant",
	const_variable = "const_variable",
	variable = "variable",
};

export function isConstantLevel(obj: any): obj is ConstantLevel {
	return obj && typeof obj === 'string' && (obj === "unknown" || obj === "constant" || obj === "const_variable" || obj === "variable")
}

export enum BitAlignment {
	byte_aligned = "byte_aligned",
	bit_1 = "bit_1",
	bit_2 = "bit_2",
	bit_3 = "bit_3",
	bit_4 = "bit_4",
	bit_5 = "bit_5",
	bit_6 = "bit_6",
	bit_7 = "bit_7",
	not_target = "not_target",
	not_decidable = "not_decidable",
};

export function isBitAlignment(obj: any): obj is BitAlignment {
	return obj && typeof obj === 'string' && (obj === "byte_aligned" || obj === "bit_1" || obj === "bit_2" || obj === "bit_3" || obj === "bit_4" || obj === "bit_5" || obj === "bit_6" || obj === "bit_7" || obj === "not_target" || obj === "not_decidable")
}

export interface Node {
	readonly node_type: NodeType;
	loc: Loc;
}

export function isNode(obj: any): obj is Node {
	if (isProgram(obj)) return true;
	if (isComment(obj)) return true;
	if (isCommentGroup(obj)) return true;
	if (isBinary(obj)) return true;
	if (isUnary(obj)) return true;
	if (isCond(obj)) return true;
	if (isIdent(obj)) return true;
	if (isCall(obj)) return true;
	if (isIf(obj)) return true;
	if (isMemberAccess(obj)) return true;
	if (isParen(obj)) return true;
	if (isIndex(obj)) return true;
	if (isMatch(obj)) return true;
	if (isRange(obj)) return true;
	if (isTmpVar(obj)) return true;
	if (isBlockExpr(obj)) return true;
	if (isImport(obj)) return true;
	if (isCast(obj)) return true;
	if (isAvailable(obj)) return true;
	if (isLoop(obj)) return true;
	if (isIndentBlock(obj)) return true;
	if (isMatchBranch(obj)) return true;
	if (isUnionCandidate(obj)) return true;
	if (isReturn(obj)) return true;
	if (isBreak(obj)) return true;
	if (isContinue(obj)) return true;
	if (isAssert(obj)) return true;
	if (isImplicitYield(obj)) return true;
	if (isIntType(obj)) return true;
	if (isIdentType(obj)) return true;
	if (isIntLiteralType(obj)) return true;
	if (isStrLiteralType(obj)) return true;
	if (isVoidType(obj)) return true;
	if (isBoolType(obj)) return true;
	if (isArrayType(obj)) return true;
	if (isFunctionType(obj)) return true;
	if (isStructType(obj)) return true;
	if (isStructUnionType(obj)) return true;
	if (isUnionType(obj)) return true;
	if (isRangeType(obj)) return true;
	if (isEnumType(obj)) return true;
	if (isIntLiteral(obj)) return true;
	if (isBoolLiteral(obj)) return true;
	if (isStrLiteral(obj)) return true;
	if (isInput(obj)) return true;
	if (isOutput(obj)) return true;
	if (isConfig(obj)) return true;
	if (isField(obj)) return true;
	if (isFormat(obj)) return true;
	if (isState(obj)) return true;
	if (isEnum(obj)) return true;
	if (isEnumMember(obj)) return true;
	if (isFunction(obj)) return true;
	if (isBuiltinFunction(obj)) return true;
	return false;
}

export interface Expr extends Node {
	expr_type: Type|null;
	constant_level: ConstantLevel;
}

export function isExpr(obj: any): obj is Expr {
	if (isBinary(obj)) return true;
	if (isUnary(obj)) return true;
	if (isCond(obj)) return true;
	if (isIdent(obj)) return true;
	if (isCall(obj)) return true;
	if (isIf(obj)) return true;
	if (isMemberAccess(obj)) return true;
	if (isParen(obj)) return true;
	if (isIndex(obj)) return true;
	if (isMatch(obj)) return true;
	if (isRange(obj)) return true;
	if (isTmpVar(obj)) return true;
	if (isBlockExpr(obj)) return true;
	if (isImport(obj)) return true;
	if (isCast(obj)) return true;
	if (isAvailable(obj)) return true;
	if (isIntLiteral(obj)) return true;
	if (isBoolLiteral(obj)) return true;
	if (isStrLiteral(obj)) return true;
	if (isInput(obj)) return true;
	if (isOutput(obj)) return true;
	if (isConfig(obj)) return true;
	return false;
}

export interface Stmt extends Node {
}

export function isStmt(obj: any): obj is Stmt {
	if (isLoop(obj)) return true;
	if (isIndentBlock(obj)) return true;
	if (isMatchBranch(obj)) return true;
	if (isUnionCandidate(obj)) return true;
	if (isReturn(obj)) return true;
	if (isBreak(obj)) return true;
	if (isContinue(obj)) return true;
	if (isAssert(obj)) return true;
	if (isImplicitYield(obj)) return true;
	if (isField(obj)) return true;
	if (isFormat(obj)) return true;
	if (isState(obj)) return true;
	if (isEnum(obj)) return true;
	if (isEnumMember(obj)) return true;
	if (isFunction(obj)) return true;
	if (isBuiltinFunction(obj)) return true;
	return false;
}

export interface Type extends Node {
	is_explicit: boolean;
	is_int_set: boolean;
	bit_alignment: BitAlignment;
	bit_size: number;
}

export function isType(obj: any): obj is Type {
	if (isIntType(obj)) return true;
	if (isIdentType(obj)) return true;
	if (isIntLiteralType(obj)) return true;
	if (isStrLiteralType(obj)) return true;
	if (isVoidType(obj)) return true;
	if (isBoolType(obj)) return true;
	if (isArrayType(obj)) return true;
	if (isFunctionType(obj)) return true;
	if (isStructType(obj)) return true;
	if (isStructUnionType(obj)) return true;
	if (isUnionType(obj)) return true;
	if (isRangeType(obj)) return true;
	if (isEnumType(obj)) return true;
	return false;
}

export interface Literal extends Expr {
}

export function isLiteral(obj: any): obj is Literal {
	if (isIntLiteral(obj)) return true;
	if (isBoolLiteral(obj)) return true;
	if (isStrLiteral(obj)) return true;
	if (isInput(obj)) return true;
	if (isOutput(obj)) return true;
	if (isConfig(obj)) return true;
	return false;
}

export interface Member extends Stmt {
	belong: Member|null;
	belong_struct: StructType|null;
	ident: Ident|null;
}

export function isMember(obj: any): obj is Member {
	if (isField(obj)) return true;
	if (isFormat(obj)) return true;
	if (isState(obj)) return true;
	if (isEnum(obj)) return true;
	if (isEnumMember(obj)) return true;
	if (isFunction(obj)) return true;
	if (isBuiltinFunction(obj)) return true;
	return false;
}

export interface Program extends Node {
	struct_type: StructType|null;
	elements: Node[];
	global_scope: Scope|null;
}

export function isProgram(obj: any): obj is Program {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "program"
}

export interface Comment extends Node {
	comment: string;
}

export function isComment(obj: any): obj is Comment {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "comment"
}

export interface CommentGroup extends Node {
	comments: Comment[];
}

export function isCommentGroup(obj: any): obj is CommentGroup {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "comment_group"
}

export interface Binary extends Expr {
	op: BinaryOp;
	left: Expr|null;
	right: Expr|null;
}

export function isBinary(obj: any): obj is Binary {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "binary"
}

export interface Unary extends Expr {
	op: UnaryOp;
	expr: Expr|null;
}

export function isUnary(obj: any): obj is Unary {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "unary"
}

export interface Cond extends Expr {
	cond: Expr|null;
	then: Expr|null;
	els_loc: Loc;
	els: Expr|null;
}

export function isCond(obj: any): obj is Cond {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "cond"
}

export interface Ident extends Expr {
	ident: string;
	usage: IdentUsage;
	base: Node|null;
	scope: Scope|null;
}

export function isIdent(obj: any): obj is Ident {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "ident"
}

export interface Call extends Expr {
	callee: Expr|null;
	raw_arguments: Expr|null;
	arguments: Expr[];
	end_loc: Loc;
}

export function isCall(obj: any): obj is Call {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "call"
}

export interface If extends Expr {
	cond_scope: Scope|null;
	cond: Expr|null;
	then: IndentBlock|null;
	els: Node|null;
}

export function isIf(obj: any): obj is If {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "if"
}

export interface MemberAccess extends Expr {
	target: Expr|null;
	member: Ident|null;
	base: Node|null;
}

export function isMemberAccess(obj: any): obj is MemberAccess {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "member_access"
}

export interface Paren extends Expr {
	expr: Expr|null;
	end_loc: Loc;
}

export function isParen(obj: any): obj is Paren {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "paren"
}

export interface Index extends Expr {
	expr: Expr|null;
	index: Expr|null;
	end_loc: Loc;
}

export function isIndex(obj: any): obj is Index {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "index"
}

export interface Match extends Expr {
	cond_scope: Scope|null;
	cond: Expr|null;
	branch: Node[];
}

export function isMatch(obj: any): obj is Match {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "match"
}

export interface Range extends Expr {
	op: BinaryOp;
	start: Expr|null;
	end: Expr|null;
}

export function isRange(obj: any): obj is Range {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "range"
}

export interface TmpVar extends Expr {
	tmp_var: number;
}

export function isTmpVar(obj: any): obj is TmpVar {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "tmp_var"
}

export interface BlockExpr extends Expr {
	calls: Node[];
	expr: Expr|null;
}

export function isBlockExpr(obj: any): obj is BlockExpr {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "block_expr"
}

export interface Import extends Expr {
	path: string;
	base: Call|null;
	import_desc: Program|null;
}

export function isImport(obj: any): obj is Import {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "import"
}

export interface Cast extends Expr {
	base: Call|null;
	expr: Expr|null;
}

export function isCast(obj: any): obj is Cast {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "cast"
}

export interface Available extends Expr {
	base: Call|null;
	target: Ident|null;
}

export function isAvailable(obj: any): obj is Available {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "available"
}

export interface Loop extends Stmt {
	cond_scope: Scope|null;
	init: Expr|null;
	cond: Expr|null;
	step: Expr|null;
	body: IndentBlock|null;
}

export function isLoop(obj: any): obj is Loop {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "loop"
}

export interface IndentBlock extends Stmt {
	struct_type: StructType|null;
	elements: Node[];
	scope: Scope|null;
}

export function isIndentBlock(obj: any): obj is IndentBlock {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "indent_block"
}

export interface MatchBranch extends Stmt {
	cond: Expr|null;
	sym_loc: Loc;
	then: Node|null;
}

export function isMatchBranch(obj: any): obj is MatchBranch {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "match_branch"
}

export interface UnionCandidate extends Stmt {
	cond: Expr|null;
	field: Field|null;
}

export function isUnionCandidate(obj: any): obj is UnionCandidate {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "union_candidate"
}

export interface Return extends Stmt {
	expr: Expr|null;
}

export function isReturn(obj: any): obj is Return {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "return"
}

export interface Break extends Stmt {
}

export function isBreak(obj: any): obj is Break {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "break"
}

export interface Continue extends Stmt {
}

export function isContinue(obj: any): obj is Continue {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "continue"
}

export interface Assert extends Stmt {
	cond: Binary|null;
}

export function isAssert(obj: any): obj is Assert {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "assert"
}

export interface ImplicitYield extends Stmt {
	expr: Expr|null;
}

export function isImplicitYield(obj: any): obj is ImplicitYield {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "implicit_yield"
}

export interface IntType extends Type {
	endian: Endian;
	is_signed: boolean;
	is_common_supported: boolean;
}

export function isIntType(obj: any): obj is IntType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "int_type"
}

export interface IdentType extends Type {
	ident: Ident|null;
	base: Type|null;
}

export function isIdentType(obj: any): obj is IdentType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "ident_type"
}

export interface IntLiteralType extends Type {
	base: IntLiteral|null;
}

export function isIntLiteralType(obj: any): obj is IntLiteralType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "int_literal_type"
}

export interface StrLiteralType extends Type {
	base: StrLiteral|null;
}

export function isStrLiteralType(obj: any): obj is StrLiteralType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "str_literal_type"
}

export interface VoidType extends Type {
}

export function isVoidType(obj: any): obj is VoidType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "void_type"
}

export interface BoolType extends Type {
}

export function isBoolType(obj: any): obj is BoolType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "bool_type"
}

export interface ArrayType extends Type {
	end_loc: Loc;
	base_type: Type|null;
	length: Expr|null;
	length_value: number;
	has_const_length: boolean;
}

export function isArrayType(obj: any): obj is ArrayType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "array_type"
}

export interface FunctionType extends Type {
	return_type: Type|null;
	parameters: Type[];
}

export function isFunctionType(obj: any): obj is FunctionType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "function_type"
}

export interface StructType extends Type {
	fields: Member[];
	base: Node|null;
	recursive: boolean;
}

export function isStructType(obj: any): obj is StructType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "struct_type"
}

export interface StructUnionType extends Type {
	structs: StructType[];
	base: Expr|null;
	union_fields: Field[];
}

export function isStructUnionType(obj: any): obj is StructUnionType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "struct_union_type"
}

export interface UnionType extends Type {
	cond: Expr|null;
	candidates: UnionCandidate[];
	base_type: StructUnionType|null;
	common_type: Type|null;
}

export function isUnionType(obj: any): obj is UnionType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "union_type"
}

export interface RangeType extends Type {
	base_type: Type|null;
	range: Range|null;
}

export function isRangeType(obj: any): obj is RangeType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "range_type"
}

export interface EnumType extends Type {
	base: Enum|null;
}

export function isEnumType(obj: any): obj is EnumType {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "enum_type"
}

export interface IntLiteral extends Literal {
	value: string;
}

export function isIntLiteral(obj: any): obj is IntLiteral {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "int_literal"
}

export interface BoolLiteral extends Literal {
	value: boolean;
}

export function isBoolLiteral(obj: any): obj is BoolLiteral {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "bool_literal"
}

export interface StrLiteral extends Literal {
	value: string;
}

export function isStrLiteral(obj: any): obj is StrLiteral {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "str_literal"
}

export interface Input extends Literal {
}

export function isInput(obj: any): obj is Input {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "input"
}

export interface Output extends Literal {
}

export function isOutput(obj: any): obj is Output {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "output"
}

export interface Config extends Literal {
}

export function isConfig(obj: any): obj is Config {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "config"
}

export interface Field extends Member {
	colon_loc: Loc;
	field_type: Type|null;
	raw_arguments: Expr|null;
	arguments: Expr[];
	bit_alignment: BitAlignment;
}

export function isField(obj: any): obj is Field {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "field"
}

export interface Format extends Member {
	body: IndentBlock|null;
}

export function isFormat(obj: any): obj is Format {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "format"
}

export interface State extends Member {
	body: IndentBlock|null;
}

export function isState(obj: any): obj is State {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "state"
}

export interface Enum extends Member {
	scope: Scope|null;
	colon_loc: Loc;
	base_type: Type|null;
	members: EnumMember[];
	enum_type: EnumType|null;
}

export function isEnum(obj: any): obj is Enum {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "enum"
}

export interface EnumMember extends Member {
	expr: Expr|null;
}

export function isEnumMember(obj: any): obj is EnumMember {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "enum_member"
}

export interface Function extends Member {
	parameters: Field[];
	return_type: Type|null;
	body: IndentBlock|null;
	func_type: FunctionType|null;
	is_cast: boolean;
	cast_loc: Loc;
}

export function isFunction(obj: any): obj is Function {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "function"
}

export interface BuiltinFunction extends Member {
	func_type: FunctionType|null;
}

export function isBuiltinFunction(obj: any): obj is BuiltinFunction {
	return obj && typeof obj === 'object' && typeof obj?.node_type === 'string' && obj.node_type === "builtin_function"
}

export interface Scope {
	prev: Scope|null;
	next: Scope|null;
	branch: Scope|null;
	ident: Ident[];
	owner: Node|null;
	branch_root: boolean;
}

export function isScope(obj: any): obj is Scope {
	return obj && typeof obj === 'object' && typeof obj?.prev === 'object' && typeof obj?.next === 'object' && typeof obj?.branch === 'object' && Array.isArray(obj?.ident) && (obj?.owner === null || isNode(obj?.owner)) && typeof obj?.branch_root === "boolean"
}

export interface Pos {
	begin: number;
	end: number;
}

export function isPos(obj: any): obj is Pos {
	return obj && typeof obj === 'object' && typeof obj?.begin === "number" && typeof obj?.end === "number"
}

export interface Loc {
	pos: Pos;
	file: number;
	line: number;
	col: number;
}

export function isLoc(obj: any): obj is Loc {
	return obj && typeof obj === 'object' && isPos(obj?.pos) && typeof obj?.file === "number" && typeof obj?.line === "number" && typeof obj?.col === "number"
}

export interface Token {
	tag: TokenTag;
	token: string;
	loc: Loc;
}

export function isToken(obj: any): obj is Token {
	return obj && typeof obj === 'object' && isTokenTag(obj?.tag) && typeof obj?.token === "string" && isLoc(obj?.loc)
}

export interface RawScope {
	prev: number|null;
	next: number|null;
	branch: number|null;
	ident: number[];
	owner: number|null;
	branch_root: boolean;
}

export function isRawScope(obj: any): obj is RawScope {
	return obj && typeof obj === 'object' && (obj?.prev === null || typeof obj?.prev === "number") && (obj?.next === null || typeof obj?.next === "number") && (obj?.branch === null || typeof obj?.branch === "number") && Array.isArray(obj?.ident) && (obj?.owner === null || typeof obj?.owner === "number") && typeof obj?.branch_root === "boolean"
}

export interface RawNode {
	node_type: NodeType;
	loc: Loc;
	body: any;
}

export function isRawNode(obj: any): obj is RawNode {
	return obj && typeof obj === 'object' && isNodeType(obj?.node_type) && isLoc(obj?.loc) && obj?.body !== undefined
}

export interface SrcErrorEntry {
	msg: string;
	file: string;
	loc: Loc;
	src: string;
	warn: boolean;
}

export function isSrcErrorEntry(obj: any): obj is SrcErrorEntry {
	return obj && typeof obj === 'object' && typeof obj?.msg === "string" && typeof obj?.file === "string" && isLoc(obj?.loc) && typeof obj?.src === "string" && typeof obj?.warn === "boolean"
}

export interface SrcError {
	errs: SrcErrorEntry[];
}

export function isSrcError(obj: any): obj is SrcError {
	return obj && typeof obj === 'object' && Array.isArray(obj?.errs)
}

export interface JsonAst {
	node: RawNode[];
	scope: RawScope[];
}

export function isJsonAst(obj: any): obj is JsonAst {
	return obj && typeof obj === 'object' && Array.isArray(obj?.node) && Array.isArray(obj?.scope)
}

export interface AstFile {
	files: string[];
	ast: JsonAst|null;
	error: SrcError|null;
}

export function isAstFile(obj: any): obj is AstFile {
	return obj && typeof obj === 'object' && Array.isArray(obj?.files) && (obj?.ast === null || isJsonAst(obj?.ast)) && (obj?.error === null || isSrcError(obj?.error))
}

export interface TokenFile {
	files: string[];
	tokens: Token[]|null;
	error: SrcError|null;
}

export function isTokenFile(obj: any): obj is TokenFile {
	return obj && typeof obj === 'object' && Array.isArray(obj?.files) && (obj?.tokens === null || Array.isArray(obj?.tokens)) && (obj?.error === null || isSrcError(obj?.error))
}

interface astConstructor {
	node : Node[];
	scope : Scope[];
}

export function parseAST(obj: any): Program {
	if (!isJsonAst(obj)) {
		throw new Error('invalid ast');
	}
	const o :JsonAst = {
		node: obj.node.map((n: any) => {
			if (!isRawNode(n)) {
				throw new Error('invalid node');
			}
			return n;
		}),
		scope: obj.scope.map((s: any) => {
			if (!isRawScope(s)) {
				throw new Error('invalid scope');
			}
			return s;
		})
	}
	const c :astConstructor = {
		node: [],
		scope: []
	}
	for (const on of o.node) {
		switch (on.node_type) {
		case "program": {
			const n :Program = {
				node_type: "program",
				loc: on.loc,
				struct_type: null,
				elements: [],
				global_scope: null,
			}
			c.node.push(n);
			break;
		}
		case "comment": {
			const n :Comment = {
				node_type: "comment",
				loc: on.loc,
				comment: '',
			}
			c.node.push(n);
			break;
		}
		case "comment_group": {
			const n :CommentGroup = {
				node_type: "comment_group",
				loc: on.loc,
				comments: [],
			}
			c.node.push(n);
			break;
		}
		case "binary": {
			const n :Binary = {
				node_type: "binary",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				op: BinaryOp.mul,
				left: null,
				right: null,
			}
			c.node.push(n);
			break;
		}
		case "unary": {
			const n :Unary = {
				node_type: "unary",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				op: UnaryOp.not,
				expr: null,
			}
			c.node.push(n);
			break;
		}
		case "cond": {
			const n :Cond = {
				node_type: "cond",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				cond: null,
				then: null,
				els_loc: on.loc,
				els: null,
			}
			c.node.push(n);
			break;
		}
		case "ident": {
			const n :Ident = {
				node_type: "ident",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				ident: '',
				usage: IdentUsage.unknown,
				base: null,
				scope: null,
			}
			c.node.push(n);
			break;
		}
		case "call": {
			const n :Call = {
				node_type: "call",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				callee: null,
				raw_arguments: null,
				arguments: [],
				end_loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "if": {
			const n :If = {
				node_type: "if",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				cond_scope: null,
				cond: null,
				then: null,
				els: null,
			}
			c.node.push(n);
			break;
		}
		case "member_access": {
			const n :MemberAccess = {
				node_type: "member_access",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				target: null,
				member: null,
				base: null,
			}
			c.node.push(n);
			break;
		}
		case "paren": {
			const n :Paren = {
				node_type: "paren",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				expr: null,
				end_loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "index": {
			const n :Index = {
				node_type: "index",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				expr: null,
				index: null,
				end_loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "match": {
			const n :Match = {
				node_type: "match",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				cond_scope: null,
				cond: null,
				branch: [],
			}
			c.node.push(n);
			break;
		}
		case "range": {
			const n :Range = {
				node_type: "range",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				op: BinaryOp.mul,
				start: null,
				end: null,
			}
			c.node.push(n);
			break;
		}
		case "tmp_var": {
			const n :TmpVar = {
				node_type: "tmp_var",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				tmp_var: 0,
			}
			c.node.push(n);
			break;
		}
		case "block_expr": {
			const n :BlockExpr = {
				node_type: "block_expr",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				calls: [],
				expr: null,
			}
			c.node.push(n);
			break;
		}
		case "import": {
			const n :Import = {
				node_type: "import",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				path: '',
				base: null,
				import_desc: null,
			}
			c.node.push(n);
			break;
		}
		case "cast": {
			const n :Cast = {
				node_type: "cast",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				base: null,
				expr: null,
			}
			c.node.push(n);
			break;
		}
		case "available": {
			const n :Available = {
				node_type: "available",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				base: null,
				target: null,
			}
			c.node.push(n);
			break;
		}
		case "loop": {
			const n :Loop = {
				node_type: "loop",
				loc: on.loc,
				cond_scope: null,
				init: null,
				cond: null,
				step: null,
				body: null,
			}
			c.node.push(n);
			break;
		}
		case "indent_block": {
			const n :IndentBlock = {
				node_type: "indent_block",
				loc: on.loc,
				struct_type: null,
				elements: [],
				scope: null,
			}
			c.node.push(n);
			break;
		}
		case "match_branch": {
			const n :MatchBranch = {
				node_type: "match_branch",
				loc: on.loc,
				cond: null,
				sym_loc: on.loc,
				then: null,
			}
			c.node.push(n);
			break;
		}
		case "union_candidate": {
			const n :UnionCandidate = {
				node_type: "union_candidate",
				loc: on.loc,
				cond: null,
				field: null,
			}
			c.node.push(n);
			break;
		}
		case "return": {
			const n :Return = {
				node_type: "return",
				loc: on.loc,
				expr: null,
			}
			c.node.push(n);
			break;
		}
		case "break": {
			const n :Break = {
				node_type: "break",
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "continue": {
			const n :Continue = {
				node_type: "continue",
				loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "assert": {
			const n :Assert = {
				node_type: "assert",
				loc: on.loc,
				cond: null,
			}
			c.node.push(n);
			break;
		}
		case "implicit_yield": {
			const n :ImplicitYield = {
				node_type: "implicit_yield",
				loc: on.loc,
				expr: null,
			}
			c.node.push(n);
			break;
		}
		case "int_type": {
			const n :IntType = {
				node_type: "int_type",
				loc: on.loc,
				is_explicit: false,
				is_int_set: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: 0,
				endian: Endian.unspec,
				is_signed: false,
				is_common_supported: false,
			}
			c.node.push(n);
			break;
		}
		case "ident_type": {
			const n :IdentType = {
				node_type: "ident_type",
				loc: on.loc,
				is_explicit: false,
				is_int_set: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: 0,
				ident: null,
				base: null,
			}
			c.node.push(n);
			break;
		}
		case "int_literal_type": {
			const n :IntLiteralType = {
				node_type: "int_literal_type",
				loc: on.loc,
				is_explicit: false,
				is_int_set: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: 0,
				base: null,
			}
			c.node.push(n);
			break;
		}
		case "str_literal_type": {
			const n :StrLiteralType = {
				node_type: "str_literal_type",
				loc: on.loc,
				is_explicit: false,
				is_int_set: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: 0,
				base: null,
			}
			c.node.push(n);
			break;
		}
		case "void_type": {
			const n :VoidType = {
				node_type: "void_type",
				loc: on.loc,
				is_explicit: false,
				is_int_set: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: 0,
			}
			c.node.push(n);
			break;
		}
		case "bool_type": {
			const n :BoolType = {
				node_type: "bool_type",
				loc: on.loc,
				is_explicit: false,
				is_int_set: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: 0,
			}
			c.node.push(n);
			break;
		}
		case "array_type": {
			const n :ArrayType = {
				node_type: "array_type",
				loc: on.loc,
				is_explicit: false,
				is_int_set: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: 0,
				end_loc: on.loc,
				base_type: null,
				length: null,
				length_value: 0,
				has_const_length: false,
			}
			c.node.push(n);
			break;
		}
		case "function_type": {
			const n :FunctionType = {
				node_type: "function_type",
				loc: on.loc,
				is_explicit: false,
				is_int_set: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: 0,
				return_type: null,
				parameters: [],
			}
			c.node.push(n);
			break;
		}
		case "struct_type": {
			const n :StructType = {
				node_type: "struct_type",
				loc: on.loc,
				is_explicit: false,
				is_int_set: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: 0,
				fields: [],
				base: null,
				recursive: false,
			}
			c.node.push(n);
			break;
		}
		case "struct_union_type": {
			const n :StructUnionType = {
				node_type: "struct_union_type",
				loc: on.loc,
				is_explicit: false,
				is_int_set: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: 0,
				structs: [],
				base: null,
				union_fields: [],
			}
			c.node.push(n);
			break;
		}
		case "union_type": {
			const n :UnionType = {
				node_type: "union_type",
				loc: on.loc,
				is_explicit: false,
				is_int_set: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: 0,
				cond: null,
				candidates: [],
				base_type: null,
				common_type: null,
			}
			c.node.push(n);
			break;
		}
		case "range_type": {
			const n :RangeType = {
				node_type: "range_type",
				loc: on.loc,
				is_explicit: false,
				is_int_set: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: 0,
				base_type: null,
				range: null,
			}
			c.node.push(n);
			break;
		}
		case "enum_type": {
			const n :EnumType = {
				node_type: "enum_type",
				loc: on.loc,
				is_explicit: false,
				is_int_set: false,
				bit_alignment: BitAlignment.byte_aligned,
				bit_size: 0,
				base: null,
			}
			c.node.push(n);
			break;
		}
		case "int_literal": {
			const n :IntLiteral = {
				node_type: "int_literal",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				value: '',
			}
			c.node.push(n);
			break;
		}
		case "bool_literal": {
			const n :BoolLiteral = {
				node_type: "bool_literal",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				value: false,
			}
			c.node.push(n);
			break;
		}
		case "str_literal": {
			const n :StrLiteral = {
				node_type: "str_literal",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
				value: '',
			}
			c.node.push(n);
			break;
		}
		case "input": {
			const n :Input = {
				node_type: "input",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
			}
			c.node.push(n);
			break;
		}
		case "output": {
			const n :Output = {
				node_type: "output",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
			}
			c.node.push(n);
			break;
		}
		case "config": {
			const n :Config = {
				node_type: "config",
				loc: on.loc,
				expr_type: null,
				constant_level: ConstantLevel.unknown,
			}
			c.node.push(n);
			break;
		}
		case "field": {
			const n :Field = {
				node_type: "field",
				loc: on.loc,
				belong: null,
				belong_struct: null,
				ident: null,
				colon_loc: on.loc,
				field_type: null,
				raw_arguments: null,
				arguments: [],
				bit_alignment: BitAlignment.byte_aligned,
			}
			c.node.push(n);
			break;
		}
		case "format": {
			const n :Format = {
				node_type: "format",
				loc: on.loc,
				belong: null,
				belong_struct: null,
				ident: null,
				body: null,
			}
			c.node.push(n);
			break;
		}
		case "state": {
			const n :State = {
				node_type: "state",
				loc: on.loc,
				belong: null,
				belong_struct: null,
				ident: null,
				body: null,
			}
			c.node.push(n);
			break;
		}
		case "enum": {
			const n :Enum = {
				node_type: "enum",
				loc: on.loc,
				belong: null,
				belong_struct: null,
				ident: null,
				scope: null,
				colon_loc: on.loc,
				base_type: null,
				members: [],
				enum_type: null,
			}
			c.node.push(n);
			break;
		}
		case "enum_member": {
			const n :EnumMember = {
				node_type: "enum_member",
				loc: on.loc,
				belong: null,
				belong_struct: null,
				ident: null,
				expr: null,
			}
			c.node.push(n);
			break;
		}
		case "function": {
			const n :Function = {
				node_type: "function",
				loc: on.loc,
				belong: null,
				belong_struct: null,
				ident: null,
				parameters: [],
				return_type: null,
				body: null,
				func_type: null,
				is_cast: false,
				cast_loc: on.loc,
			}
			c.node.push(n);
			break;
		}
		case "builtin_function": {
			const n :BuiltinFunction = {
				node_type: "builtin_function",
				loc: on.loc,
				belong: null,
				belong_struct: null,
				ident: null,
				func_type: null,
			}
			c.node.push(n);
			break;
		}
		default:
			throw new Error('invalid node type');
		}
	}
	for (const _ of o.scope) {
		const n :Scope = {
			prev: null,
			next: null,
			branch: null,
			ident: [],
			owner: null,
			branch_root: false,
		}
		c.scope.push(n);
	}
	for (let i = 0; i < o.node.length; i++) {
		const on = o.node[i];
		const cnode = c.node[i];
		switch (cnode.node_type) {
		case "program": {
			const n :Program = cnode as Program;
			if (on.body?.struct_type !== null && typeof on.body?.struct_type !== 'number') {
				throw new Error('invalid node list at Program::struct_type');
			}
			const tmpstruct_type = on.body.struct_type === null ? null : c.node[on.body.struct_type];
			if (!(tmpstruct_type === null || isStructType(tmpstruct_type))) {
				throw new Error('invalid node list at Program::struct_type');
			}
			n.struct_type = tmpstruct_type;
			for (const o of on.body.elements) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at Program::elements');
				}
				const tmpelements = c.node[o];
				n.elements.push(tmpelements);
			}
			if (on.body?.global_scope !== null && typeof on.body?.global_scope !== 'number') {
				throw new Error('invalid node list at Program::global_scope');
			}
			const tmpglobal_scope = on.body.global_scope === null ? null : c.scope[on.body.global_scope];
			if (tmpglobal_scope !== null && !isScope(tmpglobal_scope)) {
				throw new Error('invalid node list at Program::global_scope');
			}
			n.global_scope = tmpglobal_scope;
			break;
		}
		case "comment": {
			const n :Comment = cnode as Comment;
			const tmpcomment = on.body?.comment;
			if (typeof on.body?.comment !== "string") {
				throw new Error('invalid node list at Comment::comment');
			}
			n.comment = on.body.comment;
			break;
		}
		case "comment_group": {
			const n :CommentGroup = cnode as CommentGroup;
			for (const o of on.body.comments) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at CommentGroup::comments');
				}
				const tmpcomments = c.node[o];
				if (!isComment(tmpcomments)) {
					throw new Error('invalid node list at CommentGroup::comments');
				}
				n.comments.push(tmpcomments);
			}
			break;
		}
		case "binary": {
			const n :Binary = cnode as Binary;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Binary::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Binary::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Binary::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmpop = on.body?.op;
			if (!isBinaryOp(tmpop)) {
				throw new Error('invalid node list at Binary::op');
			}
			n.op = tmpop;
			if (on.body?.left !== null && typeof on.body?.left !== 'number') {
				throw new Error('invalid node list at Binary::left');
			}
			const tmpleft = on.body.left === null ? null : c.node[on.body.left];
			if (!(tmpleft === null || isExpr(tmpleft))) {
				throw new Error('invalid node list at Binary::left');
			}
			n.left = tmpleft;
			if (on.body?.right !== null && typeof on.body?.right !== 'number') {
				throw new Error('invalid node list at Binary::right');
			}
			const tmpright = on.body.right === null ? null : c.node[on.body.right];
			if (!(tmpright === null || isExpr(tmpright))) {
				throw new Error('invalid node list at Binary::right');
			}
			n.right = tmpright;
			break;
		}
		case "unary": {
			const n :Unary = cnode as Unary;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Unary::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Unary::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Unary::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmpop = on.body?.op;
			if (!isUnaryOp(tmpop)) {
				throw new Error('invalid node list at Unary::op');
			}
			n.op = tmpop;
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list at Unary::expr');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list at Unary::expr');
			}
			n.expr = tmpexpr;
			break;
		}
		case "cond": {
			const n :Cond = cnode as Cond;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Cond::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Cond::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Cond::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list at Cond::cond');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isExpr(tmpcond))) {
				throw new Error('invalid node list at Cond::cond');
			}
			n.cond = tmpcond;
			if (on.body?.then !== null && typeof on.body?.then !== 'number') {
				throw new Error('invalid node list at Cond::then');
			}
			const tmpthen = on.body.then === null ? null : c.node[on.body.then];
			if (!(tmpthen === null || isExpr(tmpthen))) {
				throw new Error('invalid node list at Cond::then');
			}
			n.then = tmpthen;
			const tmpels_loc = on.body?.els_loc;
			if (!isLoc(tmpels_loc)) {
				throw new Error('invalid node list at Cond::els_loc');
			}
			n.els_loc = tmpels_loc;
			if (on.body?.els !== null && typeof on.body?.els !== 'number') {
				throw new Error('invalid node list at Cond::els');
			}
			const tmpels = on.body.els === null ? null : c.node[on.body.els];
			if (!(tmpels === null || isExpr(tmpels))) {
				throw new Error('invalid node list at Cond::els');
			}
			n.els = tmpels;
			break;
		}
		case "ident": {
			const n :Ident = cnode as Ident;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Ident::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Ident::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Ident::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmpident = on.body?.ident;
			if (typeof on.body?.ident !== "string") {
				throw new Error('invalid node list at Ident::ident');
			}
			n.ident = on.body.ident;
			const tmpusage = on.body?.usage;
			if (!isIdentUsage(tmpusage)) {
				throw new Error('invalid node list at Ident::usage');
			}
			n.usage = tmpusage;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at Ident::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isNode(tmpbase))) {
				throw new Error('invalid node list at Ident::base');
			}
			n.base = tmpbase;
			if (on.body?.scope !== null && typeof on.body?.scope !== 'number') {
				throw new Error('invalid node list at Ident::scope');
			}
			const tmpscope = on.body.scope === null ? null : c.scope[on.body.scope];
			if (tmpscope !== null && !isScope(tmpscope)) {
				throw new Error('invalid node list at Ident::scope');
			}
			n.scope = tmpscope;
			break;
		}
		case "call": {
			const n :Call = cnode as Call;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Call::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Call::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Call::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.callee !== null && typeof on.body?.callee !== 'number') {
				throw new Error('invalid node list at Call::callee');
			}
			const tmpcallee = on.body.callee === null ? null : c.node[on.body.callee];
			if (!(tmpcallee === null || isExpr(tmpcallee))) {
				throw new Error('invalid node list at Call::callee');
			}
			n.callee = tmpcallee;
			if (on.body?.raw_arguments !== null && typeof on.body?.raw_arguments !== 'number') {
				throw new Error('invalid node list at Call::raw_arguments');
			}
			const tmpraw_arguments = on.body.raw_arguments === null ? null : c.node[on.body.raw_arguments];
			if (!(tmpraw_arguments === null || isExpr(tmpraw_arguments))) {
				throw new Error('invalid node list at Call::raw_arguments');
			}
			n.raw_arguments = tmpraw_arguments;
			for (const o of on.body.arguments) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at Call::arguments');
				}
				const tmparguments = c.node[o];
				if (!isExpr(tmparguments)) {
					throw new Error('invalid node list at Call::arguments');
				}
				n.arguments.push(tmparguments);
			}
			const tmpend_loc = on.body?.end_loc;
			if (!isLoc(tmpend_loc)) {
				throw new Error('invalid node list at Call::end_loc');
			}
			n.end_loc = tmpend_loc;
			break;
		}
		case "if": {
			const n :If = cnode as If;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at If::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at If::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at If::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.cond_scope !== null && typeof on.body?.cond_scope !== 'number') {
				throw new Error('invalid node list at If::cond_scope');
			}
			const tmpcond_scope = on.body.cond_scope === null ? null : c.scope[on.body.cond_scope];
			if (tmpcond_scope !== null && !isScope(tmpcond_scope)) {
				throw new Error('invalid node list at If::cond_scope');
			}
			n.cond_scope = tmpcond_scope;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list at If::cond');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isExpr(tmpcond))) {
				throw new Error('invalid node list at If::cond');
			}
			n.cond = tmpcond;
			if (on.body?.then !== null && typeof on.body?.then !== 'number') {
				throw new Error('invalid node list at If::then');
			}
			const tmpthen = on.body.then === null ? null : c.node[on.body.then];
			if (!(tmpthen === null || isIndentBlock(tmpthen))) {
				throw new Error('invalid node list at If::then');
			}
			n.then = tmpthen;
			if (on.body?.els !== null && typeof on.body?.els !== 'number') {
				throw new Error('invalid node list at If::els');
			}
			const tmpels = on.body.els === null ? null : c.node[on.body.els];
			if (!(tmpels === null || isNode(tmpels))) {
				throw new Error('invalid node list at If::els');
			}
			n.els = tmpels;
			break;
		}
		case "member_access": {
			const n :MemberAccess = cnode as MemberAccess;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at MemberAccess::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at MemberAccess::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at MemberAccess::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.target !== null && typeof on.body?.target !== 'number') {
				throw new Error('invalid node list at MemberAccess::target');
			}
			const tmptarget = on.body.target === null ? null : c.node[on.body.target];
			if (!(tmptarget === null || isExpr(tmptarget))) {
				throw new Error('invalid node list at MemberAccess::target');
			}
			n.target = tmptarget;
			if (on.body?.member !== null && typeof on.body?.member !== 'number') {
				throw new Error('invalid node list at MemberAccess::member');
			}
			const tmpmember = on.body.member === null ? null : c.node[on.body.member];
			if (!(tmpmember === null || isIdent(tmpmember))) {
				throw new Error('invalid node list at MemberAccess::member');
			}
			n.member = tmpmember;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at MemberAccess::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isNode(tmpbase))) {
				throw new Error('invalid node list at MemberAccess::base');
			}
			n.base = tmpbase;
			break;
		}
		case "paren": {
			const n :Paren = cnode as Paren;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Paren::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Paren::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Paren::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list at Paren::expr');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list at Paren::expr');
			}
			n.expr = tmpexpr;
			const tmpend_loc = on.body?.end_loc;
			if (!isLoc(tmpend_loc)) {
				throw new Error('invalid node list at Paren::end_loc');
			}
			n.end_loc = tmpend_loc;
			break;
		}
		case "index": {
			const n :Index = cnode as Index;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Index::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Index::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Index::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list at Index::expr');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list at Index::expr');
			}
			n.expr = tmpexpr;
			if (on.body?.index !== null && typeof on.body?.index !== 'number') {
				throw new Error('invalid node list at Index::index');
			}
			const tmpindex = on.body.index === null ? null : c.node[on.body.index];
			if (!(tmpindex === null || isExpr(tmpindex))) {
				throw new Error('invalid node list at Index::index');
			}
			n.index = tmpindex;
			const tmpend_loc = on.body?.end_loc;
			if (!isLoc(tmpend_loc)) {
				throw new Error('invalid node list at Index::end_loc');
			}
			n.end_loc = tmpend_loc;
			break;
		}
		case "match": {
			const n :Match = cnode as Match;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Match::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Match::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Match::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.cond_scope !== null && typeof on.body?.cond_scope !== 'number') {
				throw new Error('invalid node list at Match::cond_scope');
			}
			const tmpcond_scope = on.body.cond_scope === null ? null : c.scope[on.body.cond_scope];
			if (tmpcond_scope !== null && !isScope(tmpcond_scope)) {
				throw new Error('invalid node list at Match::cond_scope');
			}
			n.cond_scope = tmpcond_scope;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list at Match::cond');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isExpr(tmpcond))) {
				throw new Error('invalid node list at Match::cond');
			}
			n.cond = tmpcond;
			for (const o of on.body.branch) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at Match::branch');
				}
				const tmpbranch = c.node[o];
				n.branch.push(tmpbranch);
			}
			break;
		}
		case "range": {
			const n :Range = cnode as Range;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Range::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Range::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Range::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmpop = on.body?.op;
			if (!isBinaryOp(tmpop)) {
				throw new Error('invalid node list at Range::op');
			}
			n.op = tmpop;
			if (on.body?.start !== null && typeof on.body?.start !== 'number') {
				throw new Error('invalid node list at Range::start');
			}
			const tmpstart = on.body.start === null ? null : c.node[on.body.start];
			if (!(tmpstart === null || isExpr(tmpstart))) {
				throw new Error('invalid node list at Range::start');
			}
			n.start = tmpstart;
			if (on.body?.end !== null && typeof on.body?.end !== 'number') {
				throw new Error('invalid node list at Range::end');
			}
			const tmpend = on.body.end === null ? null : c.node[on.body.end];
			if (!(tmpend === null || isExpr(tmpend))) {
				throw new Error('invalid node list at Range::end');
			}
			n.end = tmpend;
			break;
		}
		case "tmp_var": {
			const n :TmpVar = cnode as TmpVar;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at TmpVar::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at TmpVar::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at TmpVar::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmptmp_var = on.body?.tmp_var;
			if (typeof on.body?.tmp_var !== "number") {
				throw new Error('invalid node list at TmpVar::tmp_var');
			}
			n.tmp_var = on.body.tmp_var;
			break;
		}
		case "block_expr": {
			const n :BlockExpr = cnode as BlockExpr;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at BlockExpr::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at BlockExpr::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at BlockExpr::constant_level');
			}
			n.constant_level = tmpconstant_level;
			for (const o of on.body.calls) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at BlockExpr::calls');
				}
				const tmpcalls = c.node[o];
				n.calls.push(tmpcalls);
			}
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list at BlockExpr::expr');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list at BlockExpr::expr');
			}
			n.expr = tmpexpr;
			break;
		}
		case "import": {
			const n :Import = cnode as Import;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Import::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Import::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Import::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmppath = on.body?.path;
			if (typeof on.body?.path !== "string") {
				throw new Error('invalid node list at Import::path');
			}
			n.path = on.body.path;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at Import::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isCall(tmpbase))) {
				throw new Error('invalid node list at Import::base');
			}
			n.base = tmpbase;
			if (on.body?.import_desc !== null && typeof on.body?.import_desc !== 'number') {
				throw new Error('invalid node list at Import::import_desc');
			}
			const tmpimport_desc = on.body.import_desc === null ? null : c.node[on.body.import_desc];
			if (!(tmpimport_desc === null || isProgram(tmpimport_desc))) {
				throw new Error('invalid node list at Import::import_desc');
			}
			n.import_desc = tmpimport_desc;
			break;
		}
		case "cast": {
			const n :Cast = cnode as Cast;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Cast::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Cast::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Cast::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at Cast::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isCall(tmpbase))) {
				throw new Error('invalid node list at Cast::base');
			}
			n.base = tmpbase;
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list at Cast::expr');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list at Cast::expr');
			}
			n.expr = tmpexpr;
			break;
		}
		case "available": {
			const n :Available = cnode as Available;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Available::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Available::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Available::constant_level');
			}
			n.constant_level = tmpconstant_level;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at Available::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isCall(tmpbase))) {
				throw new Error('invalid node list at Available::base');
			}
			n.base = tmpbase;
			if (on.body?.target !== null && typeof on.body?.target !== 'number') {
				throw new Error('invalid node list at Available::target');
			}
			const tmptarget = on.body.target === null ? null : c.node[on.body.target];
			if (!(tmptarget === null || isIdent(tmptarget))) {
				throw new Error('invalid node list at Available::target');
			}
			n.target = tmptarget;
			break;
		}
		case "loop": {
			const n :Loop = cnode as Loop;
			if (on.body?.cond_scope !== null && typeof on.body?.cond_scope !== 'number') {
				throw new Error('invalid node list at Loop::cond_scope');
			}
			const tmpcond_scope = on.body.cond_scope === null ? null : c.scope[on.body.cond_scope];
			if (tmpcond_scope !== null && !isScope(tmpcond_scope)) {
				throw new Error('invalid node list at Loop::cond_scope');
			}
			n.cond_scope = tmpcond_scope;
			if (on.body?.init !== null && typeof on.body?.init !== 'number') {
				throw new Error('invalid node list at Loop::init');
			}
			const tmpinit = on.body.init === null ? null : c.node[on.body.init];
			if (!(tmpinit === null || isExpr(tmpinit))) {
				throw new Error('invalid node list at Loop::init');
			}
			n.init = tmpinit;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list at Loop::cond');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isExpr(tmpcond))) {
				throw new Error('invalid node list at Loop::cond');
			}
			n.cond = tmpcond;
			if (on.body?.step !== null && typeof on.body?.step !== 'number') {
				throw new Error('invalid node list at Loop::step');
			}
			const tmpstep = on.body.step === null ? null : c.node[on.body.step];
			if (!(tmpstep === null || isExpr(tmpstep))) {
				throw new Error('invalid node list at Loop::step');
			}
			n.step = tmpstep;
			if (on.body?.body !== null && typeof on.body?.body !== 'number') {
				throw new Error('invalid node list at Loop::body');
			}
			const tmpbody = on.body.body === null ? null : c.node[on.body.body];
			if (!(tmpbody === null || isIndentBlock(tmpbody))) {
				throw new Error('invalid node list at Loop::body');
			}
			n.body = tmpbody;
			break;
		}
		case "indent_block": {
			const n :IndentBlock = cnode as IndentBlock;
			if (on.body?.struct_type !== null && typeof on.body?.struct_type !== 'number') {
				throw new Error('invalid node list at IndentBlock::struct_type');
			}
			const tmpstruct_type = on.body.struct_type === null ? null : c.node[on.body.struct_type];
			if (!(tmpstruct_type === null || isStructType(tmpstruct_type))) {
				throw new Error('invalid node list at IndentBlock::struct_type');
			}
			n.struct_type = tmpstruct_type;
			for (const o of on.body.elements) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at IndentBlock::elements');
				}
				const tmpelements = c.node[o];
				n.elements.push(tmpelements);
			}
			if (on.body?.scope !== null && typeof on.body?.scope !== 'number') {
				throw new Error('invalid node list at IndentBlock::scope');
			}
			const tmpscope = on.body.scope === null ? null : c.scope[on.body.scope];
			if (tmpscope !== null && !isScope(tmpscope)) {
				throw new Error('invalid node list at IndentBlock::scope');
			}
			n.scope = tmpscope;
			break;
		}
		case "match_branch": {
			const n :MatchBranch = cnode as MatchBranch;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list at MatchBranch::cond');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isExpr(tmpcond))) {
				throw new Error('invalid node list at MatchBranch::cond');
			}
			n.cond = tmpcond;
			const tmpsym_loc = on.body?.sym_loc;
			if (!isLoc(tmpsym_loc)) {
				throw new Error('invalid node list at MatchBranch::sym_loc');
			}
			n.sym_loc = tmpsym_loc;
			if (on.body?.then !== null && typeof on.body?.then !== 'number') {
				throw new Error('invalid node list at MatchBranch::then');
			}
			const tmpthen = on.body.then === null ? null : c.node[on.body.then];
			if (!(tmpthen === null || isNode(tmpthen))) {
				throw new Error('invalid node list at MatchBranch::then');
			}
			n.then = tmpthen;
			break;
		}
		case "union_candidate": {
			const n :UnionCandidate = cnode as UnionCandidate;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list at UnionCandidate::cond');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isExpr(tmpcond))) {
				throw new Error('invalid node list at UnionCandidate::cond');
			}
			n.cond = tmpcond;
			if (on.body?.field !== null && typeof on.body?.field !== 'number') {
				throw new Error('invalid node list at UnionCandidate::field');
			}
			const tmpfield = on.body.field === null ? null : c.node[on.body.field];
			if (!(tmpfield === null || isField(tmpfield))) {
				throw new Error('invalid node list at UnionCandidate::field');
			}
			n.field = tmpfield;
			break;
		}
		case "return": {
			const n :Return = cnode as Return;
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list at Return::expr');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list at Return::expr');
			}
			n.expr = tmpexpr;
			break;
		}
		case "break": {
			const n :Break = cnode as Break;
			break;
		}
		case "continue": {
			const n :Continue = cnode as Continue;
			break;
		}
		case "assert": {
			const n :Assert = cnode as Assert;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list at Assert::cond');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isBinary(tmpcond))) {
				throw new Error('invalid node list at Assert::cond');
			}
			n.cond = tmpcond;
			break;
		}
		case "implicit_yield": {
			const n :ImplicitYield = cnode as ImplicitYield;
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list at ImplicitYield::expr');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list at ImplicitYield::expr');
			}
			n.expr = tmpexpr;
			break;
		}
		case "int_type": {
			const n :IntType = cnode as IntType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof on.body?.is_explicit !== "boolean") {
				throw new Error('invalid node list at IntType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpis_int_set = on.body?.is_int_set;
			if (typeof on.body?.is_int_set !== "boolean") {
				throw new Error('invalid node list at IntType::is_int_set');
			}
			n.is_int_set = on.body.is_int_set;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at IntType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (typeof on.body?.bit_size !== "number") {
				throw new Error('invalid node list at IntType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			const tmpendian = on.body?.endian;
			if (!isEndian(tmpendian)) {
				throw new Error('invalid node list at IntType::endian');
			}
			n.endian = tmpendian;
			const tmpis_signed = on.body?.is_signed;
			if (typeof on.body?.is_signed !== "boolean") {
				throw new Error('invalid node list at IntType::is_signed');
			}
			n.is_signed = on.body.is_signed;
			const tmpis_common_supported = on.body?.is_common_supported;
			if (typeof on.body?.is_common_supported !== "boolean") {
				throw new Error('invalid node list at IntType::is_common_supported');
			}
			n.is_common_supported = on.body.is_common_supported;
			break;
		}
		case "ident_type": {
			const n :IdentType = cnode as IdentType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof on.body?.is_explicit !== "boolean") {
				throw new Error('invalid node list at IdentType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpis_int_set = on.body?.is_int_set;
			if (typeof on.body?.is_int_set !== "boolean") {
				throw new Error('invalid node list at IdentType::is_int_set');
			}
			n.is_int_set = on.body.is_int_set;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at IdentType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (typeof on.body?.bit_size !== "number") {
				throw new Error('invalid node list at IdentType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			if (on.body?.ident !== null && typeof on.body?.ident !== 'number') {
				throw new Error('invalid node list at IdentType::ident');
			}
			const tmpident = on.body.ident === null ? null : c.node[on.body.ident];
			if (!(tmpident === null || isIdent(tmpident))) {
				throw new Error('invalid node list at IdentType::ident');
			}
			n.ident = tmpident;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at IdentType::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isType(tmpbase))) {
				throw new Error('invalid node list at IdentType::base');
			}
			n.base = tmpbase;
			break;
		}
		case "int_literal_type": {
			const n :IntLiteralType = cnode as IntLiteralType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof on.body?.is_explicit !== "boolean") {
				throw new Error('invalid node list at IntLiteralType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpis_int_set = on.body?.is_int_set;
			if (typeof on.body?.is_int_set !== "boolean") {
				throw new Error('invalid node list at IntLiteralType::is_int_set');
			}
			n.is_int_set = on.body.is_int_set;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at IntLiteralType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (typeof on.body?.bit_size !== "number") {
				throw new Error('invalid node list at IntLiteralType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at IntLiteralType::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isIntLiteral(tmpbase))) {
				throw new Error('invalid node list at IntLiteralType::base');
			}
			n.base = tmpbase;
			break;
		}
		case "str_literal_type": {
			const n :StrLiteralType = cnode as StrLiteralType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof on.body?.is_explicit !== "boolean") {
				throw new Error('invalid node list at StrLiteralType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpis_int_set = on.body?.is_int_set;
			if (typeof on.body?.is_int_set !== "boolean") {
				throw new Error('invalid node list at StrLiteralType::is_int_set');
			}
			n.is_int_set = on.body.is_int_set;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at StrLiteralType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (typeof on.body?.bit_size !== "number") {
				throw new Error('invalid node list at StrLiteralType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at StrLiteralType::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isStrLiteral(tmpbase))) {
				throw new Error('invalid node list at StrLiteralType::base');
			}
			n.base = tmpbase;
			break;
		}
		case "void_type": {
			const n :VoidType = cnode as VoidType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof on.body?.is_explicit !== "boolean") {
				throw new Error('invalid node list at VoidType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpis_int_set = on.body?.is_int_set;
			if (typeof on.body?.is_int_set !== "boolean") {
				throw new Error('invalid node list at VoidType::is_int_set');
			}
			n.is_int_set = on.body.is_int_set;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at VoidType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (typeof on.body?.bit_size !== "number") {
				throw new Error('invalid node list at VoidType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			break;
		}
		case "bool_type": {
			const n :BoolType = cnode as BoolType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof on.body?.is_explicit !== "boolean") {
				throw new Error('invalid node list at BoolType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpis_int_set = on.body?.is_int_set;
			if (typeof on.body?.is_int_set !== "boolean") {
				throw new Error('invalid node list at BoolType::is_int_set');
			}
			n.is_int_set = on.body.is_int_set;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at BoolType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (typeof on.body?.bit_size !== "number") {
				throw new Error('invalid node list at BoolType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			break;
		}
		case "array_type": {
			const n :ArrayType = cnode as ArrayType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof on.body?.is_explicit !== "boolean") {
				throw new Error('invalid node list at ArrayType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpis_int_set = on.body?.is_int_set;
			if (typeof on.body?.is_int_set !== "boolean") {
				throw new Error('invalid node list at ArrayType::is_int_set');
			}
			n.is_int_set = on.body.is_int_set;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at ArrayType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (typeof on.body?.bit_size !== "number") {
				throw new Error('invalid node list at ArrayType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			const tmpend_loc = on.body?.end_loc;
			if (!isLoc(tmpend_loc)) {
				throw new Error('invalid node list at ArrayType::end_loc');
			}
			n.end_loc = tmpend_loc;
			if (on.body?.base_type !== null && typeof on.body?.base_type !== 'number') {
				throw new Error('invalid node list at ArrayType::base_type');
			}
			const tmpbase_type = on.body.base_type === null ? null : c.node[on.body.base_type];
			if (!(tmpbase_type === null || isType(tmpbase_type))) {
				throw new Error('invalid node list at ArrayType::base_type');
			}
			n.base_type = tmpbase_type;
			if (on.body?.length !== null && typeof on.body?.length !== 'number') {
				throw new Error('invalid node list at ArrayType::length');
			}
			const tmplength = on.body.length === null ? null : c.node[on.body.length];
			if (!(tmplength === null || isExpr(tmplength))) {
				throw new Error('invalid node list at ArrayType::length');
			}
			n.length = tmplength;
			const tmplength_value = on.body?.length_value;
			if (typeof on.body?.length_value !== "number") {
				throw new Error('invalid node list at ArrayType::length_value');
			}
			n.length_value = on.body.length_value;
			const tmphas_const_length = on.body?.has_const_length;
			if (typeof on.body?.has_const_length !== "boolean") {
				throw new Error('invalid node list at ArrayType::has_const_length');
			}
			n.has_const_length = on.body.has_const_length;
			break;
		}
		case "function_type": {
			const n :FunctionType = cnode as FunctionType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof on.body?.is_explicit !== "boolean") {
				throw new Error('invalid node list at FunctionType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpis_int_set = on.body?.is_int_set;
			if (typeof on.body?.is_int_set !== "boolean") {
				throw new Error('invalid node list at FunctionType::is_int_set');
			}
			n.is_int_set = on.body.is_int_set;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at FunctionType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (typeof on.body?.bit_size !== "number") {
				throw new Error('invalid node list at FunctionType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			if (on.body?.return_type !== null && typeof on.body?.return_type !== 'number') {
				throw new Error('invalid node list at FunctionType::return_type');
			}
			const tmpreturn_type = on.body.return_type === null ? null : c.node[on.body.return_type];
			if (!(tmpreturn_type === null || isType(tmpreturn_type))) {
				throw new Error('invalid node list at FunctionType::return_type');
			}
			n.return_type = tmpreturn_type;
			for (const o of on.body.parameters) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at FunctionType::parameters');
				}
				const tmpparameters = c.node[o];
				if (!isType(tmpparameters)) {
					throw new Error('invalid node list at FunctionType::parameters');
				}
				n.parameters.push(tmpparameters);
			}
			break;
		}
		case "struct_type": {
			const n :StructType = cnode as StructType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof on.body?.is_explicit !== "boolean") {
				throw new Error('invalid node list at StructType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpis_int_set = on.body?.is_int_set;
			if (typeof on.body?.is_int_set !== "boolean") {
				throw new Error('invalid node list at StructType::is_int_set');
			}
			n.is_int_set = on.body.is_int_set;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at StructType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (typeof on.body?.bit_size !== "number") {
				throw new Error('invalid node list at StructType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			for (const o of on.body.fields) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at StructType::fields');
				}
				const tmpfields = c.node[o];
				if (!isMember(tmpfields)) {
					throw new Error('invalid node list at StructType::fields');
				}
				n.fields.push(tmpfields);
			}
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at StructType::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isNode(tmpbase))) {
				throw new Error('invalid node list at StructType::base');
			}
			n.base = tmpbase;
			const tmprecursive = on.body?.recursive;
			if (typeof on.body?.recursive !== "boolean") {
				throw new Error('invalid node list at StructType::recursive');
			}
			n.recursive = on.body.recursive;
			break;
		}
		case "struct_union_type": {
			const n :StructUnionType = cnode as StructUnionType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof on.body?.is_explicit !== "boolean") {
				throw new Error('invalid node list at StructUnionType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpis_int_set = on.body?.is_int_set;
			if (typeof on.body?.is_int_set !== "boolean") {
				throw new Error('invalid node list at StructUnionType::is_int_set');
			}
			n.is_int_set = on.body.is_int_set;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at StructUnionType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (typeof on.body?.bit_size !== "number") {
				throw new Error('invalid node list at StructUnionType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			for (const o of on.body.structs) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at StructUnionType::structs');
				}
				const tmpstructs = c.node[o];
				if (!isStructType(tmpstructs)) {
					throw new Error('invalid node list at StructUnionType::structs');
				}
				n.structs.push(tmpstructs);
			}
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at StructUnionType::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isExpr(tmpbase))) {
				throw new Error('invalid node list at StructUnionType::base');
			}
			n.base = tmpbase;
			for (const o of on.body.union_fields) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at StructUnionType::union_fields');
				}
				const tmpunion_fields = c.node[o];
				if (!isField(tmpunion_fields)) {
					throw new Error('invalid node list at StructUnionType::union_fields');
				}
				n.union_fields.push(tmpunion_fields);
			}
			break;
		}
		case "union_type": {
			const n :UnionType = cnode as UnionType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof on.body?.is_explicit !== "boolean") {
				throw new Error('invalid node list at UnionType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpis_int_set = on.body?.is_int_set;
			if (typeof on.body?.is_int_set !== "boolean") {
				throw new Error('invalid node list at UnionType::is_int_set');
			}
			n.is_int_set = on.body.is_int_set;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at UnionType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (typeof on.body?.bit_size !== "number") {
				throw new Error('invalid node list at UnionType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			if (on.body?.cond !== null && typeof on.body?.cond !== 'number') {
				throw new Error('invalid node list at UnionType::cond');
			}
			const tmpcond = on.body.cond === null ? null : c.node[on.body.cond];
			if (!(tmpcond === null || isExpr(tmpcond))) {
				throw new Error('invalid node list at UnionType::cond');
			}
			n.cond = tmpcond;
			for (const o of on.body.candidates) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at UnionType::candidates');
				}
				const tmpcandidates = c.node[o];
				if (!isUnionCandidate(tmpcandidates)) {
					throw new Error('invalid node list at UnionType::candidates');
				}
				n.candidates.push(tmpcandidates);
			}
			if (on.body?.base_type !== null && typeof on.body?.base_type !== 'number') {
				throw new Error('invalid node list at UnionType::base_type');
			}
			const tmpbase_type = on.body.base_type === null ? null : c.node[on.body.base_type];
			if (!(tmpbase_type === null || isStructUnionType(tmpbase_type))) {
				throw new Error('invalid node list at UnionType::base_type');
			}
			n.base_type = tmpbase_type;
			if (on.body?.common_type !== null && typeof on.body?.common_type !== 'number') {
				throw new Error('invalid node list at UnionType::common_type');
			}
			const tmpcommon_type = on.body.common_type === null ? null : c.node[on.body.common_type];
			if (!(tmpcommon_type === null || isType(tmpcommon_type))) {
				throw new Error('invalid node list at UnionType::common_type');
			}
			n.common_type = tmpcommon_type;
			break;
		}
		case "range_type": {
			const n :RangeType = cnode as RangeType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof on.body?.is_explicit !== "boolean") {
				throw new Error('invalid node list at RangeType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpis_int_set = on.body?.is_int_set;
			if (typeof on.body?.is_int_set !== "boolean") {
				throw new Error('invalid node list at RangeType::is_int_set');
			}
			n.is_int_set = on.body.is_int_set;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at RangeType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (typeof on.body?.bit_size !== "number") {
				throw new Error('invalid node list at RangeType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			if (on.body?.base_type !== null && typeof on.body?.base_type !== 'number') {
				throw new Error('invalid node list at RangeType::base_type');
			}
			const tmpbase_type = on.body.base_type === null ? null : c.node[on.body.base_type];
			if (!(tmpbase_type === null || isType(tmpbase_type))) {
				throw new Error('invalid node list at RangeType::base_type');
			}
			n.base_type = tmpbase_type;
			if (on.body?.range !== null && typeof on.body?.range !== 'number') {
				throw new Error('invalid node list at RangeType::range');
			}
			const tmprange = on.body.range === null ? null : c.node[on.body.range];
			if (!(tmprange === null || isRange(tmprange))) {
				throw new Error('invalid node list at RangeType::range');
			}
			n.range = tmprange;
			break;
		}
		case "enum_type": {
			const n :EnumType = cnode as EnumType;
			const tmpis_explicit = on.body?.is_explicit;
			if (typeof on.body?.is_explicit !== "boolean") {
				throw new Error('invalid node list at EnumType::is_explicit');
			}
			n.is_explicit = on.body.is_explicit;
			const tmpis_int_set = on.body?.is_int_set;
			if (typeof on.body?.is_int_set !== "boolean") {
				throw new Error('invalid node list at EnumType::is_int_set');
			}
			n.is_int_set = on.body.is_int_set;
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at EnumType::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			const tmpbit_size = on.body?.bit_size;
			if (typeof on.body?.bit_size !== "number") {
				throw new Error('invalid node list at EnumType::bit_size');
			}
			n.bit_size = on.body.bit_size;
			if (on.body?.base !== null && typeof on.body?.base !== 'number') {
				throw new Error('invalid node list at EnumType::base');
			}
			const tmpbase = on.body.base === null ? null : c.node[on.body.base];
			if (!(tmpbase === null || isEnum(tmpbase))) {
				throw new Error('invalid node list at EnumType::base');
			}
			n.base = tmpbase;
			break;
		}
		case "int_literal": {
			const n :IntLiteral = cnode as IntLiteral;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at IntLiteral::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at IntLiteral::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at IntLiteral::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmpvalue = on.body?.value;
			if (typeof on.body?.value !== "string") {
				throw new Error('invalid node list at IntLiteral::value');
			}
			n.value = on.body.value;
			break;
		}
		case "bool_literal": {
			const n :BoolLiteral = cnode as BoolLiteral;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at BoolLiteral::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at BoolLiteral::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at BoolLiteral::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmpvalue = on.body?.value;
			if (typeof on.body?.value !== "boolean") {
				throw new Error('invalid node list at BoolLiteral::value');
			}
			n.value = on.body.value;
			break;
		}
		case "str_literal": {
			const n :StrLiteral = cnode as StrLiteral;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at StrLiteral::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at StrLiteral::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at StrLiteral::constant_level');
			}
			n.constant_level = tmpconstant_level;
			const tmpvalue = on.body?.value;
			if (typeof on.body?.value !== "string") {
				throw new Error('invalid node list at StrLiteral::value');
			}
			n.value = on.body.value;
			break;
		}
		case "input": {
			const n :Input = cnode as Input;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Input::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Input::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Input::constant_level');
			}
			n.constant_level = tmpconstant_level;
			break;
		}
		case "output": {
			const n :Output = cnode as Output;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Output::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Output::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Output::constant_level');
			}
			n.constant_level = tmpconstant_level;
			break;
		}
		case "config": {
			const n :Config = cnode as Config;
			if (on.body?.expr_type !== null && typeof on.body?.expr_type !== 'number') {
				throw new Error('invalid node list at Config::expr_type');
			}
			const tmpexpr_type = on.body.expr_type === null ? null : c.node[on.body.expr_type];
			if (!(tmpexpr_type === null || isType(tmpexpr_type))) {
				throw new Error('invalid node list at Config::expr_type');
			}
			n.expr_type = tmpexpr_type;
			const tmpconstant_level = on.body?.constant_level;
			if (!isConstantLevel(tmpconstant_level)) {
				throw new Error('invalid node list at Config::constant_level');
			}
			n.constant_level = tmpconstant_level;
			break;
		}
		case "field": {
			const n :Field = cnode as Field;
			if (on.body?.belong !== null && typeof on.body?.belong !== 'number') {
				throw new Error('invalid node list at Field::belong');
			}
			const tmpbelong = on.body.belong === null ? null : c.node[on.body.belong];
			if (!(tmpbelong === null || isMember(tmpbelong))) {
				throw new Error('invalid node list at Field::belong');
			}
			n.belong = tmpbelong;
			if (on.body?.belong_struct !== null && typeof on.body?.belong_struct !== 'number') {
				throw new Error('invalid node list at Field::belong_struct');
			}
			const tmpbelong_struct = on.body.belong_struct === null ? null : c.node[on.body.belong_struct];
			if (!(tmpbelong_struct === null || isStructType(tmpbelong_struct))) {
				throw new Error('invalid node list at Field::belong_struct');
			}
			n.belong_struct = tmpbelong_struct;
			if (on.body?.ident !== null && typeof on.body?.ident !== 'number') {
				throw new Error('invalid node list at Field::ident');
			}
			const tmpident = on.body.ident === null ? null : c.node[on.body.ident];
			if (!(tmpident === null || isIdent(tmpident))) {
				throw new Error('invalid node list at Field::ident');
			}
			n.ident = tmpident;
			const tmpcolon_loc = on.body?.colon_loc;
			if (!isLoc(tmpcolon_loc)) {
				throw new Error('invalid node list at Field::colon_loc');
			}
			n.colon_loc = tmpcolon_loc;
			if (on.body?.field_type !== null && typeof on.body?.field_type !== 'number') {
				throw new Error('invalid node list at Field::field_type');
			}
			const tmpfield_type = on.body.field_type === null ? null : c.node[on.body.field_type];
			if (!(tmpfield_type === null || isType(tmpfield_type))) {
				throw new Error('invalid node list at Field::field_type');
			}
			n.field_type = tmpfield_type;
			if (on.body?.raw_arguments !== null && typeof on.body?.raw_arguments !== 'number') {
				throw new Error('invalid node list at Field::raw_arguments');
			}
			const tmpraw_arguments = on.body.raw_arguments === null ? null : c.node[on.body.raw_arguments];
			if (!(tmpraw_arguments === null || isExpr(tmpraw_arguments))) {
				throw new Error('invalid node list at Field::raw_arguments');
			}
			n.raw_arguments = tmpraw_arguments;
			for (const o of on.body.arguments) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at Field::arguments');
				}
				const tmparguments = c.node[o];
				if (!isExpr(tmparguments)) {
					throw new Error('invalid node list at Field::arguments');
				}
				n.arguments.push(tmparguments);
			}
			const tmpbit_alignment = on.body?.bit_alignment;
			if (!isBitAlignment(tmpbit_alignment)) {
				throw new Error('invalid node list at Field::bit_alignment');
			}
			n.bit_alignment = tmpbit_alignment;
			break;
		}
		case "format": {
			const n :Format = cnode as Format;
			if (on.body?.belong !== null && typeof on.body?.belong !== 'number') {
				throw new Error('invalid node list at Format::belong');
			}
			const tmpbelong = on.body.belong === null ? null : c.node[on.body.belong];
			if (!(tmpbelong === null || isMember(tmpbelong))) {
				throw new Error('invalid node list at Format::belong');
			}
			n.belong = tmpbelong;
			if (on.body?.belong_struct !== null && typeof on.body?.belong_struct !== 'number') {
				throw new Error('invalid node list at Format::belong_struct');
			}
			const tmpbelong_struct = on.body.belong_struct === null ? null : c.node[on.body.belong_struct];
			if (!(tmpbelong_struct === null || isStructType(tmpbelong_struct))) {
				throw new Error('invalid node list at Format::belong_struct');
			}
			n.belong_struct = tmpbelong_struct;
			if (on.body?.ident !== null && typeof on.body?.ident !== 'number') {
				throw new Error('invalid node list at Format::ident');
			}
			const tmpident = on.body.ident === null ? null : c.node[on.body.ident];
			if (!(tmpident === null || isIdent(tmpident))) {
				throw new Error('invalid node list at Format::ident');
			}
			n.ident = tmpident;
			if (on.body?.body !== null && typeof on.body?.body !== 'number') {
				throw new Error('invalid node list at Format::body');
			}
			const tmpbody = on.body.body === null ? null : c.node[on.body.body];
			if (!(tmpbody === null || isIndentBlock(tmpbody))) {
				throw new Error('invalid node list at Format::body');
			}
			n.body = tmpbody;
			break;
		}
		case "state": {
			const n :State = cnode as State;
			if (on.body?.belong !== null && typeof on.body?.belong !== 'number') {
				throw new Error('invalid node list at State::belong');
			}
			const tmpbelong = on.body.belong === null ? null : c.node[on.body.belong];
			if (!(tmpbelong === null || isMember(tmpbelong))) {
				throw new Error('invalid node list at State::belong');
			}
			n.belong = tmpbelong;
			if (on.body?.belong_struct !== null && typeof on.body?.belong_struct !== 'number') {
				throw new Error('invalid node list at State::belong_struct');
			}
			const tmpbelong_struct = on.body.belong_struct === null ? null : c.node[on.body.belong_struct];
			if (!(tmpbelong_struct === null || isStructType(tmpbelong_struct))) {
				throw new Error('invalid node list at State::belong_struct');
			}
			n.belong_struct = tmpbelong_struct;
			if (on.body?.ident !== null && typeof on.body?.ident !== 'number') {
				throw new Error('invalid node list at State::ident');
			}
			const tmpident = on.body.ident === null ? null : c.node[on.body.ident];
			if (!(tmpident === null || isIdent(tmpident))) {
				throw new Error('invalid node list at State::ident');
			}
			n.ident = tmpident;
			if (on.body?.body !== null && typeof on.body?.body !== 'number') {
				throw new Error('invalid node list at State::body');
			}
			const tmpbody = on.body.body === null ? null : c.node[on.body.body];
			if (!(tmpbody === null || isIndentBlock(tmpbody))) {
				throw new Error('invalid node list at State::body');
			}
			n.body = tmpbody;
			break;
		}
		case "enum": {
			const n :Enum = cnode as Enum;
			if (on.body?.belong !== null && typeof on.body?.belong !== 'number') {
				throw new Error('invalid node list at Enum::belong');
			}
			const tmpbelong = on.body.belong === null ? null : c.node[on.body.belong];
			if (!(tmpbelong === null || isMember(tmpbelong))) {
				throw new Error('invalid node list at Enum::belong');
			}
			n.belong = tmpbelong;
			if (on.body?.belong_struct !== null && typeof on.body?.belong_struct !== 'number') {
				throw new Error('invalid node list at Enum::belong_struct');
			}
			const tmpbelong_struct = on.body.belong_struct === null ? null : c.node[on.body.belong_struct];
			if (!(tmpbelong_struct === null || isStructType(tmpbelong_struct))) {
				throw new Error('invalid node list at Enum::belong_struct');
			}
			n.belong_struct = tmpbelong_struct;
			if (on.body?.ident !== null && typeof on.body?.ident !== 'number') {
				throw new Error('invalid node list at Enum::ident');
			}
			const tmpident = on.body.ident === null ? null : c.node[on.body.ident];
			if (!(tmpident === null || isIdent(tmpident))) {
				throw new Error('invalid node list at Enum::ident');
			}
			n.ident = tmpident;
			if (on.body?.scope !== null && typeof on.body?.scope !== 'number') {
				throw new Error('invalid node list at Enum::scope');
			}
			const tmpscope = on.body.scope === null ? null : c.scope[on.body.scope];
			if (tmpscope !== null && !isScope(tmpscope)) {
				throw new Error('invalid node list at Enum::scope');
			}
			n.scope = tmpscope;
			const tmpcolon_loc = on.body?.colon_loc;
			if (!isLoc(tmpcolon_loc)) {
				throw new Error('invalid node list at Enum::colon_loc');
			}
			n.colon_loc = tmpcolon_loc;
			if (on.body?.base_type !== null && typeof on.body?.base_type !== 'number') {
				throw new Error('invalid node list at Enum::base_type');
			}
			const tmpbase_type = on.body.base_type === null ? null : c.node[on.body.base_type];
			if (!(tmpbase_type === null || isType(tmpbase_type))) {
				throw new Error('invalid node list at Enum::base_type');
			}
			n.base_type = tmpbase_type;
			for (const o of on.body.members) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at Enum::members');
				}
				const tmpmembers = c.node[o];
				if (!isEnumMember(tmpmembers)) {
					throw new Error('invalid node list at Enum::members');
				}
				n.members.push(tmpmembers);
			}
			if (on.body?.enum_type !== null && typeof on.body?.enum_type !== 'number') {
				throw new Error('invalid node list at Enum::enum_type');
			}
			const tmpenum_type = on.body.enum_type === null ? null : c.node[on.body.enum_type];
			if (!(tmpenum_type === null || isEnumType(tmpenum_type))) {
				throw new Error('invalid node list at Enum::enum_type');
			}
			n.enum_type = tmpenum_type;
			break;
		}
		case "enum_member": {
			const n :EnumMember = cnode as EnumMember;
			if (on.body?.belong !== null && typeof on.body?.belong !== 'number') {
				throw new Error('invalid node list at EnumMember::belong');
			}
			const tmpbelong = on.body.belong === null ? null : c.node[on.body.belong];
			if (!(tmpbelong === null || isMember(tmpbelong))) {
				throw new Error('invalid node list at EnumMember::belong');
			}
			n.belong = tmpbelong;
			if (on.body?.belong_struct !== null && typeof on.body?.belong_struct !== 'number') {
				throw new Error('invalid node list at EnumMember::belong_struct');
			}
			const tmpbelong_struct = on.body.belong_struct === null ? null : c.node[on.body.belong_struct];
			if (!(tmpbelong_struct === null || isStructType(tmpbelong_struct))) {
				throw new Error('invalid node list at EnumMember::belong_struct');
			}
			n.belong_struct = tmpbelong_struct;
			if (on.body?.ident !== null && typeof on.body?.ident !== 'number') {
				throw new Error('invalid node list at EnumMember::ident');
			}
			const tmpident = on.body.ident === null ? null : c.node[on.body.ident];
			if (!(tmpident === null || isIdent(tmpident))) {
				throw new Error('invalid node list at EnumMember::ident');
			}
			n.ident = tmpident;
			if (on.body?.expr !== null && typeof on.body?.expr !== 'number') {
				throw new Error('invalid node list at EnumMember::expr');
			}
			const tmpexpr = on.body.expr === null ? null : c.node[on.body.expr];
			if (!(tmpexpr === null || isExpr(tmpexpr))) {
				throw new Error('invalid node list at EnumMember::expr');
			}
			n.expr = tmpexpr;
			break;
		}
		case "function": {
			const n :Function = cnode as Function;
			if (on.body?.belong !== null && typeof on.body?.belong !== 'number') {
				throw new Error('invalid node list at Function::belong');
			}
			const tmpbelong = on.body.belong === null ? null : c.node[on.body.belong];
			if (!(tmpbelong === null || isMember(tmpbelong))) {
				throw new Error('invalid node list at Function::belong');
			}
			n.belong = tmpbelong;
			if (on.body?.belong_struct !== null && typeof on.body?.belong_struct !== 'number') {
				throw new Error('invalid node list at Function::belong_struct');
			}
			const tmpbelong_struct = on.body.belong_struct === null ? null : c.node[on.body.belong_struct];
			if (!(tmpbelong_struct === null || isStructType(tmpbelong_struct))) {
				throw new Error('invalid node list at Function::belong_struct');
			}
			n.belong_struct = tmpbelong_struct;
			if (on.body?.ident !== null && typeof on.body?.ident !== 'number') {
				throw new Error('invalid node list at Function::ident');
			}
			const tmpident = on.body.ident === null ? null : c.node[on.body.ident];
			if (!(tmpident === null || isIdent(tmpident))) {
				throw new Error('invalid node list at Function::ident');
			}
			n.ident = tmpident;
			for (const o of on.body.parameters) {
				if (typeof o !== 'number') {
					throw new Error('invalid node list at Function::parameters');
				}
				const tmpparameters = c.node[o];
				if (!isField(tmpparameters)) {
					throw new Error('invalid node list at Function::parameters');
				}
				n.parameters.push(tmpparameters);
			}
			if (on.body?.return_type !== null && typeof on.body?.return_type !== 'number') {
				throw new Error('invalid node list at Function::return_type');
			}
			const tmpreturn_type = on.body.return_type === null ? null : c.node[on.body.return_type];
			if (!(tmpreturn_type === null || isType(tmpreturn_type))) {
				throw new Error('invalid node list at Function::return_type');
			}
			n.return_type = tmpreturn_type;
			if (on.body?.body !== null && typeof on.body?.body !== 'number') {
				throw new Error('invalid node list at Function::body');
			}
			const tmpbody = on.body.body === null ? null : c.node[on.body.body];
			if (!(tmpbody === null || isIndentBlock(tmpbody))) {
				throw new Error('invalid node list at Function::body');
			}
			n.body = tmpbody;
			if (on.body?.func_type !== null && typeof on.body?.func_type !== 'number') {
				throw new Error('invalid node list at Function::func_type');
			}
			const tmpfunc_type = on.body.func_type === null ? null : c.node[on.body.func_type];
			if (!(tmpfunc_type === null || isFunctionType(tmpfunc_type))) {
				throw new Error('invalid node list at Function::func_type');
			}
			n.func_type = tmpfunc_type;
			const tmpis_cast = on.body?.is_cast;
			if (typeof on.body?.is_cast !== "boolean") {
				throw new Error('invalid node list at Function::is_cast');
			}
			n.is_cast = on.body.is_cast;
			const tmpcast_loc = on.body?.cast_loc;
			if (!isLoc(tmpcast_loc)) {
				throw new Error('invalid node list at Function::cast_loc');
			}
			n.cast_loc = tmpcast_loc;
			break;
		}
		case "builtin_function": {
			const n :BuiltinFunction = cnode as BuiltinFunction;
			if (on.body?.belong !== null && typeof on.body?.belong !== 'number') {
				throw new Error('invalid node list at BuiltinFunction::belong');
			}
			const tmpbelong = on.body.belong === null ? null : c.node[on.body.belong];
			if (!(tmpbelong === null || isMember(tmpbelong))) {
				throw new Error('invalid node list at BuiltinFunction::belong');
			}
			n.belong = tmpbelong;
			if (on.body?.belong_struct !== null && typeof on.body?.belong_struct !== 'number') {
				throw new Error('invalid node list at BuiltinFunction::belong_struct');
			}
			const tmpbelong_struct = on.body.belong_struct === null ? null : c.node[on.body.belong_struct];
			if (!(tmpbelong_struct === null || isStructType(tmpbelong_struct))) {
				throw new Error('invalid node list at BuiltinFunction::belong_struct');
			}
			n.belong_struct = tmpbelong_struct;
			if (on.body?.ident !== null && typeof on.body?.ident !== 'number') {
				throw new Error('invalid node list at BuiltinFunction::ident');
			}
			const tmpident = on.body.ident === null ? null : c.node[on.body.ident];
			if (!(tmpident === null || isIdent(tmpident))) {
				throw new Error('invalid node list at BuiltinFunction::ident');
			}
			n.ident = tmpident;
			if (on.body?.func_type !== null && typeof on.body?.func_type !== 'number') {
				throw new Error('invalid node list at BuiltinFunction::func_type');
			}
			const tmpfunc_type = on.body.func_type === null ? null : c.node[on.body.func_type];
			if (!(tmpfunc_type === null || isFunctionType(tmpfunc_type))) {
				throw new Error('invalid node list at BuiltinFunction::func_type');
			}
			n.func_type = tmpfunc_type;
			break;
		}
		}
	}
	for (let i = 0; i < o.scope.length; i++) {
		const os = o.scope[i];
		const cscope = c.scope[i];
		if (os.prev !== null && typeof os.prev !== 'number') {
			throw new Error('invalid node list at Scope::prev');
		}
		const tmpprev = os.prev === null ? null : c.scope[os.prev];
		if (tmpprev !== null && !isScope(tmpprev)) {
			throw new Error('invalid node list at Scope::prev');
		}
		cscope.prev = tmpprev;
		if (os.next !== null && typeof os.next !== 'number') {
			throw new Error('invalid node list at Scope::next');
		}
		const tmpnext = os.next === null ? null : c.scope[os.next];
		if (tmpnext !== null && !isScope(tmpnext)) {
			throw new Error('invalid node list at Scope::next');
		}
		cscope.next = tmpnext;
		if (os.branch !== null && typeof os.branch !== 'number') {
			throw new Error('invalid node list at Scope::branch');
		}
		const tmpbranch = os.branch === null ? null : c.scope[os.branch];
		if (tmpbranch !== null && !isScope(tmpbranch)) {
			throw new Error('invalid node list at Scope::branch');
		}
		cscope.branch = tmpbranch;
		for (const o of os.ident) {
			if (typeof o !== 'number') {
				throw new Error('invalid node list at Scope::ident');
			}
			const tmpident = c.node[o];
			if (!isIdent(tmpident)) {
				throw new Error('invalid node list at Scope::ident');
			}
			cscope.ident.push(tmpident);
		}
		cscope.branch_root = os.branch_root;
	}
	const root = c.node[0];
	if (!isProgram(root)) {
		throw new Error('invalid node list at node[0]');
	}
	return root;
}

export type VisitFn<T> = (f: VisitFn<T>, arg: T) => void|undefined|boolean;

export function walk(node: Node, fn: VisitFn<Node>) {
	switch (node.node_type) {
		case "program": {
			if (!isProgram(node)) {
				break;
			}
			const n :Program = node as Program;
			if (n.struct_type !== null) {
				const result = fn(fn,n.struct_type);
				if (result === false) {
					return;
				}
			}
			for (const e of n.elements) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "comment": {
			if (!isComment(node)) {
				break;
			}
			const n :Comment = node as Comment;
			break;
		}
		case "comment_group": {
			if (!isCommentGroup(node)) {
				break;
			}
			const n :CommentGroup = node as CommentGroup;
			for (const e of n.comments) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "binary": {
			if (!isBinary(node)) {
				break;
			}
			const n :Binary = node as Binary;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.left !== null) {
				const result = fn(fn,n.left);
				if (result === false) {
					return;
				}
			}
			if (n.right !== null) {
				const result = fn(fn,n.right);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "unary": {
			if (!isUnary(node)) {
				break;
			}
			const n :Unary = node as Unary;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.expr !== null) {
				const result = fn(fn,n.expr);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "cond": {
			if (!isCond(node)) {
				break;
			}
			const n :Cond = node as Cond;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.cond !== null) {
				const result = fn(fn,n.cond);
				if (result === false) {
					return;
				}
			}
			if (n.then !== null) {
				const result = fn(fn,n.then);
				if (result === false) {
					return;
				}
			}
			if (n.els !== null) {
				const result = fn(fn,n.els);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "ident": {
			if (!isIdent(node)) {
				break;
			}
			const n :Ident = node as Ident;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "call": {
			if (!isCall(node)) {
				break;
			}
			const n :Call = node as Call;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.callee !== null) {
				const result = fn(fn,n.callee);
				if (result === false) {
					return;
				}
			}
			if (n.raw_arguments !== null) {
				const result = fn(fn,n.raw_arguments);
				if (result === false) {
					return;
				}
			}
			for (const e of n.arguments) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "if": {
			if (!isIf(node)) {
				break;
			}
			const n :If = node as If;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.cond !== null) {
				const result = fn(fn,n.cond);
				if (result === false) {
					return;
				}
			}
			if (n.then !== null) {
				const result = fn(fn,n.then);
				if (result === false) {
					return;
				}
			}
			if (n.els !== null) {
				const result = fn(fn,n.els);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "member_access": {
			if (!isMemberAccess(node)) {
				break;
			}
			const n :MemberAccess = node as MemberAccess;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.target !== null) {
				const result = fn(fn,n.target);
				if (result === false) {
					return;
				}
			}
			if (n.member !== null) {
				const result = fn(fn,n.member);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "paren": {
			if (!isParen(node)) {
				break;
			}
			const n :Paren = node as Paren;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.expr !== null) {
				const result = fn(fn,n.expr);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "index": {
			if (!isIndex(node)) {
				break;
			}
			const n :Index = node as Index;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.expr !== null) {
				const result = fn(fn,n.expr);
				if (result === false) {
					return;
				}
			}
			if (n.index !== null) {
				const result = fn(fn,n.index);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "match": {
			if (!isMatch(node)) {
				break;
			}
			const n :Match = node as Match;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.cond !== null) {
				const result = fn(fn,n.cond);
				if (result === false) {
					return;
				}
			}
			for (const e of n.branch) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "range": {
			if (!isRange(node)) {
				break;
			}
			const n :Range = node as Range;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.start !== null) {
				const result = fn(fn,n.start);
				if (result === false) {
					return;
				}
			}
			if (n.end !== null) {
				const result = fn(fn,n.end);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "tmp_var": {
			if (!isTmpVar(node)) {
				break;
			}
			const n :TmpVar = node as TmpVar;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "block_expr": {
			if (!isBlockExpr(node)) {
				break;
			}
			const n :BlockExpr = node as BlockExpr;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			for (const e of n.calls) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			if (n.expr !== null) {
				const result = fn(fn,n.expr);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "import": {
			if (!isImport(node)) {
				break;
			}
			const n :Import = node as Import;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.base !== null) {
				const result = fn(fn,n.base);
				if (result === false) {
					return;
				}
			}
			if (n.import_desc !== null) {
				const result = fn(fn,n.import_desc);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "cast": {
			if (!isCast(node)) {
				break;
			}
			const n :Cast = node as Cast;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.base !== null) {
				const result = fn(fn,n.base);
				if (result === false) {
					return;
				}
			}
			if (n.expr !== null) {
				const result = fn(fn,n.expr);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "available": {
			if (!isAvailable(node)) {
				break;
			}
			const n :Available = node as Available;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			if (n.base !== null) {
				const result = fn(fn,n.base);
				if (result === false) {
					return;
				}
			}
			if (n.target !== null) {
				const result = fn(fn,n.target);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "loop": {
			if (!isLoop(node)) {
				break;
			}
			const n :Loop = node as Loop;
			if (n.init !== null) {
				const result = fn(fn,n.init);
				if (result === false) {
					return;
				}
			}
			if (n.cond !== null) {
				const result = fn(fn,n.cond);
				if (result === false) {
					return;
				}
			}
			if (n.step !== null) {
				const result = fn(fn,n.step);
				if (result === false) {
					return;
				}
			}
			if (n.body !== null) {
				const result = fn(fn,n.body);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "indent_block": {
			if (!isIndentBlock(node)) {
				break;
			}
			const n :IndentBlock = node as IndentBlock;
			if (n.struct_type !== null) {
				const result = fn(fn,n.struct_type);
				if (result === false) {
					return;
				}
			}
			for (const e of n.elements) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "match_branch": {
			if (!isMatchBranch(node)) {
				break;
			}
			const n :MatchBranch = node as MatchBranch;
			if (n.cond !== null) {
				const result = fn(fn,n.cond);
				if (result === false) {
					return;
				}
			}
			if (n.then !== null) {
				const result = fn(fn,n.then);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "union_candidate": {
			if (!isUnionCandidate(node)) {
				break;
			}
			const n :UnionCandidate = node as UnionCandidate;
			break;
		}
		case "return": {
			if (!isReturn(node)) {
				break;
			}
			const n :Return = node as Return;
			if (n.expr !== null) {
				const result = fn(fn,n.expr);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "break": {
			if (!isBreak(node)) {
				break;
			}
			const n :Break = node as Break;
			break;
		}
		case "continue": {
			if (!isContinue(node)) {
				break;
			}
			const n :Continue = node as Continue;
			break;
		}
		case "assert": {
			if (!isAssert(node)) {
				break;
			}
			const n :Assert = node as Assert;
			if (n.cond !== null) {
				const result = fn(fn,n.cond);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "implicit_yield": {
			if (!isImplicitYield(node)) {
				break;
			}
			const n :ImplicitYield = node as ImplicitYield;
			if (n.expr !== null) {
				const result = fn(fn,n.expr);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "int_type": {
			if (!isIntType(node)) {
				break;
			}
			const n :IntType = node as IntType;
			break;
		}
		case "ident_type": {
			if (!isIdentType(node)) {
				break;
			}
			const n :IdentType = node as IdentType;
			if (n.ident !== null) {
				const result = fn(fn,n.ident);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "int_literal_type": {
			if (!isIntLiteralType(node)) {
				break;
			}
			const n :IntLiteralType = node as IntLiteralType;
			break;
		}
		case "str_literal_type": {
			if (!isStrLiteralType(node)) {
				break;
			}
			const n :StrLiteralType = node as StrLiteralType;
			break;
		}
		case "void_type": {
			if (!isVoidType(node)) {
				break;
			}
			const n :VoidType = node as VoidType;
			break;
		}
		case "bool_type": {
			if (!isBoolType(node)) {
				break;
			}
			const n :BoolType = node as BoolType;
			break;
		}
		case "array_type": {
			if (!isArrayType(node)) {
				break;
			}
			const n :ArrayType = node as ArrayType;
			if (n.base_type !== null) {
				const result = fn(fn,n.base_type);
				if (result === false) {
					return;
				}
			}
			if (n.length !== null) {
				const result = fn(fn,n.length);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "function_type": {
			if (!isFunctionType(node)) {
				break;
			}
			const n :FunctionType = node as FunctionType;
			if (n.return_type !== null) {
				const result = fn(fn,n.return_type);
				if (result === false) {
					return;
				}
			}
			for (const e of n.parameters) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "struct_type": {
			if (!isStructType(node)) {
				break;
			}
			const n :StructType = node as StructType;
			for (const e of n.fields) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "struct_union_type": {
			if (!isStructUnionType(node)) {
				break;
			}
			const n :StructUnionType = node as StructUnionType;
			for (const e of n.structs) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "union_type": {
			if (!isUnionType(node)) {
				break;
			}
			const n :UnionType = node as UnionType;
			for (const e of n.candidates) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			if (n.common_type !== null) {
				const result = fn(fn,n.common_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "range_type": {
			if (!isRangeType(node)) {
				break;
			}
			const n :RangeType = node as RangeType;
			if (n.base_type !== null) {
				const result = fn(fn,n.base_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "enum_type": {
			if (!isEnumType(node)) {
				break;
			}
			const n :EnumType = node as EnumType;
			break;
		}
		case "int_literal": {
			if (!isIntLiteral(node)) {
				break;
			}
			const n :IntLiteral = node as IntLiteral;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "bool_literal": {
			if (!isBoolLiteral(node)) {
				break;
			}
			const n :BoolLiteral = node as BoolLiteral;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "str_literal": {
			if (!isStrLiteral(node)) {
				break;
			}
			const n :StrLiteral = node as StrLiteral;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "input": {
			if (!isInput(node)) {
				break;
			}
			const n :Input = node as Input;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "output": {
			if (!isOutput(node)) {
				break;
			}
			const n :Output = node as Output;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "config": {
			if (!isConfig(node)) {
				break;
			}
			const n :Config = node as Config;
			if (n.expr_type !== null) {
				const result = fn(fn,n.expr_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "field": {
			if (!isField(node)) {
				break;
			}
			const n :Field = node as Field;
			if (n.ident !== null) {
				const result = fn(fn,n.ident);
				if (result === false) {
					return;
				}
			}
			if (n.field_type !== null) {
				const result = fn(fn,n.field_type);
				if (result === false) {
					return;
				}
			}
			if (n.raw_arguments !== null) {
				const result = fn(fn,n.raw_arguments);
				if (result === false) {
					return;
				}
			}
			for (const e of n.arguments) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "format": {
			if (!isFormat(node)) {
				break;
			}
			const n :Format = node as Format;
			if (n.ident !== null) {
				const result = fn(fn,n.ident);
				if (result === false) {
					return;
				}
			}
			if (n.body !== null) {
				const result = fn(fn,n.body);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "state": {
			if (!isState(node)) {
				break;
			}
			const n :State = node as State;
			if (n.ident !== null) {
				const result = fn(fn,n.ident);
				if (result === false) {
					return;
				}
			}
			if (n.body !== null) {
				const result = fn(fn,n.body);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "enum": {
			if (!isEnum(node)) {
				break;
			}
			const n :Enum = node as Enum;
			if (n.ident !== null) {
				const result = fn(fn,n.ident);
				if (result === false) {
					return;
				}
			}
			if (n.base_type !== null) {
				const result = fn(fn,n.base_type);
				if (result === false) {
					return;
				}
			}
			for (const e of n.members) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			if (n.enum_type !== null) {
				const result = fn(fn,n.enum_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "enum_member": {
			if (!isEnumMember(node)) {
				break;
			}
			const n :EnumMember = node as EnumMember;
			if (n.ident !== null) {
				const result = fn(fn,n.ident);
				if (result === false) {
					return;
				}
			}
			if (n.expr !== null) {
				const result = fn(fn,n.expr);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "function": {
			if (!isFunction(node)) {
				break;
			}
			const n :Function = node as Function;
			if (n.ident !== null) {
				const result = fn(fn,n.ident);
				if (result === false) {
					return;
				}
			}
			for (const e of n.parameters) {
				const result = fn(fn,e);
				if (result === false) {
					return;
				}
			}
			if (n.return_type !== null) {
				const result = fn(fn,n.return_type);
				if (result === false) {
					return;
				}
			}
			if (n.body !== null) {
				const result = fn(fn,n.body);
				if (result === false) {
					return;
				}
			}
			if (n.func_type !== null) {
				const result = fn(fn,n.func_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
		case "builtin_function": {
			if (!isBuiltinFunction(node)) {
				break;
			}
			const n :BuiltinFunction = node as BuiltinFunction;
			if (n.ident !== null) {
				const result = fn(fn,n.ident);
				if (result === false) {
					return;
				}
			}
			if (n.func_type !== null) {
				const result = fn(fn,n.func_type);
				if (result === false) {
					return;
				}
			}
			break;
		}
	}
}

}
