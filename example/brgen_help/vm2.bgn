config.cpp.namespace = "brgen::vm"

enum Op2:
    :u8
    NOP # NOP
    TRSF # TRSF <from> <to>
    LOAD_MEMORY # LOAD_MEMORY <from> <to>
    STORE_MEMORY # STORE_MEMORY <from> <to>
    LOAD_IMMEDIATE  # LOAD_IMMEDIATE <immediate value> <to>

    # artihmetic

    # binary <op> <operand1> <operand2> <result>
    ADD
    SUB
    MUL
    DIV
    MOD
    AND
    OR
    XOR
    NOT
    SHL
    SHR

    # compare <op> <operand1> <operand2> <result>
    EQ
    NE
    LT 
    LE 
    # GT and GE can be implemented by swapping the operands so they are not needed

    #unary <op> <operand> <result>
    INC
    DEC
    NEG

    # jump
    JMP # JMP <to>
    JMPIF # JMPIF <condition> <to>

    # call
    CALL # CALL <to>
    RET # RET
    # syscall
    SYSCALL # SYSCALL <syscall number>

    # stack
    PUSH # PUSH <register number>
    POP # POP <register number>
    PUSH_IMMEDIATE # PUSH_IMMEDIATE <immediate value>

  


enum Register:
    :u8
    R0
    R1
    R2
    R3
    R4
    R5
    R6
    R7
    R8
    R9
    R10
    R11
    R12
    R13
    R14
    R15
    PC

format MemoryLayout:
    stack_size :u64
    data_size :u64
    code_size :u64
    entry_point :u64

format Op2Inst:
    op :Op2
    if op == Op2.RET || op == Op2.NOP:
        ..
    if op == Op2.JMP || op == Op2.CALL || op == Op2.POP:
        to :Register
    elif op == Op2.SYSCALL:
        syscall_number :Register
    elif op == Op2.JMPIF:
        condition :Register
        to :Register
    elif op == Op2.PUSH:
        from :Register
    elif op == Op2.PUSH_IMMEDIATE:
        immediate :u64
    elif op == Op2.TRSF || op == Op2.LOAD_MEMORY || op == Op2.STORE_MEMORY:
        from :Register
        to :Register
    elif op == Op2.LOAD_IMMEDIATE:
        immediate :u64
        to :Register
    elif op == Op2.NOT || op == Op2.INC || op == Op2.DEC || op == Op2.NEG:
        operand :Register
        result :Register
    else: # binary
        operand1 :Register
        operand2 :Register
        result :Register
