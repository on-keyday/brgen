
# default bit order
input.endian = config.endian.little
input.bit_order = config.bit_order.lsb


format LLVMBitCodeFile:
    magic :"BC\x0C\xED"
    abbrev.current_abbrev_id_width = 2 # starts with 2

state VBRState:
    len :u8

vbr :VBRState

state AbbrevState:
    current_abbrev_id_width :u32
    add :fn()

abbrev :AbbrevState

format ArbilityBitInt:
    config.cpp.replace = "llvm::APInt"
    config.must_replace = true
    value :[..]u1

    fn u64() -> u64:
        return value

format AbbrevID:
 
    value :[abbrev.current_abbrev_id_width]u1(input.type = u32)

    fn u32() -> u32:
        return value

format VBRField: # TODO(on-keyday): make this to generic VBRField
    value :[vbr.len - 1]u1(input.type = u8)
    cont :u1


format VBR:
    fields :[]VBRField

    fn decode():
        loop:
           f :VBRField
           fields[fields.length] = f # append
           if f.cont == 0:
                break
    
    fn encode():
        loop i:= u64(0); i< fields.length; i = i+1:
            if i == fields.length-1:
                fields[i].cont = 0
            else:
                fields[i].cont = 1
            output.put(fields[i])

fn IdentCodeToChar(code :u6) -> u8:
    if code < 26:
        return 'a' + code
    elif code < 52:
        return 'A' + code - 26
    elif code < 62:
        return '0' + code - 52
    elif code == 62:
        return '.'
    else:
        return '_'

fn CharToIdentCode(c :u8) -> u6:
    if c >= 'a' && c <= 'z':
        return c - 'a'
    elif c >= 'A' && c <= 'Z':
        return c - 'A' + 26
    elif c >= '0' && c <= '9':
        return c - '0' + 52
    elif c == '.':
        return 62
    elif c== '_':
        return 63
    error("Invalid character")

enum DefinedAbbrevID:
    END_BLOCK = 0
    ENTER_SUBBLOCK = 1
    DEFINE_ABBREV = 2
    UNABBREV_RECORD = 3

fn align32() -> u32:
    align := 32 - input.bit_offset & 0x1F
    return align == 32 ? 0 : align

format EnterSubBlock:
    id :AbbrevID(DefinedAbbrevID.ENTER_SUBBLOCK)
    block_id :VBR(vbr.len = 8)
    new_abbrev_id_width :VBR(vbr.len = 4)
    :[align32()]u1(input.align = 32) # align to 32-bit boundary
    block_size :u32
