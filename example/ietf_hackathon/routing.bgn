config.go.package = "routing"

format SegmentRouting:
    nextHeader :ProtocolNumber
    hdrExtLen :u8
    routingType :u8
    segmentsLeft :u8
    lastEntry :u8
    flags :u8
    tag :u16
    segment_list :[segmentsLeft][16]u8
    hdrExtLen*8 + 4 >= 16*segmentsLeft
    remaining ::= hdrExtLen*8+4 - segmentsLeft*16
    options :[..]SegmentRoutingTLV(input = input.subrange(remaining))

format SegmentRoutingTLV:
    type :u8
    if type !=0:
        len :u8
        data :[len]u8

format IPv6Header:
    version :u4 
    trafficClass :u8 flowLabel :u20
    payloadLen :u16
    nextHeader :ProtocolNumber
    hopLimit :u8
    srcAddr :[16]u8
    dstAddr :[16]u8

enum ProtocolNumber:
    :u8
    HOPOPT = 0
    ICMP = 1
    IGMP = 2
    GGP = 3
    IPV4 = 4
    ST = 5
    TCP = 6
    CBT = 7
    EGP = 8
    IGP = 9
    BBN_RCC_MON = 10
    NVP_II = 11
    PUP = 12
    ARGUS = 13
    EMCON = 14
    XNET = 15
    CHAOS = 16
    UDP = 17
    MUX = 18
    DCN_MEAS = 19
    HMP = 20
    PRM = 21
    XNS_IDP = 22
    TRUNK_1 = 23
    TRUNK_2 = 24
    RoutingHeader = 43
    ICMPV6 = 58

    Ethernet = 143

enum BGPType:
    :u8
    open = 1
    update = 2
    notification = 3
    keepalive = 4

format BGPPacket:
    marker :"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
    length :u16
    type   :BGPType
    match type:
        BGPType.open => open :Open
        BGPType.update => update :Update
        BGPType.notification => notification :Notification
        BGPType.keepalive => ..

format Open:
    version :u8
    as      :u16
    hold    :u16
    id      :u32
    optlen  :u8
    options     :[..]Option(input=input.subrange(optlen))

format Option:
    type :u8
    len  :u8
    data :[len]u8

format WithdrawnRoutes:
    len :u16
    data :[..]u8(input=input.subrange(len))

format PathAttrs:
    len :u16
    data :[..]PathAttribute(input=input.subrange(len))

format Update:
    withdrawn_routes :WithdrawnRoutes
    path_attr :PathAttrs
    network_reachability_info      :[..]NetWorkReachabilityInfo


format Withdrawn:
    len :u16
    data :[len]u8

format AttributeType:
    option :u1
    transitive :u1
    partial :u1
    extended :u1
    reserved :u4(0)
    code  :u8

format PathAttribute:
    type :AttributeType
    if type.extended == 1:
        len :u16
    else:
        len :u8
    len_tmp ::= len # FIX: len_tmp is temporary used
    data :[len_tmp]u8

format NetWorkReachabilityInfo:
    prefixlen :u8
    prefix    :[prefixlen]u8

format Notification:
    code :u8
    subcode :u8
    data :[..]u8


enum EtherType:
    :u16
    ipv4 = 0x0800
    arp = 0x0806
    vlan = 0x8100
    ipv6 = 0x86DD
    service_vlen = 0x88A8
    pppoe_discovery = 0x8863
    pppoe_session = 0x8864

format OUI:
    high: u6
    local :u1
    multicast :u1
    low :[2]u8

format MacAddress:
    oui :OUI
    nic :[3]u8

format EthernetFrame:
    dstMac :[6]u8
    srcMac :[6]u8
    ether_type :u16
    if ether_type == u16(EtherType.vlan):
        vlan_tag :u16
        ether_type2 :u16
    elif ether_type == u16(EtherType.service_vlen):
        service_vlan_tag :u16
        dummy_ether_type :u16(u16(EtherType.vlan))
        vlan_tag :u16
        ether_type2 :u16
    len ::= available(ether_type2) ? ether_type2 : ether_type
    len <= 0x5dc || len >= 0x600
    if len >= 0x600:
        data :[..]u8
    else:
        # peek :u16(input.peek = true)
        data :[len]u8

format TCPHeader:
    srcPort :u16
    dstPort :u16
    seqNum :u32
    ackNum :u32
    dataOffset :u4
    reserved :u4
    CWR :u1 ECE :u1 URG :u1 ACK :u1 PSH :u1 RST :u1 SYN :u1 FIN :u1
    windowSize :u16
    checksum :u16
    urgentPointer :u16
    options :[..]TCPOption(input = input.subrange(u8(dataOffset*4)-20))

format TCPSegment:
    hdr :TCPHeader
    payload :[..]u8

enum TCPState:
    CLOSED
    LISTEN
    SYN_SENT
    SYN_RCVD
    ESTABLISHED
    FIN_WAIT_1
    FIN_WAIT_2
    CLOSE_WAIT
    CLOSING
    LAST_ACK
    TIME_WAIT

enum TCPOptionKind:
    :u8
    END_OF_OPTIONS_LIST = 0
    NOP = 1
    MAXIMUM_SEGMENT_SIZE = 2
    WINDOW_SCALE = 3
    SACK_PERMITTED = 4
    SACK = 5
    TIMESTAMP = 8
    MPTCP = 30


format TCPOption:
    kind :TCPOptionKind
    match kind:
        TCPOptionKind.END_OF_OPTIONS_LIST => ..
        TCPOptionKind.NOP => ..
        TCPOptionKind.MAXIMUM_SEGMENT_SIZE:
            length :u8
            length == 4
            mss :u16    
        TCPOptionKind.WINDOW_SCALE:
            length :u8
            length == 3
            shiftCount :u8
        TCPOptionKind.SACK_PERMITTED: 
            length :u8
            length == 2
        TCPOptionKind.SACK:
            length :u8
            length >= 2
            sack :Sack(input = input.subrange(length-2))  
        TCPOptionKind.TIMESTAMP:
            length :u8
            length == 10
            timestamp :Timestamp(input = input.subrange(length-2))  
        ..:
            length :u8
            length >= 2
            data :[length-2]u8
            

format SackBlock:
    left :u32
    right :u32

format Sack:
    blocks :[..]SackBlock

format Timestamp:
    value :u32
    echoReply :u32
