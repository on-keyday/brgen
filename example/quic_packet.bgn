config.go.import("bytes")

path ::= config.import("./ast_step/step1.bgn")

config.go.file.name = "packet.go"
config.go.package = "github.com/on-keyday/quic_packet"
config.go.import("go/ast")

config.cpp.file.header.name= "packet.h"
config.cpp.file.source.name= "packet.cpp"
config.cpp.namespace = ""


config.export(QUICPacketHeader,ConnectionID,VarInt)


format QUICPacketHeader: 
   form :u1
   fixed :u1
   if form == 1:
      hdr :LongPacketHeader
   else:
      hdr :OneRTTPacketHeader

format LongPacketHeader:
   long_packet_type :u2
   reserved :u2
   packet_number_length :u2
   version :u32
   dst_conn_id :ConnectionID
   src_conn_id :ConnectionID
   match version:
      0 => hdr :VersionNegotiationPacket
      # version 1
      1 => match long_packet_type:
         0 => hdr :InitialPacketHeader
         1 => hdr :ZeroRTTPacketHeader
         2 => hdr :HandshakePacketHeader
         3 => hdr :RetryPacket
         .. => error("invalid long packet type")
      # version 2
      0x6b3343cf => match long_packet_type: 
         1 => hdr: InitialPacketHeader
         2 => hdr: ZeroRTTPacketHeader
         3 => hdr: HandshakePacketHeader
         0 => hdr: RetryPacket
         .. => error("invalid long packet type")
      .. => error("invalid version")


format VersionNegotiationPacket:
   versions :[..]u32

format InitialPacketHeader:
   token_length :VarInt
   token :[token_length]u8
   length :VarInt
   packet_number :[config.parent.packet_number_length]u8

format RetryPacket:
   retry_token :[..]u8
   retry_integrity_tag :[16]u8

format HandshakePacketHeader:
   length :VarInt
   enc := config.arg("encrypted",bool)
   if enc:
      encrypted_payload :[length]u8
   else:
      packet_number :[config.parent.packet_number_length]u8
      payload :[length-config.parent.packet_number_length]u8

format ZeroRTTPacketHeader:
   length :VarInt
   enc := config.arg("encrypted",bool)
   if enc:
      encrypted_payload :[length]u8
   else:
      packet_number :[config.parent.packet_number_length]u8
      payload :[length-config.parent.packet_number_length]u8



format OneRTTPacketHeader:
   spin :u1
   reserved :u2
   key_phase :u2
   packet_number_length :u2
   dst_conn_id :ConnectionID


format ConnectionID:
   id :[]byte
   fn encode():
      config.pass
   fn decode():
      config.pass


format VarInt:
   value :u64
   fn decode():
      p := input[0]
      value = match p&0xC0 >> 6:
         0 => input.u8() & !msb(2)
         1 => input.u16() & !msb(2)
         2 => input.u32() & !msb(2)
         3 => input.u64() & !msb(2)

   fn encode():
      match value:
         ..0x40 => output.u8(value)
         ..0x4000 => output.u16(value | msb(2,1))
         ..0x40000000 => output.u32(value | msb(2,2))
         ..0x4000000000000000 => output.u64(value | msb(2,3))
         _ => error("too large number")
   
n ::= 20
V ::= if n < 10 && n > -10: 
   10 * n
else: 
   n / 2

loop i:=0; i<10; i=i+1 :
   print(i)
