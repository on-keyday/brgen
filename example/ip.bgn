format IPv4Header:
    version :u4 ihl :u4 dscp :u6 ecn :u2 len :u16
    id :u16 reserved :u1 dont_fragment :u1 more_fragment :u1 fragOffset :u13
    ttl :u8 proto :ProtocolNumber checksum :u16
    srcAddr :[4]u8
    dstAddr :[4]u8
    options :[u8(ihl)*4-20]u8

format IPv4Packet:
    hdr :IPv4Header
    hdr.len >= u16(hdr.ihl)*4
    len ::= hdr.len - u16(hdr.ihl*4) 
    data :[len]u8

format IPv6Header:
    version :u4 
    trafficClass :u8 flowLabel :u20
    payloadLen :u16
    nextHeader :ProtocolNumber
    hopLimit :u8
    srcAddr :[16]u8
    dstAddr :[16]u8

enum ProtocolNumber:
    :u8
    HOPOPT = 0
    ICMP = 1
    IGMP = 2
    GGP = 3
    IPV4 = 4
    ST = 5
    TCP = 6
    CBT = 7
    EGP = 8
    IGP = 9
    BBN_RCC_MON = 10
    NVP_II = 11
    PUP = 12
    ARGUS = 13
    EMCON = 14
    XNET = 15
    CHAOS = 16
    UDP = 17
    MUX = 18
    DCN_MEAS = 19
    HMP = 20
    PRM = 21
    XNS_IDP = 22
    TRUNK_1 = 23
    TRUNK_2 = 24
    ICMPV6 = 58

fn checkSum(data :[]u8) -> u16:
    sum := u32(0)
    for i in data.length / 2:
        sum += u32(data[i*2]) << 8 | u32(data[i*2+1])
    if data.length % 2 == 1:
        sum += u32(data[data.length-1]) << 8
    for sum > 0xffff:
        sum = (sum & 0xffff) + (sum >> 16)
    return u16(!sum)

#format IPHeader:
#    ip_version :u4(input.peek=true)

#    if ip_version == 4:
#        hdr :IPv4Header
 
#    elif ip_version == 6:
#        hdr :IPv6Header
#    else:
#        error("invalid ip_version: %d", ip_version)


