// Code generated by gen_ast2csharp.go. DO NOT EDIT.
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
namespace ast2cs {
public enum NodeType {
Program,
Comment,
CommentGroup,
FieldArgument,
Expr,
Binary,
Unary,
Cond,
Ident,
Call,
If,
MemberAccess,
Paren,
Index,
Match,
Range,
TmpVar,
Import,
Cast,
Available,
SpecifyOrder,
ExplicitError,
IoOperation,
BadExpr,
Stmt,
Loop,
IndentBlock,
ScopedStatement,
MatchBranch,
UnionCandidate,
Return,
Break,
Continue,
Assert,
ImplicitYield,
Metadata,
Type,
IntType,
FloatType,
IdentType,
IntLiteralType,
StrLiteralType,
VoidType,
BoolType,
ArrayType,
FunctionType,
StructType,
StructUnionType,
UnionType,
RangeType,
EnumType,
MetaType,
OptionalType,
GenericType,
Literal,
IntLiteral,
BoolLiteral,
StrLiteral,
CharLiteral,
TypeLiteral,
SpecialLiteral,
Member,
Field,
Format,
State,
Enum,
EnumMember,
Function,
BuiltinMember,
BuiltinFunction,
BuiltinField,
BuiltinObject,
}
public enum TokenTag {
Indent,
Space,
Line,
Punct,
IntLiteral,
BoolLiteral,
StrLiteral,
CharLiteral,
Keyword,
Ident,
Comment,
Error,
Unknown,
}
public enum UnaryOp {
Not,
MinusSign,
}
public enum BinaryOp {
Mul,
Div,
Mod,
LeftArithmeticShift,
RightArithmeticShift,
LeftLogicalShift,
RightLogicalShift,
BitAnd,
Add,
Sub,
BitOr,
BitXor,
Equal,
NotEqual,
Less,
LessOrEq,
Grater,
GraterOrEq,
LogicalAnd,
LogicalOr,
CondOp1,
CondOp2,
RangeExclusive,
RangeInclusive,
Assign,
DefineAssign,
ConstAssign,
AddAssign,
SubAssign,
MulAssign,
DivAssign,
ModAssign,
LeftShiftAssign,
RightShiftAssign,
BitAndAssign,
BitOrAssign,
BitXorAssign,
Comma,
}
public enum IdentUsage {
Unknown,
Reference,
DefineVariable,
DefineConst,
DefineField,
DefineFormat,
DefineState,
DefineEnum,
DefineEnumMember,
DefineFn,
DefineCastFn,
DefineArg,
ReferenceType,
ReferenceMember,
ReferenceMemberType,
MaybeType,
ReferenceBuiltinFn,
}
public enum Endian {
Unspec,
Big,
Little,
}
public enum ConstantLevel {
Unknown,
Constant,
ImmutableVariable,
Variable,
}
public enum BitAlignment {
ByteAligned,
Bit1,
Bit2,
Bit3,
Bit4,
Bit5,
Bit6,
Bit7,
NotTarget,
NotDecidable,
}
public enum Follow {
Unknown,
End,
Fixed,
Constant,
Normal,
}
public enum IoMethod {
Unspec,
OutputPut,
InputPeek,
InputGet,
InputBackward,
InputOffset,
InputRemain,
InputSubrange,
ConfigEndianLittle,
ConfigEndianBig,
ConfigEndianNative,
ConfigBitOrderLsb,
ConfigBitOrderMsb,
}
public enum SpecialLiteralKind {
Input,
Output,
Config,
}
public enum OrderType {
Byte,
BitInput,
BitMapping,
}
public interface Node {
	public Loc Loc {get; set;}
}
public interface Expr : Node {
	public Type? ExprType {get; set;}
	public ConstantLevel ConstantLevel {get; set;}
}
public interface Stmt : Node {
}
public interface Type : Node {
	public bool IsExplicit {get; set;}
	public bool NonDynamicAllocation {get; set;}
	public BitAlignment BitAlignment {get; set;}
	public ulong? BitSize {get; set;}
}
public interface Literal : Expr {
}
public interface Member : Stmt {
	public Member? Belong {get; set;}
	public StructType? BelongStruct {get; set;}
	public Ident? Ident {get; set;}
}
public interface BuiltinMember : Member {
}
public class Program : Node{
	public Loc Loc{get;set;}
	public StructType? StructType{get;set;}
	public List<Node>? Elements{get;set;}
	public Scope? GlobalScope{get;set;}
}
public class Comment : Node{
	public Loc Loc{get;set;}
	public string Comment_{get;set;} = "";
}
public class CommentGroup : Node{
	public Loc Loc{get;set;}
	public List<Comment>? Comments{get;set;}
}
public class FieldArgument : Node{
	public Loc Loc{get;set;}
	public Expr? RawArguments{get;set;}
	public Loc EndLoc{get;set;}
	public List<Expr>? CollectedArguments{get;set;}
	public List<Expr>? Arguments{get;set;}
	public Expr? Alignment{get;set;}
	public ulong? AlignmentValue{get;set;}
	public Expr? SubByteLength{get;set;}
	public Expr? SubByteBegin{get;set;}
	public Expr? Peek{get;set;}
	public ulong? PeekValue{get;set;}
	public TypeLiteral? TypeMap{get;set;}
	public List<Metadata>? Metadata{get;set;}
}
public class Binary : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public BinaryOp Op{get;set;}
	public Expr? Left{get;set;}
	public Expr? Right{get;set;}
}
public class Unary : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public UnaryOp Op{get;set;}
	public Expr? Expr{get;set;}
}
public class Cond : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Expr? Cond_{get;set;}
	public Expr? Then{get;set;}
	public Loc ElsLoc{get;set;}
	public Expr? Els{get;set;}
}
public class Ident : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public string Ident_{get;set;} = "";
	public IdentUsage Usage{get;set;}
	public Node? Base{get;set;}
	public Scope? Scope{get;set;}
}
public class Call : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Expr? Callee{get;set;}
	public Expr? RawArguments{get;set;}
	public List<Expr>? Arguments{get;set;}
	public Loc EndLoc{get;set;}
}
public class If : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public StructUnionType? StructUnionType{get;set;}
	public Scope? CondScope{get;set;}
	public Expr? Cond{get;set;}
	public IndentBlock? Then{get;set;}
	public Node? Els{get;set;}
}
public class MemberAccess : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Expr? Target{get;set;}
	public Ident? Member{get;set;}
	public Ident? Base{get;set;}
}
public class Paren : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Expr? Expr{get;set;}
	public Loc EndLoc{get;set;}
}
public class Index : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Expr? Expr{get;set;}
	public Expr? Index_{get;set;}
	public Loc EndLoc{get;set;}
}
public class Match : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public StructUnionType? StructUnionType{get;set;}
	public Scope? CondScope{get;set;}
	public Expr? Cond{get;set;}
	public List<MatchBranch>? Branch{get;set;}
}
public class Range : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public BinaryOp Op{get;set;}
	public Expr? Start{get;set;}
	public Expr? End{get;set;}
}
public class TmpVar : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public ulong TmpVar_{get;set;}
}
public class Import : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public string Path{get;set;} = "";
	public Call? Base{get;set;}
	public Program? ImportDesc{get;set;}
}
public class Cast : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Call? Base{get;set;}
	public Expr? Expr{get;set;}
}
public class Available : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Call? Base{get;set;}
	public Expr? Target{get;set;}
}
public class SpecifyOrder : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Binary? Base{get;set;}
	public OrderType OrderType{get;set;}
	public Expr? Order{get;set;}
	public ulong? OrderValue{get;set;}
}
public class ExplicitError : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Call? Base{get;set;}
	public StrLiteral? Message{get;set;}
}
public class IoOperation : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Expr? Base{get;set;}
	public IoMethod Method{get;set;}
	public List<Expr>? Arguments{get;set;}
}
public class BadExpr : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public string Content{get;set;} = "";
}
public class Loop : Stmt{
	public Loc Loc{get;set;}
	public Scope? CondScope{get;set;}
	public Expr? Init{get;set;}
	public Expr? Cond{get;set;}
	public Expr? Step{get;set;}
	public IndentBlock? Body{get;set;}
}
public class IndentBlock : Stmt{
	public Loc Loc{get;set;}
	public StructType? StructType{get;set;}
	public List<Node>? Elements{get;set;}
	public Scope? Scope{get;set;}
}
public class ScopedStatement : Stmt{
	public Loc Loc{get;set;}
	public StructType? StructType{get;set;}
	public Node? Statement{get;set;}
	public Scope? Scope{get;set;}
}
public class MatchBranch : Stmt{
	public Loc Loc{get;set;}
	public Match? Belong{get;set;}
	public Expr? Cond{get;set;}
	public Loc SymLoc{get;set;}
	public Node? Then{get;set;}
}
public class UnionCandidate : Stmt{
	public Loc Loc{get;set;}
	public Expr? Cond{get;set;}
	public Field? Field{get;set;}
}
public class Return : Stmt{
	public Loc Loc{get;set;}
	public Expr? Expr{get;set;}
}
public class Break : Stmt{
	public Loc Loc{get;set;}
}
public class Continue : Stmt{
	public Loc Loc{get;set;}
}
public class Assert : Stmt{
	public Loc Loc{get;set;}
	public Binary? Cond{get;set;}
	public bool IsIoRelated{get;set;}
}
public class ImplicitYield : Stmt{
	public Loc Loc{get;set;}
	public Expr? Expr{get;set;}
}
public class Metadata : Stmt{
	public Loc Loc{get;set;}
	public Expr? Base{get;set;}
	public string Name{get;set;} = "";
	public List<Expr>? Values{get;set;}
}
public class IntType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamicAllocation{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public Endian Endian{get;set;}
	public bool IsSigned{get;set;}
	public bool IsCommonSupported{get;set;}
}
public class FloatType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamicAllocation{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public Endian Endian{get;set;}
	public bool IsCommonSupported{get;set;}
}
public class IdentType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamicAllocation{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public MemberAccess? ImportRef{get;set;}
	public Ident? Ident{get;set;}
	public Type? Base{get;set;}
}
public class IntLiteralType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamicAllocation{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public IntLiteral? Base{get;set;}
}
public class StrLiteralType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamicAllocation{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public StrLiteral? Base{get;set;}
	public StrLiteral? StrongRef{get;set;}
}
public class VoidType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamicAllocation{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
}
public class BoolType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamicAllocation{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
}
public class ArrayType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamicAllocation{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public Loc EndLoc{get;set;}
	public Type? ElementType{get;set;}
	public Expr? Length{get;set;}
	public ulong? LengthValue{get;set;}
}
public class FunctionType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamicAllocation{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public Type? ReturnType{get;set;}
	public List<Type>? Parameters{get;set;}
}
public class StructType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamicAllocation{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public List<Member>? Fields{get;set;}
	public Node? Base{get;set;}
	public bool Recursive{get;set;}
	public ulong FixedHeaderSize{get;set;}
	public ulong FixedTailSize{get;set;}
}
public class StructUnionType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamicAllocation{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public Expr? Cond{get;set;}
	public List<Expr>? Conds{get;set;}
	public List<StructType>? Structs{get;set;}
	public Expr? Base{get;set;}
	public List<Field>? UnionFields{get;set;}
	public bool Exhaustive{get;set;}
}
public class UnionType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamicAllocation{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public Expr? Cond{get;set;}
	public List<UnionCandidate>? Candidates{get;set;}
	public StructUnionType? BaseType{get;set;}
	public Type? CommonType{get;set;}
}
public class RangeType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamicAllocation{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public Type? BaseType{get;set;}
	public Range? Range{get;set;}
}
public class EnumType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamicAllocation{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public Enum? Base{get;set;}
}
public class MetaType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamicAllocation{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
}
public class OptionalType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamicAllocation{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public Type? BaseType{get;set;}
}
public class GenericType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamicAllocation{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public Member? Belong{get;set;}
}
public class IntLiteral : Literal{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public string Value{get;set;} = "";
}
public class BoolLiteral : Literal{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public bool Value{get;set;}
}
public class StrLiteral : Literal{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public string Value{get;set;} = "";
	public ulong Length{get;set;}
}
public class CharLiteral : Literal{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public string Value{get;set;} = "";
	public ulong Code{get;set;}
}
public class TypeLiteral : Literal{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Type? TypeLiteral_{get;set;}
	public Loc EndLoc{get;set;}
}
public class SpecialLiteral : Literal{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public SpecialLiteralKind Kind{get;set;}
}
public class Field : Member{
	public Loc Loc{get;set;}
	public Member? Belong{get;set;}
	public StructType? BelongStruct{get;set;}
	public Ident? Ident{get;set;}
	public Loc ColonLoc{get;set;}
	public bool IsStateVariable{get;set;}
	public Type? FieldType{get;set;}
	public FieldArgument? Arguments{get;set;}
	public ulong? OffsetBit{get;set;}
	public ulong OffsetRecent{get;set;}
	public ulong? TailOffsetBit{get;set;}
	public ulong TailOffsetRecent{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public BitAlignment EventualBitAlignment{get;set;}
	public Follow Follow{get;set;}
	public Follow EventualFollow{get;set;}
	public Field? Next{get;set;}
}
public class Format : Member{
	public Loc Loc{get;set;}
	public Member? Belong{get;set;}
	public StructType? BelongStruct{get;set;}
	public Ident? Ident{get;set;}
	public IndentBlock? Body{get;set;}
	public Function? EncodeFn{get;set;}
	public Function? DecodeFn{get;set;}
	public List<Function>? CastFns{get;set;}
	public List<IdentType>? Depends{get;set;}
	public List<Field>? StateVariables{get;set;}
}
public class State : Member{
	public Loc Loc{get;set;}
	public Member? Belong{get;set;}
	public StructType? BelongStruct{get;set;}
	public Ident? Ident{get;set;}
	public IndentBlock? Body{get;set;}
}
public class Enum : Member{
	public Loc Loc{get;set;}
	public Member? Belong{get;set;}
	public StructType? BelongStruct{get;set;}
	public Ident? Ident{get;set;}
	public Scope? Scope{get;set;}
	public Loc ColonLoc{get;set;}
	public Type? BaseType{get;set;}
	public List<EnumMember>? Members{get;set;}
	public EnumType? EnumType{get;set;}
}
public class EnumMember : Member{
	public Loc Loc{get;set;}
	public Member? Belong{get;set;}
	public StructType? BelongStruct{get;set;}
	public Ident? Ident{get;set;}
	public Expr? RawExpr{get;set;}
	public Expr? Value{get;set;}
	public StrLiteral? StrLiteral{get;set;}
}
public class Function : Member{
	public Loc Loc{get;set;}
	public Member? Belong{get;set;}
	public StructType? BelongStruct{get;set;}
	public Ident? Ident{get;set;}
	public List<Field>? Parameters{get;set;}
	public Type? ReturnType{get;set;}
	public IndentBlock? Body{get;set;}
	public FunctionType? FuncType{get;set;}
	public bool IsCast{get;set;}
	public Loc CastLoc{get;set;}
}
public class BuiltinFunction : Member{
	public Loc Loc{get;set;}
	public Member? Belong{get;set;}
	public StructType? BelongStruct{get;set;}
	public Ident? Ident{get;set;}
	public FunctionType? FuncType{get;set;}
}
public class BuiltinField : Member{
	public Loc Loc{get;set;}
	public Member? Belong{get;set;}
	public StructType? BelongStruct{get;set;}
	public Ident? Ident{get;set;}
	public Type? FieldType{get;set;}
}
public class BuiltinObject : Member{
	public Loc Loc{get;set;}
	public Member? Belong{get;set;}
	public StructType? BelongStruct{get;set;}
	public Ident? Ident{get;set;}
	public List<BuiltinMember>? Members{get;set;}
}
public class Scope {
	public Scope? Prev{get;set;}
	public Scope? Next{get;set;}
	public Scope? Branch{get;set;}
	public List<Ident>? Ident{get;set;}
	public Node? Owner{get;set;}
	public bool BranchRoot{get;set;}
}
public struct Pos {
	public ulong Begin{get;set;}
	public ulong End{get;set;}
}
public struct Loc {
	public Pos Pos{get;set;}
	public ulong File{get;set;}
	public ulong Line{get;set;}
	public ulong Col{get;set;}
}
public class Token {
	public TokenTag Tag{get;set;}
	public string Token_{get;set;} = "";
	public Loc Loc{get;set;}
}
public class RawScope {
	public ulong? Prev{get;set;}
	public ulong? Next{get;set;}
	public ulong? Branch{get;set;}
	public List<ulong>? Ident{get;set;}
	public ulong? Owner{get;set;}
	public bool BranchRoot{get;set;}
}
public class RawNode {
	public NodeType NodeType{get;set;}
	public Loc Loc{get;set;}
	public Dictionary<string,object>? Body{get;set;}
}
public class SrcErrorEntry {
	public string Msg{get;set;} = "";
	public string File{get;set;} = "";
	public Loc Loc{get;set;}
	public string Src{get;set;} = "";
	public bool Warn{get;set;}
}
public class SrcError {
	public List<SrcErrorEntry>? Errs{get;set;}
}
public class JsonAst {
	public List<RawNode>? Node{get;set;}
	public List<RawScope>? Scope{get;set;}
}
public class AstFile {
	public List<string>? Files{get;set;}
	public JsonAst? Ast{get;set;}
	public SrcError? Error{get;set;}
}
public class TokenFile {
	public List<string>? Files{get;set;}
	public List<Token>? Tokens{get;set;}
	public SrcError? Error{get;set;}
}
public static class Ast {
  public static Program ParseAST(JsonAst ast) {
       if(ast.Node == null) {
           throw new NullReferenceException("ast.Node is null");
       }
       if(ast.Scope == null) {
           throw new NullReferenceException("ast.Scope is null");
       }
       var nodes = new Node[ast.Node.Count];
       var scopes = new Scope[ast.Scope.Count];
       for (int i = 0; i < ast.Node.Count; i++) {
           switch (ast.Node[i].NodeType) {
           case NodeType.Program:
               nodes[i] = new Program() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Comment:
               nodes[i] = new Comment() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.CommentGroup:
               nodes[i] = new CommentGroup() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.FieldArgument:
               nodes[i] = new FieldArgument() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Binary:
               nodes[i] = new Binary() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Unary:
               nodes[i] = new Unary() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Cond:
               nodes[i] = new Cond() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Ident:
               nodes[i] = new Ident() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Call:
               nodes[i] = new Call() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.If:
               nodes[i] = new If() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.MemberAccess:
               nodes[i] = new MemberAccess() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Paren:
               nodes[i] = new Paren() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Index:
               nodes[i] = new Index() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Match:
               nodes[i] = new Match() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Range:
               nodes[i] = new Range() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.TmpVar:
               nodes[i] = new TmpVar() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Import:
               nodes[i] = new Import() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Cast:
               nodes[i] = new Cast() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Available:
               nodes[i] = new Available() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.SpecifyOrder:
               nodes[i] = new SpecifyOrder() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.ExplicitError:
               nodes[i] = new ExplicitError() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.IoOperation:
               nodes[i] = new IoOperation() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.BadExpr:
               nodes[i] = new BadExpr() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Loop:
               nodes[i] = new Loop() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.IndentBlock:
               nodes[i] = new IndentBlock() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.ScopedStatement:
               nodes[i] = new ScopedStatement() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.MatchBranch:
               nodes[i] = new MatchBranch() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.UnionCandidate:
               nodes[i] = new UnionCandidate() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Return:
               nodes[i] = new Return() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Break:
               nodes[i] = new Break() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Continue:
               nodes[i] = new Continue() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Assert:
               nodes[i] = new Assert() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.ImplicitYield:
               nodes[i] = new ImplicitYield() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Metadata:
               nodes[i] = new Metadata() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.IntType:
               nodes[i] = new IntType() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.FloatType:
               nodes[i] = new FloatType() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.IdentType:
               nodes[i] = new IdentType() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.IntLiteralType:
               nodes[i] = new IntLiteralType() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.StrLiteralType:
               nodes[i] = new StrLiteralType() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.VoidType:
               nodes[i] = new VoidType() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.BoolType:
               nodes[i] = new BoolType() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.ArrayType:
               nodes[i] = new ArrayType() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.FunctionType:
               nodes[i] = new FunctionType() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.StructType:
               nodes[i] = new StructType() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.StructUnionType:
               nodes[i] = new StructUnionType() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.UnionType:
               nodes[i] = new UnionType() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.RangeType:
               nodes[i] = new RangeType() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.EnumType:
               nodes[i] = new EnumType() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.MetaType:
               nodes[i] = new MetaType() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.OptionalType:
               nodes[i] = new OptionalType() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.GenericType:
               nodes[i] = new GenericType() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.IntLiteral:
               nodes[i] = new IntLiteral() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.BoolLiteral:
               nodes[i] = new BoolLiteral() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.StrLiteral:
               nodes[i] = new StrLiteral() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.CharLiteral:
               nodes[i] = new CharLiteral() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.TypeLiteral:
               nodes[i] = new TypeLiteral() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.SpecialLiteral:
               nodes[i] = new SpecialLiteral() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Field:
               nodes[i] = new Field() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Format:
               nodes[i] = new Format() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.State:
               nodes[i] = new State() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Enum:
               nodes[i] = new Enum() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.EnumMember:
               nodes[i] = new EnumMember() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.Function:
               nodes[i] = new Function() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.BuiltinFunction:
               nodes[i] = new BuiltinFunction() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.BuiltinField:
               nodes[i] = new BuiltinField() { Loc = ast.Node[i].Loc };
               break;
           case NodeType.BuiltinObject:
               nodes[i] = new BuiltinObject() { Loc = ast.Node[i].Loc };
               break;
           }
       }
       for (int i = 0; i < ast.Scope.Count; i++) {
           scopes[i] = new Scope();
       }
       for (int i = 0; i < ast.Node.Count; i++) {
           switch (ast.Node[i].NodeType) {
           case NodeType.Program:
               var node = nodes[i] as Program;
               node.Loc = ast.Node[i].Body[loc];
               node.StructType = ast.Node[i].Body[struct_type];
               node.Elements = ast.Node[i].Body[elements];
               node.GlobalScope = ast.Node[i].Body[global_scope];
           case NodeType.Comment:
               var node = nodes[i] as Comment;
               node.Loc = ast.Node[i].Body[loc];
               node.Comment_ = ast.Node[i].Body[comment];
           case NodeType.CommentGroup:
               var node = nodes[i] as CommentGroup;
               node.Loc = ast.Node[i].Body[loc];
               node.Comments = ast.Node[i].Body[comments];
           case NodeType.FieldArgument:
               var node = nodes[i] as FieldArgument;
               node.Loc = ast.Node[i].Body[loc];
               node.RawArguments = ast.Node[i].Body[raw_arguments];
               node.EndLoc = ast.Node[i].Body[end_loc];
               node.CollectedArguments = ast.Node[i].Body[collected_arguments];
               node.Arguments = ast.Node[i].Body[arguments];
               node.Alignment = ast.Node[i].Body[alignment];
               node.AlignmentValue = ast.Node[i].Body[alignment_value];
               node.SubByteLength = ast.Node[i].Body[sub_byte_length];
               node.SubByteBegin = ast.Node[i].Body[sub_byte_begin];
               node.Peek = ast.Node[i].Body[peek];
               node.PeekValue = ast.Node[i].Body[peek_value];
               node.TypeMap = ast.Node[i].Body[type_map];
               node.Metadata = ast.Node[i].Body[metadata];
           case NodeType.Binary:
               var node = nodes[i] as Binary;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Op = ast.Node[i].Body[op];
               node.Left = ast.Node[i].Body[left];
               node.Right = ast.Node[i].Body[right];
           case NodeType.Unary:
               var node = nodes[i] as Unary;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Op = ast.Node[i].Body[op];
               node.Expr = ast.Node[i].Body[expr];
           case NodeType.Cond:
               var node = nodes[i] as Cond;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Cond_ = ast.Node[i].Body[cond];
               node.Then = ast.Node[i].Body[then];
               node.ElsLoc = ast.Node[i].Body[els_loc];
               node.Els = ast.Node[i].Body[els];
           case NodeType.Ident:
               var node = nodes[i] as Ident;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Ident_ = ast.Node[i].Body[ident];
               node.Usage = ast.Node[i].Body[usage];
               node.Base = ast.Node[i].Body[base];
               node.Scope = ast.Node[i].Body[scope];
           case NodeType.Call:
               var node = nodes[i] as Call;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Callee = ast.Node[i].Body[callee];
               node.RawArguments = ast.Node[i].Body[raw_arguments];
               node.Arguments = ast.Node[i].Body[arguments];
               node.EndLoc = ast.Node[i].Body[end_loc];
           case NodeType.If:
               var node = nodes[i] as If;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.StructUnionType = ast.Node[i].Body[struct_union_type];
               node.CondScope = ast.Node[i].Body[cond_scope];
               node.Cond = ast.Node[i].Body[cond];
               node.Then = ast.Node[i].Body[then];
               node.Els = ast.Node[i].Body[els];
           case NodeType.MemberAccess:
               var node = nodes[i] as MemberAccess;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Target = ast.Node[i].Body[target];
               node.Member = ast.Node[i].Body[member];
               node.Base = ast.Node[i].Body[base];
           case NodeType.Paren:
               var node = nodes[i] as Paren;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Expr = ast.Node[i].Body[expr];
               node.EndLoc = ast.Node[i].Body[end_loc];
           case NodeType.Index:
               var node = nodes[i] as Index;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Expr = ast.Node[i].Body[expr];
               node.Index_ = ast.Node[i].Body[index];
               node.EndLoc = ast.Node[i].Body[end_loc];
           case NodeType.Match:
               var node = nodes[i] as Match;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.StructUnionType = ast.Node[i].Body[struct_union_type];
               node.CondScope = ast.Node[i].Body[cond_scope];
               node.Cond = ast.Node[i].Body[cond];
               node.Branch = ast.Node[i].Body[branch];
           case NodeType.Range:
               var node = nodes[i] as Range;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Op = ast.Node[i].Body[op];
               node.Start = ast.Node[i].Body[start];
               node.End = ast.Node[i].Body[end];
           case NodeType.TmpVar:
               var node = nodes[i] as TmpVar;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.TmpVar_ = ast.Node[i].Body[tmp_var];
           case NodeType.Import:
               var node = nodes[i] as Import;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Path = ast.Node[i].Body[path];
               node.Base = ast.Node[i].Body[base];
               node.ImportDesc = ast.Node[i].Body[import_desc];
           case NodeType.Cast:
               var node = nodes[i] as Cast;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Base = ast.Node[i].Body[base];
               node.Expr = ast.Node[i].Body[expr];
           case NodeType.Available:
               var node = nodes[i] as Available;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Base = ast.Node[i].Body[base];
               node.Target = ast.Node[i].Body[target];
           case NodeType.SpecifyOrder:
               var node = nodes[i] as SpecifyOrder;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Base = ast.Node[i].Body[base];
               node.OrderType = ast.Node[i].Body[order_type];
               node.Order = ast.Node[i].Body[order];
               node.OrderValue = ast.Node[i].Body[order_value];
           case NodeType.ExplicitError:
               var node = nodes[i] as ExplicitError;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Base = ast.Node[i].Body[base];
               node.Message = ast.Node[i].Body[message];
           case NodeType.IoOperation:
               var node = nodes[i] as IoOperation;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Base = ast.Node[i].Body[base];
               node.Method = ast.Node[i].Body[method];
               node.Arguments = ast.Node[i].Body[arguments];
           case NodeType.BadExpr:
               var node = nodes[i] as BadExpr;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Content = ast.Node[i].Body[content];
           case NodeType.Loop:
               var node = nodes[i] as Loop;
               node.Loc = ast.Node[i].Body[loc];
               node.CondScope = ast.Node[i].Body[cond_scope];
               node.Init = ast.Node[i].Body[init];
               node.Cond = ast.Node[i].Body[cond];
               node.Step = ast.Node[i].Body[step];
               node.Body = ast.Node[i].Body[body];
           case NodeType.IndentBlock:
               var node = nodes[i] as IndentBlock;
               node.Loc = ast.Node[i].Body[loc];
               node.StructType = ast.Node[i].Body[struct_type];
               node.Elements = ast.Node[i].Body[elements];
               node.Scope = ast.Node[i].Body[scope];
           case NodeType.ScopedStatement:
               var node = nodes[i] as ScopedStatement;
               node.Loc = ast.Node[i].Body[loc];
               node.StructType = ast.Node[i].Body[struct_type];
               node.Statement = ast.Node[i].Body[statement];
               node.Scope = ast.Node[i].Body[scope];
           case NodeType.MatchBranch:
               var node = nodes[i] as MatchBranch;
               node.Loc = ast.Node[i].Body[loc];
               node.Belong = ast.Node[i].Body[belong];
               node.Cond = ast.Node[i].Body[cond];
               node.SymLoc = ast.Node[i].Body[sym_loc];
               node.Then = ast.Node[i].Body[then];
           case NodeType.UnionCandidate:
               var node = nodes[i] as UnionCandidate;
               node.Loc = ast.Node[i].Body[loc];
               node.Cond = ast.Node[i].Body[cond];
               node.Field = ast.Node[i].Body[field];
           case NodeType.Return:
               var node = nodes[i] as Return;
               node.Loc = ast.Node[i].Body[loc];
               node.Expr = ast.Node[i].Body[expr];
           case NodeType.Break:
               var node = nodes[i] as Break;
               node.Loc = ast.Node[i].Body[loc];
           case NodeType.Continue:
               var node = nodes[i] as Continue;
               node.Loc = ast.Node[i].Body[loc];
           case NodeType.Assert:
               var node = nodes[i] as Assert;
               node.Loc = ast.Node[i].Body[loc];
               node.Cond = ast.Node[i].Body[cond];
               node.IsIoRelated = ast.Node[i].Body[is_io_related];
           case NodeType.ImplicitYield:
               var node = nodes[i] as ImplicitYield;
               node.Loc = ast.Node[i].Body[loc];
               node.Expr = ast.Node[i].Body[expr];
           case NodeType.Metadata:
               var node = nodes[i] as Metadata;
               node.Loc = ast.Node[i].Body[loc];
               node.Base = ast.Node[i].Body[base];
               node.Name = ast.Node[i].Body[name];
               node.Values = ast.Node[i].Body[values];
           case NodeType.IntType:
               var node = nodes[i] as IntType;
               node.Loc = ast.Node[i].Body[loc];
               node.IsExplicit = ast.Node[i].Body[is_explicit];
               node.NonDynamicAllocation = ast.Node[i].Body[non_dynamic_allocation];
               node.BitAlignment = ast.Node[i].Body[bit_alignment];
               node.BitSize = ast.Node[i].Body[bit_size];
               node.Endian = ast.Node[i].Body[endian];
               node.IsSigned = ast.Node[i].Body[is_signed];
               node.IsCommonSupported = ast.Node[i].Body[is_common_supported];
           case NodeType.FloatType:
               var node = nodes[i] as FloatType;
               node.Loc = ast.Node[i].Body[loc];
               node.IsExplicit = ast.Node[i].Body[is_explicit];
               node.NonDynamicAllocation = ast.Node[i].Body[non_dynamic_allocation];
               node.BitAlignment = ast.Node[i].Body[bit_alignment];
               node.BitSize = ast.Node[i].Body[bit_size];
               node.Endian = ast.Node[i].Body[endian];
               node.IsCommonSupported = ast.Node[i].Body[is_common_supported];
           case NodeType.IdentType:
               var node = nodes[i] as IdentType;
               node.Loc = ast.Node[i].Body[loc];
               node.IsExplicit = ast.Node[i].Body[is_explicit];
               node.NonDynamicAllocation = ast.Node[i].Body[non_dynamic_allocation];
               node.BitAlignment = ast.Node[i].Body[bit_alignment];
               node.BitSize = ast.Node[i].Body[bit_size];
               node.ImportRef = ast.Node[i].Body[import_ref];
               node.Ident = ast.Node[i].Body[ident];
               node.Base = ast.Node[i].Body[base];
           case NodeType.IntLiteralType:
               var node = nodes[i] as IntLiteralType;
               node.Loc = ast.Node[i].Body[loc];
               node.IsExplicit = ast.Node[i].Body[is_explicit];
               node.NonDynamicAllocation = ast.Node[i].Body[non_dynamic_allocation];
               node.BitAlignment = ast.Node[i].Body[bit_alignment];
               node.BitSize = ast.Node[i].Body[bit_size];
               node.Base = ast.Node[i].Body[base];
           case NodeType.StrLiteralType:
               var node = nodes[i] as StrLiteralType;
               node.Loc = ast.Node[i].Body[loc];
               node.IsExplicit = ast.Node[i].Body[is_explicit];
               node.NonDynamicAllocation = ast.Node[i].Body[non_dynamic_allocation];
               node.BitAlignment = ast.Node[i].Body[bit_alignment];
               node.BitSize = ast.Node[i].Body[bit_size];
               node.Base = ast.Node[i].Body[base];
               node.StrongRef = ast.Node[i].Body[strong_ref];
           case NodeType.VoidType:
               var node = nodes[i] as VoidType;
               node.Loc = ast.Node[i].Body[loc];
               node.IsExplicit = ast.Node[i].Body[is_explicit];
               node.NonDynamicAllocation = ast.Node[i].Body[non_dynamic_allocation];
               node.BitAlignment = ast.Node[i].Body[bit_alignment];
               node.BitSize = ast.Node[i].Body[bit_size];
           case NodeType.BoolType:
               var node = nodes[i] as BoolType;
               node.Loc = ast.Node[i].Body[loc];
               node.IsExplicit = ast.Node[i].Body[is_explicit];
               node.NonDynamicAllocation = ast.Node[i].Body[non_dynamic_allocation];
               node.BitAlignment = ast.Node[i].Body[bit_alignment];
               node.BitSize = ast.Node[i].Body[bit_size];
           case NodeType.ArrayType:
               var node = nodes[i] as ArrayType;
               node.Loc = ast.Node[i].Body[loc];
               node.IsExplicit = ast.Node[i].Body[is_explicit];
               node.NonDynamicAllocation = ast.Node[i].Body[non_dynamic_allocation];
               node.BitAlignment = ast.Node[i].Body[bit_alignment];
               node.BitSize = ast.Node[i].Body[bit_size];
               node.EndLoc = ast.Node[i].Body[end_loc];
               node.ElementType = ast.Node[i].Body[element_type];
               node.Length = ast.Node[i].Body[length];
               node.LengthValue = ast.Node[i].Body[length_value];
           case NodeType.FunctionType:
               var node = nodes[i] as FunctionType;
               node.Loc = ast.Node[i].Body[loc];
               node.IsExplicit = ast.Node[i].Body[is_explicit];
               node.NonDynamicAllocation = ast.Node[i].Body[non_dynamic_allocation];
               node.BitAlignment = ast.Node[i].Body[bit_alignment];
               node.BitSize = ast.Node[i].Body[bit_size];
               node.ReturnType = ast.Node[i].Body[return_type];
               node.Parameters = ast.Node[i].Body[parameters];
           case NodeType.StructType:
               var node = nodes[i] as StructType;
               node.Loc = ast.Node[i].Body[loc];
               node.IsExplicit = ast.Node[i].Body[is_explicit];
               node.NonDynamicAllocation = ast.Node[i].Body[non_dynamic_allocation];
               node.BitAlignment = ast.Node[i].Body[bit_alignment];
               node.BitSize = ast.Node[i].Body[bit_size];
               node.Fields = ast.Node[i].Body[fields];
               node.Base = ast.Node[i].Body[base];
               node.Recursive = ast.Node[i].Body[recursive];
               node.FixedHeaderSize = ast.Node[i].Body[fixed_header_size];
               node.FixedTailSize = ast.Node[i].Body[fixed_tail_size];
           case NodeType.StructUnionType:
               var node = nodes[i] as StructUnionType;
               node.Loc = ast.Node[i].Body[loc];
               node.IsExplicit = ast.Node[i].Body[is_explicit];
               node.NonDynamicAllocation = ast.Node[i].Body[non_dynamic_allocation];
               node.BitAlignment = ast.Node[i].Body[bit_alignment];
               node.BitSize = ast.Node[i].Body[bit_size];
               node.Cond = ast.Node[i].Body[cond];
               node.Conds = ast.Node[i].Body[conds];
               node.Structs = ast.Node[i].Body[structs];
               node.Base = ast.Node[i].Body[base];
               node.UnionFields = ast.Node[i].Body[union_fields];
               node.Exhaustive = ast.Node[i].Body[exhaustive];
           case NodeType.UnionType:
               var node = nodes[i] as UnionType;
               node.Loc = ast.Node[i].Body[loc];
               node.IsExplicit = ast.Node[i].Body[is_explicit];
               node.NonDynamicAllocation = ast.Node[i].Body[non_dynamic_allocation];
               node.BitAlignment = ast.Node[i].Body[bit_alignment];
               node.BitSize = ast.Node[i].Body[bit_size];
               node.Cond = ast.Node[i].Body[cond];
               node.Candidates = ast.Node[i].Body[candidates];
               node.BaseType = ast.Node[i].Body[base_type];
               node.CommonType = ast.Node[i].Body[common_type];
           case NodeType.RangeType:
               var node = nodes[i] as RangeType;
               node.Loc = ast.Node[i].Body[loc];
               node.IsExplicit = ast.Node[i].Body[is_explicit];
               node.NonDynamicAllocation = ast.Node[i].Body[non_dynamic_allocation];
               node.BitAlignment = ast.Node[i].Body[bit_alignment];
               node.BitSize = ast.Node[i].Body[bit_size];
               node.BaseType = ast.Node[i].Body[base_type];
               node.Range = ast.Node[i].Body[range];
           case NodeType.EnumType:
               var node = nodes[i] as EnumType;
               node.Loc = ast.Node[i].Body[loc];
               node.IsExplicit = ast.Node[i].Body[is_explicit];
               node.NonDynamicAllocation = ast.Node[i].Body[non_dynamic_allocation];
               node.BitAlignment = ast.Node[i].Body[bit_alignment];
               node.BitSize = ast.Node[i].Body[bit_size];
               node.Base = ast.Node[i].Body[base];
           case NodeType.MetaType:
               var node = nodes[i] as MetaType;
               node.Loc = ast.Node[i].Body[loc];
               node.IsExplicit = ast.Node[i].Body[is_explicit];
               node.NonDynamicAllocation = ast.Node[i].Body[non_dynamic_allocation];
               node.BitAlignment = ast.Node[i].Body[bit_alignment];
               node.BitSize = ast.Node[i].Body[bit_size];
           case NodeType.OptionalType:
               var node = nodes[i] as OptionalType;
               node.Loc = ast.Node[i].Body[loc];
               node.IsExplicit = ast.Node[i].Body[is_explicit];
               node.NonDynamicAllocation = ast.Node[i].Body[non_dynamic_allocation];
               node.BitAlignment = ast.Node[i].Body[bit_alignment];
               node.BitSize = ast.Node[i].Body[bit_size];
               node.BaseType = ast.Node[i].Body[base_type];
           case NodeType.GenericType:
               var node = nodes[i] as GenericType;
               node.Loc = ast.Node[i].Body[loc];
               node.IsExplicit = ast.Node[i].Body[is_explicit];
               node.NonDynamicAllocation = ast.Node[i].Body[non_dynamic_allocation];
               node.BitAlignment = ast.Node[i].Body[bit_alignment];
               node.BitSize = ast.Node[i].Body[bit_size];
               node.Belong = ast.Node[i].Body[belong];
           case NodeType.IntLiteral:
               var node = nodes[i] as IntLiteral;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Value = ast.Node[i].Body[value];
           case NodeType.BoolLiteral:
               var node = nodes[i] as BoolLiteral;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Value = ast.Node[i].Body[value];
           case NodeType.StrLiteral:
               var node = nodes[i] as StrLiteral;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Value = ast.Node[i].Body[value];
               node.Length = ast.Node[i].Body[length];
           case NodeType.CharLiteral:
               var node = nodes[i] as CharLiteral;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Value = ast.Node[i].Body[value];
               node.Code = ast.Node[i].Body[code];
           case NodeType.TypeLiteral:
               var node = nodes[i] as TypeLiteral;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.TypeLiteral_ = ast.Node[i].Body[type_literal];
               node.EndLoc = ast.Node[i].Body[end_loc];
           case NodeType.SpecialLiteral:
               var node = nodes[i] as SpecialLiteral;
               node.Loc = ast.Node[i].Body[loc];
               node.ExprType = ast.Node[i].Body[expr_type];
               node.ConstantLevel = ast.Node[i].Body[constant_level];
               node.Kind = ast.Node[i].Body[kind];
           case NodeType.Field:
               var node = nodes[i] as Field;
               node.Loc = ast.Node[i].Body[loc];
               node.Belong = ast.Node[i].Body[belong];
               node.BelongStruct = ast.Node[i].Body[belong_struct];
               node.Ident = ast.Node[i].Body[ident];
               node.ColonLoc = ast.Node[i].Body[colon_loc];
               node.IsStateVariable = ast.Node[i].Body[is_state_variable];
               node.FieldType = ast.Node[i].Body[field_type];
               node.Arguments = ast.Node[i].Body[arguments];
               node.OffsetBit = ast.Node[i].Body[offset_bit];
               node.OffsetRecent = ast.Node[i].Body[offset_recent];
               node.TailOffsetBit = ast.Node[i].Body[tail_offset_bit];
               node.TailOffsetRecent = ast.Node[i].Body[tail_offset_recent];
               node.BitAlignment = ast.Node[i].Body[bit_alignment];
               node.EventualBitAlignment = ast.Node[i].Body[eventual_bit_alignment];
               node.Follow = ast.Node[i].Body[follow];
               node.EventualFollow = ast.Node[i].Body[eventual_follow];
               node.Next = ast.Node[i].Body[next];
           case NodeType.Format:
               var node = nodes[i] as Format;
               node.Loc = ast.Node[i].Body[loc];
               node.Belong = ast.Node[i].Body[belong];
               node.BelongStruct = ast.Node[i].Body[belong_struct];
               node.Ident = ast.Node[i].Body[ident];
               node.Body = ast.Node[i].Body[body];
               node.EncodeFn = ast.Node[i].Body[encode_fn];
               node.DecodeFn = ast.Node[i].Body[decode_fn];
               node.CastFns = ast.Node[i].Body[cast_fns];
               node.Depends = ast.Node[i].Body[depends];
               node.StateVariables = ast.Node[i].Body[state_variables];
           case NodeType.State:
               var node = nodes[i] as State;
               node.Loc = ast.Node[i].Body[loc];
               node.Belong = ast.Node[i].Body[belong];
               node.BelongStruct = ast.Node[i].Body[belong_struct];
               node.Ident = ast.Node[i].Body[ident];
               node.Body = ast.Node[i].Body[body];
           case NodeType.Enum:
               var node = nodes[i] as Enum;
               node.Loc = ast.Node[i].Body[loc];
               node.Belong = ast.Node[i].Body[belong];
               node.BelongStruct = ast.Node[i].Body[belong_struct];
               node.Ident = ast.Node[i].Body[ident];
               node.Scope = ast.Node[i].Body[scope];
               node.ColonLoc = ast.Node[i].Body[colon_loc];
               node.BaseType = ast.Node[i].Body[base_type];
               node.Members = ast.Node[i].Body[members];
               node.EnumType = ast.Node[i].Body[enum_type];
           case NodeType.EnumMember:
               var node = nodes[i] as EnumMember;
               node.Loc = ast.Node[i].Body[loc];
               node.Belong = ast.Node[i].Body[belong];
               node.BelongStruct = ast.Node[i].Body[belong_struct];
               node.Ident = ast.Node[i].Body[ident];
               node.RawExpr = ast.Node[i].Body[raw_expr];
               node.Value = ast.Node[i].Body[value];
               node.StrLiteral = ast.Node[i].Body[str_literal];
           case NodeType.Function:
               var node = nodes[i] as Function;
               node.Loc = ast.Node[i].Body[loc];
               node.Belong = ast.Node[i].Body[belong];
               node.BelongStruct = ast.Node[i].Body[belong_struct];
               node.Ident = ast.Node[i].Body[ident];
               node.Parameters = ast.Node[i].Body[parameters];
               node.ReturnType = ast.Node[i].Body[return_type];
               node.Body = ast.Node[i].Body[body];
               node.FuncType = ast.Node[i].Body[func_type];
               node.IsCast = ast.Node[i].Body[is_cast];
               node.CastLoc = ast.Node[i].Body[cast_loc];
           case NodeType.BuiltinFunction:
               var node = nodes[i] as BuiltinFunction;
               node.Loc = ast.Node[i].Body[loc];
               node.Belong = ast.Node[i].Body[belong];
               node.BelongStruct = ast.Node[i].Body[belong_struct];
               node.Ident = ast.Node[i].Body[ident];
               node.FuncType = ast.Node[i].Body[func_type];
           case NodeType.BuiltinField:
               var node = nodes[i] as BuiltinField;
               node.Loc = ast.Node[i].Body[loc];
               node.Belong = ast.Node[i].Body[belong];
               node.BelongStruct = ast.Node[i].Body[belong_struct];
               node.Ident = ast.Node[i].Body[ident];
               node.FieldType = ast.Node[i].Body[field_type];
           case NodeType.BuiltinObject:
               var node = nodes[i] as BuiltinObject;
               node.Loc = ast.Node[i].Body[loc];
               node.Belong = ast.Node[i].Body[belong];
               node.BelongStruct = ast.Node[i].Body[belong_struct];
               node.Ident = ast.Node[i].Body[ident];
               node.Members = ast.Node[i].Body[members];
  }
}
}
