// Code generated by gen_ast2csharp.go. DO NOT EDIT.
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
namespace ast2cs {
public enum NodeType {
Program,
Comment,
CommentGroup,
FieldArgument,
Expr,
Binary,
Unary,
Cond,
Ident,
Call,
If,
MemberAccess,
Paren,
Index,
Match,
Range,
TmpVar,
Import,
Cast,
Available,
SpecifyEndian,
ExplicitError,
IoOperation,
Stmt,
Loop,
IndentBlock,
ScopedStatement,
MatchBranch,
UnionCandidate,
Return,
Break,
Continue,
Assert,
ImplicitYield,
Type,
IntType,
FloatType,
IdentType,
IntLiteralType,
StrLiteralType,
VoidType,
BoolType,
ArrayType,
FunctionType,
StructType,
StructUnionType,
UnionType,
RangeType,
EnumType,
MetaType,
OptionalType,
Literal,
IntLiteral,
BoolLiteral,
StrLiteral,
TypeLiteral,
Input,
Output,
Config,
Member,
Field,
Format,
State,
Enum,
EnumMember,
Function,
BuiltinMember,
BuiltinFunction,
BuiltinField,
BuiltinObject,
}
public enum TokenTag {
Indent,
Space,
Line,
Punct,
IntLiteral,
BoolLiteral,
StrLiteral,
Keyword,
Ident,
Comment,
Error,
Unknown,
}
public enum UnaryOp {
Not,
MinusSign,
}
public enum BinaryOp {
Mul,
Div,
Mod,
LeftArithmeticShift,
RightArithmeticShift,
LeftLogicalShift,
RightLogicalShift,
BitAnd,
Add,
Sub,
BitOr,
BitXor,
Equal,
NotEqual,
Less,
LessOrEq,
Grater,
GraterOrEq,
LogicalAnd,
LogicalOr,
CondOp1,
CondOp2,
RangeExclusive,
RangeInclusive,
Assign,
DefineAssign,
ConstAssign,
AddAssign,
SubAssign,
MulAssign,
DivAssign,
ModAssign,
LeftShiftAssign,
RightShiftAssign,
BitAndAssign,
BitOrAssign,
BitXorAssign,
Comma,
}
public enum IdentUsage {
Unknown,
Reference,
DefineVariable,
DefineConst,
DefineField,
DefineFormat,
DefineState,
DefineEnum,
DefineEnumMember,
DefineFn,
DefineCastFn,
DefineArg,
ReferenceType,
ReferenceMember,
MaybeType,
ReferenceBuiltinFn,
}
public enum Endian {
Unspec,
Big,
Little,
}
public enum ConstantLevel {
Unknown,
Constant,
ConstVariable,
Variable,
}
public enum BitAlignment {
ByteAligned,
Bit1,
Bit2,
Bit3,
Bit4,
Bit5,
Bit6,
Bit7,
NotTarget,
NotDecidable,
}
public enum Follow {
Unknown,
End,
Fixed,
Constant,
Normal,
}
public enum IoMethod {
Unspec,
OutputPut,
InputPeek,
InputGet,
InputBackward,
InputOffset,
InputRemain,
InputSubrange,
ConfigEndianLittle,
ConfigEndianBig,
ConfigEndianNative,
}
public interface Node {
	public Loc Loc {get; set;}
}
public interface Expr : Node {
	public Type? ExprType {get; set;}
	public ConstantLevel ConstantLevel {get; set;}
}
public interface Stmt : Node {
}
public interface Type : Node {
	public bool IsExplicit {get; set;}
	public bool NonDynamic {get; set;}
	public BitAlignment BitAlignment {get; set;}
	public ulong? BitSize {get; set;}
}
public interface Literal : Expr {
}
public interface Member : Stmt {
	public Member? Belong {get; set;}
	public StructType? BelongStruct {get; set;}
	public Ident? Ident {get; set;}
}
public interface BuiltinMember : Member {
}
public class Program : Node{
	public Loc Loc{get;set;}
	public StructType? StructType{get;set;}
	public List<Node>? Elements{get;set;}
	public Scope? GlobalScope{get;set;}
}
public class Comment : Node{
	public Loc Loc{get;set;}
	public string Comment_{get;set;}
}
public class CommentGroup : Node{
	public Loc Loc{get;set;}
	public List<Comment>? Comments{get;set;}
}
public class FieldArgument : Node{
	public Loc Loc{get;set;}
	public Expr? RawArguments{get;set;}
	public Loc EndLoc{get;set;}
	public List<Expr>? CollectedArguments{get;set;}
	public List<Expr>? Arguments{get;set;}
	public Expr? Alignment{get;set;}
	public ulong? AlignmentValue{get;set;}
	public Expr? SubByteLength{get;set;}
	public Expr? SubByteBegin{get;set;}
}
public class Binary : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public BinaryOp Op{get;set;}
	public Expr? Left{get;set;}
	public Expr? Right{get;set;}
}
public class Unary : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public UnaryOp Op{get;set;}
	public Expr? Expr{get;set;}
}
public class Cond : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Expr? Cond_{get;set;}
	public Expr? Then{get;set;}
	public Loc ElsLoc{get;set;}
	public Expr? Els{get;set;}
}
public class Ident : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public string Ident_{get;set;}
	public IdentUsage Usage{get;set;}
	public Node? Base{get;set;}
	public Scope? Scope{get;set;}
}
public class Call : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Expr? Callee{get;set;}
	public Expr? RawArguments{get;set;}
	public List<Expr>? Arguments{get;set;}
	public Loc EndLoc{get;set;}
}
public class If : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Scope? CondScope{get;set;}
	public Expr? Cond{get;set;}
	public IndentBlock? Then{get;set;}
	public Node? Els{get;set;}
}
public class MemberAccess : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Expr? Target{get;set;}
	public Ident? Member{get;set;}
	public Ident? Base{get;set;}
}
public class Paren : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Expr? Expr{get;set;}
	public Loc EndLoc{get;set;}
}
public class Index : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Expr? Expr{get;set;}
	public Expr? Index_{get;set;}
	public Loc EndLoc{get;set;}
}
public class Match : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Scope? CondScope{get;set;}
	public Expr? Cond{get;set;}
	public List<Node>? Branch{get;set;}
}
public class Range : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public BinaryOp Op{get;set;}
	public Expr? Start{get;set;}
	public Expr? End{get;set;}
}
public class TmpVar : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public ulong TmpVar_{get;set;}
}
public class Import : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public string Path{get;set;}
	public Call? Base{get;set;}
	public Program? ImportDesc{get;set;}
}
public class Cast : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Call? Base{get;set;}
	public Expr? Expr{get;set;}
}
public class Available : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Call? Base{get;set;}
	public Expr? Target{get;set;}
}
public class SpecifyEndian : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Binary? Base{get;set;}
	public Expr? Endian{get;set;}
	public ulong? EndianValue{get;set;}
}
public class ExplicitError : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Call? Base{get;set;}
	public StrLiteral? Message{get;set;}
}
public class IoOperation : Expr{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Expr? Base{get;set;}
	public IoMethod Method{get;set;}
	public List<Expr>? Arguments{get;set;}
	public List<Type>? TypeArguments{get;set;}
}
public class Loop : Stmt{
	public Loc Loc{get;set;}
	public Scope? CondScope{get;set;}
	public Expr? Init{get;set;}
	public Expr? Cond{get;set;}
	public Expr? Step{get;set;}
	public IndentBlock? Body{get;set;}
}
public class IndentBlock : Stmt{
	public Loc Loc{get;set;}
	public StructType? StructType{get;set;}
	public List<Node>? Elements{get;set;}
	public Scope? Scope{get;set;}
}
public class ScopedStatement : Stmt{
	public Loc Loc{get;set;}
	public StructType? StructType{get;set;}
	public Node? Statement{get;set;}
	public Scope? Scope{get;set;}
}
public class MatchBranch : Stmt{
	public Loc Loc{get;set;}
	public Match? Belong{get;set;}
	public Expr? Cond{get;set;}
	public Loc SymLoc{get;set;}
	public Node? Then{get;set;}
}
public class UnionCandidate : Stmt{
	public Loc Loc{get;set;}
	public Expr? Cond{get;set;}
	public Field? Field{get;set;}
}
public class Return : Stmt{
	public Loc Loc{get;set;}
	public Expr? Expr{get;set;}
}
public class Break : Stmt{
	public Loc Loc{get;set;}
}
public class Continue : Stmt{
	public Loc Loc{get;set;}
}
public class Assert : Stmt{
	public Loc Loc{get;set;}
	public Binary? Cond{get;set;}
	public bool IsIoRelated{get;set;}
}
public class ImplicitYield : Stmt{
	public Loc Loc{get;set;}
	public Expr? Expr{get;set;}
}
public class IntType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamic{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public Endian Endian{get;set;}
	public bool IsSigned{get;set;}
	public bool IsCommonSupported{get;set;}
}
public class FloatType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamic{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public Endian Endian{get;set;}
	public bool IsCommonSupported{get;set;}
}
public class IdentType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamic{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public Ident? Ident{get;set;}
	public Type? Base{get;set;}
}
public class IntLiteralType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamic{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public IntLiteral? Base{get;set;}
}
public class StrLiteralType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamic{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public StrLiteral? Base{get;set;}
	public StrLiteral? StrongRef{get;set;}
}
public class VoidType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamic{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
}
public class BoolType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamic{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
}
public class ArrayType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamic{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public Loc EndLoc{get;set;}
	public Type? BaseType{get;set;}
	public Expr? Length{get;set;}
	public ulong? LengthValue{get;set;}
}
public class FunctionType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamic{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public Type? ReturnType{get;set;}
	public List<Type>? Parameters{get;set;}
}
public class StructType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamic{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public List<Member>? Fields{get;set;}
	public Node? Base{get;set;}
	public bool Recursive{get;set;}
	public ulong FixedHeaderSize{get;set;}
	public ulong FixedTailSize{get;set;}
}
public class StructUnionType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamic{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public List<StructType>? Structs{get;set;}
	public Expr? Base{get;set;}
	public List<Field>? UnionFields{get;set;}
}
public class UnionType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamic{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public Expr? Cond{get;set;}
	public List<UnionCandidate>? Candidates{get;set;}
	public StructUnionType? BaseType{get;set;}
	public Type? CommonType{get;set;}
}
public class RangeType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamic{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public Type? BaseType{get;set;}
	public Range? Range{get;set;}
}
public class EnumType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamic{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public Enum? Base{get;set;}
}
public class MetaType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamic{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
}
public class OptionalType : Type{
	public Loc Loc{get;set;}
	public bool IsExplicit{get;set;}
	public bool NonDynamic{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public ulong? BitSize{get;set;}
	public Type? BaseType{get;set;}
}
public class IntLiteral : Literal{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public string Value{get;set;}
}
public class BoolLiteral : Literal{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public bool Value{get;set;}
}
public class StrLiteral : Literal{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public string Value{get;set;}
	public ulong Length{get;set;}
}
public class TypeLiteral : Literal{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
	public Type? Type{get;set;}
	public Loc EndLoc{get;set;}
}
public class Input : Literal{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
}
public class Output : Literal{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
}
public class Config : Literal{
	public Loc Loc{get;set;}
	public Type? ExprType{get;set;}
	public ConstantLevel ConstantLevel{get;set;}
}
public class Field : Member{
	public Loc Loc{get;set;}
	public Member? Belong{get;set;}
	public StructType? BelongStruct{get;set;}
	public Ident? Ident{get;set;}
	public Loc ColonLoc{get;set;}
	public Type? FieldType{get;set;}
	public FieldArgument? Arguments{get;set;}
	public ulong? OffsetBit{get;set;}
	public ulong OffsetRecent{get;set;}
	public ulong? TailOffsetBit{get;set;}
	public ulong TailOffsetRecent{get;set;}
	public BitAlignment BitAlignment{get;set;}
	public Follow Follow{get;set;}
	public Follow EventualFollow{get;set;}
}
public class Format : Member{
	public Loc Loc{get;set;}
	public Member? Belong{get;set;}
	public StructType? BelongStruct{get;set;}
	public Ident? Ident{get;set;}
	public IndentBlock? Body{get;set;}
	public Function? EncodeFn{get;set;}
	public Function? DecodeFn{get;set;}
	public List<Function>? CastFns{get;set;}
	public List<IdentType>? Depends{get;set;}
}
public class State : Member{
	public Loc Loc{get;set;}
	public Member? Belong{get;set;}
	public StructType? BelongStruct{get;set;}
	public Ident? Ident{get;set;}
	public IndentBlock? Body{get;set;}
}
public class Enum : Member{
	public Loc Loc{get;set;}
	public Member? Belong{get;set;}
	public StructType? BelongStruct{get;set;}
	public Ident? Ident{get;set;}
	public Scope? Scope{get;set;}
	public Loc ColonLoc{get;set;}
	public Type? BaseType{get;set;}
	public List<EnumMember>? Members{get;set;}
	public EnumType? EnumType{get;set;}
}
public class EnumMember : Member{
	public Loc Loc{get;set;}
	public Member? Belong{get;set;}
	public StructType? BelongStruct{get;set;}
	public Ident? Ident{get;set;}
	public Expr? Expr{get;set;}
}
public class Function : Member{
	public Loc Loc{get;set;}
	public Member? Belong{get;set;}
	public StructType? BelongStruct{get;set;}
	public Ident? Ident{get;set;}
	public List<Field>? Parameters{get;set;}
	public Type? ReturnType{get;set;}
	public IndentBlock? Body{get;set;}
	public FunctionType? FuncType{get;set;}
	public bool IsCast{get;set;}
	public Loc CastLoc{get;set;}
}
public class BuiltinFunction : Member{
	public Loc Loc{get;set;}
	public Member? Belong{get;set;}
	public StructType? BelongStruct{get;set;}
	public Ident? Ident{get;set;}
	public FunctionType? FuncType{get;set;}
}
public class BuiltinField : Member{
	public Loc Loc{get;set;}
	public Member? Belong{get;set;}
	public StructType? BelongStruct{get;set;}
	public Ident? Ident{get;set;}
	public Type? FieldType{get;set;}
}
public class BuiltinObject : Member{
	public Loc Loc{get;set;}
	public Member? Belong{get;set;}
	public StructType? BelongStruct{get;set;}
	public Ident? Ident{get;set;}
	public List<BuiltinMember>? Members{get;set;}
}
public class Scope {
	public Scope? Prev{get;set;}
	public Scope? Next{get;set;}
	public Scope? Branch{get;set;}
	public List<Ident>? Ident{get;set;}
	public Node? Owner{get;set;}
	public bool BranchRoot{get;set;}
}
public class Pos {
	public ulong Begin{get;set;}
	public ulong End{get;set;}
}
public class Loc {
	public Pos Pos{get;set;}
	public ulong File{get;set;}
	public ulong Line{get;set;}
	public ulong Col{get;set;}
}
public class Token {
	public TokenTag Tag{get;set;}
	public string Token_{get;set;}
	public Loc Loc{get;set;}
}
public class RawScope {
	public ulong? Prev{get;set;}
	public ulong? Next{get;set;}
	public ulong? Branch{get;set;}
	public List<ulong>? Ident{get;set;}
	public ulong? Owner{get;set;}
	public bool BranchRoot{get;set;}
}
public class RawNode {
	public NodeType NodeType{get;set;}
	public Loc Loc{get;set;}
	public Dictionary<string,object> Body{get;set;}
}
public class SrcErrorEntry {
	public string Msg{get;set;}
	public string File{get;set;}
	public Loc Loc{get;set;}
	public string Src{get;set;}
	public bool Warn{get;set;}
}
public class SrcError {
	public List<SrcErrorEntry>? Errs{get;set;}
}
public class JsonAst {
	public List<RawNode>? Node{get;set;}
	public List<RawScope>? Scope{get;set;}
}
public class AstFile {
	public List<string>? Files{get;set;}
	public JsonAst? Ast{get;set;}
	public SrcError? Error{get;set;}
}
public class TokenFile {
	public List<string>? Files{get;set;}
	public List<Token>? Tokens{get;set;}
	public SrcError? Error{get;set;}
}
}
